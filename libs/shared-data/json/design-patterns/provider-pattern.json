[
  {
    "id": "design-patterns-provider-pattern-61",
    "title": "Provider Pattern Basics",
    "content": "What problem does the Provider Pattern primarily solve in React applications?",
    "type": "open-ended",
    "category": "Design Patterns",
    "topic": "General Design Patterns",
    "difficulty": "beginner",
    "learningCardId": "system-design",
    "isActive": true,
    "createdAt": "2025-10-15T00:47:17.208Z",
    "updatedAt": "2025-10-15T00:47:17.208Z",
    "createdBy": "admin",
    "updatedBy": "admin",
    "tags": ["design-patterns", "general-design-patterns", "beginner"],
    "explanation": "It solves the issue of prop drilling by allowing components to access shared state directly through context. It provides a way to make global state or values accessible to deeply nested components without passing props manually.",
    "points": 10,
    "sampleAnswers": [
      "It solves the issue of prop drilling by allowing components to access shared state directly through context.",
      "It provides a way to make global state or values accessible to deeply nested components without passing props manually."
    ],
    "hints": [],
    "metadata": {}
  },
  {
    "id": "design-patterns-provider-pattern-62",
    "title": "Prop Drilling",
    "content": "Which of the following best describes 'prop drilling'?",
    "type": "multiple-choice",
    "category": "Design Patterns",
    "topic": "General Design Patterns",
    "difficulty": "beginner",
    "learningCardId": "system-design",
    "isActive": true,
    "createdAt": "2025-10-15T00:47:17.208Z",
    "updatedAt": "2025-10-15T00:47:17.208Z",
    "createdBy": "admin",
    "updatedBy": "admin",
    "tags": ["design-patterns", "general-design-patterns", "beginner"],
    "explanation": "The correct answer is: Passing props through multiple components that don’t use them",
    "points": 10,
    "options": [
      {
        "id": "a",
        "text": "Passing props through multiple components that don’t use them",
        "isCorrect": true,
        "explanation": ""
      },
      {
        "id": "b",
        "text": "Drilling into the DOM with refs",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "c",
        "text": "Creating deeply nested providers",
        "isCorrect": false,
        "explanation": ""
      }
    ],
    "hints": [],
    "metadata": {}
  },
  {
    "id": "design-patterns-provider-pattern-63",
    "title": "useContext Hook",
    "content": "In React, how does a component consume values from a Provider?",
    "type": "open-ended",
    "category": "Design Patterns",
    "topic": "General Design Patterns",
    "difficulty": "intermediate",
    "learningCardId": "system-design",
    "isActive": true,
    "createdAt": "2025-10-15T00:47:17.208Z",
    "updatedAt": "2025-10-15T00:47:17.208Z",
    "createdBy": "admin",
    "updatedBy": "admin",
    "tags": ["design-patterns", "general-design-patterns", "intermediate"],
    "explanation": "By using the useContext hook with the context object created via React.createContext(). The component calls useContext(SomeContext) to directly access the value provided by the Provider.",
    "points": 10,
    "sampleAnswers": [
      "By using the useContext hook with the context object created via React.createContext().",
      "The component calls useContext(SomeContext) to directly access the value provided by the Provider."
    ],
    "hints": [],
    "metadata": {}
  },
  {
    "id": "design-patterns-provider-pattern-64",
    "title": "Provider Pattern Code",
    "content": "What will be rendered by the Header component in this example?\n\n```jsx\nconst DataContext = React.createContext();\n\nfunction App() {\n  const data = { title: 'Hello Provider' };\n  return (\n    <DataContext.Provider value={data}>\n      <Header />\n    </DataContext.Provider>\n  );\n}\n\nfunction Header() {\n  const data = React.useContext(DataContext);\n  return <h1>{data.title}</h1>;\n}\n```",
    "type": "multiple-choice",
    "category": "Design Patterns",
    "topic": "General Design Patterns",
    "difficulty": "intermediate",
    "learningCardId": "system-design",
    "isActive": true,
    "createdAt": "2025-10-15T00:47:17.208Z",
    "updatedAt": "2025-10-15T00:47:17.208Z",
    "createdBy": "admin",
    "updatedBy": "admin",
    "tags": ["design-patterns", "general-design-patterns", "intermediate"],
    "explanation": "The correct answer is: h1 with text 'Hello Provider'",
    "points": 10,
    "options": [
      {
        "id": "a",
        "text": "Nothing, React throws an error",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "b",
        "text": "h1 with text 'Hello Provider'",
        "isCorrect": true,
        "explanation": ""
      },
      {
        "id": "c",
        "text": "h1 with text 'undefined'",
        "isCorrect": false,
        "explanation": ""
      }
    ],
    "hints": [],
    "metadata": {}
  },
  {
    "id": "design-patterns-provider-pattern-65",
    "title": "Performance Concern",
    "content": "What is a potential downside of overusing the Provider Pattern?",
    "type": "open-ended",
    "category": "Design Patterns",
    "topic": "General Design Patterns",
    "difficulty": "intermediate",
    "learningCardId": "system-design",
    "isActive": true,
    "createdAt": "2025-10-15T00:47:17.208Z",
    "updatedAt": "2025-10-15T00:47:17.208Z",
    "createdBy": "admin",
    "updatedBy": "admin",
    "tags": ["design-patterns", "general-design-patterns", "intermediate"],
    "explanation": "All components consuming the context re-render whenever the value changes, which can hurt performance in large apps. It can cause unnecessary re-renders if too much state is stored in a single provider.",
    "points": 10,
    "sampleAnswers": [
      "All components consuming the context re-render whenever the value changes, which can hurt performance in large apps.",
      "It can cause unnecessary re-renders if too much state is stored in a single provider."
    ],
    "hints": [],
    "metadata": {}
  },
  {
    "id": "design-patterns-provider-pattern-66",
    "title": "Theme Provider Use Case",
    "content": "Why is the Provider Pattern a good fit for managing application themes (dark/light mode)?",
    "type": "open-ended",
    "category": "Design Patterns",
    "topic": "General Design Patterns",
    "difficulty": "beginner",
    "learningCardId": "system-design",
    "isActive": true,
    "createdAt": "2025-10-15T00:47:17.208Z",
    "updatedAt": "2025-10-15T00:47:17.208Z",
    "createdBy": "admin",
    "updatedBy": "admin",
    "tags": ["design-patterns", "general-design-patterns", "beginner"],
    "explanation": "Because many components need access to the theme, and the Provider allows sharing it globally without prop drilling. It centralizes theme state and makes it easy to toggle or update across the entire app.",
    "points": 10,
    "sampleAnswers": [
      "Because many components need access to the theme, and the Provider allows sharing it globally without prop drilling.",
      "It centralizes theme state and makes it easy to toggle or update across the entire app."
    ],
    "hints": [],
    "metadata": {}
  },
  {
    "id": "design-patterns-provider-pattern-67",
    "title": "Multiple Providers",
    "content": "How can you avoid unnecessary re-renders when using Providers for frequently changing values?",
    "type": "open-ended",
    "category": "Design Patterns",
    "topic": "General Design Patterns",
    "difficulty": "advanced",
    "learningCardId": "system-design",
    "isActive": true,
    "createdAt": "2025-10-15T00:47:17.208Z",
    "updatedAt": "2025-10-15T00:47:17.208Z",
    "createdBy": "admin",
    "updatedBy": "admin",
    "tags": ["design-patterns", "general-design-patterns", "advanced"],
    "explanation": "By splitting contexts into multiple smaller providers so that components only re-render when the specific value they consume changes. Using memoization or selective context providers to isolate updates.",
    "points": 10,
    "sampleAnswers": [
      "By splitting contexts into multiple smaller providers so that components only re-render when the specific value they consume changes.",
      "Using memoization or selective context providers to isolate updates."
    ],
    "hints": [],
    "metadata": {}
  },
  {
    "id": "design-patterns-provider-pattern-68",
    "title": "Custom Hook for Context",
    "content": "What is the benefit of creating a custom hook like `useThemeContext()` instead of calling `useContext(ThemeContext)` directly in every component?",
    "type": "multiple-choice",
    "category": "Design Patterns",
    "topic": "General Design Patterns",
    "difficulty": "intermediate",
    "learningCardId": "system-design",
    "isActive": true,
    "createdAt": "2025-10-15T00:47:17.208Z",
    "updatedAt": "2025-10-15T00:47:17.208Z",
    "createdBy": "admin",
    "updatedBy": "admin",
    "tags": ["design-patterns", "general-design-patterns", "intermediate"],
    "explanation": "The correct answer is: It enforces correct usage and can throw errors if used outside the provider",
    "points": 10,
    "options": [
      {
        "id": "a",
        "text": "It enforces correct usage and can throw errors if used outside the provider",
        "isCorrect": true,
        "explanation": ""
      },
      {
        "id": "b",
        "text": "It avoids the need to import useContext at all",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "c",
        "text": "It improves runtime performance automatically",
        "isCorrect": false,
        "explanation": ""
      }
    ],
    "hints": [],
    "metadata": {}
  },
  {
    "id": "design-patterns-provider-pattern-69",
    "title": "Provider vs Redux",
    "content": "How does the Provider Pattern differ from using Redux for global state management?",
    "type": "open-ended",
    "category": "Design Patterns",
    "topic": "General Design Patterns",
    "difficulty": "advanced",
    "learningCardId": "system-design",
    "isActive": true,
    "createdAt": "2025-10-15T00:47:17.208Z",
    "updatedAt": "2025-10-15T00:47:17.208Z",
    "createdBy": "admin",
    "updatedBy": "admin",
    "tags": ["design-patterns", "general-design-patterns", "advanced"],
    "explanation": "Provider Pattern with context is simpler and built into React, but doesn’t offer advanced features like middleware, devtools, or predictable reducers. Redux adds structure and tooling, while Context Providers are best for simpler shared state.",
    "points": 10,
    "sampleAnswers": [
      "Provider Pattern with context is simpler and built into React, but doesn’t offer advanced features like middleware, devtools, or predictable reducers.",
      "Redux adds structure and tooling, while Context Providers are best for simpler shared state."
    ],
    "hints": [],
    "metadata": {}
  },
  {
    "id": "design-patterns-provider-pattern-70",
    "title": "Styled-Components Provider",
    "content": "What role does the ThemeProvider from styled-components play?",
    "type": "open-ended",
    "category": "Design Patterns",
    "topic": "General Design Patterns",
    "difficulty": "intermediate",
    "learningCardId": "system-design",
    "isActive": true,
    "createdAt": "2025-10-15T00:47:17.208Z",
    "updatedAt": "2025-10-15T00:47:17.208Z",
    "createdBy": "admin",
    "updatedBy": "admin",
    "tags": ["design-patterns", "general-design-patterns", "intermediate"],
    "explanation": "It provides a theme object via context so that styled components can access theme values without passing them as props. It applies consistent design tokens (colors, spacing, etc.) across the entire component tree.",
    "points": 10,
    "sampleAnswers": [
      "It provides a theme object via context so that styled components can access theme values without passing them as props.",
      "It applies consistent design tokens (colors, spacing, etc.) across the entire component tree."
    ],
    "hints": [],
    "metadata": {}
  }
]
