---
description: Security pipeline rules for secret management, git hooks, scanning, and history remediation
globs: **/*
alwaysApply: true
---

# Security Pipeline Rules

## üîí **Secret Management**

### **Never Hardcode Secrets**
- ‚ùå **DON'T:** Hardcode API keys, tokens, or passwords in code
- ‚úÖ **DO:** Always use environment variables (`process.env.VARIABLE_NAME`)
- ‚úÖ **DO:** Add secrets to `.env.local` (never commit this file)
- ‚úÖ **DO:** Use `.env.example` for documentation (with placeholders)

### **Secret Detection**
- ‚úÖ **Pre-push hook** automatically scans for secrets before push
- ‚úÖ **GitHub** automatically scans all commits after push
- ‚úÖ **Never skip secret scanning** unless it's a known false positive
- ‚úÖ **If secrets found:** Fix immediately, don't push

### **Secret Patterns to Avoid**
```typescript
// ‚ùå DON'T: Hardcode secrets
const apiKey = "YOUR_GOOGLE_API_KEY_HERE";
const token = "YOUR_SUPABASE_KEY_HERE...";

// ‚úÖ DO: Use environment variables
const apiKey = process.env.GOOGLE_API_KEY;
const token = process.env.SUPABASE_SERVICE_ROLE_KEY;

// ‚úÖ DO: Add error handling
if (!apiKey) {
  throw new Error("GOOGLE_API_KEY is required");
}
```

## üõ°Ô∏è **Git Hooks (Local Security)**

### **Pre-Commit Hook**
- ‚úÖ **Runs automatically** on `git commit`
- ‚úÖ **What it does:** Formatting (Prettier) only
- ‚úÖ **Time:** ~10 seconds, ~100MB memory
- ‚úÖ **Blocks commit if:** Formatting fails

### **Pre-Push Hook**
- ‚úÖ **Runs automatically** on `git push`
- ‚úÖ **What it does:**
  - Linting (ESLint auto-fix + check)
  - TypeScript type checking (2GB memory limit)
  - Build validation (2GB memory limit)
  - **Secret scanning** (CRITICAL - blocks push if secrets found)
  - Cleanup build artifacts
- ‚úÖ **Time:** ~2-5 minutes, ~2GB peak memory
- ‚úÖ **Blocks push if:** Type errors, build fails, **secrets found**
- ‚úÖ **Memory optimized** for 8GB RAM systems

### **Never Skip Hooks**
- ‚ùå **DON'T:** Use `--no-verify` to skip hooks
- ‚ùå **DON'T:** Use `SKIP_SECRET_SCAN=true` unless emergency
- ‚úÖ **DO:** Let hooks run - they protect the repository
- ‚úÖ **DO:** Fix issues before pushing

## üîç **Security Scanning**

### **Local Scanning (Before Push)**
- ‚úÖ **Pre-push hook** scans changed files automatically
- ‚úÖ **Scans for:** Supabase keys, Google API keys, GitHub tokens, OpenAI keys, Sentry tokens, etc.
- ‚úÖ **Blocks push** if secrets found

### **GitHub Scanning (After Push)**
- ‚úÖ **Automatic** secret scanning on all commits
- ‚úÖ **CodeQL** analysis for security vulnerabilities
- ‚úÖ **SonarQube** analysis for code quality and security
- ‚úÖ **Creates alerts** in Security tab

### **Git History Scanning**
- ‚úÖ **Use:** `./scripts/scan-git-history-for-secrets.sh`
- ‚úÖ **When:** If GitHub alerts show secrets in history
- ‚úÖ **Memory:** ~500MB-1GB (single-threaded, optimized for 8GB RAM)
- ‚úÖ **Output:** Generates report with all findings

## üßπ **Git History Remediation**

### **When Secrets Are in History**
Even after fixing code, secrets remain in git history. Follow this process:

1. **Scan History:**
   ```bash
   ./scripts/scan-git-history-for-secrets.sh
   ```

2. **Rotate ALL Exposed Keys:**
   - Supabase: Regenerate service_role key
   - Google: Delete/restrict API keys
   - GitHub: Revoke tokens
   - Update all `.env` files
   - Update GitHub Secrets

3. **Remove from History:**
   ```bash
   ./scripts/remove-secrets-from-history-complete.sh
   ```
   - Creates backup branch automatically
   - Uses git-filter-repo (single-threaded, memory-optimized)
   - Replaces secrets with placeholders

4. **Force Push:**
   ```bash
   git push origin --force --all
   ```
   - ‚ö†Ô∏è **Only after rotating keys!**
   - ‚ö†Ô∏è **Notify team members first!**

### **History Remediation Rules**
- ‚úÖ **Always rotate keys FIRST** before removing from history
- ‚úÖ **Always create backup** (script does this automatically)
- ‚úÖ **Always verify removal** after cleanup
- ‚úÖ **Always notify team** before force pushing

## üíæ **Memory Optimization (8GB RAM)**

### **All Operations Are Memory-Optimized**
- ‚úÖ **Single-threaded:** No parallel processing
- ‚úÖ **Memory limits:** Node.js capped at 2GB
- ‚úÖ **Incremental processing:** Avoids loading full history
- ‚úÖ **Safe for 8GB RAM systems**

### **Memory Usage Guidelines**
- ‚úÖ **Pre-commit:** ~100MB (safe anytime)
- ‚úÖ **Pre-push (linting):** ~200MB (safe anytime)
- ‚úÖ **Pre-push (type check):** ~500MB-1GB (safe anytime)
- ‚ö†Ô∏è **Pre-push (build):** ~2GB (close other apps)
- ‚ö†Ô∏è **History removal:** ~1-2GB (close everything)

### **When Running Heavy Operations**
- ‚ö†Ô∏è **Close other applications** before build or history operations
- ‚ö†Ô∏è **Monitor memory usage** if system becomes slow
- ‚úÖ **Take breaks** between heavy operations

## üîÑ **Auto-Fix Workflows**

### **Fix and Resolve Secrets Workflow**
- ‚úÖ **Location:** `.github/workflows/fix-and-resolve-secrets.yml`
- ‚úÖ **What it does:**
  - Finds files with secrets
  - Fixes code (replaces with `process.env`)
  - Creates PR with fixes
  - Resolves alerts
- ‚úÖ **When:** Manual trigger or weekly schedule
- ‚úÖ **Use when:** Secrets detected in current code

### **Auto-Resolve Secret Scanning Workflow**
- ‚úÖ **Location:** `.github/workflows/auto-resolve-secret-scanning.yml`
- ‚úÖ **What it does:**
  - Marks alerts as resolved
  - Does NOT fix code (use fix-and-resolve-secrets.yml instead)
- ‚úÖ **When:** Manual trigger or daily schedule
- ‚úÖ **Use when:** Keys already rotated, just need to mark alerts resolved

## üìã **Security Checklist**

Before pushing code, ensure:
- [ ] No hardcoded secrets in code
- [ ] All secrets use `process.env`
- [ ] `.env.local` is in `.gitignore`
- [ ] Pre-push hook will run (don't skip)
- [ ] TypeScript types are correct
- [ ] Build passes locally
- [ ] No secrets in git history (if previously exposed)

## üö® **Emergency Procedures**

### **If Secrets Found in Code**
1. **Don't push!** Fix locally first
2. Replace with `process.env` variables
3. Add to `.env.local`
4. Test locally
5. Then push

### **If Secrets Found in History**
1. **Rotate keys immediately** in service dashboards
2. Update all `.env` files
3. Update GitHub Secrets
4. Run history remediation script
5. Force push after team notification

### **If Pre-Push Hook Blocks Push**
1. **Don't skip the hook!**
2. Fix the issue (secrets, type errors, build failures)
3. Run the hook again
4. Only skip in true emergencies (and document why)

## üîó **Related Documentation**

- `COMPLETE_SECURITY_PIPELINE.md` - Complete pipeline guide
- `COMPLETE_INTEGRATION_DIAGRAM.md` - Visual integration diagram
- `GIT_HISTORY_REMEDIATION.md` - History cleanup guide
- `MEMORY_OPTIMIZATION_GUIDE.md` - Memory optimization guide
- `SECRET_SCANNING_AUTOMATION.md` - Secret scanning automation

## ‚úÖ **Best Practices**

1. **Always use environment variables** for secrets
2. **Never commit `.env.local`** or any file with real secrets
3. **Let hooks run** - they protect the repository
4. **Rotate keys immediately** if exposed
5. **Scan history regularly** if repository was previously public
6. **Monitor GitHub Security tab** for alerts
7. **Use auto-fix workflows** when available
8. **Document false positives** if you must skip scanning

---

**Remember:** Security is a continuous process. These rules help prevent secrets from entering the repository and provide tools to remediate if they do.
