=== JAVASCRIPT DEEP DIVE QUESTIONS (155 total) ===

--- QUESTION zmXnG1C4hIawmm2ZIwtx ---
Question: What's the output?

```javascript
const animals = {};
let dog = { emoji: 'üê∂' }
let cat = { emoji: 'üêà' }
animals[dog] = { ...dog, name: "Mara" }
animals[cat] = { ...cat, name: "Sara" }
console.log(animals[dog])
```
Category: JavaScript
Difficulty: medium

Options:
  opt1: A: `{ emoji: "üê∂", name: "Mara" }`
  opt2: B: `{ emoji: "üêà", name: "Sara" }` ‚úì
  opt3: C: `undefined`
  opt4: D: `ReferenceError`

Correct Answer: B: `{ emoji: "üêà", name: "Sara" }`
Explanation: <p> #### Answer: B Object keys are converted to strings. Since the value of  `dog` is an object,  `animals[dog]` actually means that we‚Äôre creating a new property called `"[object Object]"` equal to the new object. `animals["[object Object]"]` is now equal to `{ emoji: "üê∂", name: "Mara"}`. `cat` is also an object, which means that `animals[cat]` actually means that we‚Äôre overwriting the value of  `animals["[object Object]"]` with the new cat properties. Logging `animals[dog]`, or actually `animals["[object Object]"]` since converting the `dog` object to a string results `"[object Object]"`, returns the `{ emoji: "üêà", name: "Sara" }`. </p> </details> ---

================================================================================

--- QUESTION rPGS7JFJWBpaGEkyUMiW ---
Question: What's the output?

```javascript
function addToList(item, list) {
return list.push(item);
}
const result = addToList('apple', ['banana']);
console.log(result);
```
Category: JavaScript
Difficulty: medium

Options:
  opt1: A: `['apple', 'banana']`
  opt2: B: `2`
  opt3: C: `` ‚úì
  opt4: D: `undefined`

Correct Answer: C: ``
Explanation: <p> #### Answer: B The `.push()` method returns the _length_ of the new array! Previously, the array contained one element (the string `"banana"`) and had a length of `1`. After adding the string `"apple"` to the array, the array contains two elements, and has a length of `2`. This gets returned from the `addToList` function. The `push` method modifies the original array. If you wanted to return the _array_ from the function rather than the _length of the array_, you should have returned `list` after pushing `item` to it. </p> </details> ---

================================================================================

--- QUESTION pCNSNwcHcuaPG1pBGFm4 ---
Question: Is this a pure function?

```javascript
function sum(a, b) {
return a + b;
}
```
Category: JavaScript
Difficulty: medium

Options:
  opt1: A: ‚úì
  opt2: B: No

Correct Answer: A:
Explanation: <p> #### Answer: A A pure function is a function that _always_ returns the same result, if the same arguments are passed. The `sum` function always returns the same result. If we pass `1` and `2`, it will _always_ return `3` without side effects. If we pass `5` and `10`, it will _always_ return `15`, and so on. This is the definition of a pure function. </p> </details> ---

================================================================================

--- QUESTION p0przTAseF0t9d1dlLVT ---
Question: What's the output?

```javascript
const obj = { 1: 'a', 2: 'b', 3: 'c' };
const set = new Set([1, 2, 3, 4, 5]);
obj.hasOwnProperty('1');
obj.hasOwnProperty(1);
set.has('1');
set.has(1);
```
Category: JavaScript
Difficulty: medium

Options:
  opt1: A: `false` `` `false` `` ‚úì
  opt2: B: `false` `` `` `` ‚úì
  opt3: C: `` `` `false` `` ‚úì
  opt4: D: `` `` `` `` ‚úì

Correct Answer: A: `false` `` `false` ``
Explanation: <p> #### Answer: C All object keys (excluding Symbols) are strings under the hood, even if you don't type it yourself as a string. This is why `obj.hasOwnProperty('1')` also returns true. It doesn't work that way for a set. There is no `'1'` in our set: `set.has('1')` returns `false`. It has the numeric type `1`, `set.has(1)` returns `true`. </p> </details> ---

================================================================================

--- QUESTION p0przTAseF0t9d1dlLVT ---
Question: What's the output?

```javascript
const obj = { 1: 'a', 2: 'b', 3: 'c' };
const set = new Set([1, 2, 3, 4, 5]);
obj.hasOwnProperty('1');
obj.hasOwnProperty(1);
set.has('1');
set.has(1);
```
Category: JavaScript
Difficulty: medium

Options:
  opt1: A: `false` `` `false` `` ‚úì
  opt2: B: `false` `` `` `` ‚úì
  opt3: C: `` `` `false` `` ‚úì
  opt4: D: `` `` `` `` ‚úì

Correct Answer: B: `false` `` `` ``
Explanation: <p> #### Answer: C All object keys (excluding Symbols) are strings under the hood, even if you don't type it yourself as a string. This is why `obj.hasOwnProperty('1')` also returns true. It doesn't work that way for a set. There is no `'1'` in our set: `set.has('1')` returns `false`. It has the numeric type `1`, `set.has(1)` returns `true`. </p> </details> ---

================================================================================

--- QUESTION p0przTAseF0t9d1dlLVT ---
Question: What's the output?

```javascript
const obj = { 1: 'a', 2: 'b', 3: 'c' };
const set = new Set([1, 2, 3, 4, 5]);
obj.hasOwnProperty('1');
obj.hasOwnProperty(1);
set.has('1');
set.has(1);
```
Category: JavaScript
Difficulty: medium

Options:
  opt1: A: `false` `` `false` `` ‚úì
  opt2: B: `false` `` `` `` ‚úì
  opt3: C: `` `` `false` `` ‚úì
  opt4: D: `` `` `` `` ‚úì

Correct Answer: C: `` `` `false` ``
Explanation: <p> #### Answer: C All object keys (excluding Symbols) are strings under the hood, even if you don't type it yourself as a string. This is why `obj.hasOwnProperty('1')` also returns true. It doesn't work that way for a set. There is no `'1'` in our set: `set.has('1')` returns `false`. It has the numeric type `1`, `set.has(1)` returns `true`. </p> </details> ---

================================================================================

--- QUESTION p0przTAseF0t9d1dlLVT ---
Question: What's the output?

```javascript
const obj = { 1: 'a', 2: 'b', 3: 'c' };
const set = new Set([1, 2, 3, 4, 5]);
obj.hasOwnProperty('1');
obj.hasOwnProperty(1);
set.has('1');
set.has(1);
```
Category: JavaScript
Difficulty: medium

Options:
  opt1: A: `false` `` `false` `` ‚úì
  opt2: B: `false` `` `` `` ‚úì
  opt3: C: `` `` `false` `` ‚úì
  opt4: D: `` `` `` `` ‚úì

Correct Answer: D: `` `` `` ``
Explanation: <p> #### Answer: C All object keys (excluding Symbols) are strings under the hood, even if you don't type it yourself as a string. This is why `obj.hasOwnProperty('1')` also returns true. It doesn't work that way for a set. There is no `'1'` in our set: `set.has('1')` returns `false`. It has the numeric type `1`, `set.has(1)` returns `true`. </p> </details> ---

================================================================================

--- QUESTION ldrimME9SN3mfNLoVaNx ---
Question: All object have prototypes.
Category: JavaScript
Difficulty: medium

Options:
  opt1: A: ‚úì
  opt2: B: false

Correct Answer: A:
Explanation: <p> #### Answer: B All objects have prototypes, except for the **base object**. The base object is the object created by the user, or an object that is created using the `new` keyword. The base object has access to some methods and properties, such as `.toString`. This is the reason why you can use built-in JavaScript methods! All of such methods are available on the prototype. Although JavaScript can't find it directly on your object, it goes down the prototype chain and finds it there, which makes it accessible for you. </p> </details> ---

================================================================================

--- QUESTION gsScvG9APMsy70l9O4Oz ---
Question: What's its value?

```javascript
console.log('‚ù§Ô∏è' === '‚ù§Ô∏è');
```
Category: JavaScript
Difficulty: medium

Options:
  opt1: A: `` ‚úì
  opt2: B: `false`

Correct Answer: A: ``
Explanation: <p> #### Answer: A Under the hood, emojis are unicodes. The unicodes for the heart emoji is `"U+2764 U+FE0F"`. These are always the same for the same emojis, so we're comparing two equal strings to each other, which returns true. </p> </details> ---

================================================================================

--- QUESTION ghRMhTvTWTzP7GFumFni ---
Question: What's the output?

```javascript
!!null;
!!'';
!!1;
```
Category: JavaScript
Difficulty: medium

Options:
  opt1: A: `false` `` `false` ‚úì
  opt2: B: `false` `false` `` ‚úì
  opt3: C: `false` `` `` ‚úì
  opt4: D: `` `` `false` ‚úì

Correct Answer: A: `false` `` `false`
Explanation: <p> #### Answer: B `null` is falsy. `!null` returns `true`. `!true` returns `false`. `""` is falsy. `!""` returns `true`. `!true` returns `false`. `1` is truthy. `!1` returns `false`. `!false` returns `true`. </p> </details> ---

================================================================================

--- QUESTION ghRMhTvTWTzP7GFumFni ---
Question: What's the output?

```javascript
!!null;
!!'';
!!1;
```
Category: JavaScript
Difficulty: medium

Options:
  opt1: A: `false` `` `false` ‚úì
  opt2: B: `false` `false` `` ‚úì
  opt3: C: `false` `` `` ‚úì
  opt4: D: `` `` `false` ‚úì

Correct Answer: B: `false` `false` ``
Explanation: <p> #### Answer: B `null` is falsy. `!null` returns `true`. `!true` returns `false`. `""` is falsy. `!""` returns `true`. `!true` returns `false`. `1` is truthy. `!1` returns `false`. `!false` returns `true`. </p> </details> ---

================================================================================

--- QUESTION ghRMhTvTWTzP7GFumFni ---
Question: What's the output?

```javascript
!!null;
!!'';
!!1;
```
Category: JavaScript
Difficulty: medium

Options:
  opt1: A: `false` `` `false` ‚úì
  opt2: B: `false` `false` `` ‚úì
  opt3: C: `false` `` `` ‚úì
  opt4: D: `` `` `false` ‚úì

Correct Answer: C: `false` `` ``
Explanation: <p> #### Answer: B `null` is falsy. `!null` returns `true`. `!true` returns `false`. `""` is falsy. `!""` returns `true`. `!true` returns `false`. `1` is truthy. `!1` returns `false`. `!false` returns `true`. </p> </details> ---

================================================================================

--- QUESTION ghRMhTvTWTzP7GFumFni ---
Question: What's the output?

```javascript
!!null;
!!'';
!!1;
```
Category: JavaScript
Difficulty: medium

Options:
  opt1: A: `false` `` `false` ‚úì
  opt2: B: `false` `false` `` ‚úì
  opt3: C: `false` `` `` ‚úì
  opt4: D: `` `` `false` ‚úì

Correct Answer: D: `` `` `false`
Explanation: <p> #### Answer: B `null` is falsy. `!null` returns `true`. `!true` returns `false`. `""` is falsy. `!""` returns `true`. `!true` returns `false`. `1` is truthy. `!1` returns `false`. `!false` returns `true`. </p> </details> ---

================================================================================

--- QUESTION bJURk9gqTOSNKZFqzZng ---
Question: What's the value of output?

```javascript
const one = false || {} || null;
const two = null || false || '';
const three = [] || 0 || true;
console.log(one, two, three);
```
Category: JavaScript
Difficulty: medium

Options:
  opt1: A: `false` `null` `[]`
  opt2: B: `null` `""` `` ‚úì
  opt3: C: `{}` `""` `[]`
  opt4: D: `null` `null` `` ‚úì

Correct Answer: B: `null` `""` ``
Explanation: <p> #### Answer: C With the `||` operator, we can return the first truthy operand. If all values are falsy, the last operand gets returned. `(false || {} || null)`: the empty object `{}` is a truthy value. This is the first (and only) truthy value, which gets returned. `one` is equal to `{}`. `(null || false || "")`: all operands are falsy values. This means that the last operand, `""` gets returned. `two` is equal to `""`. `([] || 0 || "")`: the empty array`[]` is a truthy value. This is the first truthy value, which gets returned. `three` is equal to `[]`. </p> </details> ---

================================================================================

--- QUESTION bJURk9gqTOSNKZFqzZng ---
Question: What's the value of output?

```javascript
const one = false || {} || null;
const two = null || false || '';
const three = [] || 0 || true;
console.log(one, two, three);
```
Category: JavaScript
Difficulty: medium

Options:
  opt1: A: `false` `null` `[]`
  opt2: B: `null` `""` `` ‚úì
  opt3: C: `{}` `""` `[]`
  opt4: D: `null` `null` `` ‚úì

Correct Answer: D: `null` `null` ``
Explanation: <p> #### Answer: C With the `||` operator, we can return the first truthy operand. If all values are falsy, the last operand gets returned. `(false || {} || null)`: the empty object `{}` is a truthy value. This is the first (and only) truthy value, which gets returned. `one` is equal to `{}`. `(null || false || "")`: all operands are falsy values. This means that the last operand, `""` gets returned. `two` is equal to `""`. `([] || 0 || "")`: the empty array`[]` is a truthy value. This is the first truthy value, which gets returned. `three` is equal to `[]`. </p> </details> ---

================================================================================

--- QUESTION abaZfoMXTIM1I7NAujeo ---
Question: How can we log the values that are commented out after the console.log statement?

```javascript
function* startGame() {
const answer = yield 'Do you love JavaScript?';
if (answer !== 'Yes') {
return "Oh wow... Guess we're done here";
}
return 'JavaScript loves you back ‚ù§Ô∏è';
}
const game = startGame();
console.log(/* 1 */); // Do you love JavaScript?
console.log(/* 2 */); // JavaScript loves you back ‚ù§Ô∏è
```
Category: JavaScript
Difficulty: medium

Options:
  opt1: A: `game.next("").value` and `game.next().value` ‚úì
  opt2: B: `game.next.value("")` and `game.next.value()` ‚úì
  opt3: C: `game.next().value` and `game.next("").value` ‚úì
  opt4: D: `game.next.value()` and `game.next.value("")` ‚úì

Correct Answer: A: `game.next("").value` and `game.next().value`
Explanation: if (answer !== 'Yes') { return "Oh wow... Guess we're done here"; } return 'JavaScript loves you back ‚ù§Ô∏è'; } const game = startGame(); console.log(/* 1 */); // Do you love JavaScript? console.log(/* 2 */); // JavaScript loves you back ‚ù§Ô∏è ``` - A: `game.next("Yes").value` and `game.next().value` - B: `game.next.value("Yes")` and `game.next.value()` - C: `game.next().value` and `game.next("Yes").value` - D: `game.next.value()` and `game.next.value("Yes")` <details><summary><b>Answer</b></summary> <p> #### Answer: C A generator function "pauses" its execution when it sees the `yield` keyword. First, we have to let the function yield the string "Do you love JavaScript?", which can be done by calling `game.next().value`. Every line is executed, until it finds the first `yield` keyword. There is a `yield` keyword on the first line within the function: the execution stops with the first yield! _This means that the variable `answer` is not defined yet!_ When we call `game.next("Yes").value`, the previous `yield` is replaced with the value of the parameters passed to the `next()` function, `"Yes"` in this case. The value of the variable `answer` is now equal to `"Yes"`. The condition of the if-statement returns `false`, and `JavaScript loves you back ‚ù§Ô∏è` gets logged. </p> </details> ---

================================================================================

--- QUESTION abaZfoMXTIM1I7NAujeo ---
Question: How can we log the values that are commented out after the console.log statement?

```javascript
function* startGame() {
const answer = yield 'Do you love JavaScript?';
if (answer !== 'Yes') {
return "Oh wow... Guess we're done here";
}
return 'JavaScript loves you back ‚ù§Ô∏è';
}
const game = startGame();
console.log(/* 1 */); // Do you love JavaScript?
console.log(/* 2 */); // JavaScript loves you back ‚ù§Ô∏è
```
Category: JavaScript
Difficulty: medium

Options:
  opt1: A: `game.next("").value` and `game.next().value` ‚úì
  opt2: B: `game.next.value("")` and `game.next.value()` ‚úì
  opt3: C: `game.next().value` and `game.next("").value` ‚úì
  opt4: D: `game.next.value()` and `game.next.value("")` ‚úì

Correct Answer: B: `game.next.value("")` and `game.next.value()`
Explanation: if (answer !== 'Yes') { return "Oh wow... Guess we're done here"; } return 'JavaScript loves you back ‚ù§Ô∏è'; } const game = startGame(); console.log(/* 1 */); // Do you love JavaScript? console.log(/* 2 */); // JavaScript loves you back ‚ù§Ô∏è ``` - A: `game.next("Yes").value` and `game.next().value` - B: `game.next.value("Yes")` and `game.next.value()` - C: `game.next().value` and `game.next("Yes").value` - D: `game.next.value()` and `game.next.value("Yes")` <details><summary><b>Answer</b></summary> <p> #### Answer: C A generator function "pauses" its execution when it sees the `yield` keyword. First, we have to let the function yield the string "Do you love JavaScript?", which can be done by calling `game.next().value`. Every line is executed, until it finds the first `yield` keyword. There is a `yield` keyword on the first line within the function: the execution stops with the first yield! _This means that the variable `answer` is not defined yet!_ When we call `game.next("Yes").value`, the previous `yield` is replaced with the value of the parameters passed to the `next()` function, `"Yes"` in this case. The value of the variable `answer` is now equal to `"Yes"`. The condition of the if-statement returns `false`, and `JavaScript loves you back ‚ù§Ô∏è` gets logged. </p> </details> ---

================================================================================

--- QUESTION abaZfoMXTIM1I7NAujeo ---
Question: How can we log the values that are commented out after the console.log statement?

```javascript
function* startGame() {
const answer = yield 'Do you love JavaScript?';
if (answer !== 'Yes') {
return "Oh wow... Guess we're done here";
}
return 'JavaScript loves you back ‚ù§Ô∏è';
}
const game = startGame();
console.log(/* 1 */); // Do you love JavaScript?
console.log(/* 2 */); // JavaScript loves you back ‚ù§Ô∏è
```
Category: JavaScript
Difficulty: medium

Options:
  opt1: A: `game.next("").value` and `game.next().value` ‚úì
  opt2: B: `game.next.value("")` and `game.next.value()` ‚úì
  opt3: C: `game.next().value` and `game.next("").value` ‚úì
  opt4: D: `game.next.value()` and `game.next.value("")` ‚úì

Correct Answer: C: `game.next().value` and `game.next("").value`
Explanation: if (answer !== 'Yes') { return "Oh wow... Guess we're done here"; } return 'JavaScript loves you back ‚ù§Ô∏è'; } const game = startGame(); console.log(/* 1 */); // Do you love JavaScript? console.log(/* 2 */); // JavaScript loves you back ‚ù§Ô∏è ``` - A: `game.next("Yes").value` and `game.next().value` - B: `game.next.value("Yes")` and `game.next.value()` - C: `game.next().value` and `game.next("Yes").value` - D: `game.next.value()` and `game.next.value("Yes")` <details><summary><b>Answer</b></summary> <p> #### Answer: C A generator function "pauses" its execution when it sees the `yield` keyword. First, we have to let the function yield the string "Do you love JavaScript?", which can be done by calling `game.next().value`. Every line is executed, until it finds the first `yield` keyword. There is a `yield` keyword on the first line within the function: the execution stops with the first yield! _This means that the variable `answer` is not defined yet!_ When we call `game.next("Yes").value`, the previous `yield` is replaced with the value of the parameters passed to the `next()` function, `"Yes"` in this case. The value of the variable `answer` is now equal to `"Yes"`. The condition of the if-statement returns `false`, and `JavaScript loves you back ‚ù§Ô∏è` gets logged. </p> </details> ---

================================================================================

--- QUESTION abaZfoMXTIM1I7NAujeo ---
Question: How can we log the values that are commented out after the console.log statement?

```javascript
function* startGame() {
const answer = yield 'Do you love JavaScript?';
if (answer !== 'Yes') {
return "Oh wow... Guess we're done here";
}
return 'JavaScript loves you back ‚ù§Ô∏è';
}
const game = startGame();
console.log(/* 1 */); // Do you love JavaScript?
console.log(/* 2 */); // JavaScript loves you back ‚ù§Ô∏è
```
Category: JavaScript
Difficulty: medium

Options:
  opt1: A: `game.next("").value` and `game.next().value` ‚úì
  opt2: B: `game.next.value("")` and `game.next.value()` ‚úì
  opt3: C: `game.next().value` and `game.next("").value` ‚úì
  opt4: D: `game.next.value()` and `game.next.value("")` ‚úì

Correct Answer: D: `game.next.value()` and `game.next.value("")`
Explanation: if (answer !== 'Yes') { return "Oh wow... Guess we're done here"; } return 'JavaScript loves you back ‚ù§Ô∏è'; } const game = startGame(); console.log(/* 1 */); // Do you love JavaScript? console.log(/* 2 */); // JavaScript loves you back ‚ù§Ô∏è ``` - A: `game.next("Yes").value` and `game.next().value` - B: `game.next.value("Yes")` and `game.next.value()` - C: `game.next().value` and `game.next("Yes").value` - D: `game.next.value()` and `game.next.value("Yes")` <details><summary><b>Answer</b></summary> <p> #### Answer: C A generator function "pauses" its execution when it sees the `yield` keyword. First, we have to let the function yield the string "Do you love JavaScript?", which can be done by calling `game.next().value`. Every line is executed, until it finds the first `yield` keyword. There is a `yield` keyword on the first line within the function: the execution stops with the first yield! _This means that the variable `answer` is not defined yet!_ When we call `game.next("Yes").value`, the previous `yield` is replaced with the value of the parameters passed to the `next()` function, `"Yes"` in this case. The value of the variable `answer` is now equal to `"Yes"`. The condition of the if-statement returns `false`, and `JavaScript loves you back ‚ù§Ô∏è` gets logged. </p> </details> ---

================================================================================

--- QUESTION ab9shnVdzISTBIAGr8oz ---
Question: What's the output?

```javascript
const name = 'Lydia Hallie';
console.log(!typeof name === 'object');
console.log(!typeof name === 'string');
```
Category: JavaScript
Difficulty: medium

Options:
  opt1: A: `false` `` ‚úì
  opt2: B: `` `false` ‚úì
  opt3: C: `false` `false`
  opt4: D: `` `` ‚úì

Correct Answer: A: `false` ``
Explanation: <p> #### Answer: C `typeof name` returns `"string"`. The string `"string"` is a truthy value, so `!typeof name` returns the boolean value `false`. `false === "object"` and `false === "string"` both return`false`. (If we wanted to check whether the type was (un)equal to a certain type, we should've written `!==` instead of `!typeof`) </p> </details> ---

================================================================================

--- QUESTION ab9shnVdzISTBIAGr8oz ---
Question: What's the output?

```javascript
const name = 'Lydia Hallie';
console.log(!typeof name === 'object');
console.log(!typeof name === 'string');
```
Category: JavaScript
Difficulty: medium

Options:
  opt1: A: `false` `` ‚úì
  opt2: B: `` `false` ‚úì
  opt3: C: `false` `false`
  opt4: D: `` `` ‚úì

Correct Answer: B: `` `false`
Explanation: <p> #### Answer: C `typeof name` returns `"string"`. The string `"string"` is a truthy value, so `!typeof name` returns the boolean value `false`. `false === "object"` and `false === "string"` both return`false`. (If we wanted to check whether the type was (un)equal to a certain type, we should've written `!==` instead of `!typeof`) </p> </details> ---

================================================================================

--- QUESTION ab9shnVdzISTBIAGr8oz ---
Question: What's the output?

```javascript
const name = 'Lydia Hallie';
console.log(!typeof name === 'object');
console.log(!typeof name === 'string');
```
Category: JavaScript
Difficulty: medium

Options:
  opt1: A: `false` `` ‚úì
  opt2: B: `` `false` ‚úì
  opt3: C: `false` `false`
  opt4: D: `` `` ‚úì

Correct Answer: D: `` ``
Explanation: <p> #### Answer: C `typeof name` returns `"string"`. The string `"string"` is a truthy value, so `!typeof name` returns the boolean value `false`. `false === "object"` and `false === "string"` both return`false`. (If we wanted to check whether the type was (un)equal to a certain type, we should've written `!==` instead of `!typeof`) </p> </details> ---

================================================================================

--- QUESTION XbGV9mrOLSZCk3KkU5u8 ---
Question: What's the output?

```javascript
const name = 'Lydia';
age = 21;
console.log(delete name);
console.log(delete age);
```
Category: JavaScript
Difficulty: medium

Options:
  opt1: A: `false`, `` ‚úì
  opt2: B: `"Lydia"`, `21`
  opt3: C: ``, `` ‚úì
  opt4: D: `undefined`, `undefined`

Correct Answer: A: `false`, ``
Explanation: <p> #### Answer: A The `delete` operator returns a boolean value: `true` on a successful deletion, else it'll return `false`. However, variables declared with the `var`, `const`, or `let` keywords cannot be deleted using the `delete` operator. The `name` variable was declared with a `const` keyword, so its deletion is not successful: `false` is returned. When we set `age` equal to `21`, we actually added a property called `age` to the global object. You can successfully delete properties from objects this way, also the global object, so `delete age` returns `true`. </p> </details> ---

================================================================================

--- QUESTION XbGV9mrOLSZCk3KkU5u8 ---
Question: What's the output?

```javascript
const name = 'Lydia';
age = 21;
console.log(delete name);
console.log(delete age);
```
Category: JavaScript
Difficulty: medium

Options:
  opt1: A: `false`, `` ‚úì
  opt2: B: `"Lydia"`, `21`
  opt3: C: ``, `` ‚úì
  opt4: D: `undefined`, `undefined`

Correct Answer: C: ``, ``
Explanation: <p> #### Answer: A The `delete` operator returns a boolean value: `true` on a successful deletion, else it'll return `false`. However, variables declared with the `var`, `const`, or `let` keywords cannot be deleted using the `delete` operator. The `name` variable was declared with a `const` keyword, so its deletion is not successful: `false` is returned. When we set `age` equal to `21`, we actually added a property called `age` to the global object. You can successfully delete properties from objects this way, also the global object, so `delete age` returns `true`. </p> </details> ---

================================================================================

--- QUESTION RGEDCFxvYYywKy9LYGZd ---
Question: What's the output?

```javascript
const name = 'Lydia Hallie';
const age = 21;
console.log(Number.isNaN(name));
console.log(Number.isNaN(age));
console.log(isNaN(name));
console.log(isNaN(age));
```
Category: JavaScript
Difficulty: medium

Options:
  opt1: A: `` `false` `` `false` ‚úì
  opt2: B: `` `false` `false` `false` ‚úì
  opt3: C: `false` `false` `` `false` ‚úì
  opt4: D: `false` `` `false` `` ‚úì

Correct Answer: A: `` `false` `` `false`
Explanation: <p> #### Answer: C With the `Number.isNaN` method, you can check if the value you pass is a _numeric value_ and equal to `NaN`. `name` is not a numeric value, so `Number.isNaN(name)` returns `false`. `age` is a numeric value, but is not equal to `NaN`, so `Number.isNaN(age)` returns `false`. With the `isNaN` method, you can check if the value you pass is not a number. `name` is not a number, so `isNaN(name)` returns true. `age` is a number, so `isNaN(age)` returns `false`. </p> </details> ---

================================================================================

--- QUESTION RGEDCFxvYYywKy9LYGZd ---
Question: What's the output?

```javascript
const name = 'Lydia Hallie';
const age = 21;
console.log(Number.isNaN(name));
console.log(Number.isNaN(age));
console.log(isNaN(name));
console.log(isNaN(age));
```
Category: JavaScript
Difficulty: medium

Options:
  opt1: A: `` `false` `` `false` ‚úì
  opt2: B: `` `false` `false` `false` ‚úì
  opt3: C: `false` `false` `` `false` ‚úì
  opt4: D: `false` `` `false` `` ‚úì

Correct Answer: B: `` `false` `false` `false`
Explanation: <p> #### Answer: C With the `Number.isNaN` method, you can check if the value you pass is a _numeric value_ and equal to `NaN`. `name` is not a numeric value, so `Number.isNaN(name)` returns `false`. `age` is a numeric value, but is not equal to `NaN`, so `Number.isNaN(age)` returns `false`. With the `isNaN` method, you can check if the value you pass is not a number. `name` is not a number, so `isNaN(name)` returns true. `age` is a number, so `isNaN(age)` returns `false`. </p> </details> ---

================================================================================

--- QUESTION RGEDCFxvYYywKy9LYGZd ---
Question: What's the output?

```javascript
const name = 'Lydia Hallie';
const age = 21;
console.log(Number.isNaN(name));
console.log(Number.isNaN(age));
console.log(isNaN(name));
console.log(isNaN(age));
```
Category: JavaScript
Difficulty: medium

Options:
  opt1: A: `` `false` `` `false` ‚úì
  opt2: B: `` `false` `false` `false` ‚úì
  opt3: C: `false` `false` `` `false` ‚úì
  opt4: D: `false` `` `false` `` ‚úì

Correct Answer: C: `false` `false` `` `false`
Explanation: <p> #### Answer: C With the `Number.isNaN` method, you can check if the value you pass is a _numeric value_ and equal to `NaN`. `name` is not a numeric value, so `Number.isNaN(name)` returns `false`. `age` is a numeric value, but is not equal to `NaN`, so `Number.isNaN(age)` returns `false`. With the `isNaN` method, you can check if the value you pass is not a number. `name` is not a number, so `isNaN(name)` returns true. `age` is a number, so `isNaN(age)` returns `false`. </p> </details> ---

================================================================================

--- QUESTION RGEDCFxvYYywKy9LYGZd ---
Question: What's the output?

```javascript
const name = 'Lydia Hallie';
const age = 21;
console.log(Number.isNaN(name));
console.log(Number.isNaN(age));
console.log(isNaN(name));
console.log(isNaN(age));
```
Category: JavaScript
Difficulty: medium

Options:
  opt1: A: `` `false` `` `false` ‚úì
  opt2: B: `` `false` `false` `false` ‚úì
  opt3: C: `false` `false` `` `false` ‚úì
  opt4: D: `false` `` `false` `` ‚úì

Correct Answer: D: `false` `` `false` ``
Explanation: <p> #### Answer: C With the `Number.isNaN` method, you can check if the value you pass is a _numeric value_ and equal to `NaN`. `name` is not a numeric value, so `Number.isNaN(name)` returns `false`. `age` is a numeric value, but is not equal to `NaN`, so `Number.isNaN(age)` returns `false`. With the `isNaN` method, you can check if the value you pass is not a number. `name` is not a number, so `isNaN(name)` returns true. `age` is a number, so `isNaN(age)` returns `false`. </p> </details> ---

================================================================================

--- QUESTION OopdbgREbVovuOn1Up2x ---
Question: What's the output?

```javascript
const user = {
email: "e@mail.com",
password: "12345"
}
const updateUser = ({ email, password }) => {
if (email) {
Object.assign(user, { email })
}
if (password) {
user.password = password
}
return user
}
const updatedUser = updateUser({ email: "new@email.com" })
console.log(updatedUser === user)
```
Category: JavaScript
Difficulty: medium

Options:
  opt1: A: `false`
  opt2: B: `` ‚úì
  opt3: C: `TypeError`
  opt4: D: `ReferenceError`

Correct Answer: B: ``
Explanation: <p> #### Answer: B The `updateUser` function updates the values of the `email` and `password` properties on user, if their values are passed to the function, after which the function returns the `user` object. The returned value of the `updateUser` function is the `user` object, which means that the value of updatedUser is a reference to the same `user` object that `user` points to. `updatedUser === user` equals `true`. </p> </details> ---

================================================================================

--- QUESTION JybvVISQxoi00Z2syrjl ---
Question: What's its value?

```javascript
const colorConfig = {
red: true,
blue: false,
green: true,
black: true,
yellow: false,
};
const colors = ['pink', 'red', 'blue'];
console.log(colorConfig.colors[1]);
```
Category: JavaScript
Difficulty: medium

Options:
  opt1: A: `` ‚úì
  opt2: B: `false`
  opt3: C: `undefined`
  opt4: D: `TypeError`

Correct Answer: A: ``
Explanation: <p> #### Answer: D In JavaScript, we have two ways to access properties on an object: bracket notation, or dot notation. In this example, we use dot notation (`colorConfig.colors`) instead of bracket notation (`colorConfig["colors"]`). With dot notation, JavaScript tries to find the property on the object with that exact name. In this example, JavaScript tries to find a property called `colors` on the `colorConfig` object. There is no property called `colors`, so this returns `undefined`. Then, we try to access the value of the first element by using `[1]`. We cannot do this on a value that's `undefined`, so it throws a `TypeError`: `Cannot read property '1' of undefined`. JavaScript interprets (or unboxes) statements. When we use bracket notation, it sees the first opening bracket `[` and keeps going until it finds the closing bracket `]`. Only then, it will evaluate the statement. If we would've used `colorConfig[colors[1]]`, it would have returned the value of the `red` property on the `colorConfig` object. </p> </details> ---

================================================================================

--- QUESTION JufTRDDjMIWCsL0bkEqo ---
Question: The JavaScript global execution context creates two things for you: the global object, and the "this" keyword.
Category: JavaScript
Difficulty: medium

Options:
  opt1: A: ‚úì
  opt2: B: false
  opt3: C: it depends

Correct Answer: A:
Explanation: <p> #### Answer: A The base execution context is the global execution context: it's what's accessible everywhere in your code. </p> </details> ---

================================================================================

--- QUESTION CgaqqQ1tuN0fXl7tj11C ---
Question: What's the output?

```javascript
let a = 3;
let b = new Number(3);
let c = 3;
console.log(a == b);
console.log(a === b);
console.log(b === c);
```
Category: JavaScript
Difficulty: medium

Options:
  opt1: A: `` `false` `` ‚úì
  opt2: B: `false` `false` `` ‚úì
  opt3: C: `` `false` `false` ‚úì
  opt4: D: `false` `` `` ‚úì

Correct Answer: A: `` `false` ``
Explanation: <p> #### Answer: C `new Number()` is a built-in function constructor. Although it looks like a number, it's not really a number: it has a bunch of extra features and is an object. When we use the `==` operator (Equality operator), it only checks whether it has the same _value_. They both have the value of `3`, so it returns `true`. However, when we use the `===` operator (Strict equality operator), both value _and_ type should be the same. It's not: `new Number()` is not a number, it's an **object**. Both return `false.` </p> </details> ---

================================================================================

--- QUESTION CgaqqQ1tuN0fXl7tj11C ---
Question: What's the output?

```javascript
let a = 3;
let b = new Number(3);
let c = 3;
console.log(a == b);
console.log(a === b);
console.log(b === c);
```
Category: JavaScript
Difficulty: medium

Options:
  opt1: A: `` `false` `` ‚úì
  opt2: B: `false` `false` `` ‚úì
  opt3: C: `` `false` `false` ‚úì
  opt4: D: `false` `` `` ‚úì

Correct Answer: B: `false` `false` ``
Explanation: <p> #### Answer: C `new Number()` is a built-in function constructor. Although it looks like a number, it's not really a number: it has a bunch of extra features and is an object. When we use the `==` operator (Equality operator), it only checks whether it has the same _value_. They both have the value of `3`, so it returns `true`. However, when we use the `===` operator (Strict equality operator), both value _and_ type should be the same. It's not: `new Number()` is not a number, it's an **object**. Both return `false.` </p> </details> ---

================================================================================

--- QUESTION CgaqqQ1tuN0fXl7tj11C ---
Question: What's the output?

```javascript
let a = 3;
let b = new Number(3);
let c = 3;
console.log(a == b);
console.log(a === b);
console.log(b === c);
```
Category: JavaScript
Difficulty: medium

Options:
  opt1: A: `` `false` `` ‚úì
  opt2: B: `false` `false` `` ‚úì
  opt3: C: `` `false` `false` ‚úì
  opt4: D: `false` `` `` ‚úì

Correct Answer: C: `` `false` `false`
Explanation: <p> #### Answer: C `new Number()` is a built-in function constructor. Although it looks like a number, it's not really a number: it has a bunch of extra features and is an object. When we use the `==` operator (Equality operator), it only checks whether it has the same _value_. They both have the value of `3`, so it returns `true`. However, when we use the `===` operator (Strict equality operator), both value _and_ type should be the same. It's not: `new Number()` is not a number, it's an **object**. Both return `false.` </p> </details> ---

================================================================================

--- QUESTION CgaqqQ1tuN0fXl7tj11C ---
Question: What's the output?

```javascript
let a = 3;
let b = new Number(3);
let c = 3;
console.log(a == b);
console.log(a === b);
console.log(b === c);
```
Category: JavaScript
Difficulty: medium

Options:
  opt1: A: `` `false` `` ‚úì
  opt2: B: `false` `false` `` ‚úì
  opt3: C: `` `false` `false` ‚úì
  opt4: D: `false` `` `` ‚úì

Correct Answer: D: `false` `` ``
Explanation: <p> #### Answer: C `new Number()` is a built-in function constructor. Although it looks like a number, it's not really a number: it has a bunch of extra features and is an object. When we use the `==` operator (Equality operator), it only checks whether it has the same _value_. They both have the value of `3`, so it returns `true`. However, when we use the `===` operator (Strict equality operator), both value _and_ type should be the same. It's not: `new Number()` is not a number, it's an **object**. Both return `false.` </p> </details> ---

================================================================================

--- QUESTION ATeTzjYFxPe8RBx4q1mW ---
Question: What's the output?

```javascript
const user = { name: 'Lydia', age: 21 };
const admin = { admin: true, ...user };
console.log(admin);
```
Category: JavaScript
Difficulty: medium

Options:
  opt1: A: `{ admin: , user: { name: "Lydia", age: 21 } }` ‚úì
  opt2: B: `{ admin: , name: "Lydia", age: 21 }` ‚úì
  opt3: C: `{ admin: , user: ["Lydia", 21] }` ‚úì
  opt4: D: `{ admin:  }` ‚úì

Correct Answer: A: `{ admin: , user: { name: "Lydia", age: 21 } }`
Explanation: <p> #### Answer: B It's possible to combine objects using the spread operator `...`. It lets you create copies of the key/value pairs of one object, and add them to another object. In this case, we create copies of the `user` object, and add them to the `admin` object. The `admin` object now contains the copied key/value pairs, which results in `{ admin: true, name: "Lydia", age: 21 }`. </p> </details> ---

================================================================================

--- QUESTION ATeTzjYFxPe8RBx4q1mW ---
Question: What's the output?

```javascript
const user = { name: 'Lydia', age: 21 };
const admin = { admin: true, ...user };
console.log(admin);
```
Category: JavaScript
Difficulty: medium

Options:
  opt1: A: `{ admin: , user: { name: "Lydia", age: 21 } }` ‚úì
  opt2: B: `{ admin: , name: "Lydia", age: 21 }` ‚úì
  opt3: C: `{ admin: , user: ["Lydia", 21] }` ‚úì
  opt4: D: `{ admin:  }` ‚úì

Correct Answer: B: `{ admin: , name: "Lydia", age: 21 }`
Explanation: <p> #### Answer: B It's possible to combine objects using the spread operator `...`. It lets you create copies of the key/value pairs of one object, and add them to another object. In this case, we create copies of the `user` object, and add them to the `admin` object. The `admin` object now contains the copied key/value pairs, which results in `{ admin: true, name: "Lydia", age: 21 }`. </p> </details> ---

================================================================================

--- QUESTION ATeTzjYFxPe8RBx4q1mW ---
Question: What's the output?

```javascript
const user = { name: 'Lydia', age: 21 };
const admin = { admin: true, ...user };
console.log(admin);
```
Category: JavaScript
Difficulty: medium

Options:
  opt1: A: `{ admin: , user: { name: "Lydia", age: 21 } }` ‚úì
  opt2: B: `{ admin: , name: "Lydia", age: 21 }` ‚úì
  opt3: C: `{ admin: , user: ["Lydia", 21] }` ‚úì
  opt4: D: `{ admin:  }` ‚úì

Correct Answer: C: `{ admin: , user: ["Lydia", 21] }`
Explanation: <p> #### Answer: B It's possible to combine objects using the spread operator `...`. It lets you create copies of the key/value pairs of one object, and add them to another object. In this case, we create copies of the `user` object, and add them to the `admin` object. The `admin` object now contains the copied key/value pairs, which results in `{ admin: true, name: "Lydia", age: 21 }`. </p> </details> ---

================================================================================

--- QUESTION ATeTzjYFxPe8RBx4q1mW ---
Question: What's the output?

```javascript
const user = { name: 'Lydia', age: 21 };
const admin = { admin: true, ...user };
console.log(admin);
```
Category: JavaScript
Difficulty: medium

Options:
  opt1: A: `{ admin: , user: { name: "Lydia", age: 21 } }` ‚úì
  opt2: B: `{ admin: , name: "Lydia", age: 21 }` ‚úì
  opt3: C: `{ admin: , user: ["Lydia", 21] }` ‚úì
  opt4: D: `{ admin:  }` ‚úì

Correct Answer: D: `{ admin:  }`
Explanation: <p> #### Answer: B It's possible to combine objects using the spread operator `...`. It lets you create copies of the key/value pairs of one object, and add them to another object. In this case, we create copies of the `user` object, and add them to the `admin` object. The `admin` object now contains the copied key/value pairs, which results in `{ admin: true, name: "Lydia", age: 21 }`. </p> </details> ---

================================================================================

--- QUESTION 68Dl5QMRHV9bScOCwv9n ---
Question: What's the output?

```javascript
console.log(Number(2) === Number(2));
console.log(Boolean(false) === Boolean(false));
console.log(Symbol('foo') === Symbol('foo'));
```
Category: JavaScript
Difficulty: medium

Options:
  opt1: A: ``, ``, `false` ‚úì
  opt2: B: `false`, ``, `false` ‚úì
  opt3: C: ``, `false`, `` ‚úì
  opt4: D: ``, ``, `` ‚úì

Correct Answer: A: ``, ``, `false`
Explanation: <p> #### Answer: A Every Symbol is entirely unique. The purpose of the argument passed to the Symbol is to give the Symbol a description. The value of the Symbol is not dependent on the passed argument. As we test equality, we are creating two entirely new symbols: the first `Symbol('foo')`, and the second `Symbol('foo')`. These two values are unique and not equal to each other, `Symbol('foo') === Symbol('foo')` returns `false`. </p> </details> ---

================================================================================

--- QUESTION 68Dl5QMRHV9bScOCwv9n ---
Question: What's the output?

```javascript
console.log(Number(2) === Number(2));
console.log(Boolean(false) === Boolean(false));
console.log(Symbol('foo') === Symbol('foo'));
```
Category: JavaScript
Difficulty: medium

Options:
  opt1: A: ``, ``, `false` ‚úì
  opt2: B: `false`, ``, `false` ‚úì
  opt3: C: ``, `false`, `` ‚úì
  opt4: D: ``, ``, `` ‚úì

Correct Answer: B: `false`, ``, `false`
Explanation: <p> #### Answer: A Every Symbol is entirely unique. The purpose of the argument passed to the Symbol is to give the Symbol a description. The value of the Symbol is not dependent on the passed argument. As we test equality, we are creating two entirely new symbols: the first `Symbol('foo')`, and the second `Symbol('foo')`. These two values are unique and not equal to each other, `Symbol('foo') === Symbol('foo')` returns `false`. </p> </details> ---

================================================================================

--- QUESTION 68Dl5QMRHV9bScOCwv9n ---
Question: What's the output?

```javascript
console.log(Number(2) === Number(2));
console.log(Boolean(false) === Boolean(false));
console.log(Symbol('foo') === Symbol('foo'));
```
Category: JavaScript
Difficulty: medium

Options:
  opt1: A: ``, ``, `false` ‚úì
  opt2: B: `false`, ``, `false` ‚úì
  opt3: C: ``, `false`, `` ‚úì
  opt4: D: ``, ``, `` ‚úì

Correct Answer: C: ``, `false`, ``
Explanation: <p> #### Answer: A Every Symbol is entirely unique. The purpose of the argument passed to the Symbol is to give the Symbol a description. The value of the Symbol is not dependent on the passed argument. As we test equality, we are creating two entirely new symbols: the first `Symbol('foo')`, and the second `Symbol('foo')`. These two values are unique and not equal to each other, `Symbol('foo') === Symbol('foo')` returns `false`. </p> </details> ---

================================================================================

--- QUESTION 68Dl5QMRHV9bScOCwv9n ---
Question: What's the output?

```javascript
console.log(Number(2) === Number(2));
console.log(Boolean(false) === Boolean(false));
console.log(Symbol('foo') === Symbol('foo'));
```
Category: JavaScript
Difficulty: medium

Options:
  opt1: A: ``, ``, `false` ‚úì
  opt2: B: `false`, ``, `false` ‚úì
  opt3: C: ``, `false`, `` ‚úì
  opt4: D: ``, ``, `` ‚úì

Correct Answer: D: ``, ``, ``
Explanation: <p> #### Answer: A Every Symbol is entirely unique. The purpose of the argument passed to the Symbol is to give the Symbol a description. The value of the Symbol is not dependent on the passed argument. As we test equality, we are creating two entirely new symbols: the first `Symbol('foo')`, and the second `Symbol('foo')`. These two values are unique and not equal to each other, `Symbol('foo') === Symbol('foo')` returns `false`. </p> </details> ---

================================================================================

--- QUESTION 35dhkE4tU4TPoeqcADFf ---
Question: What do we need to add to the `person` object to get `["Lydia Hallie", 21]` as the output of `[...person]`?

```javascript
const person = {
name: "Lydia Hallie",
age: 21
}
[...person] // ["Lydia Hallie", 21]
```
Category: JavaScript
Difficulty: medium

Options:
  opt1: A: Nothing, object are iterable by default
  opt2: B: `*[Symbol.iterator]() { for (let x in this) yield* this[x] }` ‚úì
  opt3: C: `*[Symbol.iterator]() { yield* Object.values(this) }`
  opt4: D: `*[Symbol.iterator]() { for (let x in this) yield this }`

Correct Answer: B: `*[Symbol.iterator]() { for (let x in this) yield* this[x] }`
Explanation: <p> #### Answer: C Objects aren't iterable by default. An iterable is an iterable if the iterator protocol is present. We can add this manually by adding the iterator symbol `[Symbol.iterator]`, which has to return a generator object, for example by making it a generator function `*[Symbol.iterator]() {}`. This generator function has to yield the `Object.values` of the `person` object if we want it to return the array `["Lydia Hallie", 21]`: `yield* Object.values(this)`. </p> </details> ---

================================================================================

