
## Question 116

What's the output?

```javascript
function Person(firstName, lastName) {
  this.firstName = firstName;
  this.lastName = lastName;
}

const lydia = new Person('Lydia', 'Hallie');
const sarah = Person('Sarah', 'Smith');

console.log(lydia);
console.log(sarah);
```

**A:** `Person {firstName: "Lydia", lastName: "Hallie"}` and `undefined`  
**B:** `Person {firstName: "Lydia", lastName: "Hallie"}` and `Person {firstName: "Sarah", lastName: "Smith"}`  
**C:** `Person {firstName: "Lydia", lastName: "Hallie"}` and `{}`  
**D:** `Person {firstName: "Lydia", lastName: "Hallie"}` and `ReferenceError`

**Answer:** A

**Explanation:** For `sarah`, we didn't use the `new` keyword. When using `new`, `this` refers to the new empty object we create. However, if you don't add `new`, `this` refers to the **global object**! We said that `this.firstName` equals `"Sarah"` and `this.lastName` equals `"Smith"`. What we actually did, is defining `global.firstName = 'Sarah'` and `global.lastName = 'Smith'`. `sarah` itself is left `undefined`, since we don't return a value from the `Person` function.

## Question 117

What are the three phases of event propagation?

**A:** Target > Capturing > Bubbling  
**B:** Bubbling > Target > Capturing  
**C:** Target > Bubbling > Capturing  
**D:** Capturing > Target > Bubbling

**Answer:** D

**Explanation:** During the **capturing** phase, the event goes through the ancestor elements down to the target element. It then reaches the **target** element, and **bubbling** begins.

## Question 118

All object have prototypes.

**A:** true  
**B:** false

**Answer:** B

**Explanation:** All objects have prototypes, except for the **base object**. The base object is the object created by the user, or an object that is created using the `new` keyword. The base object has access to some methods and properties, such as `.toString`. This is the reason why you can use built-in JavaScript methods! All of such methods are available on the prototype. Although JavaScript can't find it directly on your object, it goes down the prototype chain and finds it there, which makes it accessible for you.

## Question 119

What's the output?

```javascript
function sum(a, b) {
  return a + b;
}

sum(1, '2');
```

**A:** `NaN`  
**B:** `TypeError`  
**C:** `"12"`  
**D:** `3`

**Answer:** C

**Explanation:** JavaScript is a **dynamically typed language**: we don't specify what types certain variables are. Values can automatically be converted into another type without you knowing, which is called _implicit type coercion_. **Coercion** is converting from one type into another. In this example, JavaScript converts the number `1` into a string, in order for the function to make sense and return a value. During the addition of a numeric type (`1`) and a string type (`'2'`), the number is treated as a string. We can concatenate strings like `"Hello" + "World"`, so what's happening here is `"1" + "2"` which returns `"12"`.

## Question 120

What's the output?

```javascript
let number = 0;
console.log(number++);
console.log(++number);
console.log(number);
```

**A:** `1` `1` `2`  
**B:** `1` `2` `2`  
**C:** `0` `2` `2`  
**D:** `0` `1` `2`

**Answer:** C

**Explanation:** The **postfix** unary operator `++`: 1. Returns the value (this returns `0`) 2. Increments the value (number is now `1`). The **prefix** unary operator `++`: 1. Increments the value (number is now `2`) 2. Returns the value (this returns `2`). This returns `0 2 2`.

## Question 121

What's the output?

```javascript
function getPersonInfo(one, two, three) {
  console.log(one);
  console.log(two);
  console.log(three);
}

const person = 'Lydia';
const age = 21;

getPersonInfo`${person} is ${age} years old`;
```

**A:** `"Lydia"` `21` `["", " is ", " years old"]`  
**B:** `["", " is ", " years old"]` `"Lydia"` `21`  
**C:** `"Lydia"` `["", " is ", " years old"]` `21`

**Answer:** B

**Explanation:** If you use tagged template literals, the value of the first argument is always an array of the string values. The remaining arguments get the values of the passed expressions!

## Question 122

What's the output?

```javascript
function checkAge(data) {
  if (data === { age: 18 }) {
    console.log('You are an adult!');
  } else if (data == { age: 18 }) {
    console.log('You are still an adult.');
  } else {
    console.log(`Hmm.. You don't have an age I guess`);
  }
}

checkAge({ age: 18 });
```

**A:** `You are an adult!`  
**B:** `You are still an adult.`  
**C:** `Hmm.. You don't have an age I guess`

**Answer:** C

**Explanation:** When testing equality, primitives are compared by their _value_, while objects are compared by their _reference_. JavaScript checks if the objects have a reference to the same location in memory. The two objects that we are comparing don't have that: the object we passed as a parameter refers to a different location in memory than the object we used in order to check equality. This is why both `{ age: 18 } === { age: 18 }` and `{ age: 18 } == { age: 18 }` return `false`.

## Question 123

What's the output?

```javascript
function getAge(...args) {
  console.log(typeof args);
}

getAge(21);
```

**A:** `"number"`  
**B:** `"array"`  
**C:** `"object"`  
**D:** `"NaN"`

**Answer:** C

**Explanation:** The rest parameter (`...args`) lets us "collect" all remaining arguments into an array. An array is an object, so `typeof args` returns `"object"`

## Question 124

What's the output?

```javascript
function getAge() {
  'use strict';
  age = 21;
  console.log(age);
}

getAge();
```

**A:** `21`  
**B:** `undefined`  
**C:** `ReferenceError`  
**D:** `TypeError`

**Answer:** C

**Explanation:** With `"use strict"`, you can make sure that you don't accidentally declare global variables. We never declared the variable `age`, and since we use `"use strict"`, it will throw a reference error. If we didn't use `"use strict"`, it would have worked, since the property `age` would have gotten added to the global object.

## Question 125

What's the value of `sum`?

```javascript
const sum = eval('10*10+5');
```

**A:** `105`  
**B:** `"105"`  
**C:** `TypeError`  
**D:** `"10*10+5"`

**Answer:** A

**Explanation:** `eval` evaluates code that's passed as a string. If it's an expression, like in this case, it evaluates the expression. The expression is `10 * 10 + 5`. This returns the number `105`.

## Question 126

How long is cool_secret accessible?

```javascript
sessionStorage.setItem('cool_secret', 123);
```

**A:** Forever, the data doesn't get lost.  
**B:** When the user closes the tab.  
**C:** When the user closes the entire browser, not only the tab.  
**D:** When the user shuts off their computer.

**Answer:** B

**Explanation:** The data stored in `sessionStorage` is removed after closing the _tab_. If you used `localStorage`, the data would've been there forever, unless for example `localStorage.clear()` is invoked.

## Question 127

What's the output?

```javascript
var num = 8;
var num = 10;

console.log(num);
```

**A:** `8`  
**B:** `10`  
**C:** `SyntaxError`  
**D:** `ReferenceError`

**Answer:** B

**Explanation:** With the `var` keyword, you can declare multiple variables with the same name. The variable will then hold the latest value. You cannot do this with `let` or `const` since they're block-scoped and therefore can't be redeclared.

## Question 128

What's the output?

```javascript
const obj = { 1: 'a', 2: 'b', 3: 'c' };
const set = new Set([1, 2, 3, 4, 5]);

obj.hasOwnProperty('1');
obj.hasOwnProperty(1);
set.has('1');
set.has(1);
```

**A:** `false` `true` `false` `true`  
**B:** `false` `true` `true` `true`  
**C:** `true` `true` `false` `true`  
**D:** `true` `true` `true` `true`

**Answer:** C

**Explanation:** All object keys (excluding Symbols) are strings under the hood, even if you don't type it yourself as a string. This is why `obj.hasOwnProperty('1')` also returns true. It doesn't work that way for a set. There is no `'1'` in our set: `set.has('1')` returns `false`. It has the numeric type `1`, `set.has(1)` returns `true`.

## Question 129

What's the output?

```javascript
const obj = { a: 'one', b: 'two', a: 'three' };
console.log(obj);
```

**A:** `{ a: "one", b: "two" }`  
**B:** `{ b: "two", a: "three" }`  
**C:** `{ a: "three", b: "two" }`  
**D:** `SyntaxError`

**Answer:** C

**Explanation:** If you have two keys with the same name, the key will be replaced. It will still be in its first position, but with the last specified value.
