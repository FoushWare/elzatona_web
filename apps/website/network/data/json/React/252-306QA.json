[
  {
    "id": "q252",
    "title": "How does React update the screen in an application?",
    "content": "React updates the UI in three steps: (1) Triggering a render (initial or state update), (2) Rendering components recursively, (3) Committing minimal DOM changes.",
    "type": "open-ended",
    "category": "React",
    "subcategory": "React Basics",
    "difficulty": "intermediate",
    "learningCardId": "framework-questions",
    "topic": "Rendering",
    "isActive": true,
    "createdAt": "2024-01-01T00:00:00.000Z",
    "updatedAt": "2024-01-01T00:00:00.000Z",
    "createdBy": "admin",
    "tags": ["react", "rendering", "dom", "reconciliation"],
    "explanation": "React uses a render-commit cycle: it first computes what to render, then applies only necessary changes to the DOM for performance.",
    "points": 7,
    "sampleAnswers": [
      "React triggers a render on mount or state change, recursively calls component functions to build a virtual DOM, then commits minimal real DOM updates.",
      "This three-step process ensures efficient UI updates without unnecessary repaints or reflows."
    ]
  },
  {
    "id": "q253",
    "title": "How does React batch multiple state updates?",
    "content": "React groups multiple state updates in event handlers into a single re-render (batching). React 18 extends this to async code (automatic batching).",
    "type": "open-ended",
    "category": "React",
    "subcategory": "State Management",
    "difficulty": "intermediate",
    "learningCardId": "framework-questions",
    "topic": "State Updates",
    "isActive": true,
    "createdAt": "2024-01-01T00:00:00.000Z",
    "updatedAt": "2024-01-01T00:00:00.000Z",
    "createdBy": "admin",
    "tags": ["react", "batching", "state", "performance"],
    "explanation": "Automatic batching in React 18 ensures that even async updates (e.g., in fetch callbacks) trigger only one re-render, improving performance.",
    "points": 7,
    "sampleAnswers": [
      "React batches multiple `setState` calls in the same event handler into one re-render. In React 18, this works even in promises and timeouts.",
      "Example: calling `setA()` and `setB()` in a fetch callback causes only one re-render, not two."
    ]
  },
  {
    "id": "q254",
    "title": "Is it possible to prevent automatic batching?",
    "content": "Yes, using `flushSync` from `react-dom` to force immediate DOM updates and disable batching for specific state changes.",
    "type": "open-ended",
    "category": "React",
    "subcategory": "State Management",
    "difficulty": "advanced",
    "learningCardId": "framework-questions",
    "topic": "State Updates",
    "isActive": true,
    "createdAt": "2024-01-01T00:00:00.000Z",
    "updatedAt": "2024-01-01T00:00:00.000Z",
    "createdBy": "admin",
    "tags": ["react", "flushsync", "batching", "dom"],
    "explanation": "`flushSync` forces React to process state updates immediately, useful when you need DOM to reflect state before next line executes.",
    "points": 8,
    "sampleAnswers": [
      "`flushSync(() => { setA(a+1); }); setB(b+1);` causes two re-renders: one after `setA`, another after `setB`.",
      "Use sparingly—it defeats performance benefits of batching and should only be used when DOM measurement is required mid-update."
    ]
  },
  {
    "id": "q255",
    "title": "What is React hydration?",
    "content": "Hydration attaches event handlers and state to server-rendered static HTML, making it interactive on the client.",
    "type": "open-ended",
    "category": "React",
    "subcategory": "Server-Side Rendering",
    "difficulty": "intermediate",
    "learningCardId": "framework-questions",
    "topic": "Hydration",
    "isActive": true,
    "createdAt": "2024-01-01T00:00:00.000Z",
    "updatedAt": "2024-01-01T00:00:00.000Z",
    "createdBy": "admin",
    "tags": ["react", "hydration", "ssr", "seo"],
    "explanation": "After server sends pre-rendered HTML, `hydrateRoot` makes it interactive by attaching React event system and state.",
    "points": 7,
    "sampleAnswers": [
      "Hydration is the process where React takes static HTML from the server and 'activates' it by attaching event listeners and state.",
      "It enables fast initial load (SEO-friendly) with full interactivity, bridging server and client rendering."
    ]
  },
  {
    "id": "q256",
    "title": "How do you update objects inside state?",
    "content": "Never mutate state objects directly. Create a new object using spread syntax: `setUser({ ...user, name: 'New' })`.",
    "type": "open-ended",
    "category": "React",
    "subcategory": "State Management",
    "difficulty": "intermediate",
    "learningCardId": "framework-questions",
    "topic": "Immutable State",
    "isActive": true,
    "createdAt": "2024-01-01T00:00:00.000Z",
    "updatedAt": "2024-01-01T00:00:00.000Z",
    "createdBy": "admin",
    "tags": ["react", "state", "immutability", "objects"],
    "explanation": "React relies on object reference comparison; mutating state directly won’t trigger re-renders.",
    "points": 6,
    "sampleAnswers": [
      "Use spread syntax to create a new object: `setUser({ ...user, firstName: e.target.value })` instead of `user.firstName = ...`.",
      "Direct mutation bypasses React’s change detection, so the UI won’t update even if state changes."
    ]
  },
  {
    "id": "q257",
    "title": "How do you update nested objects inside state?",
    "content": "Use nested spread syntax: `setUser({ ...user, address: { ...user.address, country: 'Germany' } })`.",
    "type": "open-ended",
    "category": "React",
    "subcategory": "State Management",
    "difficulty": "intermediate",
    "learningCardId": "framework-questions",
    "topic": "Immutable State",
    "isActive": true,
    "createdAt": "2024-01-01T00:00:00.000Z",
    "updatedAt": "2024-01-01T00:00:00.000Z",
    "createdBy": "admin",
    "tags": ["react", "nested-state", "immutability", "objects"],
    "explanation": "Spread is shallow, so nested objects require spreading at each level to preserve immutability.",
    "points": 7,
    "sampleAnswers": [
      "For `user.address.country`, update with: `setUser({ ...user, address: { ...user.address, country: 'Germany' } })`.",
      "This ensures a new reference for both the top-level object and the nested object, triggering re-renders correctly."
    ]
  },
  {
    "id": "q258",
    "title": "How do you update arrays inside state?",
    "content": "Avoid mutating methods (`push`, `pop`). Use non-mutating methods (`filter`, `map`, spread) to create new arrays.",
    "type": "open-ended",
    "category": "React",
    "subcategory": "State Management",
    "difficulty": "intermediate",
    "learningCardId": "framework-questions",
    "topic": "Immutable State",
    "isActive": true,
    "createdAt": "2024-01-01T00:00:00.000Z",
    "updatedAt": "2024-01-01T00:00:00.000Z",
    "createdBy": "admin",
    "tags": ["react", "arrays", "immutability", "state"],
    "explanation": "React compares array references; mutating the original array won’t trigger a re-render.",
    "points": 6,
    "sampleAnswers": [
      "To add an item: `setTodos([...todos, newItem])`. To remove: `setTodos(todos.filter((_, i) => i !== index))`.",
      "Never use `todos.push()` directly—always create a new array instance."
    ]
  },
  {
    "id": "q259",
    "title": "How do you use immer library for state updates?",
    "content": "Use `useImmer` to write mutable-style code that produces immutable updates via proxies.",
    "type": "open-ended",
    "category": "React",
    "subcategory": "State Management",
    "difficulty": "intermediate",
    "learningCardId": "framework-questions",
    "topic": "Immer",
    "isActive": true,
    "createdAt": "2024-01-01T00:00:00.000Z",
    "updatedAt": "2024-01-01T00:00:00.000Z",
    "createdBy": "admin",
    "tags": ["react", "immer", "immutability", "state"],
    "explanation": "Immer lets you write `draft.address.country = 'Germany'` while ensuring the final state is immutable.",
    "points": 7,
    "sampleAnswers": [
      "Install `use-immer`, then `const [user, setUser] = useImmer(initialState); setUser(draft => { draft.address.country = 'Germany'; });`",
      "Immer uses proxies to track mutations and produce a new immutable state object automatically."
    ]
  },
  {
    "id": "q260",
    "title": "What are the benefits of preventing direct state mutations?",
    "content": "Prevents bugs, enables predictable re-renders, supports time-travel debugging, and aligns with React’s declarative model.",
    "type": "multiple-choice",
    "category": "React",
    "subcategory": "State Management",
    "difficulty": "intermediate",
    "learningCardId": "framework-questions",
    "topic": "Immutable State",
    "isActive": true,
    "createdAt": "2024-01-01T00:00:00.000Z",
    "updatedAt": "2024-01-01T00:00:00.000Z",
    "createdBy": "admin",
    "tags": ["react", "immutability", "state", "debugging"],
    "explanation": "Immutability ensures React can detect changes via reference comparison, enabling performance optimizations and debugging tools.",
    "points": 6,
    "options": [
      {
        "id": "a",
        "text": "Allows faster direct DOM manipulation",
        "isCorrect": false
      },
      {
        "id": "b",
        "text": "Enables predictable re-renders, debugging, and performance optimizations",
        "isCorrect": true
      },
      {
        "id": "c",
        "text": "Reduces bundle size",
        "isCorrect": false
      },
      {
        "id": "d",
        "text": "Makes code more verbose",
        "isCorrect": false
      }
    ]
  },
  {
    "id": "q261",
    "title": "What are preferred and non-preferred array operations for updating state?",
    "content": "Preferred: `concat`, `...`, `filter`, `map`, `slice`. Non-preferred: `push`, `pop`, `splice`, direct assignment, `sort`, `reverse`.",
    "type": "multiple-choice",
    "category": "React",
    "subcategory": "State Management",
    "difficulty": "intermediate",
    "learningCardId": "framework-questions",
    "topic": "Immutable State",
    "isActive": true,
    "createdAt": "2024-01-01T00:00:00.000Z",
    "updatedAt": "2024-01-01T00:00:00.000Z",
    "createdBy": "admin",
    "tags": ["react", "arrays", "immutability", "state"],
    "explanation": "Non-mutating methods return new arrays, preserving immutability; mutating methods change the original array.",
    "points": 6,
    "options": [
      {
        "id": "a",
        "text": "Use `push` and `splice` for performance",
        "isCorrect": false
      },
      {
        "id": "b",
        "text": "Preferred: concat/spread/filter/map; Non-preferred: push/pop/splice/sort",
        "isCorrect": true
      },
      {
        "id": "c",
        "text": "All array methods are safe",
        "isCorrect": false
      },
      {
        "id": "d",
        "text": "Only `slice` is safe",
        "isCorrect": false
      }
    ]
  },
  {
    "id": "q262",
    "title": "What happens by defining nested function components?",
    "content": "Defining components inside other components causes unnecessary re-renders and performance issues due to new identity on every render.",
    "type": "open-ended",
    "category": "React",
    "subcategory": "Performance Optimization",
    "difficulty": "intermediate",
    "learningCardId": "framework-questions",
    "topic": "Component Definition",
    "isActive": true,
    "createdAt": "2024-01-01T00:00:00.000Z",
    "updatedAt": "2024-01-01T00:00:00.000Z",
    "createdBy": "admin",
    "tags": ["react", "nested-components", "performance", "optimization"],
    "explanation": "Nested components get a new identity each render, breaking memoization and causing child re-renders even when props haven’t changed.",
    "points": 6,
    "sampleAnswers": [
      "Defining a component inside another creates a new function on every render, so `React.memo` won’t work and children re-render unnecessarily.",
      "Always define components at the top level or outside the parent component to preserve referential identity."
    ]
  },
  {
    "id": "q263",
    "title": "Can I use keys for non-list items?",
    "content": "Yes. Keys help React identify components beyond lists, such as toggling between different component types.",
    "type": "true-false",
    "category": "React",
    "subcategory": "Lists and Keys",
    "difficulty": "intermediate",
    "learningCardId": "framework-questions",
    "topic": "Keys",
    "isActive": true,
    "createdAt": "2024-01-01T00:00:00.000Z",
    "updatedAt": "2024-01-01T00:00:00.000Z",
    "createdBy": "admin",
    "tags": ["react", "keys", "components", "reconciliation"],
    "explanation": "Keys are used whenever React needs to distinguish between elements of the same type, not just in lists.",
    "points": 5,
    "options": [
      {
        "id": "a",
        "text": "True",
        "isCorrect": true
      },
      {
        "id": "b",
        "text": "False",
        "isCorrect": false
      }
    ]
  },
  {
    "id": "q264",
    "title": "What are the guidelines for writing reducers?",
    "content": "1. Reducers must be pure (no side effects). 2. Each action should represent a single user intent, even if it updates multiple state fields.",
    "type": "multiple-choice",
    "category": "React",
    "subcategory": "State Management",
    "difficulty": "intermediate",
    "learningCardId": "framework-questions",
    "topic": "Reducers",
    "isActive": true,
    "createdAt": "2024-01-01T00:00:00.000Z",
    "updatedAt": "2024-01-01T00:00:00.000Z",
    "createdBy": "admin",
    "tags": ["react", "reducers", "redux", "pure-functions"],
    "explanation": "Pure reducers ensure predictability and testability; single-intent actions improve debugging and time-travel.",
    "points": 7,
    "options": [
      {
        "id": "a",
        "text": "Reducers can make API calls",
        "isCorrect": false
      },
      {
        "id": "b",
        "text": "Reducers must be pure; actions should represent single user intents",
        "isCorrect": true
      },
      {
        "id": "c",
        "text": "Each state field needs its own action",
        "isCorrect": false
      },
      {
        "id": "d",
        "text": "Reducers should mutate state for performance",
        "isCorrect": false
      }
    ]
  },
  {
    "id": "q265",
    "title": "How does ReactJS work behind the scenes?",
    "content": "React uses Virtual DOM, Fiber architecture, reconciliation, and commit phases to efficiently update UI with minimal DOM changes.",
    "type": "open-ended",
    "category": "React",
    "subcategory": "Virtual DOM",
    "difficulty": "advanced",
    "learningCardId": "framework-questions",
    "topic": "Fiber Architecture",
    "isActive": true,
    "createdAt": "2024-01-01T00:00:00.000Z",
    "updatedAt": "2024-01-01T00:00:00.000Z",
    "createdBy": "admin",
    "tags": ["react", "fiber", "virtual-dom", "reconciliation"],
    "explanation": "Fiber breaks work into units, enables interruptible rendering, and uses scheduler for priority-based updates.",
    "points": 9,
    "sampleAnswers": [
      "React builds a Virtual DOM tree, reconciles it with the previous tree using a diffing algorithm, then commits minimal real DOM changes in the commit phase.",
      "Fiber architecture allows React to pause, resume, and prioritize work, enabling concurrent features like Suspense and time-slicing."
    ]
  },
  {
    "id": "q266",
    "title": "How is `useReducer` different from `useState`?",
    "content": "useState: simple state, direct updates. useReducer: complex state, action-based updates, logic in reducer, more testable.",
    "type": "multiple-choice",
    "category": "React",
    "subcategory": "React Hooks",
    "difficulty": "intermediate",
    "learningCardId": "framework-questions",
    "topic": "useReducer",
    "isActive": true,
    "createdAt": "2024-01-01T00:00:00.000Z",
    "updatedAt": "2024-01-01T00:00:00.000Z",
    "createdBy": "admin",
    "tags": ["react", "usereducer", "usestate", "hooks"],
    "explanation": "`useReducer` centralizes update logic, making it ideal for complex state with multiple sub-values or dependencies.",
    "points": 7,
    "options": [
      {
        "id": "a",
        "text": "useReducer is only for Redux",
        "isCorrect": false
      },
      {
        "id": "b",
        "text": "useState: simple state; useReducer: complex state with centralized logic",
        "isCorrect": true
      },
      {
        "id": "c",
        "text": "useState cannot hold objects",
        "isCorrect": false
      },
      {
        "id": "d",
        "text": "useReducer causes more re-renders",
        "isCorrect": false
      }
    ]
  },
  {
    "id": "q267",
    "title": "What is useContext? What are the steps to follow for useContext?",
    "content": "Steps: (1) Create context with `createContext()`, (2) Wrap with `Provider`, (3) Consume with `useContext()` in child components.",
    "type": "open-ended",
    "category": "React",
    "subcategory": "Context API",
    "difficulty": "intermediate",
    "learningCardId": "framework-questions",
    "topic": "Context API",
    "isActive": true,
    "createdAt": "2024-01-01T00:00:00.000Z",
    "updatedAt": "2024-01-01T00:00:00.000Z",
    "createdBy": "admin",
    "tags": ["react", "context-api", "usecontext", "state-management"],
    "explanation": "`useContext` eliminates prop drilling by allowing components to access shared state from a Provider.",
    "points": 6,
    "sampleAnswers": [
      "1. `const ThemeContext = createContext();` 2. `<ThemeContext.Provider value=\"dark\"><App /></ThemeContext.Provider>` 3. `const theme = useContext(ThemeContext);`",
      "This pattern is ideal for themes, auth, or any global state that many components need."
    ]
  },
  {
    "id": "q268",
    "title": "What are the use cases of useContext hook?",
    "content": "Theme switching, auth state, localization, modal visibility, and global state when combined with useReducer.",
    "type": "multiple-choice",
    "category": "React",
    "subcategory": "Context API",
    "difficulty": "intermediate",
    "learningCardId": "framework-questions",
    "topic": "Context API",
    "isActive": true,
    "createdAt": "2024-01-01T00:00:00.000Z",
    "updatedAt": "2024-01-01T00:00:00.000Z",
    "createdBy": "admin",
    "tags": ["react", "usecontext", "global-state", "theming"],
    "explanation": "Context is perfect for data that needs to be accessed by many components at different nesting levels.",
    "points": 6,
    "options": [
      {
        "id": "a",
        "text": "Only for passing props to immediate children",
        "isCorrect": false
      },
      {
        "id": "b",
        "text": "Theme, auth, i18n, modals, and global state with useReducer",
        "isCorrect": true
      },
      {
        "id": "c",
        "text": "Replacing all useState calls",
        "isCorrect": false
      },
      {
        "id": "d",
        "text": "Only for class components",
        "isCorrect": false
      }
    ]
  },
  {
    "id": "q269",
    "title": "When to use client and server components?",
    "content": "Client: interactivity, state, effects, browser APIs. Server: data fetching, backend access, sensitive info, reducing JS bundle.",
    "type": "multiple-choice",
    "category": "Next.js & Frameworks",
    "subcategory": "Next.js Basics",
    "difficulty": "intermediate",
    "learningPath": "Next.js & Frameworks",
    "topic": "App Router",
    "isActive": true,
    "createdAt": "2024-01-01T00:00:00.000Z",
    "updatedAt": "2024-01-01T00:00:00.000Z",
    "createdBy": "admin",
    "tags": ["nextjs", "server-components", "client-components", "rsc"],
    "explanation": "Server Components run only on the server, have no interactivity, but can access databases directly and reduce client JS.",
    "points": 7,
    "options": [
      {
        "id": "a",
        "text": "Use client components for all data fetching",
        "isCorrect": false
      },
      {
        "id": "b",
        "text": "Client: interactivity/state; Server: data fetching/sensitive logic",
        "isCorrect": true
      },
      {
        "id": "c",
        "text": "Server components can use useState",
        "isCorrect": false
      },
      {
        "id": "d",
        "text": "Client components are always faster",
        "isCorrect": false
      }
    ]
  },
  {
    "id": "q270",
    "title": "What are the differences between page router and app router in Next.js?",
    "content": "Pages Router: file-based, client-side navigation. App Router: React Server Components, nested layouts, streaming, and built-in Suspense.",
    "type": "open-ended",
    "category": "Next.js & Frameworks",
    "subcategory": "Next.js Basics",
    "difficulty": "advanced",
    "learningPath": "Next.js & Frameworks",
    "topic": "App Router vs Pages Router",
    "isActive": true,
    "createdAt": "2024-01-01T00:00:00.000Z",
    "updatedAt": "2024-01-01T00:00:00.000Z",
    "createdBy": "admin",
    "tags": ["nextjs", "app-router", "pages-router", "routing"],
    "explanation": "App Router is the modern Next.js architecture with server-first rendering, layouts, and better data fetching.",
    "points": 8,
    "sampleAnswers": [
      "Pages Router uses `pages/` directory with client-side routing. App Router uses `app/` with server components, nested layouts, and streaming.",
      "App Router supports React Server Components, Suspense for data, and automatic code splitting by route."
    ]
  },
  {
    "id": "q271",
    "title": "Can you describe the useMemo() Hook?",
    "content": "`useMemo` caches expensive calculations and only recomputes when dependencies change.",
    "type": "open-ended",
    "category": "React",
    "subcategory": "React Hooks",
    "difficulty": "intermediate",
    "learningCardId": "framework-questions",
    "topic": "useMemo",
    "isActive": true,
    "createdAt": "2024-01-01T00:00:00.000Z",
    "updatedAt": "2024-01-01T00:00:00.000Z",
    "createdBy": "admin",
    "tags": ["react", "usememo", "performance", "hooks"],
    "explanation": "It prevents unnecessary recalculations on every render, improving performance for derived data.",
    "points": 7,
    "sampleAnswers": [
      "`const filteredUsers = useMemo(() => users.filter(u => u.name.includes(search)), [search]);` only filters when `search` changes.",
      "Use `useMemo` for expensive operations like sorting, filtering, or complex computations that depend on props or state."
    ]
  },
  {
    "id": "q272",
    "title": "Can Hooks be used in class components?",
    "content": "No. Hooks are only for function components. Class and function components can coexist in the same app.",
    "type": "true-false",
    "category": "React",
    "subcategory": "React Hooks",
    "difficulty": "beginner",
    "learningCardId": "framework-questions",
    "topic": "React Hooks",
    "isActive": true,
    "createdAt": "2024-01-01T00:00:00.000Z",
    "updatedAt": "2024-01-01T00:00:00.000Z",
    "createdBy": "admin",
    "tags": ["react", "hooks", "class-components", "function-components"],
    "explanation": "Hooks rely on call order, which is only guaranteed in function components.",
    "points": 4,
    "options": [
      {
        "id": "a",
        "text": "True",
        "isCorrect": false
      },
      {
        "id": "b",
        "text": "False",
        "isCorrect": true
      }
    ]
  },
  {
    "id": "q273",
    "title": "What is an updater function? Should it be used in all cases?",
    "content": "An updater function is `setState(prev => newValue)`. Use it when state depends on previous state; not needed for static values.",
    "type": "open-ended",
    "category": "React",
    "subcategory": "State Management",
    "difficulty": "intermediate",
    "learningCardId": "framework-questions",
    "topic": "State Updates",
    "isActive": true,
    "createdAt": "2024-01-01T00:00:00.000Z",
    "updatedAt": "2024-01-01T00:00:00.000Z",
    "createdBy": "admin",
    "tags": ["react", "setstate", "updater-function", "state"],
    "explanation": "Updater functions ensure you always have the latest state, avoiding stale closures in async or batched updates.",
    "points": 6,
    "sampleAnswers": [
      "Use `setCount(c => c + 1)` when incrementing; use `setName('John')` for static values. The former avoids stale state issues.",
      "In event handlers with multiple updates, updater functions guarantee correct sequencing: `setC(c=>c+1); setC(c=>c+1)` adds 2."
    ]
  },
  {
    "id": "q274",
    "title": "Can useState take a function as an initial value?",
    "content": "Yes. `useState(() => expensiveComputation())` for lazy initialization—runs only once on mount.",
    "type": "true-false",
    "category": "React",
    "subcategory": "React Hooks",
    "difficulty": "intermediate",
    "learningCardId": "framework-questions",
    "topic": "useState",
    "isActive": true,
    "createdAt": "2024-01-01T00:00:00.000Z",
    "updatedAt": "2024-01-01T00:00:00.000Z",
    "createdBy": "admin",
    "tags": ["react", "usestate", "lazy-initialization", "hooks"],
    "explanation": "The initializer function runs only once, avoiding expensive computation on every render.",
    "points": 5,
    "options": [
      {
        "id": "a",
        "text": "True",
        "isCorrect": true
      },
      {
        "id": "b",
        "text": "False",
        "isCorrect": false
      }
    ]
  },
  {
    "id": "q275",
    "title": "What types of values can `useState` hold?",
    "content": "Any type: primitives, objects, arrays, functions, null, undefined. But objects/arrays require immutability for re-renders.",
    "type": "multiple-choice",
    "category": "React",
    "subcategory": "React Hooks",
    "difficulty": "intermediate",
    "learningCardId": "framework-questions",
    "topic": "useState",
    "isActive": true,
    "createdAt": "2024-01-01T00:00:00.000Z",
    "updatedAt": "2024-01-01T00:00:00.000Z",
    "createdBy": "admin",
    "tags": ["react", "usestate", "state", "immutability"],
    "explanation": "React compares state by reference, so mutating objects/arrays won’t trigger re-renders.",
    "points": 6,
    "options": [
      {
        "id": "a",
        "text": "Only strings and numbers",
        "isCorrect": false
      },
      {
        "id": "b",
        "text": "Any type, but objects/arrays must be immutable",
        "isCorrect": true
      },
      {
        "id": "c",
        "text": "Functions are not allowed",
        "isCorrect": false
      },
      {
        "id": "d",
        "text": "Only primitives",
        "isCorrect": false
      }
    ]
  },
  {
    "id": "q276",
    "title": "What happens if you call `useState` conditionally?",
    "content": "React throws a runtime error because hooks must be called in the same order every render.",
    "type": "open-ended",
    "category": "React",
    "subcategory": "React Hooks",
    "difficulty": "intermediate",
    "learningCardId": "framework-questions",
    "topic": "Rules of Hooks",
    "isActive": true,
    "createdAt": "2024-01-01T00:00:00.000Z",
    "updatedAt": "2024-01-01T00:00:00.000Z",
    "createdBy": "admin",
    "tags": ["react", "hooks", "conditional", "rules-of-hooks"],
    "explanation": "Conditional hook calls break React’s internal hook order tracking, causing bugs.",
    "points": 6,
    "sampleAnswers": [
      "Calling `useState` inside an `if` statement violates the Rules of Hooks—React can’t match hooks to their state across renders.",
      "Always call hooks at the top level of your component, before any early returns or conditionals."
    ]
  },
  {
    "id": "q277",
    "title": "Is useState synchronous or asynchronous?",
    "content": "`useState` call is sync; state updates are async (batched). Use `useEffect` to observe new state.",
    "type": "open-ended",
    "category": "React",
    "subcategory": "State Management",
    "difficulty": "intermediate",
    "learningCardId": "framework-questions",
    "topic": "State Updates",
    "isActive": true,
    "createdAt": "2024-01-01T00:00:00.000Z",
    "updatedAt": "2024-01-01T00:00:00.000Z",
    "createdBy": "admin",
    "tags": ["react", "usestate", "asynchronous", "batching"],
    "explanation": "State updates are queued and applied before the next render, so logging state right after `setState` shows the old value.",
    "points": 6,
    "sampleAnswers": [
      "`setCount(count+1); console.log(count);` logs the old value. Use `useEffect(() => { console.log(count); }, [count])` to see the new value.",
      "React batches updates for performance, so state changes are not immediate but are applied before the next render."
    ]
  },
  {
    "id": "q278",
    "title": "Can you explain how useState works internally?",
    "content": "React maintains a hook list per component. Each `useState` call corresponds to a slot storing state and update queue.",
    "type": "open-ended",
    "category": "React",
    "subcategory": "React Hooks",
    "difficulty": "advanced",
    "learningCardId": "framework-questions",
    "topic": "useState",
    "isActive": true,
    "createdAt": "2024-01-01T00:00:00.000Z",
    "updatedAt": "2024-01-01T00:00:00.000Z",
    "createdBy": "admin",
    "tags": ["react", "hooks", "internal", "useState"],
    "explanation": "Hooks rely on a linked list of state slots; order of calls must be consistent across renders.",
    "points": 8,
    "sampleAnswers": [
      "React keeps an array of hook states for each component. On first render, `useState` initializes a slot. On updates, it processes the update queue.",
      "The setter function enqueues an update and schedules a re-render. On next render, React applies queued updates in order."
    ]
  },
  {
    "id": "q279",
    "title": "What is `useReducer`? Why do you use it?",
    "content": "`useReducer` manages complex state logic via actions and a reducer function, similar to Redux.",
    "type": "open-ended",
    "category": "React",
    "subcategory": "React Hooks",
    "difficulty": "intermediate",
    "learningCardId": "framework-questions",
    "topic": "useReducer",
    "isActive": true,
    "createdAt": "2024-01-01T00:00:00.000Z",
    "updatedAt": "2024-01-01T00:00:00.000Z",
    "createdBy": "admin",
    "tags": ["react", "usereducer", "state-management", "hooks"],
    "explanation": "It’s ideal for state with multiple sub-values, when next state depends on previous, or for complex update logic.",
    "points": 7,
    "sampleAnswers": [
      "`useReducer` centralizes state update logic in a reducer function, making it easier to test and debug complex state transitions.",
      "Use it for forms, shopping carts, or any state that requires multiple related updates in response to user actions."
    ]
  },
  {
    "id": "q280",
    "title": "How does `useReducer` work? Explain with an example",
    "content": "Define a reducer function, call `useReducer(reducer, initialState)`, dispatch actions to update state.",
    "type": "open-ended",
    "category": "React",
    "subcategory": "React Hooks",
    "difficulty": "intermediate",
    "learningCardId": "framework-questions",
    "topic": "useReducer",
    "isActive": true,
    "createdAt": "2024-01-01T00:00:00.000Z",
    "updatedAt": "2024-01-01T00:00:00.000Z",
    "createdBy": "admin",
    "tags": ["react", "usereducer", "example", "hooks"],
    "explanation": "The reducer takes current state and an action, returns new state. Dispatch sends actions to the reducer.",
    "points": 7,
    "sampleAnswers": [
      "```javascript\nfunction reducer(state, action) {\n  switch(action.type) {\n    case 'increment': return { count: state.count + 1 };\n    default: return state;\n  }\n}\nconst [state, dispatch] = useReducer(reducer, { count: 0 });\n```",
      "Dispatch with `dispatch({ type: 'increment' })` to trigger state updates through the reducer."
    ]
  },
  {
    "id": "q281",
    "title": "Can you combine `useReducer` with `useContext`?",
    "content": "Yes. Wrap `useReducer` in a Context Provider to create a lightweight global state management system.",
    "type": "true-false",
    "category": "React",
    "subcategory": "State Management",
    "difficulty": "intermediate",
    "learningCardId": "framework-questions",
    "topic": "Context API",
    "isActive": true,
    "createdAt": "2024-01-01T00:00:00.000Z",
    "updatedAt": "2024-01-01T00:00:00.000Z",
    "createdBy": "admin",
    "tags": ["react", "usereducer", "usecontext", "global-state"],
    "explanation": "This pattern mimics Redux without external libraries—ideal for medium-sized apps.",
    "points": 6,
    "options": [
      {
        "id": "a",
        "text": "True",
        "isCorrect": true
      },
      {
        "id": "b",
        "text": "False",
        "isCorrect": false
      }
    ]
  },
  {
    "id": "q282",
    "title": "Can you dispatch multiple actions in a row with useReducer?",
    "content": "Yes. Call `dispatch()` multiple times, or create a custom action that performs multiple state changes.",
    "type": "open-ended",
    "category": "React",
    "subcategory": "React Hooks",
    "difficulty": "intermediate",
    "learningCardId": "framework-questions",
    "topic": "useReducer",
    "isActive": true,
    "createdAt": "2024-01-01T00:00:00.000Z",
    "updatedAt": "2024-01-01T00:00:00.000Z",
    "createdBy": "admin",
    "tags": ["react", "usereducer", "dispatch", "actions"],
    "explanation": "Each `dispatch` queues an update; React processes them in order during the next render.",
    "points": 6,
    "sampleAnswers": [
      "`dispatch({type:'inc'}); dispatch({type:'inc'});` increments twice. Or define `case 'inc_twice': return { count: state.count + 2 };`",
      "Multiple dispatches are batched into a single re-render, ensuring consistent state transitions."
    ]
  },
  {
    "id": "q283",
    "title": "How does useContext work? Explain with an example",
    "content": "Create context, provide value via Provider, consume with `useContext` in child components.",
    "type": "open-ended",
    "category": "React",
    "subcategory": "Context API",
    "difficulty": "intermediate",
    "learningCardId": "framework-questions",
    "topic": "Context API",
    "isActive": true,
    "createdAt": "2024-01-01T00:00:00.000Z",
    "updatedAt": "2024-01-01T00:00:00.000Z",
    "createdBy": "admin",
    "tags": ["react", "usecontext", "example", "authentication"],
    "explanation": "The example shows auth state shared across components without prop drilling.",
    "points": 7,
    "sampleAnswers": [
      "```javascript\nconst AuthContext = createContext();\nfunction AuthProvider({children}) {\n  const [user, setUser] = useState(null);\n  return <AuthContext.Provider value={{user, login, logout}}>{children}</AuthContext.Provider>;\n}\n// In child: const {user, login} = useContext(AuthContext);\n```",
      "This pattern allows any component to access auth state and methods without passing props through every level."
    ]
  },
  {
    "id": "q284",
    "title": "Can you use multiple contexts in one component?",
    "content": "Yes. Call `useContext` once for each context in the same component.",
    "type": "true-false",
    "category": "React",
    "subcategory": "Context API",
    "difficulty": "intermediate",
    "learningCardId": "framework-questions",
    "topic": "Context API",
    "isActive": true,
    "createdAt": "2024-01-01T00:00:00.000Z",
    "updatedAt": "2024-01-01T00:00:00.000Z",
    "createdBy": "admin",
    "tags": ["react", "multiple-contexts", "usecontext", "composition"],
    "explanation": "Components can consume as many contexts as needed by calling `useContext` multiple times.",
    "points": 5,
    "options": [
      {
        "id": "a",
        "text": "True",
        "isCorrect": true
      },
      {
        "id": "b",
        "text": "False",
        "isCorrect": false
      }
    ]
  },
  {
    "id": "q285",
    "title": "What's a common pitfall when using useContext with objects?",
    "content": "Providing a new object literal as context value causes unnecessary re-renders of all consumers.",
    "type": "open-ended",
    "category": "React",
    "subcategory": "Context API",
    "difficulty": "advanced",
    "learningCardId": "framework-questions",
    "topic": "Context API",
    "isActive": true,
    "createdAt": "2024-01-01T00:00:00.000Z",
    "updatedAt": "2024-01-01T00:00:00.000Z",
    "createdBy": "admin",
    "tags": ["react", "context-pitfall", "re-renders", "usememo"],
    "explanation": "React compares context value by reference; a new object on every render triggers all consumers to re-render.",
    "points": 8,
    "sampleAnswers": [
      "Avoid `<Provider value={{user, theme}}>`—instead, lift to state or memoize with `useMemo(() => ({user, theme}), [user, theme])`.",
      "Split contexts by concern (e.g., `UserContext`, `ThemeContext`) to isolate re-renders to only affected components."
    ]
  },
  {
    "id": "q286",
    "title": "What would the context value be for no matching provider?",
    "content": "The default value passed to `createContext(defaultValue)` is returned if no Provider is found.",
    "type": "open-ended",
    "category": "React",
    "subcategory": "Context API",
    "difficulty": "intermediate",
    "learningCardId": "framework-questions",
    "topic": "Context API",
    "isActive": true,
    "createdAt": "2024-01-01T00:00:00.000Z",
    "updatedAt": "2024-01-01T00:00:00.000Z",
    "createdBy": "admin",
    "tags": ["react", "context", "default-value", "provider"],
    "explanation": "This is useful for testing components in isolation without wrapping them in a Provider.",
    "points": 5,
    "sampleAnswers": [
      "`const ThemeContext = createContext('light');` means `useContext(ThemeContext)` returns 'light' if no Provider is present.",
      "If no default is provided, the context value is `undefined` when no Provider exists."
    ]
  },
  {
    "id": "q287",
    "title": "How do reactive dependencies in useEffect affect execution?",
    "content": "Empty array: runs once. With deps: runs on mount and when deps change. No array: runs every render.",
    "type": "multiple-choice",
    "category": "React",
    "subcategory": "React Hooks",
    "difficulty": "intermediate",
    "learningCardId": "framework-questions",
    "topic": "useEffect",
    "isActive": true,
    "createdAt": "2024-01-01T00:00:00.000Z",
    "updatedAt": "2024-01-01T00:00:00.000Z",
    "createdBy": "admin",
    "tags": ["react", "useeffect", "dependencies", "hooks"],
    "explanation": "The dependency array controls when the effect re-runs, based on shallow equality of values.",
    "points": 6,
    "options": [
      {
        "id": "a",
        "text": "Effect always runs once regardless of deps",
        "isCorrect": false
      },
      {
        "id": "b",
        "text": "[]: once; [deps]: on change; none: every render",
        "isCorrect": true
      },
      {
        "id": "c",
        "text": "Deps are deep-comparison",
        "isCorrect": false
      },
      {
        "id": "d",
        "text": "Effect runs before render",
        "isCorrect": false
      }
    ]
  },
  {
    "id": "q288",
    "title": "When does React invoke setup and cleanup in useEffect?",
    "content": "Setup: after mount or when deps change. Cleanup: before re-running effect or on unmount.",
    "type": "open-ended",
    "category": "React",
    "subcategory": "React Hooks",
    "difficulty": "intermediate",
    "learningCardId": "framework-questions",
    "topic": "useEffect",
    "isActive": true,
    "createdAt": "2024-01-01T00:00:00.000Z",
    "updatedAt": "2024-01-01T00:00:00.000Z",
    "createdBy": "admin",
    "tags": ["react", "useeffect", "cleanup", "lifecycle"],
    "explanation": "Cleanup ensures side effects like subscriptions or timers are properly disposed of.",
    "points": 6,
    "sampleAnswers": [
      "Setup runs after the component mounts or when dependencies change. Cleanup runs before the next setup or when the component unmounts.",
      "Example: `useEffect(() => { const id = setInterval(...); return () => clearInterval(id); }, [])` cleans up on unmount."
    ]
  },
  {
    "id": "q289",
    "title": "What happens if you return a Promise from useEffect?",
    "content": "React ignores it. useEffect must return a cleanup function or nothing—not a Promise.",
    "type": "open-ended",
    "category": "React",
    "subcategory": "React Hooks",
    "difficulty": "intermediate",
    "learningCardId": "framework-questions",
    "topic": "useEffect",
    "isActive": true,
    "createdAt": "2024-01-01T00:00:00.000Z",
    "updatedAt": "2024-01-01T00:00:00.000Z",
    "createdBy": "admin",
    "tags": ["react", "useeffect", "async", "promise"],
    "explanation": "Async functions return Promises, which useEffect doesn’t handle. Do async work inside the effect, not as the effect itself.",
    "points": 6,
    "sampleAnswers": [
      "Never write `useEffect(async () => { ... })`. Instead, define an async function inside: `useEffect(() => { const fn = async () => { ... }; fn(); }, []);`",
      "Returning a Promise confuses React’s cleanup mechanism and may cause memory leaks or warnings."
    ]
  },
  {
    "id": "q290",
    "title": "Can you have multiple useEffect hooks in a single component?",
    "content": "Yes. Multiple useEffect hooks are encouraged to separate unrelated side effects.",
    "type": "true-false",
    "category": "React",
    "subcategory": "React Hooks",
    "difficulty": "beginner",
    "learningCardId": "framework-questions",
    "topic": "useEffect",
    "isActive": true,
    "createdAt": "2024-01-01T00:00:00.000Z",
    "updatedAt": "2024-01-01T00:00:00.000Z",
    "createdBy": "admin",
    "tags": ["react", "useeffect", "multiple", "hooks"],
    "explanation": "Separating effects by concern improves readability and maintainability.",
    "points": 4,
    "options": [
      {
        "id": "a",
        "text": "True",
        "isCorrect": true
      },
      {
        "id": "b",
        "text": "False",
        "isCorrect": false
      }
    ]
  },
  {
    "id": "q291",
    "title": "How to prevent infinite loops with useEffect?",
    "content": "Ensure state updates in effect don’t depend on values that trigger the effect, or add guards.",
    "type": "open-ended",
    "category": "React",
    "subcategory": "React Hooks",
    "difficulty": "intermediate",
    "learningCardId": "framework-questions",
    "topic": "useEffect",
    "isActive": true,
    "createdAt": "2024-01-01T00:00:00.000Z",
    "updatedAt": "2024-01-01T00:00:00.000Z",
    "createdBy": "admin",
    "tags": ["react", "useeffect", "infinite-loop", "dependencies"],
    "explanation": "Infinite loops occur when an effect updates state that’s in its dependency array, causing re-runs.",
    "points": 6,
    "sampleAnswers": [
      "If `useEffect(() => { setCount(count + 1); }, [count]);`, it loops. Fix by removing `count` from deps if update is unconditional, or use updater function.",
      "Add a condition: `if (count < 5) setCount(count + 1);` to break the cycle."
    ]
  },
  {
    "id": "q292",
    "title": "What are the use cases of useLayoutEffect?",
    "content": "Reading layout (size/position), preventing visual flicker, synchronously updating DOM before paint.",
    "type": "multiple-choice",
    "category": "React",
    "subcategory": "React Hooks",
    "difficulty": "advanced",
    "learningCardId": "framework-questions",
    "topic": "useLayoutEffect",
    "isActive": true,
    "createdAt": "2024-01-01T00:00:00.000Z",
    "updatedAt": "2024-01-01T00:00:00.000Z",
    "createdBy": "admin",
    "tags": ["react", "uselayouteffect", "layout", "flicker"],
    "explanation": "It runs synchronously before paint, so use only when necessary to avoid blocking visual updates.",
    "points": 7,
    "options": [
      {
        "id": "a",
        "text": "Data fetching and logging",
        "isCorrect": false
      },
      {
        "id": "b",
        "text": "Layout measurements, preventing flicker, synchronous DOM updates",
        "isCorrect": true
      },
      {
        "id": "c",
        "text": "Replacing all useEffect calls",
        "isCorrect": false
      },
      {
        "id": "d",
        "text": "Only for server-side rendering",
        "isCorrect": false
      }
    ]
  },
  {
    "id": "q293",
    "title": "How does useLayoutEffect work during SSR?",
    "content": "It doesn’t run on the server. Use a polyfill like `useIsomorphicLayoutEffect` for SSR compatibility.",
    "type": "open-ended",
    "category": "React",
    "subcategory": "Server-Side Rendering",
    "difficulty": "advanced",
    "learningCardId": "framework-questions",
    "topic": "useLayoutEffect",
    "isActive": true,
    "createdAt": "2024-01-01T00:00:00.000Z",
    "updatedAt": "2024-01-01T00:00:00.000Z",
    "createdBy": "admin",
    "tags": ["react", "ssr", "uselayouteffect", "nextjs"],
    "explanation": "Since there’s no DOM on the server, `useLayoutEffect` is skipped, but React warns in SSR environments.",
    "points": 7,
    "sampleAnswers": [
      "`const useIsomorphicLayoutEffect = typeof window !== 'undefined' ? useLayoutEffect : useEffect;` avoids SSR warnings.",
      "In Next.js, always use this pattern for components that render on both server and client."
    ]
  },
  {
    "id": "q294",
    "title": "What happens if you use useLayoutEffect for non-layout logic?",
    "content": "It degrades performance by blocking the browser paint for non-visual work like data fetching or logging.",
    "type": "open-ended",
    "category": "React",
    "subcategory": "React Hooks",
    "difficulty": "intermediate",
    "learningCardId": "framework-questions",
    "topic": "useLayoutEffect",
    "isActive": true,
    "createdAt": "2024-01-01T00:00:00.000Z",
    "updatedAt": "2024-01-01T00:00:00.000Z",
    "createdBy": "admin",
    "tags": ["react", "uselayouteffect", "performance", "anti-pattern"],
    "explanation": "Reserve `useLayoutEffect` for layout-critical code; use `useEffect` for everything else.",
    "points": 6,
    "sampleAnswers": [
      "Using `useLayoutEffect` for analytics or API calls delays visual updates unnecessarily. Use `useEffect` instead.",
      "It should only be used when you need to measure or adjust the DOM before the user sees it."
    ]
  },
  {
    "id": "q295",
    "title": "How does useLayoutEffect cause layout thrashing?",
    "content": "Repeated read-write DOM operations in `useLayoutEffect` force synchronous reflows, blocking rendering.",
    "type": "open-ended",
    "category": "React",
    "subcategory": "Performance Optimization",
    "difficulty": "advanced",
    "learningPath": "Performance Optimization Specialist",
    "topic": "Layout Thrashing",
    "isActive": true,
    "createdAt": "2024-01-01T00:00:00.000Z",
    "updatedAt": "2024-01-01T00:00:00.000Z",
    "createdBy": "admin",
    "tags": ["react", "layout-thrashing", "uselayouteffect", "performance"],
    "explanation": "Each DOM read after a write triggers a reflow; doing this in `useLayoutEffect` blocks the main thread.",
    "points": 8,
    "sampleAnswers": [
      "Avoid `const h = el.offsetHeight; el.style.height = h + 10; const newH = el.offsetHeight;` in `useLayoutEffect`—batch reads and writes.",
      "Read all layout values first, compute changes, then apply all writes in one go to minimize reflows."
    ]
  },
  {
    "id": "q296",
    "title": "How to use useRef to access a DOM element?",
    "content": "Create a ref with `useRef()`, attach to DOM element via `ref` prop, access via `ref.current`.",
    "type": "open-ended",
    "category": "React",
    "subcategory": "React Hooks",
    "difficulty": "beginner",
    "learningCardId": "framework-questions",
    "topic": "useRef",
    "isActive": true,
    "createdAt": "2024-01-01T00:00:00.000Z",
    "updatedAt": "2024-01-01T00:00:00.000Z",
    "createdBy": "admin",
    "tags": ["react", "useref", "dom", "focus"],
    "explanation": "Refs provide a way to imperatively interact with DOM elements, like focusing an input.",
    "points": 5,
    "sampleAnswers": [
      "```javascript\nconst inputRef = useRef();\nreturn <input ref={inputRef} />;\n// Focus: inputRef.current.focus();\n```",
      "Refs are the standard way to access DOM nodes in React without query selectors."
    ]
  },
  {
    "id": "q297",
    "title": "Can you use useRef to persist values across renders?",
    "content": "Yes. `useRef` holds a mutable `.current` value that persists across renders without causing re-renders.",
    "type": "true-false",
    "category": "React",
    "subcategory": "React Hooks",
    "difficulty": "intermediate",
    "learningCardId": "framework-questions",
    "topic": "useRef",
    "isActive": true,
    "createdAt": "2024-01-01T00:00:00.000Z",
    "updatedAt": "2024-01-01T00:00:00.000Z",
    "createdBy": "admin",
    "tags": ["react", "useref", "persistence", "hooks"],
    "explanation": "Unlike `useState`, updating `ref.current` doesn’t trigger a re-render, making it ideal for counters or timers.",
    "points": 5,
    "options": [
      {
        "id": "a",
        "text": "True",
        "isCorrect": true
      },
      {
        "id": "b",
        "text": "False",
        "isCorrect": false
      }
    ]
  },
  {
    "id": "q298",
    "title": "Can useRef be used to store previous values?",
    "content": "Yes. Update ref in `useEffect` to store previous props or state for comparison.",
    "type": "open-ended",
    "category": "React",
    "subcategory": "React Hooks",
    "difficulty": "intermediate",
    "learningCardId": "framework-questions",
    "topic": "useRef",
    "isActive": true,
    "createdAt": "2024-01-01T00:00:00.000Z",
    "updatedAt": "2024-01-01T00:00:00.000Z",
    "createdBy": "admin",
    "tags": ["react", "useref", "previous-value", "hooks"],
    "explanation": "This pattern is common for detecting changes between renders without causing extra re-renders.",
    "points": 6,
    "sampleAnswers": [
      "```javascript\nconst prevCountRef = useRef();\nuseEffect(() => { prevCountRef.current = count; }, [count]);\nconst prevCount = prevCountRef.current;\n```",
      "This lets you compare current and previous values in render without storing them in state."
    ]
  },
  {
    "id": "q299",
    "title": "Is it possible to access a ref in the render method?",
    "content": "Yes, but `ref.current` is `null` during initial render until after the component mounts.",
    "type": "open-ended",
    "category": "React",
    "subcategory": "React Hooks",
    "difficulty": "intermediate",
    "learningCardId": "framework-questions",
    "topic": "useRef",
    "isActive": true,
    "createdAt": "2024-01-01T00:00:00.000Z",
    "updatedAt": "2024-01-01T00:00:00.000Z",
    "createdBy": "admin",
    "tags": ["react", "useref", "render", "dom"],
    "explanation": "Refs are populated after the component mounts, so accessing them in render is usually not useful.",
    "points": 5,
    "sampleAnswers": [
      "`console.log(ref.current)` in render logs `null` on first render. Use `useEffect` to access the DOM node after mount.",
      "Refs should be used in event handlers or effects, not in the render method itself."
    ]
  },
  {
    "id": "q300",
    "title": "What are common use cases of useRef hook?",
    "content": "Focus management, scroll control, DOM measurements, media playback, and integrating with non-React libraries.",
    "type": "multiple-choice",
    "category": "React",
    "subcategory": "React Hooks",
    "difficulty": "intermediate",
    "learningCardId": "framework-questions",
    "topic": "useRef",
    "isActive": true,
    "createdAt": "2024-01-01T00:00:00.000Z",
    "updatedAt": "2024-01-01T00:00:00.000Z",
    "createdBy": "admin",
    "tags": ["react", "useref", "dom", "imperative"],
    "explanation": "Refs enable imperative interactions with DOM elements that aren’t possible with declarative React alone.",
    "points": 6,
    "options": [
      {
        "id": "a",
        "text": "Managing application state",
        "isCorrect": false
      },
      {
        "id": "b",
        "text": "Focus, scroll, measurements, media, and third-party libraries",
        "isCorrect": true
      },
      {
        "id": "c",
        "text": "Replacing useState",
        "isCorrect": false
      },
      {
        "id": "d",
        "text": "Only for class components",
        "isCorrect": false
      }
    ]
  },
  {
    "id": "q301",
    "title": "What is useImperativeHandle Hook? Give an example.",
    "content": "Exposes custom methods from child to parent via ref, used with `forwardRef` for modals, inputs, etc.",
    "type": "open-ended",
    "category": "React",
    "subcategory": "React Hooks",
    "difficulty": "advanced",
    "learningCardId": "framework-questions",
    "topic": "useImperativeHandle",
    "isActive": true,
    "createdAt": "2024-01-01T00:00:00.000Z",
    "updatedAt": "2024-01-01T00:00:00.000Z",
    "createdBy": "admin",
    "tags": ["react", "useimperativehandle", "forwardref", "imperative"],
    "explanation": "It lets parents control child behavior imperatively while hiding internal implementation.",
    "points": 8,
    "sampleAnswers": [
      "```javascript\nconst Dialog = forwardRef((props, ref) => {\n  const [open, setOpen] = useState(false);\n  useImperativeHandle(ref, () => ({ open: () => setOpen(true) }));\n  return open ? <div>Dialog</div> : null;\n});\n// Parent: dialogRef.current.open();\n```",
      "This pattern is essential for reusable component libraries that need to expose controlled APIs."
    ]
  },
  {
    "id": "q302",
    "title": "When should you use useImperativeHandle?",
    "content": "For reusable components that need to expose imperative methods (modals, inputs, scroll containers).",
    "type": "multiple-choice",
    "category": "React",
    "subcategory": "React Hooks",
    "difficulty": "advanced",
    "learningCardId": "framework-questions",
    "topic": "useImperativeHandle",
    "isActive": true,
    "createdAt": "2024-01-01T00:00:00.000Z",
    "updatedAt": "2024-01-01T00:00:00.000Z",
    "createdBy": "admin",
    "tags": ["react", "useimperativehandle", "component-libraries", "api"],
    "explanation": "It’s for when you need to give parents controlled access to child behavior without exposing internals.",
    "points": 7,
    "options": [
      {
        "id": "a",
        "text": "For all state management",
        "isCorrect": false
      },
      {
        "id": "b",
        "text": "For modals, inputs, scroll containers in reusable libraries",
        "isCorrect": true
      },
      {
        "id": "c",
        "text": "To replace useEffect",
        "isCorrect": false
      },
      {
        "id": "d",
        "text": "Only in class components",
        "isCorrect": false
      }
    ]
  },
  {
    "id": "q303",
    "title": "Is it possible to use useImperativeHandle without forwardRef?",
    "content": "No. `useImperativeHandle` only works when the component is wrapped in `forwardRef`.",
    "type": "true-false",
    "category": "React",
    "subcategory": "React Hooks",
    "difficulty": "intermediate",
    "learningCardId": "framework-questions",
    "topic": "useImperativeHandle",
    "isActive": true,
    "createdAt": "2024-01-01T00:00:00.000Z",
    "updatedAt": "2024-01-01T00:00:00.000Z",
    "createdBy": "admin",
    "tags": ["react", "useimperativehandle", "forwardref", "refs"],
    "explanation": "`forwardRef` is required to pass the ref from parent to child so `useImperativeHandle` can attach methods to it.",
    "points": 6,
    "options": [
      {
        "id": "a",
        "text": "True",
        "isCorrect": false
      },
      {
        "id": "b",
        "text": "False",
        "isCorrect": true
      }
    ]
  },
  {
    "id": "q304",
    "title": "How is useMemo different from useCallback?",
    "content": "`useMemo` memoizes values; `useCallback` memoizes functions.",
    "type": "multiple-choice",
    "category": "React",
    "subcategory": "React Hooks",
    "difficulty": "intermediate",
    "learningCardId": "framework-questions",
    "topic": "useMemo vs useCallback",
    "isActive": true,
    "createdAt": "2024-01-01T00:00:00.000Z",
    "updatedAt": "2024-01-01T00:00:00.000Z",
    "createdBy": "admin",
    "tags": ["react", "usememo", "usecallback", "performance"],
    "explanation": "`useCallback(fn, deps)` is equivalent to `useMemo(() => fn, deps)`.",
    "points": 7,
    "options": [
      {
        "id": "a",
        "text": "useMemo is for functions; useCallback for values",
        "isCorrect": false
      },
      {
        "id": "b",
        "text": "useMemo memoizes values; useCallback memoizes functions",
        "isCorrect": true
      },
      {
        "id": "c",
        "text": "They are identical",
        "isCorrect": false
      },
      {
        "id": "d",
        "text": "useCallback prevents re-renders of parent",
        "isCorrect": false
      }
    ]
  },
  {
    "id": "q305",
    "title": "Does useMemo prevent re-rendering of child components?",
    "content": "Not directly. But when combined with `React.memo`, it prevents re-renders by preserving prop reference equality.",
    "type": "open-ended",
    "category": "React",
    "subcategory": "Performance Optimization",
    "difficulty": "advanced",
    "learningCardId": "framework-questions",
    "topic": "useMemo",
    "isActive": true,
    "createdAt": "2024-01-01T00:00:00.000Z",
    "updatedAt": "2024-01-01T00:00:00.000Z",
    "createdBy": "admin",
    "tags": ["react", "usememo", "react-memo", "performance"],
    "explanation": "`useMemo` ensures the value doesn’t change between renders, so `React.memo` can skip child re-renders.",
    "points": 7,
    "sampleAnswers": [
      "`const data = useMemo(() => compute(data), [data]);` passed to `<Child data={data} />` where `Child = React.memo(...)` prevents re-renders if `data` hasn’t changed.",
      "Alone, `useMemo` only optimizes the parent’s computation; with `React.memo`, it optimizes child rendering too."
    ]
  },
  {
    "id": "q306",
    "title": "What is `useCallback` and why is it used?",
    "content": "`useCallback` memoizes function references to prevent unnecessary re-renders of child components.",
    "type": "open-ended",
    "category": "React",
    "subcategory": "React Hooks",
    "difficulty": "intermediate",
    "learningCardId": "framework-questions",
    "topic": "useCallback",
    "isActive": true,
    "createdAt": "2024-01-01T00:00:00.000Z",
    "updatedAt": "2024-01-01T00:00:00.000Z",
    "createdBy": "admin",
    "tags": ["react", "usecallback", "performance", "react-memo"],
    "explanation": "Without it, new function instances on every render cause `React.memo` children to re-render unnecessarily.",
    "points": 6,
    "sampleAnswers": [
      "`const handleClick = useCallback(() => { ... }, []);` ensures the function reference stays the same across renders.",
      "Pass `handleClick` to a `React.memo` child to prevent it from re-rendering when parent state changes but the callback hasn’t."
    ]
  }
]
