24427fca52f07930e26c66192fed42ac
/* eslint-disable @typescript-eslint/no-explicit-any */ /**
 * Admin Authentication Integration Tests
 *
 * End-to-end tests for the complete admin authentication flow:
 * - Login process
 * - Session management
 * - Route protection
 * - Logout functionality
 * - Token validation
 */ "use strict";
// Mock NextResponse to ensure json() method works correctly
jest.mock('next/server', ()=>{
    const actual = jest.requireActual('next/server');
    return {
        ...actual,
        NextResponse: {
            ...actual.NextResponse,
            json: (body, init)=>{
                const response = actual.NextResponse.json(body, init);
                // Ensure _body is set for test compatibility
                response._body = JSON.stringify(body);
                return response;
            }
        }
    };
});
// Mock Supabase - shared instance for route handler
// Define inside factory to avoid hoisting issues
jest.mock('@supabase/supabase-js', ()=>{
    const mockSupabaseClient = {
        from: jest.fn()
    };
    return {
        createClient: jest.fn(()=>mockSupabaseClient)
    };
});
// Mock bcrypt
jest.mock('bcryptjs', ()=>({
        compare: jest.fn(),
        hash: jest.fn()
    }));
// Mock admin.config
jest.mock('@/admin.config', ()=>({
        adminConfig: {
            security: {
                saltRounds: 10,
                sessionTimeout: 24 * 60 * 60 * 1000
            },
            jwt: {
                secret: 'test-jwt-secret-key-for-testing'
            }
        }
    }));
Object.defineProperty(exports, "__esModule", {
    value: true
});
const _server = require("next/server");
const _route = require("../../apps/website/src/app/api/admin/auth/route");
const _jsonwebtoken = /*#__PURE__*/ _interop_require_default(require("jsonwebtoken"));
function _interop_require_default(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
// Helper to extract JSON from NextResponse
async function getResponseData(response) {
    if (response._body !== undefined) {
        const body = response._body;
        if (typeof body === 'string') {
            try {
                return JSON.parse(body);
            } catch  {
                return {};
            }
        }
        if (body && typeof body === 'object') {
            return body;
        }
    }
    try {
        const data = await response.json();
        if (data && typeof data === 'object' && Object.keys(data).length > 0) {
            return data;
        }
    } catch (e) {
    // Continue
    }
    try {
        const text = await response.text();
        if (text) {
            return JSON.parse(text);
        }
    } catch (e) {
    // Continue
    }
    return {};
}
describe('Admin Authentication Integration', ()=>{
    // eslint-disable-next-line @typescript-eslint/no-require-imports
    const bcrypt = require('bcryptjs');
    // eslint-disable-next-line @typescript-eslint/no-require-imports
    const { createClient } = require('@supabase/supabase-js');
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    let mockSupabaseClient;
    let consoleErrorSpy;
    beforeEach(()=>{
        jest.clearAllMocks();
        mockSupabaseClient = createClient();
        mockSupabaseClient.from.mockClear();
        process.env.JWT_SECRET = 'test-jwt-secret-key-for-testing';
        process.env.NEXT_PUBLIC_SUPABASE_URL = 'https://test.supabase.co';
        process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY = 'test-anon-key';
        process.env.SUPABASE_SERVICE_ROLE_KEY = 'test-service-role-key';
        // Suppress console.error for expected error tests
        // Use jest.spyOn to properly mock and suppress console.error output
        consoleErrorSpy = jest.spyOn(console, 'error').mockImplementation(()=>{
        // Suppress console.error output during tests
        });
    });
    afterEach(()=>{
        // Restore console.error
        consoleErrorSpy.mockRestore();
        delete process.env.JWT_SECRET;
        delete process.env.NEXT_PUBLIC_SUPABASE_URL;
        delete process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY;
        delete process.env.SUPABASE_SERVICE_ROLE_KEY;
    });
    describe('Complete Login Flow', ()=>{
        it('should complete full authentication flow successfully', async ()=>{
            const mockAdmin = {
                id: 'admin_123',
                email: 'test@example.com',
                name: 'Test Admin',
                role: 'super_admin',
                password_hash: 'hashed_password',
                is_active: true,
                created_at: new Date().toISOString()
            };
            const mockSingle = Promise.resolve({
                data: mockAdmin,
                error: null
            });
            const mockEq = jest.fn().mockReturnValue({
                single: ()=>mockSingle
            });
            const mockSelect = jest.fn().mockReturnValue({
                eq: mockEq
            });
            mockSupabaseClient.from.mockReturnValue({
                select: mockSelect,
                update: jest.fn().mockReturnValue({
                    eq: jest.fn().mockResolvedValue({
                        error: null
                    })
                })
            });
            bcrypt.compare.mockResolvedValue(true);
            // Step 1: Login request
            const loginRequest = new _server.NextRequest('http://localhost:3000/api/admin/auth', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    email: 'test@example.com',
                    password: 'testpassword123'
                })
            });
            const loginResponse = await (0, _route.POST)(loginRequest);
            const loginData = await getResponseData(loginResponse);
            expect(loginResponse.status).toBe(200);
            expect(loginData.success).toBe(true);
            expect(loginData.admin.token).toBeDefined();
            expect(loginData.admin.expiresAt).toBeDefined();
            // Step 2: Verify JWT token
            const token = loginData.admin.token;
            const decoded = _jsonwebtoken.default.verify(token, process.env.JWT_SECRET);
            expect(decoded.adminId).toBe(mockAdmin.id);
            expect(decoded.email).toBe(mockAdmin.email);
            expect(decoded.role).toBe(mockAdmin.role);
            expect(decoded.exp).toBeDefined();
            // Step 3: Verify token expiration is reasonable (24 hours)
            const expirationTime = decoded.exp * 1000; // Convert to milliseconds
            const now = Date.now();
            const twentyFourHours = 24 * 60 * 60 * 1000;
            expect(expirationTime - now).toBeGreaterThan(twentyFourHours - 60000); // Allow 1 minute tolerance
            expect(expirationTime - now).toBeLessThan(twentyFourHours + 60000);
        });
        it('should handle authentication failure gracefully', async ()=>{
            const mockSingle = Promise.resolve({
                data: null,
                error: {
                    message: 'Not found'
                }
            });
            const mockEq = jest.fn().mockReturnValue({
                single: ()=>mockSingle
            });
            const mockSelect = jest.fn().mockReturnValue({
                eq: mockEq
            });
            mockSupabaseClient.from.mockReturnValue({
                select: mockSelect
            });
            const loginRequest = new _server.NextRequest('http://localhost:3000/api/admin/auth', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    email: 'test@example.com',
                    password: 'wrongpassword'
                })
            });
            const loginResponse = await (0, _route.POST)(loginRequest);
            const loginData = await getResponseData(loginResponse);
            expect(loginResponse.status).toBe(401);
            expect(loginData.success).toBe(false);
            expect(loginData.error).toBe('Invalid email or password');
            expect(loginData.admin).toBeUndefined();
        });
    });
    describe('Session Management', ()=>{
        it('should create valid session after successful login', async ()=>{
            const mockAdmin = {
                id: 'admin_123',
                email: 'test@example.com',
                name: 'Test Admin',
                role: 'super_admin',
                password_hash: 'hashed_password',
                is_active: true,
                created_at: new Date().toISOString()
            };
            const mockSingle = Promise.resolve({
                data: mockAdmin,
                error: null
            });
            const mockEq = jest.fn().mockReturnValue({
                single: ()=>mockSingle
            });
            const mockSelect = jest.fn().mockReturnValue({
                eq: mockEq
            });
            mockSupabaseClient.from.mockReturnValue({
                select: mockSelect,
                update: jest.fn().mockReturnValue({
                    eq: jest.fn().mockResolvedValue({
                        error: null
                    })
                })
            });
            bcrypt.compare.mockResolvedValue(true);
            const loginRequest = new _server.NextRequest('http://localhost:3000/api/admin/auth', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    email: 'test@example.com',
                    password: 'testpassword123'
                })
            });
            const loginResponse = await (0, _route.POST)(loginRequest);
            const loginData = await getResponseData(loginResponse);
            // Verify session data structure
            expect(loginData.admin).toBeDefined();
            expect(loginData.admin.email).toBe(mockAdmin.email);
            expect(loginData.admin.name).toBe(mockAdmin.name);
            expect(loginData.admin.role).toBe(mockAdmin.role);
            expect(loginData.admin.token).toBeDefined();
            expect(loginData.admin.expiresAt).toBeDefined();
            // Verify token can be used for subsequent requests
            const token = loginData.admin.token;
            const decoded = _jsonwebtoken.default.verify(token, process.env.JWT_SECRET);
            expect(decoded.adminId).toBe(mockAdmin.id);
            expect(decoded.email).toBe(mockAdmin.email);
            expect(decoded.role).toBe(mockAdmin.role);
        });
        it('should handle expired tokens', async ()=>{
            // Create an expired token
            const expiredToken = _jsonwebtoken.default.sign({
                adminId: 'admin_test@example.com',
                email: 'test@example.com',
                role: 'super_admin',
                iat: Math.floor(Date.now() / 1000) - 86400,
                exp: Math.floor(Date.now() / 1000) - 3600
            }, process.env.JWT_SECRET);
            // Attempt to use expired token
            expect(()=>{
                _jsonwebtoken.default.verify(expiredToken, process.env.JWT_SECRET);
            }).toThrow('jwt expired');
        });
        it('should handle invalid tokens', async ()=>{
            const invalidToken = 'invalid.jwt.token';
            expect(()=>{
                _jsonwebtoken.default.verify(invalidToken, process.env.JWT_SECRET);
            }).toThrow();
        });
    });
    describe('Logout Flow', ()=>{
        it('should clear session on logout', async ()=>{
            // Logout functionality would be tested with the actual logout endpoint
            // For now, we'll skip this test as it requires a different endpoint
            // TODO: Implement logout endpoint test when available
            expect(true).toBe(true);
        });
    });
    describe('Route Protection', ()=>{
        it('should protect admin routes without valid token', async ()=>{
            // This would typically be tested with middleware or route handlers
            // For now, we'll test the token validation logic
            const invalidToken = 'invalid.token';
            expect(()=>{
                _jsonwebtoken.default.verify(invalidToken, process.env.JWT_SECRET);
            }).toThrow();
        });
        it('should allow access with valid token', async ()=>{
            const validToken = _jsonwebtoken.default.sign({
                adminId: 'admin_test@example.com',
                email: 'test@example.com',
                role: 'super_admin',
                iat: Math.floor(Date.now() / 1000),
                exp: Math.floor(Date.now() / 1000) + 86400
            }, process.env.JWT_SECRET);
            const decoded = _jsonwebtoken.default.verify(validToken, process.env.JWT_SECRET);
            expect(decoded.adminId).toBe('admin_test@example.com');
            expect(decoded.email).toBe('test@example.com');
            expect(decoded.role).toBe('super_admin');
        });
    });
    describe('Error Handling', ()=>{
        it('should handle database connection errors', async ()=>{
            const mockSingle = Promise.reject(new Error('Database connection failed'));
            const mockEq = jest.fn().mockReturnValue({
                single: ()=>mockSingle
            });
            const mockSelect = jest.fn().mockReturnValue({
                eq: mockEq
            });
            mockSupabaseClient.from.mockReturnValue({
                select: mockSelect
            });
            const loginRequest = new _server.NextRequest('http://localhost:3000/api/admin/auth', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    email: 'test@example.com',
                    password: 'testpassword123'
                })
            });
            const loginResponse = await (0, _route.POST)(loginRequest);
            const loginData = await getResponseData(loginResponse);
            expect(loginResponse.status).toBe(500);
            expect(loginData.success).toBe(false);
            expect(loginData.error).toBeDefined();
        });
        it('should handle malformed requests', async ()=>{
            const loginRequest = new _server.NextRequest('http://localhost:3000/api/admin/auth', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: 'invalid json'
            });
            const loginResponse = await (0, _route.POST)(loginRequest);
            const loginData = await getResponseData(loginResponse);
            expect(loginResponse.status).toBe(400);
            expect(loginData.success).toBe(false);
            expect(loginData.error).toBeDefined();
        });
        it('should handle missing environment variables', async ()=>{
            delete process.env.JWT_SECRET;
            const mockAdmin = {
                id: 'admin_123',
                email: 'test@example.com',
                name: 'Test Admin',
                role: 'super_admin',
                password_hash: 'hashed_password',
                is_active: true,
                created_at: new Date().toISOString()
            };
            const mockSingle = Promise.resolve({
                data: mockAdmin,
                error: null
            });
            const mockEq = jest.fn().mockReturnValue({
                single: ()=>mockSingle
            });
            const mockSelect = jest.fn().mockReturnValue({
                eq: mockEq
            });
            mockSupabaseClient.from.mockReturnValue({
                select: mockSelect,
                update: jest.fn().mockReturnValue({
                    eq: jest.fn().mockResolvedValue({
                        error: null
                    })
                })
            });
            bcrypt.compare.mockResolvedValue(true);
            const loginRequest = new _server.NextRequest('http://localhost:3000/api/admin/auth', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    email: 'test@example.com',
                    password: 'testpassword123'
                })
            });
            const loginResponse = await (0, _route.POST)(loginRequest);
            const loginData = await getResponseData(loginResponse);
            expect(loginResponse.status).toBe(500);
            expect(loginData.success).toBe(false);
            expect(loginData.error).toBeDefined();
        });
    });
    describe('Security Tests', ()=>{
        it('should not expose sensitive information in error messages', async ()=>{
            const mockSingle = Promise.reject(new Error('Database connection failed: password=secret123'));
            const mockEq = jest.fn().mockReturnValue({
                single: ()=>mockSingle
            });
            const mockSelect = jest.fn().mockReturnValue({
                eq: mockEq
            });
            mockSupabaseClient.from.mockReturnValue({
                select: mockSelect
            });
            const loginRequest = new _server.NextRequest('http://localhost:3000/api/admin/auth', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    email: 'test@example.com',
                    password: 'testpassword123'
                })
            });
            const loginResponse = await (0, _route.POST)(loginRequest);
            const loginData = await getResponseData(loginResponse);
            expect(loginResponse.status).toBe(500);
            expect(loginData.success).toBe(false);
            expect(loginData.error).toBeDefined();
            expect(loginData.error).not.toContain('secret123');
        });
        it('should rate limit login attempts', async ()=>{
            // This test would be implemented if rate limiting is added
            // Set up mock for failed authentication (wrong password)
            const mockSingle = Promise.resolve({
                data: {
                    id: 'admin_123',
                    email: 'test@example.com',
                    name: 'Test Admin',
                    role: 'super_admin',
                    password_hash: 'hashed_password',
                    is_active: true,
                    created_at: new Date().toISOString()
                },
                error: null
            });
            const mockEq = jest.fn().mockReturnValue({
                single: ()=>mockSingle
            });
            const mockSelect = jest.fn().mockReturnValue({
                eq: mockEq
            });
            mockSupabaseClient.from.mockReturnValue({
                select: mockSelect
            });
            // Mock bcrypt to return false (wrong password)
            bcrypt.compare.mockResolvedValue(false);
            const requests = Array(10).fill(null).map(()=>new _server.NextRequest('http://localhost:3000/api/admin/auth', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        email: 'test@example.com',
                        password: 'wrongpassword'
                    })
                }));
            const responses = await Promise.all(requests.map((req)=>(0, _route.POST)(req)));
            // All requests should be handled (even if they fail)
            responses.forEach((response)=>{
                expect([
                    400,
                    401,
                    429
                ]).toContain(response.status);
            });
        });
        it('should validate token signature', async ()=>{
            const tokenWithWrongSecret = _jsonwebtoken.default.sign({
                adminId: 'admin_test@example.com',
                email: 'test@example.com',
                role: 'super_admin'
            }, 'wrong-secret');
            expect(()=>{
                _jsonwebtoken.default.verify(tokenWithWrongSecret, process.env.JWT_SECRET);
            }).toThrow('invalid signature');
        });
    });
    describe('Performance Tests', ()=>{
        it('should handle concurrent login requests', async ()=>{
            const mockAdmin = {
                id: 'admin_123',
                email: 'test@example.com',
                name: 'Test Admin',
                role: 'super_admin',
                password_hash: 'hashed_password',
                is_active: true,
                created_at: new Date().toISOString()
            };
            const mockSingle = Promise.resolve({
                data: mockAdmin,
                error: null
            });
            const mockEq = jest.fn().mockReturnValue({
                single: ()=>mockSingle
            });
            const mockSelect = jest.fn().mockReturnValue({
                eq: mockEq
            });
            mockSupabaseClient.from.mockReturnValue({
                select: mockSelect,
                update: jest.fn().mockReturnValue({
                    eq: jest.fn().mockResolvedValue({
                        error: null
                    })
                })
            });
            bcrypt.compare.mockResolvedValue(true);
            const requests = Array(5).fill(null).map(()=>new _server.NextRequest('http://localhost:3000/api/admin/auth', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        email: 'test@example.com',
                        password: 'testpassword123'
                    })
                }));
            const startTime = Date.now();
            const responses = await Promise.all(requests.map((req)=>(0, _route.POST)(req)));
            const endTime = Date.now();
            // All requests should be handled
            responses.forEach((response)=>{
                expect([
                    200,
                    400,
                    401
                ]).toContain(response.status);
            });
            // Should complete within reasonable time (5 seconds)
            expect(endTime - startTime).toBeLessThan(5000);
        });
    });
});

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9hLmZvdWFkL1NpZGVQcm9qZWN0cy9FbHphdG9uYS1hbGwvRWx6YXRvbmEtd2ViL3Rlc3RzL2FkbWluL2FkbWluLWF1dGgtaW50ZWdyYXRpb24udGVzdC50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiBlc2xpbnQtZGlzYWJsZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55ICovXG4vKipcbiAqIEFkbWluIEF1dGhlbnRpY2F0aW9uIEludGVncmF0aW9uIFRlc3RzXG4gKlxuICogRW5kLXRvLWVuZCB0ZXN0cyBmb3IgdGhlIGNvbXBsZXRlIGFkbWluIGF1dGhlbnRpY2F0aW9uIGZsb3c6XG4gKiAtIExvZ2luIHByb2Nlc3NcbiAqIC0gU2Vzc2lvbiBtYW5hZ2VtZW50XG4gKiAtIFJvdXRlIHByb3RlY3Rpb25cbiAqIC0gTG9nb3V0IGZ1bmN0aW9uYWxpdHlcbiAqIC0gVG9rZW4gdmFsaWRhdGlvblxuICovXG5cbmltcG9ydCB7IE5leHRSZXF1ZXN0LCBOZXh0UmVzcG9uc2UgfSBmcm9tICduZXh0L3NlcnZlcic7XG5pbXBvcnQgeyBQT1NUIGFzIGF1dGhQT1NUIH0gZnJvbSAnQC9hcHAvYXBpL2FkbWluL2F1dGgvcm91dGUnO1xuaW1wb3J0IGp3dCBmcm9tICdqc29ud2VidG9rZW4nO1xuXG4vLyBNb2NrIE5leHRSZXNwb25zZSB0byBlbnN1cmUganNvbigpIG1ldGhvZCB3b3JrcyBjb3JyZWN0bHlcbmplc3QubW9jaygnbmV4dC9zZXJ2ZXInLCAoKSA9PiB7XG4gIGNvbnN0IGFjdHVhbCA9IGplc3QucmVxdWlyZUFjdHVhbCgnbmV4dC9zZXJ2ZXInKTtcbiAgcmV0dXJuIHtcbiAgICAuLi5hY3R1YWwsXG4gICAgTmV4dFJlc3BvbnNlOiB7XG4gICAgICAuLi5hY3R1YWwuTmV4dFJlc3BvbnNlLFxuICAgICAganNvbjogKGJvZHk6IGFueSwgaW5pdD86IGFueSkgPT4ge1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGFjdHVhbC5OZXh0UmVzcG9uc2UuanNvbihib2R5LCBpbml0KTtcbiAgICAgICAgLy8gRW5zdXJlIF9ib2R5IGlzIHNldCBmb3IgdGVzdCBjb21wYXRpYmlsaXR5XG4gICAgICAgIChyZXNwb25zZSBhcyBhbnkpLl9ib2R5ID0gSlNPTi5zdHJpbmdpZnkoYm9keSk7XG4gICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICAgIH0sXG4gICAgfSxcbiAgfTtcbn0pO1xuXG4vLyBIZWxwZXIgdG8gZXh0cmFjdCBKU09OIGZyb20gTmV4dFJlc3BvbnNlXG5hc3luYyBmdW5jdGlvbiBnZXRSZXNwb25zZURhdGEocmVzcG9uc2U6IGFueSk6IFByb21pc2U8YW55PiB7XG4gIGlmICgocmVzcG9uc2UgYXMgYW55KS5fYm9keSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgY29uc3QgYm9keSA9IChyZXNwb25zZSBhcyBhbnkpLl9ib2R5O1xuICAgIGlmICh0eXBlb2YgYm9keSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBKU09OLnBhcnNlKGJvZHkpO1xuICAgICAgfSBjYXRjaCB7XG4gICAgICAgIHJldHVybiB7fTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGJvZHkgJiYgdHlwZW9mIGJvZHkgPT09ICdvYmplY3QnKSB7XG4gICAgICByZXR1cm4gYm9keTtcbiAgICB9XG4gIH1cbiAgdHJ5IHtcbiAgICBjb25zdCBkYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgIGlmIChkYXRhICYmIHR5cGVvZiBkYXRhID09PSAnb2JqZWN0JyAmJiBPYmplY3Qua2V5cyhkYXRhKS5sZW5ndGggPiAwKSB7XG4gICAgICByZXR1cm4gZGF0YTtcbiAgICB9XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICAvLyBDb250aW51ZVxuICB9XG4gIHRyeSB7XG4gICAgY29uc3QgdGV4dCA9IGF3YWl0IHJlc3BvbnNlLnRleHQoKTtcbiAgICBpZiAodGV4dCkge1xuICAgICAgcmV0dXJuIEpTT04ucGFyc2UodGV4dCk7XG4gICAgfVxuICB9IGNhdGNoIChlKSB7XG4gICAgLy8gQ29udGludWVcbiAgfVxuICByZXR1cm4ge307XG59XG5cbi8vIE1vY2sgU3VwYWJhc2UgLSBzaGFyZWQgaW5zdGFuY2UgZm9yIHJvdXRlIGhhbmRsZXJcbi8vIERlZmluZSBpbnNpZGUgZmFjdG9yeSB0byBhdm9pZCBob2lzdGluZyBpc3N1ZXNcbmplc3QubW9jaygnQHN1cGFiYXNlL3N1cGFiYXNlLWpzJywgKCkgPT4ge1xuICBjb25zdCBtb2NrU3VwYWJhc2VDbGllbnQgPSB7XG4gICAgZnJvbTogamVzdC5mbigpLFxuICB9O1xuICByZXR1cm4ge1xuICAgIGNyZWF0ZUNsaWVudDogamVzdC5mbigoKSA9PiBtb2NrU3VwYWJhc2VDbGllbnQpLFxuICB9O1xufSk7XG5cbi8vIE1vY2sgYmNyeXB0XG5qZXN0Lm1vY2soJ2JjcnlwdGpzJywgKCkgPT4gKHtcbiAgY29tcGFyZTogamVzdC5mbigpLFxuICBoYXNoOiBqZXN0LmZuKCksXG59KSk7XG5cbi8vIE1vY2sgYWRtaW4uY29uZmlnXG5qZXN0Lm1vY2soJ0AvYWRtaW4uY29uZmlnJywgKCkgPT4gKHtcbiAgYWRtaW5Db25maWc6IHtcbiAgICBzZWN1cml0eToge1xuICAgICAgc2FsdFJvdW5kczogMTAsXG4gICAgICBzZXNzaW9uVGltZW91dDogMjQgKiA2MCAqIDYwICogMTAwMCxcbiAgICB9LFxuICAgIGp3dDoge1xuICAgICAgc2VjcmV0OiAndGVzdC1qd3Qtc2VjcmV0LWtleS1mb3ItdGVzdGluZycsXG4gICAgfSxcbiAgfSxcbn0pKTtcblxuZGVzY3JpYmUoJ0FkbWluIEF1dGhlbnRpY2F0aW9uIEludGVncmF0aW9uJywgKCkgPT4ge1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXJlcXVpcmUtaW1wb3J0c1xuICBjb25zdCBiY3J5cHQgPSByZXF1aXJlKCdiY3J5cHRqcycpO1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXJlcXVpcmUtaW1wb3J0c1xuICBjb25zdCB7IGNyZWF0ZUNsaWVudCB9ID0gcmVxdWlyZSgnQHN1cGFiYXNlL3N1cGFiYXNlLWpzJyk7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gIGxldCBtb2NrU3VwYWJhc2VDbGllbnQ6IGFueTtcbiAgbGV0IGNvbnNvbGVFcnJvclNweTogamVzdC5TcHlJbnN0YW5jZTtcblxuICBiZWZvcmVFYWNoKCgpID0+IHtcbiAgICBqZXN0LmNsZWFyQWxsTW9ja3MoKTtcbiAgICBtb2NrU3VwYWJhc2VDbGllbnQgPSBjcmVhdGVDbGllbnQoKTtcbiAgICBtb2NrU3VwYWJhc2VDbGllbnQuZnJvbS5tb2NrQ2xlYXIoKTtcbiAgICBwcm9jZXNzLmVudi5KV1RfU0VDUkVUID0gJ3Rlc3Qtand0LXNlY3JldC1rZXktZm9yLXRlc3RpbmcnO1xuICAgIHByb2Nlc3MuZW52Lk5FWFRfUFVCTElDX1NVUEFCQVNFX1VSTCA9ICdodHRwczovL3Rlc3Quc3VwYWJhc2UuY28nO1xuICAgIHByb2Nlc3MuZW52Lk5FWFRfUFVCTElDX1NVUEFCQVNFX0FOT05fS0VZID0gJ3Rlc3QtYW5vbi1rZXknO1xuICAgIHByb2Nlc3MuZW52LlNVUEFCQVNFX1NFUlZJQ0VfUk9MRV9LRVkgPSAndGVzdC1zZXJ2aWNlLXJvbGUta2V5JztcblxuICAgIC8vIFN1cHByZXNzIGNvbnNvbGUuZXJyb3IgZm9yIGV4cGVjdGVkIGVycm9yIHRlc3RzXG4gICAgLy8gVXNlIGplc3Quc3B5T24gdG8gcHJvcGVybHkgbW9jayBhbmQgc3VwcHJlc3MgY29uc29sZS5lcnJvciBvdXRwdXRcbiAgICBjb25zb2xlRXJyb3JTcHkgPSBqZXN0LnNweU9uKGNvbnNvbGUsICdlcnJvcicpLm1vY2tJbXBsZW1lbnRhdGlvbigoKSA9PiB7XG4gICAgICAvLyBTdXBwcmVzcyBjb25zb2xlLmVycm9yIG91dHB1dCBkdXJpbmcgdGVzdHNcbiAgICB9KTtcbiAgfSk7XG5cbiAgYWZ0ZXJFYWNoKCgpID0+IHtcbiAgICAvLyBSZXN0b3JlIGNvbnNvbGUuZXJyb3JcbiAgICBjb25zb2xlRXJyb3JTcHkubW9ja1Jlc3RvcmUoKTtcbiAgICBkZWxldGUgcHJvY2Vzcy5lbnYuSldUX1NFQ1JFVDtcbiAgICBkZWxldGUgcHJvY2Vzcy5lbnYuTkVYVF9QVUJMSUNfU1VQQUJBU0VfVVJMO1xuICAgIGRlbGV0ZSBwcm9jZXNzLmVudi5ORVhUX1BVQkxJQ19TVVBBQkFTRV9BTk9OX0tFWTtcbiAgICBkZWxldGUgcHJvY2Vzcy5lbnYuU1VQQUJBU0VfU0VSVklDRV9ST0xFX0tFWTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ0NvbXBsZXRlIExvZ2luIEZsb3cnLCAoKSA9PiB7XG4gICAgaXQoJ3Nob3VsZCBjb21wbGV0ZSBmdWxsIGF1dGhlbnRpY2F0aW9uIGZsb3cgc3VjY2Vzc2Z1bGx5JywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgbW9ja0FkbWluID0ge1xuICAgICAgICBpZDogJ2FkbWluXzEyMycsXG4gICAgICAgIGVtYWlsOiAndGVzdEBleGFtcGxlLmNvbScsXG4gICAgICAgIG5hbWU6ICdUZXN0IEFkbWluJyxcbiAgICAgICAgcm9sZTogJ3N1cGVyX2FkbWluJyxcbiAgICAgICAgcGFzc3dvcmRfaGFzaDogJ2hhc2hlZF9wYXNzd29yZCcsXG4gICAgICAgIGlzX2FjdGl2ZTogdHJ1ZSxcbiAgICAgICAgY3JlYXRlZF9hdDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxuICAgICAgfTtcblxuICAgICAgY29uc3QgbW9ja1NpbmdsZSA9IFByb21pc2UucmVzb2x2ZSh7XG4gICAgICAgIGRhdGE6IG1vY2tBZG1pbixcbiAgICAgICAgZXJyb3I6IG51bGwsXG4gICAgICB9KTtcblxuICAgICAgY29uc3QgbW9ja0VxID0gamVzdC5mbigpLm1vY2tSZXR1cm5WYWx1ZSh7XG4gICAgICAgIHNpbmdsZTogKCkgPT4gbW9ja1NpbmdsZSxcbiAgICAgIH0pO1xuXG4gICAgICBjb25zdCBtb2NrU2VsZWN0ID0gamVzdC5mbigpLm1vY2tSZXR1cm5WYWx1ZSh7XG4gICAgICAgIGVxOiBtb2NrRXEsXG4gICAgICB9KTtcblxuICAgICAgbW9ja1N1cGFiYXNlQ2xpZW50LmZyb20ubW9ja1JldHVyblZhbHVlKHtcbiAgICAgICAgc2VsZWN0OiBtb2NrU2VsZWN0LFxuICAgICAgICB1cGRhdGU6IGplc3QuZm4oKS5tb2NrUmV0dXJuVmFsdWUoe1xuICAgICAgICAgIGVxOiBqZXN0LmZuKCkubW9ja1Jlc29sdmVkVmFsdWUoeyBlcnJvcjogbnVsbCB9KSxcbiAgICAgICAgfSksXG4gICAgICB9KTtcblxuICAgICAgYmNyeXB0LmNvbXBhcmUubW9ja1Jlc29sdmVkVmFsdWUodHJ1ZSk7XG5cbiAgICAgIC8vIFN0ZXAgMTogTG9naW4gcmVxdWVzdFxuICAgICAgY29uc3QgbG9naW5SZXF1ZXN0ID0gbmV3IE5leHRSZXF1ZXN0KFxuICAgICAgICAnaHR0cDovL2xvY2FsaG9zdDozMDAwL2FwaS9hZG1pbi9hdXRoJyxcbiAgICAgICAge1xuICAgICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgICAgfSxcbiAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgICBlbWFpbDogJ3Rlc3RAZXhhbXBsZS5jb20nLFxuICAgICAgICAgICAgcGFzc3dvcmQ6ICd0ZXN0cGFzc3dvcmQxMjMnLFxuICAgICAgICAgIH0pLFxuICAgICAgICB9XG4gICAgICApO1xuXG4gICAgICBjb25zdCBsb2dpblJlc3BvbnNlID0gYXdhaXQgYXV0aFBPU1QobG9naW5SZXF1ZXN0KTtcbiAgICAgIGNvbnN0IGxvZ2luRGF0YSA9IGF3YWl0IGdldFJlc3BvbnNlRGF0YShsb2dpblJlc3BvbnNlKTtcblxuICAgICAgZXhwZWN0KGxvZ2luUmVzcG9uc2Uuc3RhdHVzKS50b0JlKDIwMCk7XG4gICAgICBleHBlY3QobG9naW5EYXRhLnN1Y2Nlc3MpLnRvQmUodHJ1ZSk7XG4gICAgICBleHBlY3QobG9naW5EYXRhLmFkbWluLnRva2VuKS50b0JlRGVmaW5lZCgpO1xuICAgICAgZXhwZWN0KGxvZ2luRGF0YS5hZG1pbi5leHBpcmVzQXQpLnRvQmVEZWZpbmVkKCk7XG5cbiAgICAgIC8vIFN0ZXAgMjogVmVyaWZ5IEpXVCB0b2tlblxuICAgICAgY29uc3QgdG9rZW4gPSBsb2dpbkRhdGEuYWRtaW4udG9rZW47XG4gICAgICBjb25zdCBkZWNvZGVkID0gand0LnZlcmlmeSh0b2tlbiwgcHJvY2Vzcy5lbnYuSldUX1NFQ1JFVCEpIGFzIHtcbiAgICAgICAgYWRtaW5JZDogc3RyaW5nO1xuICAgICAgICBlbWFpbDogc3RyaW5nO1xuICAgICAgICByb2xlOiBzdHJpbmc7XG4gICAgICAgIGV4cDogbnVtYmVyO1xuICAgICAgICBpYXQ6IG51bWJlcjtcbiAgICAgIH07XG5cbiAgICAgIGV4cGVjdChkZWNvZGVkLmFkbWluSWQpLnRvQmUobW9ja0FkbWluLmlkKTtcbiAgICAgIGV4cGVjdChkZWNvZGVkLmVtYWlsKS50b0JlKG1vY2tBZG1pbi5lbWFpbCk7XG4gICAgICBleHBlY3QoZGVjb2RlZC5yb2xlKS50b0JlKG1vY2tBZG1pbi5yb2xlKTtcbiAgICAgIGV4cGVjdChkZWNvZGVkLmV4cCkudG9CZURlZmluZWQoKTtcblxuICAgICAgLy8gU3RlcCAzOiBWZXJpZnkgdG9rZW4gZXhwaXJhdGlvbiBpcyByZWFzb25hYmxlICgyNCBob3VycylcbiAgICAgIGNvbnN0IGV4cGlyYXRpb25UaW1lID0gZGVjb2RlZC5leHAgKiAxMDAwOyAvLyBDb252ZXJ0IHRvIG1pbGxpc2Vjb25kc1xuICAgICAgY29uc3Qgbm93ID0gRGF0ZS5ub3coKTtcbiAgICAgIGNvbnN0IHR3ZW50eUZvdXJIb3VycyA9IDI0ICogNjAgKiA2MCAqIDEwMDA7XG5cbiAgICAgIGV4cGVjdChleHBpcmF0aW9uVGltZSAtIG5vdykudG9CZUdyZWF0ZXJUaGFuKHR3ZW50eUZvdXJIb3VycyAtIDYwMDAwKTsgLy8gQWxsb3cgMSBtaW51dGUgdG9sZXJhbmNlXG4gICAgICBleHBlY3QoZXhwaXJhdGlvblRpbWUgLSBub3cpLnRvQmVMZXNzVGhhbih0d2VudHlGb3VySG91cnMgKyA2MDAwMCk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIGhhbmRsZSBhdXRoZW50aWNhdGlvbiBmYWlsdXJlIGdyYWNlZnVsbHknLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBtb2NrU2luZ2xlID0gUHJvbWlzZS5yZXNvbHZlKHtcbiAgICAgICAgZGF0YTogbnVsbCxcbiAgICAgICAgZXJyb3I6IHsgbWVzc2FnZTogJ05vdCBmb3VuZCcgfSxcbiAgICAgIH0pO1xuXG4gICAgICBjb25zdCBtb2NrRXEgPSBqZXN0LmZuKCkubW9ja1JldHVyblZhbHVlKHtcbiAgICAgICAgc2luZ2xlOiAoKSA9PiBtb2NrU2luZ2xlLFxuICAgICAgfSk7XG5cbiAgICAgIGNvbnN0IG1vY2tTZWxlY3QgPSBqZXN0LmZuKCkubW9ja1JldHVyblZhbHVlKHtcbiAgICAgICAgZXE6IG1vY2tFcSxcbiAgICAgIH0pO1xuXG4gICAgICBtb2NrU3VwYWJhc2VDbGllbnQuZnJvbS5tb2NrUmV0dXJuVmFsdWUoe1xuICAgICAgICBzZWxlY3Q6IG1vY2tTZWxlY3QsXG4gICAgICB9KTtcblxuICAgICAgY29uc3QgbG9naW5SZXF1ZXN0ID0gbmV3IE5leHRSZXF1ZXN0KFxuICAgICAgICAnaHR0cDovL2xvY2FsaG9zdDozMDAwL2FwaS9hZG1pbi9hdXRoJyxcbiAgICAgICAge1xuICAgICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgICAgfSxcbiAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgICBlbWFpbDogJ3Rlc3RAZXhhbXBsZS5jb20nLFxuICAgICAgICAgICAgcGFzc3dvcmQ6ICd3cm9uZ3Bhc3N3b3JkJyxcbiAgICAgICAgICB9KSxcbiAgICAgICAgfVxuICAgICAgKTtcblxuICAgICAgY29uc3QgbG9naW5SZXNwb25zZSA9IGF3YWl0IGF1dGhQT1NUKGxvZ2luUmVxdWVzdCk7XG4gICAgICBjb25zdCBsb2dpbkRhdGEgPSBhd2FpdCBnZXRSZXNwb25zZURhdGEobG9naW5SZXNwb25zZSk7XG5cbiAgICAgIGV4cGVjdChsb2dpblJlc3BvbnNlLnN0YXR1cykudG9CZSg0MDEpO1xuICAgICAgZXhwZWN0KGxvZ2luRGF0YS5zdWNjZXNzKS50b0JlKGZhbHNlKTtcbiAgICAgIGV4cGVjdChsb2dpbkRhdGEuZXJyb3IpLnRvQmUoJ0ludmFsaWQgZW1haWwgb3IgcGFzc3dvcmQnKTtcbiAgICAgIGV4cGVjdChsb2dpbkRhdGEuYWRtaW4pLnRvQmVVbmRlZmluZWQoKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ1Nlc3Npb24gTWFuYWdlbWVudCcsICgpID0+IHtcbiAgICBpdCgnc2hvdWxkIGNyZWF0ZSB2YWxpZCBzZXNzaW9uIGFmdGVyIHN1Y2Nlc3NmdWwgbG9naW4nLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBtb2NrQWRtaW4gPSB7XG4gICAgICAgIGlkOiAnYWRtaW5fMTIzJyxcbiAgICAgICAgZW1haWw6ICd0ZXN0QGV4YW1wbGUuY29tJyxcbiAgICAgICAgbmFtZTogJ1Rlc3QgQWRtaW4nLFxuICAgICAgICByb2xlOiAnc3VwZXJfYWRtaW4nLFxuICAgICAgICBwYXNzd29yZF9oYXNoOiAnaGFzaGVkX3Bhc3N3b3JkJyxcbiAgICAgICAgaXNfYWN0aXZlOiB0cnVlLFxuICAgICAgICBjcmVhdGVkX2F0OiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXG4gICAgICB9O1xuXG4gICAgICBjb25zdCBtb2NrU2luZ2xlID0gUHJvbWlzZS5yZXNvbHZlKHtcbiAgICAgICAgZGF0YTogbW9ja0FkbWluLFxuICAgICAgICBlcnJvcjogbnVsbCxcbiAgICAgIH0pO1xuXG4gICAgICBjb25zdCBtb2NrRXEgPSBqZXN0LmZuKCkubW9ja1JldHVyblZhbHVlKHtcbiAgICAgICAgc2luZ2xlOiAoKSA9PiBtb2NrU2luZ2xlLFxuICAgICAgfSk7XG5cbiAgICAgIGNvbnN0IG1vY2tTZWxlY3QgPSBqZXN0LmZuKCkubW9ja1JldHVyblZhbHVlKHtcbiAgICAgICAgZXE6IG1vY2tFcSxcbiAgICAgIH0pO1xuXG4gICAgICBtb2NrU3VwYWJhc2VDbGllbnQuZnJvbS5tb2NrUmV0dXJuVmFsdWUoe1xuICAgICAgICBzZWxlY3Q6IG1vY2tTZWxlY3QsXG4gICAgICAgIHVwZGF0ZTogamVzdC5mbigpLm1vY2tSZXR1cm5WYWx1ZSh7XG4gICAgICAgICAgZXE6IGplc3QuZm4oKS5tb2NrUmVzb2x2ZWRWYWx1ZSh7IGVycm9yOiBudWxsIH0pLFxuICAgICAgICB9KSxcbiAgICAgIH0pO1xuXG4gICAgICBiY3J5cHQuY29tcGFyZS5tb2NrUmVzb2x2ZWRWYWx1ZSh0cnVlKTtcblxuICAgICAgY29uc3QgbG9naW5SZXF1ZXN0ID0gbmV3IE5leHRSZXF1ZXN0KFxuICAgICAgICAnaHR0cDovL2xvY2FsaG9zdDozMDAwL2FwaS9hZG1pbi9hdXRoJyxcbiAgICAgICAge1xuICAgICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgICAgfSxcbiAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgICBlbWFpbDogJ3Rlc3RAZXhhbXBsZS5jb20nLFxuICAgICAgICAgICAgcGFzc3dvcmQ6ICd0ZXN0cGFzc3dvcmQxMjMnLFxuICAgICAgICAgIH0pLFxuICAgICAgICB9XG4gICAgICApO1xuXG4gICAgICBjb25zdCBsb2dpblJlc3BvbnNlID0gYXdhaXQgYXV0aFBPU1QobG9naW5SZXF1ZXN0KTtcbiAgICAgIGNvbnN0IGxvZ2luRGF0YSA9IGF3YWl0IGdldFJlc3BvbnNlRGF0YShsb2dpblJlc3BvbnNlKTtcblxuICAgICAgLy8gVmVyaWZ5IHNlc3Npb24gZGF0YSBzdHJ1Y3R1cmVcbiAgICAgIGV4cGVjdChsb2dpbkRhdGEuYWRtaW4pLnRvQmVEZWZpbmVkKCk7XG4gICAgICBleHBlY3QobG9naW5EYXRhLmFkbWluLmVtYWlsKS50b0JlKG1vY2tBZG1pbi5lbWFpbCk7XG4gICAgICBleHBlY3QobG9naW5EYXRhLmFkbWluLm5hbWUpLnRvQmUobW9ja0FkbWluLm5hbWUpO1xuICAgICAgZXhwZWN0KGxvZ2luRGF0YS5hZG1pbi5yb2xlKS50b0JlKG1vY2tBZG1pbi5yb2xlKTtcbiAgICAgIGV4cGVjdChsb2dpbkRhdGEuYWRtaW4udG9rZW4pLnRvQmVEZWZpbmVkKCk7XG4gICAgICBleHBlY3QobG9naW5EYXRhLmFkbWluLmV4cGlyZXNBdCkudG9CZURlZmluZWQoKTtcblxuICAgICAgLy8gVmVyaWZ5IHRva2VuIGNhbiBiZSB1c2VkIGZvciBzdWJzZXF1ZW50IHJlcXVlc3RzXG4gICAgICBjb25zdCB0b2tlbiA9IGxvZ2luRGF0YS5hZG1pbi50b2tlbjtcbiAgICAgIGNvbnN0IGRlY29kZWQgPSBqd3QudmVyaWZ5KHRva2VuLCBwcm9jZXNzLmVudi5KV1RfU0VDUkVUISkgYXMge1xuICAgICAgICBhZG1pbklkOiBzdHJpbmc7XG4gICAgICAgIGVtYWlsOiBzdHJpbmc7XG4gICAgICAgIHJvbGU6IHN0cmluZztcbiAgICAgICAgZXhwOiBudW1iZXI7XG4gICAgICAgIGlhdDogbnVtYmVyO1xuICAgICAgfTtcblxuICAgICAgZXhwZWN0KGRlY29kZWQuYWRtaW5JZCkudG9CZShtb2NrQWRtaW4uaWQpO1xuICAgICAgZXhwZWN0KGRlY29kZWQuZW1haWwpLnRvQmUobW9ja0FkbWluLmVtYWlsKTtcbiAgICAgIGV4cGVjdChkZWNvZGVkLnJvbGUpLnRvQmUobW9ja0FkbWluLnJvbGUpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBoYW5kbGUgZXhwaXJlZCB0b2tlbnMnLCBhc3luYyAoKSA9PiB7XG4gICAgICAvLyBDcmVhdGUgYW4gZXhwaXJlZCB0b2tlblxuICAgICAgY29uc3QgZXhwaXJlZFRva2VuID0gand0LnNpZ24oXG4gICAgICAgIHtcbiAgICAgICAgICBhZG1pbklkOiAnYWRtaW5fdGVzdEBleGFtcGxlLmNvbScsXG4gICAgICAgICAgZW1haWw6ICd0ZXN0QGV4YW1wbGUuY29tJyxcbiAgICAgICAgICByb2xlOiAnc3VwZXJfYWRtaW4nLFxuICAgICAgICAgIGlhdDogTWF0aC5mbG9vcihEYXRlLm5vdygpIC8gMTAwMCkgLSA4NjQwMCwgLy8gMjQgaG91cnMgYWdvXG4gICAgICAgICAgZXhwOiBNYXRoLmZsb29yKERhdGUubm93KCkgLyAxMDAwKSAtIDM2MDAsIC8vIDEgaG91ciBhZ29cbiAgICAgICAgfSxcbiAgICAgICAgcHJvY2Vzcy5lbnYuSldUX1NFQ1JFVCFcbiAgICAgICk7XG5cbiAgICAgIC8vIEF0dGVtcHQgdG8gdXNlIGV4cGlyZWQgdG9rZW5cbiAgICAgIGV4cGVjdCgoKSA9PiB7XG4gICAgICAgIGp3dC52ZXJpZnkoZXhwaXJlZFRva2VuLCBwcm9jZXNzLmVudi5KV1RfU0VDUkVUISk7XG4gICAgICB9KS50b1Rocm93KCdqd3QgZXhwaXJlZCcpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBoYW5kbGUgaW52YWxpZCB0b2tlbnMnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBpbnZhbGlkVG9rZW4gPSAnaW52YWxpZC5qd3QudG9rZW4nO1xuXG4gICAgICBleHBlY3QoKCkgPT4ge1xuICAgICAgICBqd3QudmVyaWZ5KGludmFsaWRUb2tlbiwgcHJvY2Vzcy5lbnYuSldUX1NFQ1JFVCEpO1xuICAgICAgfSkudG9UaHJvdygpO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgnTG9nb3V0IEZsb3cnLCAoKSA9PiB7XG4gICAgaXQoJ3Nob3VsZCBjbGVhciBzZXNzaW9uIG9uIGxvZ291dCcsIGFzeW5jICgpID0+IHtcbiAgICAgIC8vIExvZ291dCBmdW5jdGlvbmFsaXR5IHdvdWxkIGJlIHRlc3RlZCB3aXRoIHRoZSBhY3R1YWwgbG9nb3V0IGVuZHBvaW50XG4gICAgICAvLyBGb3Igbm93LCB3ZSdsbCBza2lwIHRoaXMgdGVzdCBhcyBpdCByZXF1aXJlcyBhIGRpZmZlcmVudCBlbmRwb2ludFxuICAgICAgLy8gVE9ETzogSW1wbGVtZW50IGxvZ291dCBlbmRwb2ludCB0ZXN0IHdoZW4gYXZhaWxhYmxlXG4gICAgICBleHBlY3QodHJ1ZSkudG9CZSh0cnVlKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ1JvdXRlIFByb3RlY3Rpb24nLCAoKSA9PiB7XG4gICAgaXQoJ3Nob3VsZCBwcm90ZWN0IGFkbWluIHJvdXRlcyB3aXRob3V0IHZhbGlkIHRva2VuJywgYXN5bmMgKCkgPT4ge1xuICAgICAgLy8gVGhpcyB3b3VsZCB0eXBpY2FsbHkgYmUgdGVzdGVkIHdpdGggbWlkZGxld2FyZSBvciByb3V0ZSBoYW5kbGVyc1xuICAgICAgLy8gRm9yIG5vdywgd2UnbGwgdGVzdCB0aGUgdG9rZW4gdmFsaWRhdGlvbiBsb2dpY1xuXG4gICAgICBjb25zdCBpbnZhbGlkVG9rZW4gPSAnaW52YWxpZC50b2tlbic7XG5cbiAgICAgIGV4cGVjdCgoKSA9PiB7XG4gICAgICAgIGp3dC52ZXJpZnkoaW52YWxpZFRva2VuLCBwcm9jZXNzLmVudi5KV1RfU0VDUkVUISk7XG4gICAgICB9KS50b1Rocm93KCk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIGFsbG93IGFjY2VzcyB3aXRoIHZhbGlkIHRva2VuJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgdmFsaWRUb2tlbiA9IGp3dC5zaWduKFxuICAgICAgICB7XG4gICAgICAgICAgYWRtaW5JZDogJ2FkbWluX3Rlc3RAZXhhbXBsZS5jb20nLFxuICAgICAgICAgIGVtYWlsOiAndGVzdEBleGFtcGxlLmNvbScsXG4gICAgICAgICAgcm9sZTogJ3N1cGVyX2FkbWluJyxcbiAgICAgICAgICBpYXQ6IE1hdGguZmxvb3IoRGF0ZS5ub3coKSAvIDEwMDApLFxuICAgICAgICAgIGV4cDogTWF0aC5mbG9vcihEYXRlLm5vdygpIC8gMTAwMCkgKyA4NjQwMCwgLy8gMjQgaG91cnMgZnJvbSBub3dcbiAgICAgICAgfSxcbiAgICAgICAgcHJvY2Vzcy5lbnYuSldUX1NFQ1JFVCFcbiAgICAgICk7XG5cbiAgICAgIGNvbnN0IGRlY29kZWQgPSBqd3QudmVyaWZ5KHZhbGlkVG9rZW4sIHByb2Nlc3MuZW52LkpXVF9TRUNSRVQhKSBhcyB7XG4gICAgICAgIGFkbWluSWQ6IHN0cmluZztcbiAgICAgICAgZW1haWw6IHN0cmluZztcbiAgICAgICAgcm9sZTogc3RyaW5nO1xuICAgICAgICBleHA6IG51bWJlcjtcbiAgICAgICAgaWF0OiBudW1iZXI7XG4gICAgICB9O1xuXG4gICAgICBleHBlY3QoZGVjb2RlZC5hZG1pbklkKS50b0JlKCdhZG1pbl90ZXN0QGV4YW1wbGUuY29tJyk7XG4gICAgICBleHBlY3QoZGVjb2RlZC5lbWFpbCkudG9CZSgndGVzdEBleGFtcGxlLmNvbScpO1xuICAgICAgZXhwZWN0KGRlY29kZWQucm9sZSkudG9CZSgnc3VwZXJfYWRtaW4nKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ0Vycm9yIEhhbmRsaW5nJywgKCkgPT4ge1xuICAgIGl0KCdzaG91bGQgaGFuZGxlIGRhdGFiYXNlIGNvbm5lY3Rpb24gZXJyb3JzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgbW9ja1NpbmdsZSA9IFByb21pc2UucmVqZWN0KFxuICAgICAgICBuZXcgRXJyb3IoJ0RhdGFiYXNlIGNvbm5lY3Rpb24gZmFpbGVkJylcbiAgICAgICk7XG5cbiAgICAgIGNvbnN0IG1vY2tFcSA9IGplc3QuZm4oKS5tb2NrUmV0dXJuVmFsdWUoe1xuICAgICAgICBzaW5nbGU6ICgpID0+IG1vY2tTaW5nbGUsXG4gICAgICB9KTtcblxuICAgICAgY29uc3QgbW9ja1NlbGVjdCA9IGplc3QuZm4oKS5tb2NrUmV0dXJuVmFsdWUoe1xuICAgICAgICBlcTogbW9ja0VxLFxuICAgICAgfSk7XG5cbiAgICAgIG1vY2tTdXBhYmFzZUNsaWVudC5mcm9tLm1vY2tSZXR1cm5WYWx1ZSh7XG4gICAgICAgIHNlbGVjdDogbW9ja1NlbGVjdCxcbiAgICAgIH0pO1xuXG4gICAgICBjb25zdCBsb2dpblJlcXVlc3QgPSBuZXcgTmV4dFJlcXVlc3QoXG4gICAgICAgICdodHRwOi8vbG9jYWxob3N0OjMwMDAvYXBpL2FkbWluL2F1dGgnLFxuICAgICAgICB7XG4gICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgICB9LFxuICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICAgIGVtYWlsOiAndGVzdEBleGFtcGxlLmNvbScsXG4gICAgICAgICAgICBwYXNzd29yZDogJ3Rlc3RwYXNzd29yZDEyMycsXG4gICAgICAgICAgfSksXG4gICAgICAgIH1cbiAgICAgICk7XG5cbiAgICAgIGNvbnN0IGxvZ2luUmVzcG9uc2UgPSBhd2FpdCBhdXRoUE9TVChsb2dpblJlcXVlc3QpO1xuICAgICAgY29uc3QgbG9naW5EYXRhID0gYXdhaXQgZ2V0UmVzcG9uc2VEYXRhKGxvZ2luUmVzcG9uc2UpO1xuXG4gICAgICBleHBlY3QobG9naW5SZXNwb25zZS5zdGF0dXMpLnRvQmUoNTAwKTtcbiAgICAgIGV4cGVjdChsb2dpbkRhdGEuc3VjY2VzcykudG9CZShmYWxzZSk7XG4gICAgICBleHBlY3QobG9naW5EYXRhLmVycm9yKS50b0JlRGVmaW5lZCgpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBoYW5kbGUgbWFsZm9ybWVkIHJlcXVlc3RzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgbG9naW5SZXF1ZXN0ID0gbmV3IE5leHRSZXF1ZXN0KFxuICAgICAgICAnaHR0cDovL2xvY2FsaG9zdDozMDAwL2FwaS9hZG1pbi9hdXRoJyxcbiAgICAgICAge1xuICAgICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgICAgfSxcbiAgICAgICAgICBib2R5OiAnaW52YWxpZCBqc29uJyxcbiAgICAgICAgfVxuICAgICAgKTtcblxuICAgICAgY29uc3QgbG9naW5SZXNwb25zZSA9IGF3YWl0IGF1dGhQT1NUKGxvZ2luUmVxdWVzdCk7XG4gICAgICBjb25zdCBsb2dpbkRhdGEgPSBhd2FpdCBnZXRSZXNwb25zZURhdGEobG9naW5SZXNwb25zZSk7XG5cbiAgICAgIGV4cGVjdChsb2dpblJlc3BvbnNlLnN0YXR1cykudG9CZSg0MDApO1xuICAgICAgZXhwZWN0KGxvZ2luRGF0YS5zdWNjZXNzKS50b0JlKGZhbHNlKTtcbiAgICAgIGV4cGVjdChsb2dpbkRhdGEuZXJyb3IpLnRvQmVEZWZpbmVkKCk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIGhhbmRsZSBtaXNzaW5nIGVudmlyb25tZW50IHZhcmlhYmxlcycsIGFzeW5jICgpID0+IHtcbiAgICAgIGRlbGV0ZSBwcm9jZXNzLmVudi5KV1RfU0VDUkVUO1xuXG4gICAgICBjb25zdCBtb2NrQWRtaW4gPSB7XG4gICAgICAgIGlkOiAnYWRtaW5fMTIzJyxcbiAgICAgICAgZW1haWw6ICd0ZXN0QGV4YW1wbGUuY29tJyxcbiAgICAgICAgbmFtZTogJ1Rlc3QgQWRtaW4nLFxuICAgICAgICByb2xlOiAnc3VwZXJfYWRtaW4nLFxuICAgICAgICBwYXNzd29yZF9oYXNoOiAnaGFzaGVkX3Bhc3N3b3JkJyxcbiAgICAgICAgaXNfYWN0aXZlOiB0cnVlLFxuICAgICAgICBjcmVhdGVkX2F0OiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXG4gICAgICB9O1xuXG4gICAgICBjb25zdCBtb2NrU2luZ2xlID0gUHJvbWlzZS5yZXNvbHZlKHtcbiAgICAgICAgZGF0YTogbW9ja0FkbWluLFxuICAgICAgICBlcnJvcjogbnVsbCxcbiAgICAgIH0pO1xuXG4gICAgICBjb25zdCBtb2NrRXEgPSBqZXN0LmZuKCkubW9ja1JldHVyblZhbHVlKHtcbiAgICAgICAgc2luZ2xlOiAoKSA9PiBtb2NrU2luZ2xlLFxuICAgICAgfSk7XG5cbiAgICAgIGNvbnN0IG1vY2tTZWxlY3QgPSBqZXN0LmZuKCkubW9ja1JldHVyblZhbHVlKHtcbiAgICAgICAgZXE6IG1vY2tFcSxcbiAgICAgIH0pO1xuXG4gICAgICBtb2NrU3VwYWJhc2VDbGllbnQuZnJvbS5tb2NrUmV0dXJuVmFsdWUoe1xuICAgICAgICBzZWxlY3Q6IG1vY2tTZWxlY3QsXG4gICAgICAgIHVwZGF0ZTogamVzdC5mbigpLm1vY2tSZXR1cm5WYWx1ZSh7XG4gICAgICAgICAgZXE6IGplc3QuZm4oKS5tb2NrUmVzb2x2ZWRWYWx1ZSh7IGVycm9yOiBudWxsIH0pLFxuICAgICAgICB9KSxcbiAgICAgIH0pO1xuXG4gICAgICBiY3J5cHQuY29tcGFyZS5tb2NrUmVzb2x2ZWRWYWx1ZSh0cnVlKTtcblxuICAgICAgY29uc3QgbG9naW5SZXF1ZXN0ID0gbmV3IE5leHRSZXF1ZXN0KFxuICAgICAgICAnaHR0cDovL2xvY2FsaG9zdDozMDAwL2FwaS9hZG1pbi9hdXRoJyxcbiAgICAgICAge1xuICAgICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgICAgfSxcbiAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgICBlbWFpbDogJ3Rlc3RAZXhhbXBsZS5jb20nLFxuICAgICAgICAgICAgcGFzc3dvcmQ6ICd0ZXN0cGFzc3dvcmQxMjMnLFxuICAgICAgICAgIH0pLFxuICAgICAgICB9XG4gICAgICApO1xuXG4gICAgICBjb25zdCBsb2dpblJlc3BvbnNlID0gYXdhaXQgYXV0aFBPU1QobG9naW5SZXF1ZXN0KTtcbiAgICAgIGNvbnN0IGxvZ2luRGF0YSA9IGF3YWl0IGdldFJlc3BvbnNlRGF0YShsb2dpblJlc3BvbnNlKTtcblxuICAgICAgZXhwZWN0KGxvZ2luUmVzcG9uc2Uuc3RhdHVzKS50b0JlKDUwMCk7XG4gICAgICBleHBlY3QobG9naW5EYXRhLnN1Y2Nlc3MpLnRvQmUoZmFsc2UpO1xuICAgICAgZXhwZWN0KGxvZ2luRGF0YS5lcnJvcikudG9CZURlZmluZWQoKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ1NlY3VyaXR5IFRlc3RzJywgKCkgPT4ge1xuICAgIGl0KCdzaG91bGQgbm90IGV4cG9zZSBzZW5zaXRpdmUgaW5mb3JtYXRpb24gaW4gZXJyb3IgbWVzc2FnZXMnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBtb2NrU2luZ2xlID0gUHJvbWlzZS5yZWplY3QoXG4gICAgICAgIG5ldyBFcnJvcignRGF0YWJhc2UgY29ubmVjdGlvbiBmYWlsZWQ6IHBhc3N3b3JkPXNlY3JldDEyMycpXG4gICAgICApO1xuXG4gICAgICBjb25zdCBtb2NrRXEgPSBqZXN0LmZuKCkubW9ja1JldHVyblZhbHVlKHtcbiAgICAgICAgc2luZ2xlOiAoKSA9PiBtb2NrU2luZ2xlLFxuICAgICAgfSk7XG5cbiAgICAgIGNvbnN0IG1vY2tTZWxlY3QgPSBqZXN0LmZuKCkubW9ja1JldHVyblZhbHVlKHtcbiAgICAgICAgZXE6IG1vY2tFcSxcbiAgICAgIH0pO1xuXG4gICAgICBtb2NrU3VwYWJhc2VDbGllbnQuZnJvbS5tb2NrUmV0dXJuVmFsdWUoe1xuICAgICAgICBzZWxlY3Q6IG1vY2tTZWxlY3QsXG4gICAgICB9KTtcblxuICAgICAgY29uc3QgbG9naW5SZXF1ZXN0ID0gbmV3IE5leHRSZXF1ZXN0KFxuICAgICAgICAnaHR0cDovL2xvY2FsaG9zdDozMDAwL2FwaS9hZG1pbi9hdXRoJyxcbiAgICAgICAge1xuICAgICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgICAgfSxcbiAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgICBlbWFpbDogJ3Rlc3RAZXhhbXBsZS5jb20nLFxuICAgICAgICAgICAgcGFzc3dvcmQ6ICd0ZXN0cGFzc3dvcmQxMjMnLFxuICAgICAgICAgIH0pLFxuICAgICAgICB9XG4gICAgICApO1xuXG4gICAgICBjb25zdCBsb2dpblJlc3BvbnNlID0gYXdhaXQgYXV0aFBPU1QobG9naW5SZXF1ZXN0KTtcbiAgICAgIGNvbnN0IGxvZ2luRGF0YSA9IGF3YWl0IGdldFJlc3BvbnNlRGF0YShsb2dpblJlc3BvbnNlKTtcblxuICAgICAgZXhwZWN0KGxvZ2luUmVzcG9uc2Uuc3RhdHVzKS50b0JlKDUwMCk7XG4gICAgICBleHBlY3QobG9naW5EYXRhLnN1Y2Nlc3MpLnRvQmUoZmFsc2UpO1xuICAgICAgZXhwZWN0KGxvZ2luRGF0YS5lcnJvcikudG9CZURlZmluZWQoKTtcbiAgICAgIGV4cGVjdChsb2dpbkRhdGEuZXJyb3IpLm5vdC50b0NvbnRhaW4oJ3NlY3JldDEyMycpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCByYXRlIGxpbWl0IGxvZ2luIGF0dGVtcHRzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgLy8gVGhpcyB0ZXN0IHdvdWxkIGJlIGltcGxlbWVudGVkIGlmIHJhdGUgbGltaXRpbmcgaXMgYWRkZWRcbiAgICAgIC8vIFNldCB1cCBtb2NrIGZvciBmYWlsZWQgYXV0aGVudGljYXRpb24gKHdyb25nIHBhc3N3b3JkKVxuICAgICAgY29uc3QgbW9ja1NpbmdsZSA9IFByb21pc2UucmVzb2x2ZSh7XG4gICAgICAgIGRhdGE6IHtcbiAgICAgICAgICBpZDogJ2FkbWluXzEyMycsXG4gICAgICAgICAgZW1haWw6ICd0ZXN0QGV4YW1wbGUuY29tJyxcbiAgICAgICAgICBuYW1lOiAnVGVzdCBBZG1pbicsXG4gICAgICAgICAgcm9sZTogJ3N1cGVyX2FkbWluJyxcbiAgICAgICAgICBwYXNzd29yZF9oYXNoOiAnaGFzaGVkX3Bhc3N3b3JkJyxcbiAgICAgICAgICBpc19hY3RpdmU6IHRydWUsXG4gICAgICAgICAgY3JlYXRlZF9hdDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxuICAgICAgICB9LFxuICAgICAgICBlcnJvcjogbnVsbCxcbiAgICAgIH0pO1xuXG4gICAgICBjb25zdCBtb2NrRXEgPSBqZXN0LmZuKCkubW9ja1JldHVyblZhbHVlKHtcbiAgICAgICAgc2luZ2xlOiAoKSA9PiBtb2NrU2luZ2xlLFxuICAgICAgfSk7XG5cbiAgICAgIGNvbnN0IG1vY2tTZWxlY3QgPSBqZXN0LmZuKCkubW9ja1JldHVyblZhbHVlKHtcbiAgICAgICAgZXE6IG1vY2tFcSxcbiAgICAgIH0pO1xuXG4gICAgICBtb2NrU3VwYWJhc2VDbGllbnQuZnJvbS5tb2NrUmV0dXJuVmFsdWUoe1xuICAgICAgICBzZWxlY3Q6IG1vY2tTZWxlY3QsXG4gICAgICB9KTtcblxuICAgICAgLy8gTW9jayBiY3J5cHQgdG8gcmV0dXJuIGZhbHNlICh3cm9uZyBwYXNzd29yZClcbiAgICAgIGJjcnlwdC5jb21wYXJlLm1vY2tSZXNvbHZlZFZhbHVlKGZhbHNlKTtcblxuICAgICAgY29uc3QgcmVxdWVzdHMgPSBBcnJheSgxMClcbiAgICAgICAgLmZpbGwobnVsbClcbiAgICAgICAgLm1hcChcbiAgICAgICAgICAoKSA9PlxuICAgICAgICAgICAgbmV3IE5leHRSZXF1ZXN0KCdodHRwOi8vbG9jYWxob3N0OjMwMDAvYXBpL2FkbWluL2F1dGgnLCB7XG4gICAgICAgICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICAgICAgICAgIGVtYWlsOiAndGVzdEBleGFtcGxlLmNvbScsXG4gICAgICAgICAgICAgICAgcGFzc3dvcmQ6ICd3cm9uZ3Bhc3N3b3JkJyxcbiAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICB9KVxuICAgICAgICApO1xuXG4gICAgICBjb25zdCByZXNwb25zZXMgPSBhd2FpdCBQcm9taXNlLmFsbChyZXF1ZXN0cy5tYXAocmVxID0+IGF1dGhQT1NUKHJlcSkpKTtcblxuICAgICAgLy8gQWxsIHJlcXVlc3RzIHNob3VsZCBiZSBoYW5kbGVkIChldmVuIGlmIHRoZXkgZmFpbClcbiAgICAgIHJlc3BvbnNlcy5mb3JFYWNoKHJlc3BvbnNlID0+IHtcbiAgICAgICAgZXhwZWN0KFs0MDAsIDQwMSwgNDI5XSkudG9Db250YWluKHJlc3BvbnNlLnN0YXR1cyk7XG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgdmFsaWRhdGUgdG9rZW4gc2lnbmF0dXJlJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgdG9rZW5XaXRoV3JvbmdTZWNyZXQgPSBqd3Quc2lnbihcbiAgICAgICAge1xuICAgICAgICAgIGFkbWluSWQ6ICdhZG1pbl90ZXN0QGV4YW1wbGUuY29tJyxcbiAgICAgICAgICBlbWFpbDogJ3Rlc3RAZXhhbXBsZS5jb20nLFxuICAgICAgICAgIHJvbGU6ICdzdXBlcl9hZG1pbicsXG4gICAgICAgIH0sXG4gICAgICAgICd3cm9uZy1zZWNyZXQnXG4gICAgICApO1xuXG4gICAgICBleHBlY3QoKCkgPT4ge1xuICAgICAgICBqd3QudmVyaWZ5KHRva2VuV2l0aFdyb25nU2VjcmV0LCBwcm9jZXNzLmVudi5KV1RfU0VDUkVUISk7XG4gICAgICB9KS50b1Rocm93KCdpbnZhbGlkIHNpZ25hdHVyZScpO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgnUGVyZm9ybWFuY2UgVGVzdHMnLCAoKSA9PiB7XG4gICAgaXQoJ3Nob3VsZCBoYW5kbGUgY29uY3VycmVudCBsb2dpbiByZXF1ZXN0cycsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IG1vY2tBZG1pbiA9IHtcbiAgICAgICAgaWQ6ICdhZG1pbl8xMjMnLFxuICAgICAgICBlbWFpbDogJ3Rlc3RAZXhhbXBsZS5jb20nLFxuICAgICAgICBuYW1lOiAnVGVzdCBBZG1pbicsXG4gICAgICAgIHJvbGU6ICdzdXBlcl9hZG1pbicsXG4gICAgICAgIHBhc3N3b3JkX2hhc2g6ICdoYXNoZWRfcGFzc3dvcmQnLFxuICAgICAgICBpc19hY3RpdmU6IHRydWUsXG4gICAgICAgIGNyZWF0ZWRfYXQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcbiAgICAgIH07XG5cbiAgICAgIGNvbnN0IG1vY2tTaW5nbGUgPSBQcm9taXNlLnJlc29sdmUoe1xuICAgICAgICBkYXRhOiBtb2NrQWRtaW4sXG4gICAgICAgIGVycm9yOiBudWxsLFxuICAgICAgfSk7XG5cbiAgICAgIGNvbnN0IG1vY2tFcSA9IGplc3QuZm4oKS5tb2NrUmV0dXJuVmFsdWUoe1xuICAgICAgICBzaW5nbGU6ICgpID0+IG1vY2tTaW5nbGUsXG4gICAgICB9KTtcblxuICAgICAgY29uc3QgbW9ja1NlbGVjdCA9IGplc3QuZm4oKS5tb2NrUmV0dXJuVmFsdWUoe1xuICAgICAgICBlcTogbW9ja0VxLFxuICAgICAgfSk7XG5cbiAgICAgIG1vY2tTdXBhYmFzZUNsaWVudC5mcm9tLm1vY2tSZXR1cm5WYWx1ZSh7XG4gICAgICAgIHNlbGVjdDogbW9ja1NlbGVjdCxcbiAgICAgICAgdXBkYXRlOiBqZXN0LmZuKCkubW9ja1JldHVyblZhbHVlKHtcbiAgICAgICAgICBlcTogamVzdC5mbigpLm1vY2tSZXNvbHZlZFZhbHVlKHsgZXJyb3I6IG51bGwgfSksXG4gICAgICAgIH0pLFxuICAgICAgfSk7XG5cbiAgICAgIGJjcnlwdC5jb21wYXJlLm1vY2tSZXNvbHZlZFZhbHVlKHRydWUpO1xuXG4gICAgICBjb25zdCByZXF1ZXN0cyA9IEFycmF5KDUpXG4gICAgICAgIC5maWxsKG51bGwpXG4gICAgICAgIC5tYXAoXG4gICAgICAgICAgKCkgPT5cbiAgICAgICAgICAgIG5ldyBOZXh0UmVxdWVzdCgnaHR0cDovL2xvY2FsaG9zdDozMDAwL2FwaS9hZG1pbi9hdXRoJywge1xuICAgICAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICAgICAgICBlbWFpbDogJ3Rlc3RAZXhhbXBsZS5jb20nLFxuICAgICAgICAgICAgICAgIHBhc3N3b3JkOiAndGVzdHBhc3N3b3JkMTIzJyxcbiAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICB9KVxuICAgICAgICApO1xuXG4gICAgICBjb25zdCBzdGFydFRpbWUgPSBEYXRlLm5vdygpO1xuICAgICAgY29uc3QgcmVzcG9uc2VzID0gYXdhaXQgUHJvbWlzZS5hbGwocmVxdWVzdHMubWFwKHJlcSA9PiBhdXRoUE9TVChyZXEpKSk7XG4gICAgICBjb25zdCBlbmRUaW1lID0gRGF0ZS5ub3coKTtcblxuICAgICAgLy8gQWxsIHJlcXVlc3RzIHNob3VsZCBiZSBoYW5kbGVkXG4gICAgICByZXNwb25zZXMuZm9yRWFjaChyZXNwb25zZSA9PiB7XG4gICAgICAgIGV4cGVjdChbMjAwLCA0MDAsIDQwMV0pLnRvQ29udGFpbihyZXNwb25zZS5zdGF0dXMpO1xuICAgICAgfSk7XG5cbiAgICAgIC8vIFNob3VsZCBjb21wbGV0ZSB3aXRoaW4gcmVhc29uYWJsZSB0aW1lICg1IHNlY29uZHMpXG4gICAgICBleHBlY3QoZW5kVGltZSAtIHN0YXJ0VGltZSkudG9CZUxlc3NUaGFuKDUwMDApO1xuICAgIH0pO1xuICB9KTtcbn0pO1xuIl0sIm5hbWVzIjpbImplc3QiLCJtb2NrIiwiYWN0dWFsIiwicmVxdWlyZUFjdHVhbCIsIk5leHRSZXNwb25zZSIsImpzb24iLCJib2R5IiwiaW5pdCIsInJlc3BvbnNlIiwiX2JvZHkiLCJKU09OIiwic3RyaW5naWZ5IiwibW9ja1N1cGFiYXNlQ2xpZW50IiwiZnJvbSIsImZuIiwiY3JlYXRlQ2xpZW50IiwiY29tcGFyZSIsImhhc2giLCJhZG1pbkNvbmZpZyIsInNlY3VyaXR5Iiwic2FsdFJvdW5kcyIsInNlc3Npb25UaW1lb3V0Iiwiand0Iiwic2VjcmV0IiwiZ2V0UmVzcG9uc2VEYXRhIiwidW5kZWZpbmVkIiwicGFyc2UiLCJkYXRhIiwiT2JqZWN0Iiwia2V5cyIsImxlbmd0aCIsImUiLCJ0ZXh0IiwiZGVzY3JpYmUiLCJiY3J5cHQiLCJyZXF1aXJlIiwiY29uc29sZUVycm9yU3B5IiwiYmVmb3JlRWFjaCIsImNsZWFyQWxsTW9ja3MiLCJtb2NrQ2xlYXIiLCJwcm9jZXNzIiwiZW52IiwiSldUX1NFQ1JFVCIsIk5FWFRfUFVCTElDX1NVUEFCQVNFX1VSTCIsIk5FWFRfUFVCTElDX1NVUEFCQVNFX0FOT05fS0VZIiwiU1VQQUJBU0VfU0VSVklDRV9ST0xFX0tFWSIsInNweU9uIiwiY29uc29sZSIsIm1vY2tJbXBsZW1lbnRhdGlvbiIsImFmdGVyRWFjaCIsIm1vY2tSZXN0b3JlIiwiaXQiLCJtb2NrQWRtaW4iLCJpZCIsImVtYWlsIiwibmFtZSIsInJvbGUiLCJwYXNzd29yZF9oYXNoIiwiaXNfYWN0aXZlIiwiY3JlYXRlZF9hdCIsIkRhdGUiLCJ0b0lTT1N0cmluZyIsIm1vY2tTaW5nbGUiLCJQcm9taXNlIiwicmVzb2x2ZSIsImVycm9yIiwibW9ja0VxIiwibW9ja1JldHVyblZhbHVlIiwic2luZ2xlIiwibW9ja1NlbGVjdCIsImVxIiwic2VsZWN0IiwidXBkYXRlIiwibW9ja1Jlc29sdmVkVmFsdWUiLCJsb2dpblJlcXVlc3QiLCJOZXh0UmVxdWVzdCIsIm1ldGhvZCIsImhlYWRlcnMiLCJwYXNzd29yZCIsImxvZ2luUmVzcG9uc2UiLCJhdXRoUE9TVCIsImxvZ2luRGF0YSIsImV4cGVjdCIsInN0YXR1cyIsInRvQmUiLCJzdWNjZXNzIiwiYWRtaW4iLCJ0b2tlbiIsInRvQmVEZWZpbmVkIiwiZXhwaXJlc0F0IiwiZGVjb2RlZCIsInZlcmlmeSIsImFkbWluSWQiLCJleHAiLCJleHBpcmF0aW9uVGltZSIsIm5vdyIsInR3ZW50eUZvdXJIb3VycyIsInRvQmVHcmVhdGVyVGhhbiIsInRvQmVMZXNzVGhhbiIsIm1lc3NhZ2UiLCJ0b0JlVW5kZWZpbmVkIiwiZXhwaXJlZFRva2VuIiwic2lnbiIsImlhdCIsIk1hdGgiLCJmbG9vciIsInRvVGhyb3ciLCJpbnZhbGlkVG9rZW4iLCJ2YWxpZFRva2VuIiwicmVqZWN0IiwiRXJyb3IiLCJub3QiLCJ0b0NvbnRhaW4iLCJyZXF1ZXN0cyIsIkFycmF5IiwiZmlsbCIsIm1hcCIsInJlc3BvbnNlcyIsImFsbCIsInJlcSIsImZvckVhY2giLCJ0b2tlbldpdGhXcm9uZ1NlY3JldCIsInN0YXJ0VGltZSIsImVuZFRpbWUiXSwibWFwcGluZ3MiOiJBQUFBLHFEQUFxRCxHQUNyRDs7Ozs7Ozs7O0NBU0M7QUFNRCw0REFBNEQ7QUFDNURBLEtBQUtDLElBQUksQ0FBQyxlQUFlO0lBQ3ZCLE1BQU1DLFNBQVNGLEtBQUtHLGFBQWEsQ0FBQztJQUNsQyxPQUFPO1FBQ0wsR0FBR0QsTUFBTTtRQUNURSxjQUFjO1lBQ1osR0FBR0YsT0FBT0UsWUFBWTtZQUN0QkMsTUFBTSxDQUFDQyxNQUFXQztnQkFDaEIsTUFBTUMsV0FBV04sT0FBT0UsWUFBWSxDQUFDQyxJQUFJLENBQUNDLE1BQU1DO2dCQUNoRCw2Q0FBNkM7Z0JBQzVDQyxT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