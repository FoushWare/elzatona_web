8c62c87b6ef649936658f2596300c816
/* eslint-disable @typescript-eslint/no-explicit-any */ /**
 * Admin Login API Tests
 *
 * Tests for the /api/admin/auth endpoint to ensure:
 * - Authentication works correctly
 * - Proper error handling
 * - JWT token generation
 * - Security measures
 */ "use strict";
// Mock NextResponse to ensure json() method works correctly
jest.mock('next/server', ()=>{
    const actual = jest.requireActual('next/server');
    return {
        ...actual,
        NextResponse: {
            ...actual.NextResponse,
            json: (body, init)=>{
                const response = actual.NextResponse.json(body, init);
                // Ensure _body is set for test compatibility
                response._body = JSON.stringify(body);
                return response;
            }
        }
    };
});
jest.mock('@supabase/supabase-js', ()=>{
    // Create the mock client inside the factory
    const client = {
        from: jest.fn()
    };
    return {
        createClient: jest.fn(()=>client)
    };
});
// Export the mock client so tests can configure it
// We'll get it from the mocked module
// Mock bcrypt
jest.mock('bcryptjs', ()=>({
        compare: jest.fn(),
        hash: jest.fn()
    }));
// Mock admin.config
jest.mock('@/admin.config', ()=>({
        adminConfig: {
            security: {
                saltRounds: 10,
                sessionTimeout: 24 * 60 * 60 * 1000
            },
            jwt: {
                secret: 'test-jwt-secret'
            }
        },
        getAdminApiUrl: jest.fn((path)=>`http://localhost:3000${path}`)
    }));
Object.defineProperty(exports, "__esModule", {
    value: true
});
const _server = require("next/server");
const _route = require("../../apps/website/src/app/api/admin/auth/route");
// Helper to extract JSON from NextResponse
async function getResponseData(response) {
    // NextResponse.json() stores data in response._body or response.body
    // Check all possible locations
    // Method 1: Try json() method
    try {
        const data = await response.json();
        if (data && typeof data === 'object' && Object.keys(data).length > 0) {
            return data;
        }
    } catch (e) {
    // Continue to other methods
    }
    // Method 2: Check internal _body property (NextResponse might use this)
    if (response._body !== undefined) {
        const body = response._body;
        if (typeof body === 'string') {
            try {
                return JSON.parse(body);
            } catch  {
                return {};
            }
        }
        if (body && typeof body === 'object') {
            return body;
        }
    }
    // Method 3: Try text() method
    try {
        const text = await response.text();
        if (text) {
            return JSON.parse(text);
        }
    } catch (e) {
    // Continue
    }
    // Method 4: Try body ReadableStream
    if (response.body) {
        try {
            const reader = response.body.getReader();
            const { value, done } = await reader.read();
            if (!done && value) {
                const text = new TextDecoder().decode(value);
                return JSON.parse(text);
            }
        } catch (e) {
        // Continue
        }
    }
    // Method 5: Check if response has data property directly
    if (response.data) {
        return response.data;
    }
    return {};
}
// Mock Supabase - this needs to be set up before the route module is imported
// The route handler creates the client at module load, so we need a shared instance
// Define the mock client inside the factory to avoid hoisting issues
const mockSupabaseClient = {
    from: jest.fn()
};
describe('Admin Login API', ()=>{
    // eslint-disable-next-line @typescript-eslint/no-require-imports
    const bcrypt = require('bcryptjs');
    // eslint-disable-next-line @typescript-eslint/no-require-imports
    const { createClient } = require('@supabase/supabase-js');
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    let mockSupabaseClient;
    beforeEach(()=>{
        jest.clearAllMocks();
        // Get the mock client instance (same one used by the route handler)
        mockSupabaseClient = createClient();
        // Reset the from mock for each test
        mockSupabaseClient.from.mockClear();
        // Set up environment variables
        process.env.JWT_SECRET = 'test-jwt-secret';
        process.env.NEXT_PUBLIC_SUPABASE_URL = 'https://test.supabase.co';
        process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY = 'test-anon-key';
        process.env.SUPABASE_SERVICE_ROLE_KEY = 'test-service-role-key';
    });
    afterEach(()=>{
        delete process.env.JWT_SECRET;
        delete process.env.NEXT_PUBLIC_SUPABASE_URL;
        delete process.env.SUPABASE_SERVICE_ROLE_KEY;
    });
    describe('POST /api/admin/auth', ()=>{
        it('should authenticate admin with valid credentials', async ()=>{
            // Mock Supabase response
            const mockAdmin = {
                id: 'admin_123',
                email: 'test@example.com',
                name: 'Test Admin',
                role: 'super_admin',
                password_hash: 'hashed_password',
                is_active: true,
                created_at: new Date().toISOString()
            };
            const mockSingle = Promise.resolve({
                data: mockAdmin,
                error: null
            });
            const mockEq = jest.fn().mockReturnValue({
                single: ()=>mockSingle
            });
            const mockSelect = jest.fn().mockReturnValue({
                eq: mockEq
            });
            mockSupabaseClient.from.mockReturnValue({
                select: mockSelect,
                update: jest.fn().mockReturnValue({
                    eq: jest.fn().mockResolvedValue({
                        error: null
                    })
                })
            });
            // Mock bcrypt compare
            bcrypt.compare.mockResolvedValue(true);
            const request = new _server.NextRequest('http://localhost:3000/api/admin/auth', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    email: 'test@example.com',
                    password: 'testpassword123'
                })
            });
            const response = await (0, _route.POST)(request);
            const data = await getResponseData(response);
            expect(response.status).toBe(200);
            expect(data).toBeDefined();
            expect(data.success).toBe(true);
            expect(data.admin).toBeDefined();
            expect(data.admin.email).toBe(mockAdmin.email);
            expect(data.admin.token).toBeDefined();
            expect(data.admin.token).toMatch(/^[A-Za-z0-9-_]+\.[A-Za-z0-9-_]+\.[A-Za-z0-9-_]+$/);
        });
        it('should reject authentication with invalid credentials', async ()=>{
            // Mock Supabase - admin not found
            const mockSingle = jest.fn().mockResolvedValue({
                data: null,
                error: {
                    message: 'Not found'
                }
            });
            mockSupabaseClient.from.mockReturnValue({
                select: jest.fn().mockReturnValue({
                    eq: jest.fn().mockReturnValue({
                        single: mockSingle
                    })
                })
            });
            const request = new _server.NextRequest('http://localhost:3000/api/admin/auth', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    email: 'test@example.com',
                    password: 'wrongpassword'
                })
            });
            const response = await (0, _route.POST)(request);
            const data = await getResponseData(response);
            expect(response.status).toBe(401);
            expect(data.success).toBe(false);
            expect(data.error).toBe('Invalid email or password');
        });
        it('should reject authentication with wrong password', async ()=>{
            // Mock Supabase - admin found but wrong password
            const mockAdmin = {
                id: 'admin_123',
                email: 'test@example.com',
                password_hash: 'hashed_password',
                is_active: true
            };
            const mockSingle = Promise.resolve({
                data: mockAdmin,
                error: null
            });
            const mockEq = jest.fn().mockReturnValue({
                single: ()=>mockSingle
            });
            const mockSelect = jest.fn().mockReturnValue({
                eq: mockEq
            });
            mockSupabaseClient.from.mockReturnValue({
                select: mockSelect
            });
            // Mock bcrypt compare - wrong password
            bcrypt.compare.mockResolvedValue(false);
            const request = new _server.NextRequest('http://localhost:3000/api/admin/auth', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    email: 'test@example.com',
                    password: 'wrongpassword'
                })
            });
            const response = await (0, _route.POST)(request);
            const data = await getResponseData(response);
            expect(response.status).toBe(401);
            expect(data.success).toBe(false);
            expect(data.error).toBe('Invalid email or password');
        });
        it('should reject authentication with missing email', async ()=>{
            const request = new _server.NextRequest('http://localhost:3000/api/admin/auth', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    password: 'testpassword123'
                })
            });
            const response = await (0, _route.POST)(request);
            const data = await getResponseData(response);
            expect(response.status).toBe(400);
            expect(data.success).toBe(false);
            expect(data.error).toBe('Email and password are required');
        });
        it('should reject authentication with missing password', async ()=>{
            const request = new _server.NextRequest('http://localhost:3000/api/admin/auth', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    email: 'test@example.com'
                })
            });
            const response = await (0, _route.POST)(request);
            const data = await getResponseData(response);
            expect(response.status).toBe(400);
            expect(data.success).toBe(false);
            expect(data.error).toBe('Email and password are required');
        });
        it('should handle server errors gracefully', async ()=>{
            // Mock Supabase error
            const mockSingle = Promise.reject(new Error('Database connection failed'));
            const mockEq = jest.fn().mockReturnValue({
                single: ()=>mockSingle
            });
            const mockSelect = jest.fn().mockReturnValue({
                eq: mockEq
            });
            mockSupabaseClient.from.mockReturnValue({
                select: mockSelect
            });
            const request = new _server.NextRequest('http://localhost:3000/api/admin/auth', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    email: 'test@example.com',
                    password: 'testpassword123'
                })
            });
            const response = await (0, _route.POST)(request);
            const data = await getResponseData(response);
            expect(response.status).toBe(500);
            expect(data.success).toBe(false);
            expect(data.error).toBeDefined();
        });
        it('should handle requests without Content-Type header', async ()=>{
            // Mock Supabase - admin not found
            const mockSingle = Promise.resolve({
                data: null,
                error: {
                    message: 'Not found'
                }
            });
            const mockEq = jest.fn().mockReturnValue({
                single: ()=>mockSingle
            });
            const mockSelect = jest.fn().mockReturnValue({
                eq: mockEq
            });
            mockSupabaseClient.from.mockReturnValue({
                select: mockSelect
            });
            const request = new _server.NextRequest('http://localhost:3000/api/admin/auth', {
                method: 'POST',
                body: JSON.stringify({
                    email: 'test@example.com',
                    password: 'testpassword123'
                })
            });
            const response = await (0, _route.POST)(request);
            const data = await getResponseData(response);
            // The route should still process the request if body is valid JSON
            // It will fail authentication (401) since admin is not found
            expect(response.status).toBe(401);
            expect(data.success).toBe(false);
        });
        it('should generate JWT token with correct expiration', async ()=>{
            const mockAdmin = {
                id: 'admin_123',
                email: 'test@example.com',
                name: 'Test Admin',
                role: 'super_admin',
                password_hash: 'hashed_password',
                is_active: true,
                created_at: new Date().toISOString()
            };
            const mockSingle = Promise.resolve({
                data: mockAdmin,
                error: null
            });
            const mockEq = jest.fn().mockReturnValue({
                single: ()=>mockSingle
            });
            const mockSelect = jest.fn().mockReturnValue({
                eq: mockEq
            });
            mockSupabaseClient.from.mockReturnValue({
                select: mockSelect,
                update: jest.fn().mockReturnValue({
                    eq: jest.fn().mockResolvedValue({
                        error: null
                    })
                })
            });
            bcrypt.compare.mockResolvedValue(true);
            const request = new _server.NextRequest('http://localhost:3000/api/admin/auth', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    email: 'test@example.com',
                    password: 'testpassword123'
                })
            });
            const response = await (0, _route.POST)(request);
            const data = await getResponseData(response);
            expect(response.status).toBe(200);
            expect(data.admin.token).toBeDefined();
            expect(data.admin.expiresAt).toBeDefined();
            // Check that expiration is in the future
            const expirationDate = new Date(data.admin.expiresAt);
            const now = new Date();
            expect(expirationDate.getTime()).toBeGreaterThan(now.getTime());
        });
        it('should handle multiple requests', async ()=>{
            // Mock Supabase - admin not found for all requests
            const mockSingle = Promise.resolve({
                data: null,
                error: {
                    message: 'Not found'
                }
            });
            const mockEq = jest.fn().mockReturnValue({
                single: ()=>mockSingle
            });
            const mockSelect = jest.fn().mockReturnValue({
                eq: mockEq
            });
            mockSupabaseClient.from.mockReturnValue({
                select: mockSelect
            });
            const requests = Array(5).fill(null).map(()=>new _server.NextRequest('http://localhost:3000/api/admin/auth', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        email: 'test@example.com',
                        password: 'wrongpassword'
                    })
                }));
            const responses = await Promise.all(requests.map((req)=>(0, _route.POST)(req)));
            // All requests should be handled (even if they fail)
            responses.forEach((response)=>{
                expect([
                    400,
                    401
                ]).toContain(response.status);
            });
        });
    });
});

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9hLmZvdWFkL1NpZGVQcm9qZWN0cy9FbHphdG9uYS1hbGwvRWx6YXRvbmEtd2ViL3Rlc3RzL2FkbWluL2FkbWluLWxvZ2luLWFwaS50ZXN0LnRzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIGVzbGludC1kaXNhYmxlIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnkgKi9cbi8qKlxuICogQWRtaW4gTG9naW4gQVBJIFRlc3RzXG4gKlxuICogVGVzdHMgZm9yIHRoZSAvYXBpL2FkbWluL2F1dGggZW5kcG9pbnQgdG8gZW5zdXJlOlxuICogLSBBdXRoZW50aWNhdGlvbiB3b3JrcyBjb3JyZWN0bHlcbiAqIC0gUHJvcGVyIGVycm9yIGhhbmRsaW5nXG4gKiAtIEpXVCB0b2tlbiBnZW5lcmF0aW9uXG4gKiAtIFNlY3VyaXR5IG1lYXN1cmVzXG4gKi9cblxuaW1wb3J0IHsgTmV4dFJlcXVlc3QsIE5leHRSZXNwb25zZSB9IGZyb20gJ25leHQvc2VydmVyJztcbmltcG9ydCB7IFBPU1QgfSBmcm9tICdAL2FwcC9hcGkvYWRtaW4vYXV0aC9yb3V0ZSc7XG5cbi8vIE1vY2sgTmV4dFJlc3BvbnNlIHRvIGVuc3VyZSBqc29uKCkgbWV0aG9kIHdvcmtzIGNvcnJlY3RseVxuamVzdC5tb2NrKCduZXh0L3NlcnZlcicsICgpID0+IHtcbiAgY29uc3QgYWN0dWFsID0gamVzdC5yZXF1aXJlQWN0dWFsKCduZXh0L3NlcnZlcicpO1xuICByZXR1cm4ge1xuICAgIC4uLmFjdHVhbCxcbiAgICBOZXh0UmVzcG9uc2U6IHtcbiAgICAgIC4uLmFjdHVhbC5OZXh0UmVzcG9uc2UsXG4gICAgICBqc29uOiAoYm9keTogYW55LCBpbml0PzogYW55KSA9PiB7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYWN0dWFsLk5leHRSZXNwb25zZS5qc29uKGJvZHksIGluaXQpO1xuICAgICAgICAvLyBFbnN1cmUgX2JvZHkgaXMgc2V0IGZvciB0ZXN0IGNvbXBhdGliaWxpdHlcbiAgICAgICAgKHJlc3BvbnNlIGFzIGFueSkuX2JvZHkgPSBKU09OLnN0cmluZ2lmeShib2R5KTtcbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgICAgfSxcbiAgICB9LFxuICB9O1xufSk7XG5cbi8vIEhlbHBlciB0byBleHRyYWN0IEpTT04gZnJvbSBOZXh0UmVzcG9uc2VcbmFzeW5jIGZ1bmN0aW9uIGdldFJlc3BvbnNlRGF0YShyZXNwb25zZTogYW55KTogUHJvbWlzZTxhbnk+IHtcbiAgLy8gTmV4dFJlc3BvbnNlLmpzb24oKSBzdG9yZXMgZGF0YSBpbiByZXNwb25zZS5fYm9keSBvciByZXNwb25zZS5ib2R5XG4gIC8vIENoZWNrIGFsbCBwb3NzaWJsZSBsb2NhdGlvbnNcblxuICAvLyBNZXRob2QgMTogVHJ5IGpzb24oKSBtZXRob2RcbiAgdHJ5IHtcbiAgICBjb25zdCBkYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgIGlmIChkYXRhICYmIHR5cGVvZiBkYXRhID09PSAnb2JqZWN0JyAmJiBPYmplY3Qua2V5cyhkYXRhKS5sZW5ndGggPiAwKSB7XG4gICAgICByZXR1cm4gZGF0YTtcbiAgICB9XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICAvLyBDb250aW51ZSB0byBvdGhlciBtZXRob2RzXG4gIH1cblxuICAvLyBNZXRob2QgMjogQ2hlY2sgaW50ZXJuYWwgX2JvZHkgcHJvcGVydHkgKE5leHRSZXNwb25zZSBtaWdodCB1c2UgdGhpcylcbiAgaWYgKChyZXNwb25zZSBhcyBhbnkpLl9ib2R5ICE9PSB1bmRlZmluZWQpIHtcbiAgICBjb25zdCBib2R5ID0gKHJlc3BvbnNlIGFzIGFueSkuX2JvZHk7XG4gICAgaWYgKHR5cGVvZiBib2R5ID09PSAnc3RyaW5nJykge1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIEpTT04ucGFyc2UoYm9keSk7XG4gICAgICB9IGNhdGNoIHtcbiAgICAgICAgcmV0dXJuIHt9O1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoYm9keSAmJiB0eXBlb2YgYm9keSA9PT0gJ29iamVjdCcpIHtcbiAgICAgIHJldHVybiBib2R5O1xuICAgIH1cbiAgfVxuXG4gIC8vIE1ldGhvZCAzOiBUcnkgdGV4dCgpIG1ldGhvZFxuICB0cnkge1xuICAgIGNvbnN0IHRleHQgPSBhd2FpdCByZXNwb25zZS50ZXh0KCk7XG4gICAgaWYgKHRleHQpIHtcbiAgICAgIHJldHVybiBKU09OLnBhcnNlKHRleHQpO1xuICAgIH1cbiAgfSBjYXRjaCAoZSkge1xuICAgIC8vIENvbnRpbnVlXG4gIH1cblxuICAvLyBNZXRob2QgNDogVHJ5IGJvZHkgUmVhZGFibGVTdHJlYW1cbiAgaWYgKHJlc3BvbnNlLmJvZHkpIHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgcmVhZGVyID0gcmVzcG9uc2UuYm9keS5nZXRSZWFkZXIoKTtcbiAgICAgIGNvbnN0IHsgdmFsdWUsIGRvbmUgfSA9IGF3YWl0IHJlYWRlci5yZWFkKCk7XG4gICAgICBpZiAoIWRvbmUgJiYgdmFsdWUpIHtcbiAgICAgICAgY29uc3QgdGV4dCA9IG5ldyBUZXh0RGVjb2RlcigpLmRlY29kZSh2YWx1ZSk7XG4gICAgICAgIHJldHVybiBKU09OLnBhcnNlKHRleHQpO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIC8vIENvbnRpbnVlXG4gICAgfVxuICB9XG5cbiAgLy8gTWV0aG9kIDU6IENoZWNrIGlmIHJlc3BvbnNlIGhhcyBkYXRhIHByb3BlcnR5IGRpcmVjdGx5XG4gIGlmICgocmVzcG9uc2UgYXMgYW55KS5kYXRhKSB7XG4gICAgcmV0dXJuIChyZXNwb25zZSBhcyBhbnkpLmRhdGE7XG4gIH1cblxuICByZXR1cm4ge307XG59XG5cbi8vIE1vY2sgU3VwYWJhc2UgLSB0aGlzIG5lZWRzIHRvIGJlIHNldCB1cCBiZWZvcmUgdGhlIHJvdXRlIG1vZHVsZSBpcyBpbXBvcnRlZFxuLy8gVGhlIHJvdXRlIGhhbmRsZXIgY3JlYXRlcyB0aGUgY2xpZW50IGF0IG1vZHVsZSBsb2FkLCBzbyB3ZSBuZWVkIGEgc2hhcmVkIGluc3RhbmNlXG4vLyBEZWZpbmUgdGhlIG1vY2sgY2xpZW50IGluc2lkZSB0aGUgZmFjdG9yeSB0byBhdm9pZCBob2lzdGluZyBpc3N1ZXNcbmNvbnN0IG1vY2tTdXBhYmFzZUNsaWVudCA9IHtcbiAgZnJvbTogamVzdC5mbigpLFxufTtcblxuamVzdC5tb2NrKCdAc3VwYWJhc2Uvc3VwYWJhc2UtanMnLCAoKSA9PiB7XG4gIC8vIENyZWF0ZSB0aGUgbW9jayBjbGllbnQgaW5zaWRlIHRoZSBmYWN0b3J5XG4gIGNvbnN0IGNsaWVudCA9IHtcbiAgICBmcm9tOiBqZXN0LmZuKCksXG4gIH07XG4gIHJldHVybiB7XG4gICAgY3JlYXRlQ2xpZW50OiBqZXN0LmZuKCgpID0+IGNsaWVudCksXG4gIH07XG59KTtcblxuLy8gRXhwb3J0IHRoZSBtb2NrIGNsaWVudCBzbyB0ZXN0cyBjYW4gY29uZmlndXJlIGl0XG4vLyBXZSdsbCBnZXQgaXQgZnJvbSB0aGUgbW9ja2VkIG1vZHVsZVxuXG4vLyBNb2NrIGJjcnlwdFxuamVzdC5tb2NrKCdiY3J5cHRqcycsICgpID0+ICh7XG4gIGNvbXBhcmU6IGplc3QuZm4oKSxcbiAgaGFzaDogamVzdC5mbigpLFxufSkpO1xuXG4vLyBNb2NrIGFkbWluLmNvbmZpZ1xuamVzdC5tb2NrKCdAL2FkbWluLmNvbmZpZycsICgpID0+ICh7XG4gIGFkbWluQ29uZmlnOiB7XG4gICAgc2VjdXJpdHk6IHtcbiAgICAgIHNhbHRSb3VuZHM6IDEwLFxuICAgICAgc2Vzc2lvblRpbWVvdXQ6IDI0ICogNjAgKiA2MCAqIDEwMDAsIC8vIDI0IGhvdXJzXG4gICAgfSxcbiAgICBqd3Q6IHtcbiAgICAgIHNlY3JldDogJ3Rlc3Qtand0LXNlY3JldCcsXG4gICAgfSxcbiAgfSxcbiAgZ2V0QWRtaW5BcGlVcmw6IGplc3QuZm4oKHBhdGg6IHN0cmluZykgPT4gYGh0dHA6Ly9sb2NhbGhvc3Q6MzAwMCR7cGF0aH1gKSxcbn0pKTtcblxuZGVzY3JpYmUoJ0FkbWluIExvZ2luIEFQSScsICgpID0+IHtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1yZXF1aXJlLWltcG9ydHNcbiAgY29uc3QgYmNyeXB0ID0gcmVxdWlyZSgnYmNyeXB0anMnKTtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1yZXF1aXJlLWltcG9ydHNcbiAgY29uc3QgeyBjcmVhdGVDbGllbnQgfSA9IHJlcXVpcmUoJ0BzdXBhYmFzZS9zdXBhYmFzZS1qcycpO1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICBsZXQgbW9ja1N1cGFiYXNlQ2xpZW50OiBhbnk7XG5cbiAgYmVmb3JlRWFjaCgoKSA9PiB7XG4gICAgamVzdC5jbGVhckFsbE1vY2tzKCk7XG4gICAgLy8gR2V0IHRoZSBtb2NrIGNsaWVudCBpbnN0YW5jZSAoc2FtZSBvbmUgdXNlZCBieSB0aGUgcm91dGUgaGFuZGxlcilcbiAgICBtb2NrU3VwYWJhc2VDbGllbnQgPSBjcmVhdGVDbGllbnQoKTtcbiAgICAvLyBSZXNldCB0aGUgZnJvbSBtb2NrIGZvciBlYWNoIHRlc3RcbiAgICBtb2NrU3VwYWJhc2VDbGllbnQuZnJvbS5tb2NrQ2xlYXIoKTtcbiAgICAvLyBTZXQgdXAgZW52aXJvbm1lbnQgdmFyaWFibGVzXG4gICAgcHJvY2Vzcy5lbnYuSldUX1NFQ1JFVCA9ICd0ZXN0LWp3dC1zZWNyZXQnO1xuICAgIHByb2Nlc3MuZW52Lk5FWFRfUFVCTElDX1NVUEFCQVNFX1VSTCA9ICdodHRwczovL3Rlc3Quc3VwYWJhc2UuY28nO1xuICAgIHByb2Nlc3MuZW52Lk5FWFRfUFVCTElDX1NVUEFCQVNFX0FOT05fS0VZID0gJ3Rlc3QtYW5vbi1rZXknO1xuICAgIHByb2Nlc3MuZW52LlNVUEFCQVNFX1NFUlZJQ0VfUk9MRV9LRVkgPSAndGVzdC1zZXJ2aWNlLXJvbGUta2V5JztcbiAgfSk7XG5cbiAgYWZ0ZXJFYWNoKCgpID0+IHtcbiAgICBkZWxldGUgcHJvY2Vzcy5lbnYuSldUX1NFQ1JFVDtcbiAgICBkZWxldGUgcHJvY2Vzcy5lbnYuTkVYVF9QVUJMSUNfU1VQQUJBU0VfVVJMO1xuICAgIGRlbGV0ZSBwcm9jZXNzLmVudi5TVVBBQkFTRV9TRVJWSUNFX1JPTEVfS0VZO1xuICB9KTtcblxuICBkZXNjcmliZSgnUE9TVCAvYXBpL2FkbWluL2F1dGgnLCAoKSA9PiB7XG4gICAgaXQoJ3Nob3VsZCBhdXRoZW50aWNhdGUgYWRtaW4gd2l0aCB2YWxpZCBjcmVkZW50aWFscycsIGFzeW5jICgpID0+IHtcbiAgICAgIC8vIE1vY2sgU3VwYWJhc2UgcmVzcG9uc2VcbiAgICAgIGNvbnN0IG1vY2tBZG1pbiA9IHtcbiAgICAgICAgaWQ6ICdhZG1pbl8xMjMnLFxuICAgICAgICBlbWFpbDogJ3Rlc3RAZXhhbXBsZS5jb20nLFxuICAgICAgICBuYW1lOiAnVGVzdCBBZG1pbicsXG4gICAgICAgIHJvbGU6ICdzdXBlcl9hZG1pbicsXG4gICAgICAgIHBhc3N3b3JkX2hhc2g6ICdoYXNoZWRfcGFzc3dvcmQnLFxuICAgICAgICBpc19hY3RpdmU6IHRydWUsXG4gICAgICAgIGNyZWF0ZWRfYXQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcbiAgICAgIH07XG5cbiAgICAgIGNvbnN0IG1vY2tTaW5nbGUgPSBQcm9taXNlLnJlc29sdmUoe1xuICAgICAgICBkYXRhOiBtb2NrQWRtaW4sXG4gICAgICAgIGVycm9yOiBudWxsLFxuICAgICAgfSk7XG5cbiAgICAgIGNvbnN0IG1vY2tFcSA9IGplc3QuZm4oKS5tb2NrUmV0dXJuVmFsdWUoe1xuICAgICAgICBzaW5nbGU6ICgpID0+IG1vY2tTaW5nbGUsXG4gICAgICB9KTtcblxuICAgICAgY29uc3QgbW9ja1NlbGVjdCA9IGplc3QuZm4oKS5tb2NrUmV0dXJuVmFsdWUoe1xuICAgICAgICBlcTogbW9ja0VxLFxuICAgICAgfSk7XG5cbiAgICAgIG1vY2tTdXBhYmFzZUNsaWVudC5mcm9tLm1vY2tSZXR1cm5WYWx1ZSh7XG4gICAgICAgIHNlbGVjdDogbW9ja1NlbGVjdCxcbiAgICAgICAgdXBkYXRlOiBqZXN0LmZuKCkubW9ja1JldHVyblZhbHVlKHtcbiAgICAgICAgICBlcTogamVzdC5mbigpLm1vY2tSZXNvbHZlZFZhbHVlKHsgZXJyb3I6IG51bGwgfSksXG4gICAgICAgIH0pLFxuICAgICAgfSk7XG5cbiAgICAgIC8vIE1vY2sgYmNyeXB0IGNvbXBhcmVcbiAgICAgIGJjcnlwdC5jb21wYXJlLm1vY2tSZXNvbHZlZFZhbHVlKHRydWUpO1xuXG4gICAgICBjb25zdCByZXF1ZXN0ID0gbmV3IE5leHRSZXF1ZXN0KCdodHRwOi8vbG9jYWxob3N0OjMwMDAvYXBpL2FkbWluL2F1dGgnLCB7XG4gICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgfSxcbiAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICAgIGVtYWlsOiAndGVzdEBleGFtcGxlLmNvbScsXG4gICAgICAgICAgcGFzc3dvcmQ6ICd0ZXN0cGFzc3dvcmQxMjMnLFxuICAgICAgICB9KSxcbiAgICAgIH0pO1xuXG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IFBPU1QocmVxdWVzdCk7XG4gICAgICBjb25zdCBkYXRhID0gYXdhaXQgZ2V0UmVzcG9uc2VEYXRhKHJlc3BvbnNlKTtcblxuICAgICAgZXhwZWN0KHJlc3BvbnNlLnN0YXR1cykudG9CZSgyMDApO1xuICAgICAgZXhwZWN0KGRhdGEpLnRvQmVEZWZpbmVkKCk7XG4gICAgICBleHBlY3QoZGF0YS5zdWNjZXNzKS50b0JlKHRydWUpO1xuICAgICAgZXhwZWN0KGRhdGEuYWRtaW4pLnRvQmVEZWZpbmVkKCk7XG4gICAgICBleHBlY3QoZGF0YS5hZG1pbi5lbWFpbCkudG9CZShtb2NrQWRtaW4uZW1haWwpO1xuICAgICAgZXhwZWN0KGRhdGEuYWRtaW4udG9rZW4pLnRvQmVEZWZpbmVkKCk7XG4gICAgICBleHBlY3QoZGF0YS5hZG1pbi50b2tlbikudG9NYXRjaChcbiAgICAgICAgL15bQS1aYS16MC05LV9dK1xcLltBLVphLXowLTktX10rXFwuW0EtWmEtejAtOS1fXSskL1xuICAgICAgKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgcmVqZWN0IGF1dGhlbnRpY2F0aW9uIHdpdGggaW52YWxpZCBjcmVkZW50aWFscycsIGFzeW5jICgpID0+IHtcbiAgICAgIC8vIE1vY2sgU3VwYWJhc2UgLSBhZG1pbiBub3QgZm91bmRcbiAgICAgIGNvbnN0IG1vY2tTaW5nbGUgPSBqZXN0LmZuKCkubW9ja1Jlc29sdmVkVmFsdWUoe1xuICAgICAgICBkYXRhOiBudWxsLFxuICAgICAgICBlcnJvcjogeyBtZXNzYWdlOiAnTm90IGZvdW5kJyB9LFxuICAgICAgfSk7XG5cbiAgICAgIG1vY2tTdXBhYmFzZUNsaWVudC5mcm9tLm1vY2tSZXR1cm5WYWx1ZSh7XG4gICAgICAgIHNlbGVjdDogamVzdC5mbigpLm1vY2tSZXR1cm5WYWx1ZSh7XG4gICAgICAgICAgZXE6IGplc3QuZm4oKS5tb2NrUmV0dXJuVmFsdWUoe1xuICAgICAgICAgICAgc2luZ2xlOiBtb2NrU2luZ2xlLFxuICAgICAgICAgIH0pLFxuICAgICAgICB9KSxcbiAgICAgIH0pO1xuXG4gICAgICBjb25zdCByZXF1ZXN0ID0gbmV3IE5leHRSZXF1ZXN0KCdodHRwOi8vbG9jYWxob3N0OjMwMDAvYXBpL2FkbWluL2F1dGgnLCB7XG4gICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgfSxcbiAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICAgIGVtYWlsOiAndGVzdEBleGFtcGxlLmNvbScsXG4gICAgICAgICAgcGFzc3dvcmQ6ICd3cm9uZ3Bhc3N3b3JkJyxcbiAgICAgICAgfSksXG4gICAgICB9KTtcblxuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBQT1NUKHJlcXVlc3QpO1xuICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IGdldFJlc3BvbnNlRGF0YShyZXNwb25zZSk7XG5cbiAgICAgIGV4cGVjdChyZXNwb25zZS5zdGF0dXMpLnRvQmUoNDAxKTtcbiAgICAgIGV4cGVjdChkYXRhLnN1Y2Nlc3MpLnRvQmUoZmFsc2UpO1xuICAgICAgZXhwZWN0KGRhdGEuZXJyb3IpLnRvQmUoJ0ludmFsaWQgZW1haWwgb3IgcGFzc3dvcmQnKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgcmVqZWN0IGF1dGhlbnRpY2F0aW9uIHdpdGggd3JvbmcgcGFzc3dvcmQnLCBhc3luYyAoKSA9PiB7XG4gICAgICAvLyBNb2NrIFN1cGFiYXNlIC0gYWRtaW4gZm91bmQgYnV0IHdyb25nIHBhc3N3b3JkXG4gICAgICBjb25zdCBtb2NrQWRtaW4gPSB7XG4gICAgICAgIGlkOiAnYWRtaW5fMTIzJyxcbiAgICAgICAgZW1haWw6ICd0ZXN0QGV4YW1wbGUuY29tJyxcbiAgICAgICAgcGFzc3dvcmRfaGFzaDogJ2hhc2hlZF9wYXNzd29yZCcsXG4gICAgICAgIGlzX2FjdGl2ZTogdHJ1ZSxcbiAgICAgIH07XG5cbiAgICAgIGNvbnN0IG1vY2tTaW5nbGUgPSBQcm9taXNlLnJlc29sdmUoe1xuICAgICAgICBkYXRhOiBtb2NrQWRtaW4sXG4gICAgICAgIGVycm9yOiBudWxsLFxuICAgICAgfSk7XG5cbiAgICAgIGNvbnN0IG1vY2tFcSA9IGplc3QuZm4oKS5tb2NrUmV0dXJuVmFsdWUoe1xuICAgICAgICBzaW5nbGU6ICgpID0+IG1vY2tTaW5nbGUsXG4gICAgICB9KTtcblxuICAgICAgY29uc3QgbW9ja1NlbGVjdCA9IGplc3QuZm4oKS5tb2NrUmV0dXJuVmFsdWUoe1xuICAgICAgICBlcTogbW9ja0VxLFxuICAgICAgfSk7XG5cbiAgICAgIG1vY2tTdXBhYmFzZUNsaWVudC5mcm9tLm1vY2tSZXR1cm5WYWx1ZSh7XG4gICAgICAgIHNlbGVjdDogbW9ja1NlbGVjdCxcbiAgICAgIH0pO1xuXG4gICAgICAvLyBNb2NrIGJjcnlwdCBjb21wYXJlIC0gd3JvbmcgcGFzc3dvcmRcbiAgICAgIGJjcnlwdC5jb21wYXJlLm1vY2tSZXNvbHZlZFZhbHVlKGZhbHNlKTtcblxuICAgICAgY29uc3QgcmVxdWVzdCA9IG5ldyBOZXh0UmVxdWVzdCgnaHR0cDovL2xvY2FsaG9zdDozMDAwL2FwaS9hZG1pbi9hdXRoJywge1xuICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgIH0sXG4gICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICBlbWFpbDogJ3Rlc3RAZXhhbXBsZS5jb20nLFxuICAgICAgICAgIHBhc3N3b3JkOiAnd3JvbmdwYXNzd29yZCcsXG4gICAgICAgIH0pLFxuICAgICAgfSk7XG5cbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgUE9TVChyZXF1ZXN0KTtcbiAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCBnZXRSZXNwb25zZURhdGEocmVzcG9uc2UpO1xuXG4gICAgICBleHBlY3QocmVzcG9uc2Uuc3RhdHVzKS50b0JlKDQwMSk7XG4gICAgICBleHBlY3QoZGF0YS5zdWNjZXNzKS50b0JlKGZhbHNlKTtcbiAgICAgIGV4cGVjdChkYXRhLmVycm9yKS50b0JlKCdJbnZhbGlkIGVtYWlsIG9yIHBhc3N3b3JkJyk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIHJlamVjdCBhdXRoZW50aWNhdGlvbiB3aXRoIG1pc3NpbmcgZW1haWwnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCByZXF1ZXN0ID0gbmV3IE5leHRSZXF1ZXN0KCdodHRwOi8vbG9jYWxob3N0OjMwMDAvYXBpL2FkbWluL2F1dGgnLCB7XG4gICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgfSxcbiAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICAgIHBhc3N3b3JkOiAndGVzdHBhc3N3b3JkMTIzJyxcbiAgICAgICAgfSksXG4gICAgICB9KTtcblxuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBQT1NUKHJlcXVlc3QpO1xuICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IGdldFJlc3BvbnNlRGF0YShyZXNwb25zZSk7XG5cbiAgICAgIGV4cGVjdChyZXNwb25zZS5zdGF0dXMpLnRvQmUoNDAwKTtcbiAgICAgIGV4cGVjdChkYXRhLnN1Y2Nlc3MpLnRvQmUoZmFsc2UpO1xuICAgICAgZXhwZWN0KGRhdGEuZXJyb3IpLnRvQmUoJ0VtYWlsIGFuZCBwYXNzd29yZCBhcmUgcmVxdWlyZWQnKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgcmVqZWN0IGF1dGhlbnRpY2F0aW9uIHdpdGggbWlzc2luZyBwYXNzd29yZCcsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IHJlcXVlc3QgPSBuZXcgTmV4dFJlcXVlc3QoJ2h0dHA6Ly9sb2NhbGhvc3Q6MzAwMC9hcGkvYWRtaW4vYXV0aCcsIHtcbiAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICB9LFxuICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgZW1haWw6ICd0ZXN0QGV4YW1wbGUuY29tJyxcbiAgICAgICAgfSksXG4gICAgICB9KTtcblxuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBQT1NUKHJlcXVlc3QpO1xuICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IGdldFJlc3BvbnNlRGF0YShyZXNwb25zZSk7XG5cbiAgICAgIGV4cGVjdChyZXNwb25zZS5zdGF0dXMpLnRvQmUoNDAwKTtcbiAgICAgIGV4cGVjdChkYXRhLnN1Y2Nlc3MpLnRvQmUoZmFsc2UpO1xuICAgICAgZXhwZWN0KGRhdGEuZXJyb3IpLnRvQmUoJ0VtYWlsIGFuZCBwYXNzd29yZCBhcmUgcmVxdWlyZWQnKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgaGFuZGxlIHNlcnZlciBlcnJvcnMgZ3JhY2VmdWxseScsIGFzeW5jICgpID0+IHtcbiAgICAgIC8vIE1vY2sgU3VwYWJhc2UgZXJyb3JcbiAgICAgIGNvbnN0IG1vY2tTaW5nbGUgPSBQcm9taXNlLnJlamVjdChcbiAgICAgICAgbmV3IEVycm9yKCdEYXRhYmFzZSBjb25uZWN0aW9uIGZhaWxlZCcpXG4gICAgICApO1xuXG4gICAgICBjb25zdCBtb2NrRXEgPSBqZXN0LmZuKCkubW9ja1JldHVyblZhbHVlKHtcbiAgICAgICAgc2luZ2xlOiAoKSA9PiBtb2NrU2luZ2xlLFxuICAgICAgfSk7XG5cbiAgICAgIGNvbnN0IG1vY2tTZWxlY3QgPSBqZXN0LmZuKCkubW9ja1JldHVyblZhbHVlKHtcbiAgICAgICAgZXE6IG1vY2tFcSxcbiAgICAgIH0pO1xuXG4gICAgICBtb2NrU3VwYWJhc2VDbGllbnQuZnJvbS5tb2NrUmV0dXJuVmFsdWUoe1xuICAgICAgICBzZWxlY3Q6IG1vY2tTZWxlY3QsXG4gICAgICB9KTtcblxuICAgICAgY29uc3QgcmVxdWVzdCA9IG5ldyBOZXh0UmVxdWVzdCgnaHR0cDovL2xvY2FsaG9zdDozMDAwL2FwaS9hZG1pbi9hdXRoJywge1xuICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgIH0sXG4gICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICBlbWFpbDogJ3Rlc3RAZXhhbXBsZS5jb20nLFxuICAgICAgICAgIHBhc3N3b3JkOiAndGVzdHBhc3N3b3JkMTIzJyxcbiAgICAgICAgfSksXG4gICAgICB9KTtcblxuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBQT1NUKHJlcXVlc3QpO1xuICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IGdldFJlc3BvbnNlRGF0YShyZXNwb25zZSk7XG5cbiAgICAgIGV4cGVjdChyZXNwb25zZS5zdGF0dXMpLnRvQmUoNTAwKTtcbiAgICAgIGV4cGVjdChkYXRhLnN1Y2Nlc3MpLnRvQmUoZmFsc2UpO1xuICAgICAgZXhwZWN0KGRhdGEuZXJyb3IpLnRvQmVEZWZpbmVkKCk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIGhhbmRsZSByZXF1ZXN0cyB3aXRob3V0IENvbnRlbnQtVHlwZSBoZWFkZXInLCBhc3luYyAoKSA9PiB7XG4gICAgICAvLyBNb2NrIFN1cGFiYXNlIC0gYWRtaW4gbm90IGZvdW5kXG4gICAgICBjb25zdCBtb2NrU2luZ2xlID0gUHJvbWlzZS5yZXNvbHZlKHtcbiAgICAgICAgZGF0YTogbnVsbCxcbiAgICAgICAgZXJyb3I6IHsgbWVzc2FnZTogJ05vdCBmb3VuZCcgfSxcbiAgICAgIH0pO1xuXG4gICAgICBjb25zdCBtb2NrRXEgPSBqZXN0LmZuKCkubW9ja1JldHVyblZhbHVlKHtcbiAgICAgICAgc2luZ2xlOiAoKSA9PiBtb2NrU2luZ2xlLFxuICAgICAgfSk7XG5cbiAgICAgIGNvbnN0IG1vY2tTZWxlY3QgPSBqZXN0LmZuKCkubW9ja1JldHVyblZhbHVlKHtcbiAgICAgICAgZXE6IG1vY2tFcSxcbiAgICAgIH0pO1xuXG4gICAgICBtb2NrU3VwYWJhc2VDbGllbnQuZnJvbS5tb2NrUmV0dXJuVmFsdWUoe1xuICAgICAgICBzZWxlY3Q6IG1vY2tTZWxlY3QsXG4gICAgICB9KTtcblxuICAgICAgY29uc3QgcmVxdWVzdCA9IG5ldyBOZXh0UmVxdWVzdCgnaHR0cDovL2xvY2FsaG9zdDozMDAwL2FwaS9hZG1pbi9hdXRoJywge1xuICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICAgIGVtYWlsOiAndGVzdEBleGFtcGxlLmNvbScsXG4gICAgICAgICAgcGFzc3dvcmQ6ICd0ZXN0cGFzc3dvcmQxMjMnLFxuICAgICAgICB9KSxcbiAgICAgIH0pO1xuXG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IFBPU1QocmVxdWVzdCk7XG4gICAgICBjb25zdCBkYXRhID0gYXdhaXQgZ2V0UmVzcG9uc2VEYXRhKHJlc3BvbnNlKTtcblxuICAgICAgLy8gVGhlIHJvdXRlIHNob3VsZCBzdGlsbCBwcm9jZXNzIHRoZSByZXF1ZXN0IGlmIGJvZHkgaXMgdmFsaWQgSlNPTlxuICAgICAgLy8gSXQgd2lsbCBmYWlsIGF1dGhlbnRpY2F0aW9uICg0MDEpIHNpbmNlIGFkbWluIGlzIG5vdCBmb3VuZFxuICAgICAgZXhwZWN0KHJlc3BvbnNlLnN0YXR1cykudG9CZSg0MDEpO1xuICAgICAgZXhwZWN0KGRhdGEuc3VjY2VzcykudG9CZShmYWxzZSk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIGdlbmVyYXRlIEpXVCB0b2tlbiB3aXRoIGNvcnJlY3QgZXhwaXJhdGlvbicsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IG1vY2tBZG1pbiA9IHtcbiAgICAgICAgaWQ6ICdhZG1pbl8xMjMnLFxuICAgICAgICBlbWFpbDogJ3Rlc3RAZXhhbXBsZS5jb20nLFxuICAgICAgICBuYW1lOiAnVGVzdCBBZG1pbicsXG4gICAgICAgIHJvbGU6ICdzdXBlcl9hZG1pbicsXG4gICAgICAgIHBhc3N3b3JkX2hhc2g6ICdoYXNoZWRfcGFzc3dvcmQnLFxuICAgICAgICBpc19hY3RpdmU6IHRydWUsXG4gICAgICAgIGNyZWF0ZWRfYXQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcbiAgICAgIH07XG5cbiAgICAgIGNvbnN0IG1vY2tTaW5nbGUgPSBQcm9taXNlLnJlc29sdmUoe1xuICAgICAgICBkYXRhOiBtb2NrQWRtaW4sXG4gICAgICAgIGVycm9yOiBudWxsLFxuICAgICAgfSk7XG5cbiAgICAgIGNvbnN0IG1vY2tFcSA9IGplc3QuZm4oKS5tb2NrUmV0dXJuVmFsdWUoe1xuICAgICAgICBzaW5nbGU6ICgpID0+IG1vY2tTaW5nbGUsXG4gICAgICB9KTtcblxuICAgICAgY29uc3QgbW9ja1NlbGVjdCA9IGplc3QuZm4oKS5tb2NrUmV0dXJuVmFsdWUoe1xuICAgICAgICBlcTogbW9ja0VxLFxuICAgICAgfSk7XG5cbiAgICAgIG1vY2tTdXBhYmFzZUNsaWVudC5mcm9tLm1vY2tSZXR1cm5WYWx1ZSh7XG4gICAgICAgIHNlbGVjdDogbW9ja1NlbGVjdCxcbiAgICAgICAgdXBkYXRlOiBqZXN0LmZuKCkubW9ja1JldHVyblZhbHVlKHtcbiAgICAgICAgICBlcTogamVzdC5mbigpLm1vY2tSZXNvbHZlZFZhbHVlKHsgZXJyb3I6IG51bGwgfSksXG4gICAgICAgIH0pLFxuICAgICAgfSk7XG5cbiAgICAgIGJjcnlwdC5jb21wYXJlLm1vY2tSZXNvbHZlZFZhbHVlKHRydWUpO1xuXG4gICAgICBjb25zdCByZXF1ZXN0ID0gbmV3IE5leHRSZXF1ZXN0KCdodHRwOi8vbG9jYWxob3N0OjMwMDAvYXBpL2FkbWluL2F1dGgnLCB7XG4gICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgfSxcbiAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICAgIGVtYWlsOiAndGVzdEBleGFtcGxlLmNvbScsXG4gICAgICAgICAgcGFzc3dvcmQ6ICd0ZXN0cGFzc3dvcmQxMjMnLFxuICAgICAgICB9KSxcbiAgICAgIH0pO1xuXG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IFBPU1QocmVxdWVzdCk7XG4gICAgICBjb25zdCBkYXRhID0gYXdhaXQgZ2V0UmVzcG9uc2VEYXRhKHJlc3BvbnNlKTtcblxuICAgICAgZXhwZWN0KHJlc3BvbnNlLnN0YXR1cykudG9CZSgyMDApO1xuICAgICAgZXhwZWN0KGRhdGEuYWRtaW4udG9rZW4pLnRvQmVEZWZpbmVkKCk7XG4gICAgICBleHBlY3QoZGF0YS5hZG1pbi5leHBpcmVzQXQpLnRvQmVEZWZpbmVkKCk7XG5cbiAgICAgIC8vIENoZWNrIHRoYXQgZXhwaXJhdGlvbiBpcyBpbiB0aGUgZnV0dXJlXG4gICAgICBjb25zdCBleHBpcmF0aW9uRGF0ZSA9IG5ldyBEYXRlKGRhdGEuYWRtaW4uZXhwaXJlc0F0KTtcbiAgICAgIGNvbnN0IG5vdyA9IG5ldyBEYXRlKCk7XG4gICAgICBleHBlY3QoZXhwaXJhdGlvbkRhdGUuZ2V0VGltZSgpKS50b0JlR3JlYXRlclRoYW4obm93LmdldFRpbWUoKSk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIGhhbmRsZSBtdWx0aXBsZSByZXF1ZXN0cycsIGFzeW5jICgpID0+IHtcbiAgICAgIC8vIE1vY2sgU3VwYWJhc2UgLSBhZG1pbiBub3QgZm91bmQgZm9yIGFsbCByZXF1ZXN0c1xuICAgICAgY29uc3QgbW9ja1NpbmdsZSA9IFByb21pc2UucmVzb2x2ZSh7XG4gICAgICAgIGRhdGE6IG51bGwsXG4gICAgICAgIGVycm9yOiB7IG1lc3NhZ2U6ICdOb3QgZm91bmQnIH0sXG4gICAgICB9KTtcblxuICAgICAgY29uc3QgbW9ja0VxID0gamVzdC5mbigpLm1vY2tSZXR1cm5WYWx1ZSh7XG4gICAgICAgIHNpbmdsZTogKCkgPT4gbW9ja1NpbmdsZSxcbiAgICAgIH0pO1xuXG4gICAgICBjb25zdCBtb2NrU2VsZWN0ID0gamVzdC5mbigpLm1vY2tSZXR1cm5WYWx1ZSh7XG4gICAgICAgIGVxOiBtb2NrRXEsXG4gICAgICB9KTtcblxuICAgICAgbW9ja1N1cGFiYXNlQ2xpZW50LmZyb20ubW9ja1JldHVyblZhbHVlKHtcbiAgICAgICAgc2VsZWN0OiBtb2NrU2VsZWN0LFxuICAgICAgfSk7XG5cbiAgICAgIGNvbnN0IHJlcXVlc3RzID0gQXJyYXkoNSlcbiAgICAgICAgLmZpbGwobnVsbClcbiAgICAgICAgLm1hcChcbiAgICAgICAgICAoKSA9PlxuICAgICAgICAgICAgbmV3IE5leHRSZXF1ZXN0KCdodHRwOi8vbG9jYWxob3N0OjMwMDAvYXBpL2FkbWluL2F1dGgnLCB7XG4gICAgICAgICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICAgICAgICAgIGVtYWlsOiAndGVzdEBleGFtcGxlLmNvbScsXG4gICAgICAgICAgICAgICAgcGFzc3dvcmQ6ICd3cm9uZ3Bhc3N3b3JkJyxcbiAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICB9KVxuICAgICAgICApO1xuXG4gICAgICBjb25zdCByZXNwb25zZXMgPSBhd2FpdCBQcm9taXNlLmFsbChyZXF1ZXN0cy5tYXAocmVxID0+IFBPU1QocmVxKSkpO1xuXG4gICAgICAvLyBBbGwgcmVxdWVzdHMgc2hvdWxkIGJlIGhhbmRsZWQgKGV2ZW4gaWYgdGhleSBmYWlsKVxuICAgICAgcmVzcG9uc2VzLmZvckVhY2gocmVzcG9uc2UgPT4ge1xuICAgICAgICBleHBlY3QoWzQwMCwgNDAxXSkudG9Db250YWluKHJlc3BvbnNlLnN0YXR1cyk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfSk7XG59KTtcbiJdLCJuYW1lcyI6WyJqZXN0IiwibW9jayIsImFjdHVhbCIsInJlcXVpcmVBY3R1YWwiLCJOZXh0UmVzcG9uc2UiLCJqc29uIiwiYm9keSIsImluaXQiLCJyZXNwb25zZSIsIl9ib2R5IiwiSlNPTiIsInN0cmluZ2lmeSIsImNsaWVudCIsImZyb20iLCJmbiIsImNyZWF0ZUNsaWVudCIsImNvbXBhcmUiLCJoYXNoIiwiYWRtaW5Db25maWciLCJzZWN1cml0eSIsInNhbHRSb3VuZHMiLCJzZXNzaW9uVGltZW91dCIsImp3dCIsInNlY3JldCIsImdldEFkbWluQXBpVXJsIiwicGF0aCIsImdldFJlc3BvbnNlRGF0YSIsImRhdGEiLCJPYmplY3QiLCJrZXlzIiwibGVuZ3RoIiwiZSIsInVuZGVmaW5lZCIsInBhcnNlIiwidGV4dCIsInJlYWRlciIsImdldFJlYWRlciIsInZhbHVlIiwiZG9uZSIsInJlYWQiLCJUZXh0RGVjb2RlciIsImRlY29kZSIsIm1vY2tTdXBhYmFzZUNsaWVudCIsImRlc2NyaWJlIiwiYmNyeXB0IiwicmVxdWlyZSIsImJlZm9yZUVhY2giLCJjbGVhckFsbE1vY2tzIiwibW9ja0NsZWFyIiwicHJvY2VzcyIsImVudiIsIkpXVF9TRUNSRVQiLCJORVhUX1BVQkxJQ19TVVBBQkFTRV9VUkwiLCJORVhUX1BVQkxJQ19TVVBBQkFTRV9BTk9OX0tFWSIsIlNVUEFCQVNFX1NFUlZJQ0VfUk9MRV9LRVkiLCJhZnRlckVhY2giLCJpdCIsIm1vY2tBZG1pbiIsImlkIiwiZW1haWwiLCJuYW1lIiwicm9sZSIsInBhc3N3b3JkX2hhc2giLCJpc19hY3RpdmUiLCJjcmVhdGVkX2F0IiwiRGF0ZSIsInRvSVNPU3RyaW5nIiwibW9ja1NpbmdsZSIsIlByb21pc2UiLCJyZXNvbHZlIiwiZXJyb3IiLCJtb2NrRXEiLCJtb2NrUmV0dXJuVmFsdWUiLCJzaW5nbGUiLCJtb2NrU2VsZWN0IiwiZXEiLCJzZWxlY3QiLCJ1cGRhdGUiLCJtb2NrUmVzb2x2ZWRWYWx1ZSIsInJlcXVlc3QiLCJOZXh0UmVxdWVzdCIsIm1ldGhvZCIsImhlYWRlcnMiLCJwYXNzd29yZCIsIlBPU1QiLCJleHBlY3QiLCJzdGF0dXMiLCJ0b0JlIiwidG9CZURlZmluZWQiLCJzdWNjZXNzIiwiYWRtaW4iLCJ0b2tlbiIsInRvTWF0Y2giLCJtZXNzYWdlIiwicmVqZWN0IiwiRXJyb3IiLCJleHBpcmVzQXQiLCJleHBpcmF0aW9uRGF0ZSIsIm5vdyIsImdldFRpbWUiLCJ0b0JlR3JlYXRlclRoYW4iLCJyZXF1ZXN0cyIsIkFycmF5IiwiZmlsbCIsIm1hcCIsInJlc3BvbnNlcyIsImFsbCIsInJlcSIsImZvckVhY2giLCJ0b0NvbnRhaW4iXSwibWFwcGluZ3MiOiJBQUFBLHFEQUFxRCxHQUNyRDs7Ozs7Ozs7Q0FRQztBQUtELDREQUE0RDtBQUM1REEsS0FBS0MsSUFBSSxDQUFDLGVBQWU7SUFDdkIsTUFBTUMsU0FBU0YsS0FBS0csYUFBYSxDQUFDO0lBQ2xDLE9BQU87UUFDTCxHQUFHRCxNQUFNO1FBQ1RFLGNBQWM7WUFDWixHQUFHRixPQUFPRSxZQUFZO1lBQ3RCQyxNQUFNLENBQUNDLE1BQVdDO2dCQUNoQixNQUFNQyxXQUFXTixPQUFPRSxZQUFZLENBQUNDLElBQUksQ0FBQ0MsTUFBTUM7Z0JBQ2hELDZDQUE2QztnQkFDNUNDLFNBQWlCQyxLQUFLLEdBQUdDLEtBQUtDLFNBQVMsQ0FBQ0w7Z0JBQ3pDLE9BQU9FO1lBQ1Q7UUFDRjtJQUNGO0FBQ0Y7QUF1RUFSLEtBQUtDLElBQUksQ0FBQyx5QkFBeUI7SUFDakMsNENBQTRDO0lBQzVDLE1BQU1XLFNBQVM7UUFDYkMsTUFBTWIsS0FBS2MsRUFBRTtJQUNmO0lBQ0EsT0FBTztRQUNMQyxjQUFjZixLQUFLYyxFQUFFLENBQUMsSUFBTUY7SUFDOUI7QUFDRjtBQUVBLG1EQUFtRDtBQUNuRCxzQ0FBc0M7QUFFdEMsY0FBYztBQUNkWixLQUFLQyxJQUFJLENBQUMsWUFBWSxJQUFPLENBQUE7UUFDM0JlLFNBQVNoQixLQUFLYyxFQUFFO1FBQ2hCRyxNQUFNakIsS0FBS2MsRUFBRTtJQUNmLENBQUE7QUFFQSxvQkFBb0I7QUFDcEJkLEtBQUtDLElBQUksQ0FBQyxrQkFBa0IsSUFBTyxDQUFBO1FBQ2pDaUIsYUFBYTtZQUNYQyxVQUFVO2dCQUNSQyxZQUFZO2dCQUNaQyxnQkFBZ0IsS0FBSyxLQUFLLEtBQUs7WUFDakM7WUFDQUMs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