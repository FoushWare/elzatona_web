d79aaf7fb36e79225253ad90a2c456a1
'use client';
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: Object.getOwnPropertyDescriptor(all, name).get
    });
}
_export(exports, {
    get LanguageProvider () {
        return LanguageProvider;
    },
    get useLanguage () {
        return useLanguage;
    }
});
const _jsxruntime = require("react/jsx-runtime");
const _react = /*#__PURE__*/ _interop_require_wildcard(require("react"));
function _getRequireWildcardCache(nodeInterop) {
    if (typeof WeakMap !== "function") return null;
    var cacheBabelInterop = new WeakMap();
    var cacheNodeInterop = new WeakMap();
    return (_getRequireWildcardCache = function(nodeInterop) {
        return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
    })(nodeInterop);
}
function _interop_require_wildcard(obj, nodeInterop) {
    if (!nodeInterop && obj && obj.__esModule) {
        return obj;
    }
    if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return {
            default: obj
        };
    }
    var cache = _getRequireWildcardCache(nodeInterop);
    if (cache && cache.has(obj)) {
        return cache.get(obj);
    }
    var newObj = {
        __proto__: null
    };
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for(var key in obj){
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
            if (desc && (desc.get || desc.set)) {
                Object.defineProperty(newObj, key, desc);
            } else {
                newObj[key] = obj[key];
            }
        }
    }
    newObj.default = obj;
    if (cache) {
        cache.set(obj, newObj);
    }
    return newObj;
}
// Only create Supabase client if environment variables are available
// eslint-disable-next-line @typescript-eslint/no-explicit-any
let supabase = null;
if (process.env['NEXT_PUBLIC_SUPABASE_URL'] && process.env['SUPABASE_SERVICE_ROLE_KEY']) {
    // eslint-disable-next-line @typescript-eslint/no-require-imports
    const { createClient } = require('@supabase/supabase-js');
    const supabaseUrl = process.env['NEXT_PUBLIC_SUPABASE_URL'];
    const supabaseServiceRoleKey = process.env['SUPABASE_SERVICE_ROLE_KEY'];
    supabase = createClient(supabaseUrl, supabaseServiceRoleKey);
}
const LanguageContext = /*#__PURE__*/ (0, _react.createContext)(undefined);
const useLanguage = ()=>{
    const context = (0, _react.useContext)(LanguageContext);
    if (context === undefined) {
        throw new Error('useLanguage must be used within a LanguageProvider');
    }
    return context;
};
const LanguageProvider = ({ children })=>{
    const [language, setLanguageState] = (0, _react.useState)('en');
    const [isLoaded, setIsLoaded] = (0, _react.useState)(false);
    // Load language from localStorage on mount
    (0, _react.useEffect)(()=>{
        const savedLanguage = localStorage.getItem('language');
        if (savedLanguage && (savedLanguage === 'en' || savedLanguage === 'ar')) {
            setLanguageState(savedLanguage);
        }
        setIsLoaded(true);
    }, []);
    // Save language to localStorage when it changes
    (0, _react.useEffect)(()=>{
        if (isLoaded) {
            localStorage.setItem('language', language);
            // Update document direction and language
            document.documentElement.lang = language;
        }
    }, [
        language,
        isLoaded
    ]);
    const setLanguage = (newLanguage)=>{
        setLanguageState(newLanguage);
    };
    const isRTL = language === 'ar';
    const value = {
        language,
        setLanguage,
        isRTL
    };
    return /*#__PURE__*/ (0, _jsxruntime.jsx)(LanguageContext.Provider, {
        value: value,
        children: children
    });
};

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9hLmZvdWFkL1NpZGVQcm9qZWN0cy9FbHphdG9uYS1hbGwvRWx6YXRvbmEtd2ViL2xpYnMvc2hhcmVkLWNvbnRleHRzL3NyYy9saWIvTGFuZ3VhZ2VDb250ZXh0LnRzeCJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIGNsaWVudCc7XG5cbmltcG9ydCBSZWFjdCwge1xuICB1c2VTdGF0ZSxcbiAgdXNlRWZmZWN0LFxuICBSZWFjdE5vZGUsXG4gIGNyZWF0ZUNvbnRleHQsXG4gIHVzZUNvbnRleHQsXG59IGZyb20gJ3JlYWN0JztcblxuLy8gT25seSBjcmVhdGUgU3VwYWJhc2UgY2xpZW50IGlmIGVudmlyb25tZW50IHZhcmlhYmxlcyBhcmUgYXZhaWxhYmxlXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxubGV0IHN1cGFiYXNlOiBhbnkgPSBudWxsO1xuaWYgKFxuICBwcm9jZXNzLmVudlsnTkVYVF9QVUJMSUNfU1VQQUJBU0VfVVJMJ10gJiZcbiAgcHJvY2Vzcy5lbnZbJ1NVUEFCQVNFX1NFUlZJQ0VfUk9MRV9LRVknXVxuKSB7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tcmVxdWlyZS1pbXBvcnRzXG4gIGNvbnN0IHsgY3JlYXRlQ2xpZW50IH0gPSByZXF1aXJlKCdAc3VwYWJhc2Uvc3VwYWJhc2UtanMnKTtcbiAgY29uc3Qgc3VwYWJhc2VVcmwgPSBwcm9jZXNzLmVudlsnTkVYVF9QVUJMSUNfU1VQQUJBU0VfVVJMJ107XG4gIGNvbnN0IHN1cGFiYXNlU2VydmljZVJvbGVLZXkgPSBwcm9jZXNzLmVudlsnU1VQQUJBU0VfU0VSVklDRV9ST0xFX0tFWSddO1xuICBzdXBhYmFzZSA9IGNyZWF0ZUNsaWVudChzdXBhYmFzZVVybCwgc3VwYWJhc2VTZXJ2aWNlUm9sZUtleSk7XG59XG5cbnR5cGUgTGFuZ3VhZ2UgPSAnZW4nIHwgJ2FyJztcblxuaW50ZXJmYWNlIExhbmd1YWdlQ29udGV4dFR5cGUge1xuICBsYW5ndWFnZTogTGFuZ3VhZ2U7XG4gIHNldExhbmd1YWdlOiAobGFuZ3VhZ2U6IExhbmd1YWdlKSA9PiB2b2lkO1xuICBpc1JUTDogYm9vbGVhbjtcbn1cblxuY29uc3QgTGFuZ3VhZ2VDb250ZXh0ID0gY3JlYXRlQ29udGV4dDxMYW5ndWFnZUNvbnRleHRUeXBlIHwgdW5kZWZpbmVkPihcbiAgdW5kZWZpbmVkXG4pO1xuXG5leHBvcnQgY29uc3QgdXNlTGFuZ3VhZ2UgPSAoKSA9PiB7XG4gIGNvbnN0IGNvbnRleHQgPSB1c2VDb250ZXh0KExhbmd1YWdlQ29udGV4dCk7XG4gIGlmIChjb250ZXh0ID09PSB1bmRlZmluZWQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3VzZUxhbmd1YWdlIG11c3QgYmUgdXNlZCB3aXRoaW4gYSBMYW5ndWFnZVByb3ZpZGVyJyk7XG4gIH1cbiAgcmV0dXJuIGNvbnRleHQ7XG59O1xuXG5pbnRlcmZhY2UgTGFuZ3VhZ2VQcm92aWRlclByb3BzIHtcbiAgY2hpbGRyZW46IFJlYWN0LlJlYWN0Tm9kZTtcbn1cblxuZXhwb3J0IGNvbnN0IExhbmd1YWdlUHJvdmlkZXI6IFJlYWN0LkZDPExhbmd1YWdlUHJvdmlkZXJQcm9wcz4gPSAoe1xuICBjaGlsZHJlbixcbn0pID0+IHtcbiAgY29uc3QgW2xhbmd1YWdlLCBzZXRMYW5ndWFnZVN0YXRlXSA9IHVzZVN0YXRlPExhbmd1YWdlPignZW4nKTtcbiAgY29uc3QgW2lzTG9hZGVkLCBzZXRJc0xvYWRlZF0gPSB1c2VTdGF0ZShmYWxzZSk7XG5cbiAgLy8gTG9hZCBsYW5ndWFnZSBmcm9tIGxvY2FsU3RvcmFnZSBvbiBtb3VudFxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGNvbnN0IHNhdmVkTGFuZ3VhZ2UgPSBsb2NhbFN0b3JhZ2UuZ2V0SXRlbSgnbGFuZ3VhZ2UnKSBhcyBMYW5ndWFnZTtcbiAgICBpZiAoc2F2ZWRMYW5ndWFnZSAmJiAoc2F2ZWRMYW5ndWFnZSA9PT0gJ2VuJyB8fCBzYXZlZExhbmd1YWdlID09PSAnYXInKSkge1xuICAgICAgc2V0TGFuZ3VhZ2VTdGF0ZShzYXZlZExhbmd1YWdlKTtcbiAgICB9XG4gICAgc2V0SXNMb2FkZWQodHJ1ZSk7XG4gIH0sIFtdKTtcblxuICAvLyBTYXZlIGxhbmd1YWdlIHRvIGxvY2FsU3RvcmFnZSB3aGVuIGl0IGNoYW5nZXNcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoaXNMb2FkZWQpIHtcbiAgICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKCdsYW5ndWFnZScsIGxhbmd1YWdlKTtcblxuICAgICAgLy8gVXBkYXRlIGRvY3VtZW50IGRpcmVjdGlvbiBhbmQgbGFuZ3VhZ2VcbiAgICAgIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5sYW5nID0gbGFuZ3VhZ2U7XG4gICAgfVxuICB9LCBbbGFuZ3VhZ2UsIGlzTG9hZGVkXSk7XG5cbiAgY29uc3Qgc2V0TGFuZ3VhZ2UgPSAobmV3TGFuZ3VhZ2U6IExhbmd1YWdlKSA9PiB7XG4gICAgc2V0TGFuZ3VhZ2VTdGF0ZShuZXdMYW5ndWFnZSk7XG4gIH07XG5cbiAgY29uc3QgaXNSVEwgPSBsYW5ndWFnZSA9PT0gJ2FyJztcblxuICBjb25zdCB2YWx1ZSA9IHtcbiAgICBsYW5ndWFnZSxcbiAgICBzZXRMYW5ndWFnZSxcbiAgICBpc1JUTCxcbiAgfTtcblxuICByZXR1cm4gKFxuICAgIDxMYW5ndWFnZUNvbnRleHQuUHJvdmlkZXIgdmFsdWU9e3ZhbHVlfT5cbiAgICAgIHtjaGlsZHJlbn1cbiAgICA8L0xhbmd1YWdlQ29udGV4dC5Qcm92aWRlcj5cbiAgKTtcbn07XG4iXSwibmFtZXMiOlsiTGFuZ3VhZ2VQcm92aWRlciIsInVzZUxhbmd1YWdlIiwic3VwYWJhc2UiLCJwcm9jZXNzIiwiZW52IiwiY3JlYXRlQ2xpZW50IiwicmVxdWlyZSIsInN1cGFiYXNlVXJsIiwic3VwYWJhc2VTZXJ2aWNlUm9sZUtleSIsIkxhbmd1YWdlQ29udGV4dCIsImNyZWF0ZUNvbnRleHQiLCJ1bmRlZmluZWQiLCJjb250ZXh0IiwidXNlQ29udGV4dCIsIkVycm9yIiwiY2hpbGRyZW4iLCJsYW5ndWFnZSIsInNldExhbmd1YWdlU3RhdGUiLCJ1c2VTdGF0ZSIsImlzTG9hZGVkIiwic2V0SXNMb2FkZWQiLCJ1c2VFZmZlY3QiLCJzYXZlZExhbmd1YWdlIiwibG9jYWxTdG9yYWdlIiwiZ2V0SXRlbSIsInNldEl0ZW0iLCJkb2N1bWVudCIsImRvY3VtZW50RWxlbWVudCIsImxhbmciLCJzZXRMYW5ndWFnZSIsIm5ld0xhbmd1YWdlIiwiaXNSVEwiLCJ2YWx1ZSIsIlByb3ZpZGVyIl0sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7Ozs7Ozs7O1FBZ0RhQTtlQUFBQTs7UUFaQUM7ZUFBQUE7Ozs7K0RBNUJOOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFFUCxxRUFBcUU7QUFDckUsOERBQThEO0FBQzlELElBQUlDLFdBQWdCO0FBQ3BCLElBQ0VDLFFBQVFDLEdBQUcsQ0FBQywyQkFBMkIsSUFDdkNELFFBQVFDLEdBQUcsQ0FBQyw0QkFBNEIsRUFDeEM7SUFDQSxpRUFBaUU7SUFDakUsTUFBTSxFQUFFQyxZQUFZLEVBQUUsR0FBR0MsUUFBUTtJQUNqQyxNQUFNQyxjQUFjSixRQUFRQyxHQUFHLENBQUMsMkJBQTJCO0lBQzNELE1BQU1JLHlCQUF5QkwsUUFBUUMsR0FBRyxDQUFDLDRCQUE0QjtJQUN2RUYsV0FBV0csYUFBYUUsYUFBYUM7QUFDdkM7QUFVQSxNQUFNQyxnQ0FBa0JDLElBQUFBLG9CQUFhLEVBQ25DQztBQUdLLE1BQU1WLGNBQWM7SUFDekIsTUFBTVcsVUFBVUMsSUFBQUEsaUJBQVUsRUFBQ0o7SUFDM0IsSUFBSUcsWUFBWUQsV0FBVztRQUN6QixNQUFNLElBQUlHLE1BQU07SUFDbEI7SUFDQSxPQUFPRjtBQUNUO0FBTU8sTUFBTVosbUJBQW9ELENBQUMsRUFDaEVlLFFBQVEsRUFDVDtJQUNDLE1BQU0sQ0FBQ0MsVUFBVUMsaUJBQWlCLEdBQUdDLElBQUFBLGVBQVEsRUFBVztJQUN4RCxNQUFNLENBQUNDLFVBQVVDLFlBQVksR0FBR0YsSUFBQUEsZUFBUSxFQUFDO0lBRXpDLDJDQUEyQztJQUMzQ0csSUFBQUEsZ0JBQVMsRUFBQztRQUNSLE1BQU1DLGdCQUFnQkMsYUFBYUMsT0FBTyxDQUFDO1FBQzNDLElBQUlGLGlCQUFrQkEsQ0FBQUEsa0JBQWtCLFFBQVFBLGtCQUFrQixJQUFHLEdBQUk7WUFDdkVMLGlCQUFpQks7UUFDbkI7UUFDQUYsWUFBWTtJQUNkLEdBQUcsRUFBRTtJQUVMLGdEQUFnRDtJQUNoREMsSUFBQUEsZ0JBQVMsRUFBQztRQUNSLElBQUlGLFVBQVU7WUFDWkksYUFBYUUsT0FBTyxDQUFDLFlBQVlUO1lBRWpDLHlDQUF5QztZQUN6Q1UsU0FBU0MsZUFBZSxDQUFDQyxJQUFJLEdBQUdaO1FBQ2xDO0lBQ0YsR0FBRztRQUFDQTtRQUFVRztLQUFTO0lBRXZCLE1BQU1VLGNBQWMsQ0FBQ0M7UUFDbkJiLGlCQUFpQmE7SUFDbkI7SUFFQSxNQUFNQyxRQUFRZixhQUFhO0lBRTNCLE1BQU1nQixRQUFRO1FBQ1poQjtRQUNBYTtRQUNBRTtJQUNGO0lBRUEscUJBQ0UscUJBQUN0QixnQkFBZ0J3QixRQUFRO1FBQUNELE9BQU9BO2tCQUM5QmpCOztBQUdQIn0=