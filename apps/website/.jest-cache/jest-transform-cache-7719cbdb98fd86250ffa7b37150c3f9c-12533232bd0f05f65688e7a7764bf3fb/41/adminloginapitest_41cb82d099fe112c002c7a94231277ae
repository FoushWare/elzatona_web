92cf9409d68b81b95abc8c7cd403ce17
/* eslint-disable @typescript-eslint/no-explicit-any */ /**
 * Admin Login API Tests
 *
 * Tests for the /api/admin/auth endpoint to ensure:
 * - Authentication works correctly
 * - Proper error handling
 * - JWT token generation
 * - Security measures
 */ "use strict";
// Mock NextResponse to ensure json() method works correctly
jest.mock('next/server', ()=>{
    const actual = jest.requireActual('next/server');
    return {
        ...actual,
        NextResponse: {
            ...actual.NextResponse,
            json: (body, init)=>{
                const response = actual.NextResponse.json(body, init);
                // Ensure _body is set for test compatibility
                response._body = JSON.stringify(body);
                return response;
            }
        }
    };
});
jest.mock('@supabase/supabase-js', ()=>{
    // Create the mock client inside the factory
    const client = {
        from: jest.fn()
    };
    return {
        createClient: jest.fn(()=>client)
    };
});
// Export the mock client so tests can configure it
// We'll get it from the mocked module
// Mock bcrypt
jest.mock('bcryptjs', ()=>({
        compare: jest.fn(),
        hash: jest.fn()
    }));
// Mock admin.config
jest.mock('@/admin.config', ()=>({
        adminConfig: {
            security: {
                saltRounds: 10,
                sessionTimeout: 24 * 60 * 60 * 1000
            },
            jwt: {
                secret: 'test-jwt-secret'
            }
        },
        getAdminApiUrl: jest.fn((path)=>`http://localhost:3000${path}`)
    }));
Object.defineProperty(exports, "__esModule", {
    value: true
});
const _server = require("next/server");
const _route = require("../../apps/website/src/app/api/admin/auth/route");
// Helper to extract JSON from NextResponse
async function getResponseData(response) {
    // NextResponse.json() stores data in response._body or response.body
    // Check all possible locations
    // Method 1: Try json() method
    try {
        const data = await response.json();
        if (data && typeof data === 'object' && Object.keys(data).length > 0) {
            return data;
        }
    } catch (_e) {
    // Continue to other methods
    }
    // Method 2: Check internal _body property (NextResponse might use this)
    if (response._body !== undefined) {
        const body = response._body;
        if (typeof body === 'string') {
            try {
                return JSON.parse(body);
            } catch  {
                return {};
            }
        }
        if (body && typeof body === 'object') {
            return body;
        }
    }
    // Method 3: Try text() method
    try {
        const text = await response.text();
        if (text) {
            return JSON.parse(text);
        }
    } catch (_e) {
    // Continue
    }
    // Method 4: Try body ReadableStream
    if (response.body) {
        try {
            const reader = response.body.getReader();
            const { value, done } = await reader.read();
            if (!done && value) {
                const text = new TextDecoder().decode(value);
                return JSON.parse(text);
            }
        } catch (_e) {
        // Continue
        }
    }
    // Method 5: Check if response has data property directly
    if (response.data) {
        return response.data;
    }
    return {};
}
// Mock Supabase - this needs to be set up before the route module is imported
// The route handler creates the client at module load, so we need a shared instance
// Define the mock client inside the factory to avoid hoisting issues
const mockSupabaseClient = {
    from: jest.fn()
};
describe('Admin Login API', ()=>{
    // eslint-disable-next-line @typescript-eslint/no-require-imports
    const bcrypt = require('bcryptjs');
    // eslint-disable-next-line @typescript-eslint/no-require-imports
    const { createClient } = require('@supabase/supabase-js');
    let mockSupabaseClient;
    beforeEach(()=>{
        jest.clearAllMocks();
        // Get the mock client instance (same one used by the route handler)
        mockSupabaseClient = createClient();
        // Reset the from mock for each test
        mockSupabaseClient.from.mockClear();
        // Set up environment variables
        process.env.JWT_SECRET = 'test-jwt-secret';
        process.env.NEXT_PUBLIC_SUPABASE_URL = 'https://test.supabase.co';
        process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY = 'test-anon-key';
        process.env.SUPABASE_SERVICE_ROLE_KEY = 'test-service-role-key';
    });
    afterEach(()=>{
        delete process.env.JWT_SECRET;
        delete process.env.NEXT_PUBLIC_SUPABASE_URL;
        delete process.env.SUPABASE_SERVICE_ROLE_KEY;
    });
    describe('POST /api/admin/auth', ()=>{
        it('should authenticate admin with valid credentials', async ()=>{
            // Mock Supabase response
            const mockAdmin = {
                id: 'admin_123',
                email: 'test@example.com',
                name: 'Test Admin',
                role: 'super_admin',
                password_hash: 'hashed_password',
                is_active: true,
                created_at: new Date().toISOString()
            };
            const mockSingle = Promise.resolve({
                data: mockAdmin,
                error: null
            });
            const mockEq = jest.fn().mockReturnValue({
                single: ()=>mockSingle
            });
            const mockSelect = jest.fn().mockReturnValue({
                eq: mockEq
            });
            mockSupabaseClient.from.mockReturnValue({
                select: mockSelect,
                update: jest.fn().mockReturnValue({
                    eq: jest.fn().mockResolvedValue({
                        error: null
                    })
                })
            });
            // Mock bcrypt compare
            bcrypt.compare.mockResolvedValue(true);
            const request = new _server.NextRequest('http://localhost:3000/api/admin/auth', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    email: 'test@example.com',
                    password: 'testpassword123'
                })
            });
            const response = await (0, _route.POST)(request);
            const data = await getResponseData(response);
            expect(response.status).toBe(200);
            expect(data).toBeDefined();
            expect(data.success).toBe(true);
            expect(data.admin).toBeDefined();
            expect(data.admin.email).toBe(mockAdmin.email);
            expect(data.admin.token).toBeDefined();
            expect(data.admin.token).toMatch(/^[A-Za-z0-9-_]+\.[A-Za-z0-9-_]+\.[A-Za-z0-9-_]+$/);
        });
        it('should reject authentication with invalid credentials', async ()=>{
            // Mock Supabase - admin not found
            const mockSingle = jest.fn().mockResolvedValue({
                data: null,
                error: {
                    message: 'Not found'
                }
            });
            mockSupabaseClient.from.mockReturnValue({
                select: jest.fn().mockReturnValue({
                    eq: jest.fn().mockReturnValue({
                        single: mockSingle
                    })
                })
            });
            const request = new _server.NextRequest('http://localhost:3000/api/admin/auth', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    email: 'test@example.com',
                    password: 'wrongpassword'
                })
            });
            const response = await (0, _route.POST)(request);
            const data = await getResponseData(response);
            expect(response.status).toBe(401);
            expect(data.success).toBe(false);
            expect(data.error).toBe('Invalid email or password');
        });
        it('should reject authentication with wrong password', async ()=>{
            // Mock Supabase - admin found but wrong password
            const mockAdmin = {
                id: 'admin_123',
                email: 'test@example.com',
                password_hash: 'hashed_password',
                is_active: true
            };
            const mockSingle = Promise.resolve({
                data: mockAdmin,
                error: null
            });
            const mockEq = jest.fn().mockReturnValue({
                single: ()=>mockSingle
            });
            const mockSelect = jest.fn().mockReturnValue({
                eq: mockEq
            });
            mockSupabaseClient.from.mockReturnValue({
                select: mockSelect
            });
            // Mock bcrypt compare - wrong password
            bcrypt.compare.mockResolvedValue(false);
            const request = new _server.NextRequest('http://localhost:3000/api/admin/auth', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    email: 'test@example.com',
                    password: 'wrongpassword'
                })
            });
            const response = await (0, _route.POST)(request);
            const data = await getResponseData(response);
            expect(response.status).toBe(401);
            expect(data.success).toBe(false);
            expect(data.error).toBe('Invalid email or password');
        });
        it('should reject authentication with missing email', async ()=>{
            const request = new _server.NextRequest('http://localhost:3000/api/admin/auth', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    password: 'testpassword123'
                })
            });
            const response = await (0, _route.POST)(request);
            const data = await getResponseData(response);
            expect(response.status).toBe(400);
            expect(data.success).toBe(false);
            expect(data.error).toBe('Email and password are required');
        });
        it('should reject authentication with missing password', async ()=>{
            const request = new _server.NextRequest('http://localhost:3000/api/admin/auth', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    email: 'test@example.com'
                })
            });
            const response = await (0, _route.POST)(request);
            const data = await getResponseData(response);
            expect(response.status).toBe(400);
            expect(data.success).toBe(false);
            expect(data.error).toBe('Email and password are required');
        });
        it('should handle server errors gracefully', async ()=>{
            // Mock console.error to suppress error output during test
            const consoleErrorSpy = jest.spyOn(console, 'error').mockImplementation(()=>{});
            // Mock Supabase error
            const mockSingle = Promise.reject(new Error('Database connection failed'));
            const mockEq = jest.fn().mockReturnValue({
                single: ()=>mockSingle
            });
            const mockSelect = jest.fn().mockReturnValue({
                eq: mockEq
            });
            mockSupabaseClient.from.mockReturnValue({
                select: mockSelect
            });
            const request = new _server.NextRequest('http://localhost:3000/api/admin/auth', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    email: 'test@example.com',
                    password: 'testpassword123'
                })
            });
            const response = await (0, _route.POST)(request);
            const data = await getResponseData(response);
            expect(response.status).toBe(500);
            expect(data.success).toBe(false);
            expect(data.error).toBeDefined();
            // Restore console.error
            consoleErrorSpy.mockRestore();
        });
        it('should handle requests without Content-Type header', async ()=>{
            // Mock Supabase - admin not found
            const mockSingle = Promise.resolve({
                data: null,
                error: {
                    message: 'Not found'
                }
            });
            const mockEq = jest.fn().mockReturnValue({
                single: ()=>mockSingle
            });
            const mockSelect = jest.fn().mockReturnValue({
                eq: mockEq
            });
            mockSupabaseClient.from.mockReturnValue({
                select: mockSelect
            });
            const request = new _server.NextRequest('http://localhost:3000/api/admin/auth', {
                method: 'POST',
                body: JSON.stringify({
                    email: 'test@example.com',
                    password: 'testpassword123'
                })
            });
            const response = await (0, _route.POST)(request);
            const data = await getResponseData(response);
            // The route should still process the request if body is valid JSON
            // It will fail authentication (401) since admin is not found
            expect(response.status).toBe(401);
            expect(data.success).toBe(false);
        });
        it('should generate JWT token with correct expiration', async ()=>{
            const mockAdmin = {
                id: 'admin_123',
                email: 'test@example.com',
                name: 'Test Admin',
                role: 'super_admin',
                password_hash: 'hashed_password',
                is_active: true,
                created_at: new Date().toISOString()
            };
            const mockSingle = Promise.resolve({
                data: mockAdmin,
                error: null
            });
            const mockEq = jest.fn().mockReturnValue({
                single: ()=>mockSingle
            });
            const mockSelect = jest.fn().mockReturnValue({
                eq: mockEq
            });
            mockSupabaseClient.from.mockReturnValue({
                select: mockSelect,
                update: jest.fn().mockReturnValue({
                    eq: jest.fn().mockResolvedValue({
                        error: null
                    })
                })
            });
            bcrypt.compare.mockResolvedValue(true);
            const request = new _server.NextRequest('http://localhost:3000/api/admin/auth', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    email: 'test@example.com',
                    password: 'testpassword123'
                })
            });
            const response = await (0, _route.POST)(request);
            const data = await getResponseData(response);
            expect(response.status).toBe(200);
            expect(data.admin.token).toBeDefined();
            expect(data.admin.expiresAt).toBeDefined();
            // Check that expiration is in the future
            const expirationDate = new Date(data.admin.expiresAt);
            const now = new Date();
            expect(expirationDate.getTime()).toBeGreaterThan(now.getTime());
        });
        it('should handle multiple requests', async ()=>{
            // Mock Supabase - admin not found for all requests
            const mockSingle = Promise.resolve({
                data: null,
                error: {
                    message: 'Not found'
                }
            });
            const mockEq = jest.fn().mockReturnValue({
                single: ()=>mockSingle
            });
            const mockSelect = jest.fn().mockReturnValue({
                eq: mockEq
            });
            mockSupabaseClient.from.mockReturnValue({
                select: mockSelect
            });
            const requests = Array(5).fill(null).map(()=>new _server.NextRequest('http://localhost:3000/api/admin/auth', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        email: 'test@example.com',
                        password: 'wrongpassword'
                    })
                }));
            const responses = await Promise.all(requests.map((req)=>(0, _route.POST)(req)));
            // All requests should be handled (even if they fail)
            responses.forEach((response)=>{
                expect([
                    400,
                    401
                ]).toContain(response.status);
            });
        });
    });
});

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9hLmZvdWFkL1NpZGVQcm9qZWN0cy9FbHphdG9uYS1hbGwvRWx6YXRvbmEtd2ViL3Rlc3RzL2FkbWluL2FkbWluLWxvZ2luLWFwaS50ZXN0LnRzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIGVzbGludC1kaXNhYmxlIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnkgKi9cbi8qKlxuICogQWRtaW4gTG9naW4gQVBJIFRlc3RzXG4gKlxuICogVGVzdHMgZm9yIHRoZSAvYXBpL2FkbWluL2F1dGggZW5kcG9pbnQgdG8gZW5zdXJlOlxuICogLSBBdXRoZW50aWNhdGlvbiB3b3JrcyBjb3JyZWN0bHlcbiAqIC0gUHJvcGVyIGVycm9yIGhhbmRsaW5nXG4gKiAtIEpXVCB0b2tlbiBnZW5lcmF0aW9uXG4gKiAtIFNlY3VyaXR5IG1lYXN1cmVzXG4gKi9cblxuaW1wb3J0IHsgTmV4dFJlcXVlc3QsIE5leHRSZXNwb25zZSB9IGZyb20gJ25leHQvc2VydmVyJztcbmltcG9ydCB7IFBPU1QgfSBmcm9tICdAL2FwcC9hcGkvYWRtaW4vYXV0aC9yb3V0ZSc7XG5cbi8vIE1vY2sgTmV4dFJlc3BvbnNlIHRvIGVuc3VyZSBqc29uKCkgbWV0aG9kIHdvcmtzIGNvcnJlY3RseVxuamVzdC5tb2NrKCduZXh0L3NlcnZlcicsICgpID0+IHtcbiAgY29uc3QgYWN0dWFsID0gamVzdC5yZXF1aXJlQWN0dWFsKCduZXh0L3NlcnZlcicpO1xuICByZXR1cm4ge1xuICAgIC4uLmFjdHVhbCxcbiAgICBOZXh0UmVzcG9uc2U6IHtcbiAgICAgIC4uLmFjdHVhbC5OZXh0UmVzcG9uc2UsXG4gICAgICBqc29uOiAoYm9keTogYW55LCBpbml0PzogYW55KSA9PiB7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYWN0dWFsLk5leHRSZXNwb25zZS5qc29uKGJvZHksIGluaXQpO1xuICAgICAgICAvLyBFbnN1cmUgX2JvZHkgaXMgc2V0IGZvciB0ZXN0IGNvbXBhdGliaWxpdHlcbiAgICAgICAgKHJlc3BvbnNlIGFzIGFueSkuX2JvZHkgPSBKU09OLnN0cmluZ2lmeShib2R5KTtcbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgICAgfSxcbiAgICB9LFxuICB9O1xufSk7XG5cbi8vIEhlbHBlciB0byBleHRyYWN0IEpTT04gZnJvbSBOZXh0UmVzcG9uc2VcbmFzeW5jIGZ1bmN0aW9uIGdldFJlc3BvbnNlRGF0YShyZXNwb25zZTogYW55KTogUHJvbWlzZTxhbnk+IHtcbiAgLy8gTmV4dFJlc3BvbnNlLmpzb24oKSBzdG9yZXMgZGF0YSBpbiByZXNwb25zZS5fYm9keSBvciByZXNwb25zZS5ib2R5XG4gIC8vIENoZWNrIGFsbCBwb3NzaWJsZSBsb2NhdGlvbnNcblxuICAvLyBNZXRob2QgMTogVHJ5IGpzb24oKSBtZXRob2RcbiAgdHJ5IHtcbiAgICBjb25zdCBkYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgIGlmIChkYXRhICYmIHR5cGVvZiBkYXRhID09PSAnb2JqZWN0JyAmJiBPYmplY3Qua2V5cyhkYXRhKS5sZW5ndGggPiAwKSB7XG4gICAgICByZXR1cm4gZGF0YTtcbiAgICB9XG4gIH0gY2F0Y2ggKF9lKSB7XG4gICAgLy8gQ29udGludWUgdG8gb3RoZXIgbWV0aG9kc1xuICB9XG5cbiAgLy8gTWV0aG9kIDI6IENoZWNrIGludGVybmFsIF9ib2R5IHByb3BlcnR5IChOZXh0UmVzcG9uc2UgbWlnaHQgdXNlIHRoaXMpXG4gIGlmICgocmVzcG9uc2UgYXMgYW55KS5fYm9keSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgY29uc3QgYm9keSA9IChyZXNwb25zZSBhcyBhbnkpLl9ib2R5O1xuICAgIGlmICh0eXBlb2YgYm9keSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBKU09OLnBhcnNlKGJvZHkpO1xuICAgICAgfSBjYXRjaCB7XG4gICAgICAgIHJldHVybiB7fTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGJvZHkgJiYgdHlwZW9mIGJvZHkgPT09ICdvYmplY3QnKSB7XG4gICAgICByZXR1cm4gYm9keTtcbiAgICB9XG4gIH1cblxuICAvLyBNZXRob2QgMzogVHJ5IHRleHQoKSBtZXRob2RcbiAgdHJ5IHtcbiAgICBjb25zdCB0ZXh0ID0gYXdhaXQgcmVzcG9uc2UudGV4dCgpO1xuICAgIGlmICh0ZXh0KSB7XG4gICAgICByZXR1cm4gSlNPTi5wYXJzZSh0ZXh0KTtcbiAgICB9XG4gIH0gY2F0Y2ggKF9lKSB7XG4gICAgLy8gQ29udGludWVcbiAgfVxuXG4gIC8vIE1ldGhvZCA0OiBUcnkgYm9keSBSZWFkYWJsZVN0cmVhbVxuICBpZiAocmVzcG9uc2UuYm9keSkge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCByZWFkZXIgPSByZXNwb25zZS5ib2R5LmdldFJlYWRlcigpO1xuICAgICAgY29uc3QgeyB2YWx1ZSwgZG9uZSB9ID0gYXdhaXQgcmVhZGVyLnJlYWQoKTtcbiAgICAgIGlmICghZG9uZSAmJiB2YWx1ZSkge1xuICAgICAgICBjb25zdCB0ZXh0ID0gbmV3IFRleHREZWNvZGVyKCkuZGVjb2RlKHZhbHVlKTtcbiAgICAgICAgcmV0dXJuIEpTT04ucGFyc2UodGV4dCk7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoX2UpIHtcbiAgICAgIC8vIENvbnRpbnVlXG4gICAgfVxuICB9XG5cbiAgLy8gTWV0aG9kIDU6IENoZWNrIGlmIHJlc3BvbnNlIGhhcyBkYXRhIHByb3BlcnR5IGRpcmVjdGx5XG4gIGlmICgocmVzcG9uc2UgYXMgYW55KS5kYXRhKSB7XG4gICAgcmV0dXJuIChyZXNwb25zZSBhcyBhbnkpLmRhdGE7XG4gIH1cblxuICByZXR1cm4ge307XG59XG5cbi8vIE1vY2sgU3VwYWJhc2UgLSB0aGlzIG5lZWRzIHRvIGJlIHNldCB1cCBiZWZvcmUgdGhlIHJvdXRlIG1vZHVsZSBpcyBpbXBvcnRlZFxuLy8gVGhlIHJvdXRlIGhhbmRsZXIgY3JlYXRlcyB0aGUgY2xpZW50IGF0IG1vZHVsZSBsb2FkLCBzbyB3ZSBuZWVkIGEgc2hhcmVkIGluc3RhbmNlXG4vLyBEZWZpbmUgdGhlIG1vY2sgY2xpZW50IGluc2lkZSB0aGUgZmFjdG9yeSB0byBhdm9pZCBob2lzdGluZyBpc3N1ZXNcbmNvbnN0IG1vY2tTdXBhYmFzZUNsaWVudCA9IHtcbiAgZnJvbTogamVzdC5mbigpLFxufTtcblxuamVzdC5tb2NrKCdAc3VwYWJhc2Uvc3VwYWJhc2UtanMnLCAoKSA9PiB7XG4gIC8vIENyZWF0ZSB0aGUgbW9jayBjbGllbnQgaW5zaWRlIHRoZSBmYWN0b3J5XG4gIGNvbnN0IGNsaWVudCA9IHtcbiAgICBmcm9tOiBqZXN0LmZuKCksXG4gIH07XG4gIHJldHVybiB7XG4gICAgY3JlYXRlQ2xpZW50OiBqZXN0LmZuKCgpID0+IGNsaWVudCksXG4gIH07XG59KTtcblxuLy8gRXhwb3J0IHRoZSBtb2NrIGNsaWVudCBzbyB0ZXN0cyBjYW4gY29uZmlndXJlIGl0XG4vLyBXZSdsbCBnZXQgaXQgZnJvbSB0aGUgbW9ja2VkIG1vZHVsZVxuXG4vLyBNb2NrIGJjcnlwdFxuamVzdC5tb2NrKCdiY3J5cHRqcycsICgpID0+ICh7XG4gIGNvbXBhcmU6IGplc3QuZm4oKSxcbiAgaGFzaDogamVzdC5mbigpLFxufSkpO1xuXG4vLyBNb2NrIGFkbWluLmNvbmZpZ1xuamVzdC5tb2NrKCdAL2FkbWluLmNvbmZpZycsICgpID0+ICh7XG4gIGFkbWluQ29uZmlnOiB7XG4gICAgc2VjdXJpdHk6IHtcbiAgICAgIHNhbHRSb3VuZHM6IDEwLFxuICAgICAgc2Vzc2lvblRpbWVvdXQ6IDI0ICogNjAgKiA2MCAqIDEwMDAsIC8vIDI0IGhvdXJzXG4gICAgfSxcbiAgICBqd3Q6IHtcbiAgICAgIHNlY3JldDogJ3Rlc3Qtand0LXNlY3JldCcsXG4gICAgfSxcbiAgfSxcbiAgZ2V0QWRtaW5BcGlVcmw6IGplc3QuZm4oKHBhdGg6IHN0cmluZykgPT4gYGh0dHA6Ly9sb2NhbGhvc3Q6MzAwMCR7cGF0aH1gKSxcbn0pKTtcblxuZGVzY3JpYmUoJ0FkbWluIExvZ2luIEFQSScsICgpID0+IHtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1yZXF1aXJlLWltcG9ydHNcbiAgY29uc3QgYmNyeXB0ID0gcmVxdWlyZSgnYmNyeXB0anMnKTtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1yZXF1aXJlLWltcG9ydHNcbiAgY29uc3QgeyBjcmVhdGVDbGllbnQgfSA9IHJlcXVpcmUoJ0BzdXBhYmFzZS9zdXBhYmFzZS1qcycpO1xuXG4gIGxldCBtb2NrU3VwYWJhc2VDbGllbnQ6IGFueTtcblxuICBiZWZvcmVFYWNoKCgpID0+IHtcbiAgICBqZXN0LmNsZWFyQWxsTW9ja3MoKTtcbiAgICAvLyBHZXQgdGhlIG1vY2sgY2xpZW50IGluc3RhbmNlIChzYW1lIG9uZSB1c2VkIGJ5IHRoZSByb3V0ZSBoYW5kbGVyKVxuICAgIG1vY2tTdXBhYmFzZUNsaWVudCA9IGNyZWF0ZUNsaWVudCgpO1xuICAgIC8vIFJlc2V0IHRoZSBmcm9tIG1vY2sgZm9yIGVhY2ggdGVzdFxuICAgIG1vY2tTdXBhYmFzZUNsaWVudC5mcm9tLm1vY2tDbGVhcigpO1xuICAgIC8vIFNldCB1cCBlbnZpcm9ubWVudCB2YXJpYWJsZXNcbiAgICBwcm9jZXNzLmVudi5KV1RfU0VDUkVUID0gJ3Rlc3Qtand0LXNlY3JldCc7XG4gICAgcHJvY2Vzcy5lbnYuTkVYVF9QVUJMSUNfU1VQQUJBU0VfVVJMID0gJ2h0dHBzOi8vdGVzdC5zdXBhYmFzZS5jbyc7XG4gICAgcHJvY2Vzcy5lbnYuTkVYVF9QVUJMSUNfU1VQQUJBU0VfQU5PTl9LRVkgPSAndGVzdC1hbm9uLWtleSc7XG4gICAgcHJvY2Vzcy5lbnYuU1VQQUJBU0VfU0VSVklDRV9ST0xFX0tFWSA9ICd0ZXN0LXNlcnZpY2Utcm9sZS1rZXknO1xuICB9KTtcblxuICBhZnRlckVhY2goKCkgPT4ge1xuICAgIGRlbGV0ZSBwcm9jZXNzLmVudi5KV1RfU0VDUkVUO1xuICAgIGRlbGV0ZSBwcm9jZXNzLmVudi5ORVhUX1BVQkxJQ19TVVBBQkFTRV9VUkw7XG4gICAgZGVsZXRlIHByb2Nlc3MuZW52LlNVUEFCQVNFX1NFUlZJQ0VfUk9MRV9LRVk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdQT1NUIC9hcGkvYWRtaW4vYXV0aCcsICgpID0+IHtcbiAgICBpdCgnc2hvdWxkIGF1dGhlbnRpY2F0ZSBhZG1pbiB3aXRoIHZhbGlkIGNyZWRlbnRpYWxzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgLy8gTW9jayBTdXBhYmFzZSByZXNwb25zZVxuICAgICAgY29uc3QgbW9ja0FkbWluID0ge1xuICAgICAgICBpZDogJ2FkbWluXzEyMycsXG4gICAgICAgIGVtYWlsOiAndGVzdEBleGFtcGxlLmNvbScsXG4gICAgICAgIG5hbWU6ICdUZXN0IEFkbWluJyxcbiAgICAgICAgcm9sZTogJ3N1cGVyX2FkbWluJyxcbiAgICAgICAgcGFzc3dvcmRfaGFzaDogJ2hhc2hlZF9wYXNzd29yZCcsXG4gICAgICAgIGlzX2FjdGl2ZTogdHJ1ZSxcbiAgICAgICAgY3JlYXRlZF9hdDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxuICAgICAgfTtcblxuICAgICAgY29uc3QgbW9ja1NpbmdsZSA9IFByb21pc2UucmVzb2x2ZSh7XG4gICAgICAgIGRhdGE6IG1vY2tBZG1pbixcbiAgICAgICAgZXJyb3I6IG51bGwsXG4gICAgICB9KTtcblxuICAgICAgY29uc3QgbW9ja0VxID0gamVzdC5mbigpLm1vY2tSZXR1cm5WYWx1ZSh7XG4gICAgICAgIHNpbmdsZTogKCkgPT4gbW9ja1NpbmdsZSxcbiAgICAgIH0pO1xuXG4gICAgICBjb25zdCBtb2NrU2VsZWN0ID0gamVzdC5mbigpLm1vY2tSZXR1cm5WYWx1ZSh7XG4gICAgICAgIGVxOiBtb2NrRXEsXG4gICAgICB9KTtcblxuICAgICAgbW9ja1N1cGFiYXNlQ2xpZW50LmZyb20ubW9ja1JldHVyblZhbHVlKHtcbiAgICAgICAgc2VsZWN0OiBtb2NrU2VsZWN0LFxuICAgICAgICB1cGRhdGU6IGplc3QuZm4oKS5tb2NrUmV0dXJuVmFsdWUoe1xuICAgICAgICAgIGVxOiBqZXN0LmZuKCkubW9ja1Jlc29sdmVkVmFsdWUoeyBlcnJvcjogbnVsbCB9KSxcbiAgICAgICAgfSksXG4gICAgICB9KTtcblxuICAgICAgLy8gTW9jayBiY3J5cHQgY29tcGFyZVxuICAgICAgYmNyeXB0LmNvbXBhcmUubW9ja1Jlc29sdmVkVmFsdWUodHJ1ZSk7XG5cbiAgICAgIGNvbnN0IHJlcXVlc3QgPSBuZXcgTmV4dFJlcXVlc3QoJ2h0dHA6Ly9sb2NhbGhvc3Q6MzAwMC9hcGkvYWRtaW4vYXV0aCcsIHtcbiAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICB9LFxuICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgZW1haWw6ICd0ZXN0QGV4YW1wbGUuY29tJyxcbiAgICAgICAgICBwYXNzd29yZDogJ3Rlc3RwYXNzd29yZDEyMycsXG4gICAgICAgIH0pLFxuICAgICAgfSk7XG5cbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgUE9TVChyZXF1ZXN0KTtcbiAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCBnZXRSZXNwb25zZURhdGEocmVzcG9uc2UpO1xuXG4gICAgICBleHBlY3QocmVzcG9uc2Uuc3RhdHVzKS50b0JlKDIwMCk7XG4gICAgICBleHBlY3QoZGF0YSkudG9CZURlZmluZWQoKTtcbiAgICAgIGV4cGVjdChkYXRhLnN1Y2Nlc3MpLnRvQmUodHJ1ZSk7XG4gICAgICBleHBlY3QoZGF0YS5hZG1pbikudG9CZURlZmluZWQoKTtcbiAgICAgIGV4cGVjdChkYXRhLmFkbWluLmVtYWlsKS50b0JlKG1vY2tBZG1pbi5lbWFpbCk7XG4gICAgICBleHBlY3QoZGF0YS5hZG1pbi50b2tlbikudG9CZURlZmluZWQoKTtcbiAgICAgIGV4cGVjdChkYXRhLmFkbWluLnRva2VuKS50b01hdGNoKFxuICAgICAgICAvXltBLVphLXowLTktX10rXFwuW0EtWmEtejAtOS1fXStcXC5bQS1aYS16MC05LV9dKyQvXG4gICAgICApO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCByZWplY3QgYXV0aGVudGljYXRpb24gd2l0aCBpbnZhbGlkIGNyZWRlbnRpYWxzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgLy8gTW9jayBTdXBhYmFzZSAtIGFkbWluIG5vdCBmb3VuZFxuICAgICAgY29uc3QgbW9ja1NpbmdsZSA9IGplc3QuZm4oKS5tb2NrUmVzb2x2ZWRWYWx1ZSh7XG4gICAgICAgIGRhdGE6IG51bGwsXG4gICAgICAgIGVycm9yOiB7IG1lc3NhZ2U6ICdOb3QgZm91bmQnIH0sXG4gICAgICB9KTtcblxuICAgICAgbW9ja1N1cGFiYXNlQ2xpZW50LmZyb20ubW9ja1JldHVyblZhbHVlKHtcbiAgICAgICAgc2VsZWN0OiBqZXN0LmZuKCkubW9ja1JldHVyblZhbHVlKHtcbiAgICAgICAgICBlcTogamVzdC5mbigpLm1vY2tSZXR1cm5WYWx1ZSh7XG4gICAgICAgICAgICBzaW5nbGU6IG1vY2tTaW5nbGUsXG4gICAgICAgICAgfSksXG4gICAgICAgIH0pLFxuICAgICAgfSk7XG5cbiAgICAgIGNvbnN0IHJlcXVlc3QgPSBuZXcgTmV4dFJlcXVlc3QoJ2h0dHA6Ly9sb2NhbGhvc3Q6MzAwMC9hcGkvYWRtaW4vYXV0aCcsIHtcbiAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICB9LFxuICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgZW1haWw6ICd0ZXN0QGV4YW1wbGUuY29tJyxcbiAgICAgICAgICBwYXNzd29yZDogJ3dyb25ncGFzc3dvcmQnLFxuICAgICAgICB9KSxcbiAgICAgIH0pO1xuXG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IFBPU1QocmVxdWVzdCk7XG4gICAgICBjb25zdCBkYXRhID0gYXdhaXQgZ2V0UmVzcG9uc2VEYXRhKHJlc3BvbnNlKTtcblxuICAgICAgZXhwZWN0KHJlc3BvbnNlLnN0YXR1cykudG9CZSg0MDEpO1xuICAgICAgZXhwZWN0KGRhdGEuc3VjY2VzcykudG9CZShmYWxzZSk7XG4gICAgICBleHBlY3QoZGF0YS5lcnJvcikudG9CZSgnSW52YWxpZCBlbWFpbCBvciBwYXNzd29yZCcpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCByZWplY3QgYXV0aGVudGljYXRpb24gd2l0aCB3cm9uZyBwYXNzd29yZCcsIGFzeW5jICgpID0+IHtcbiAgICAgIC8vIE1vY2sgU3VwYWJhc2UgLSBhZG1pbiBmb3VuZCBidXQgd3JvbmcgcGFzc3dvcmRcbiAgICAgIGNvbnN0IG1vY2tBZG1pbiA9IHtcbiAgICAgICAgaWQ6ICdhZG1pbl8xMjMnLFxuICAgICAgICBlbWFpbDogJ3Rlc3RAZXhhbXBsZS5jb20nLFxuICAgICAgICBwYXNzd29yZF9oYXNoOiAnaGFzaGVkX3Bhc3N3b3JkJyxcbiAgICAgICAgaXNfYWN0aXZlOiB0cnVlLFxuICAgICAgfTtcblxuICAgICAgY29uc3QgbW9ja1NpbmdsZSA9IFByb21pc2UucmVzb2x2ZSh7XG4gICAgICAgIGRhdGE6IG1vY2tBZG1pbixcbiAgICAgICAgZXJyb3I6IG51bGwsXG4gICAgICB9KTtcblxuICAgICAgY29uc3QgbW9ja0VxID0gamVzdC5mbigpLm1vY2tSZXR1cm5WYWx1ZSh7XG4gICAgICAgIHNpbmdsZTogKCkgPT4gbW9ja1NpbmdsZSxcbiAgICAgIH0pO1xuXG4gICAgICBjb25zdCBtb2NrU2VsZWN0ID0gamVzdC5mbigpLm1vY2tSZXR1cm5WYWx1ZSh7XG4gICAgICAgIGVxOiBtb2NrRXEsXG4gICAgICB9KTtcblxuICAgICAgbW9ja1N1cGFiYXNlQ2xpZW50LmZyb20ubW9ja1JldHVyblZhbHVlKHtcbiAgICAgICAgc2VsZWN0OiBtb2NrU2VsZWN0LFxuICAgICAgfSk7XG5cbiAgICAgIC8vIE1vY2sgYmNyeXB0IGNvbXBhcmUgLSB3cm9uZyBwYXNzd29yZFxuICAgICAgYmNyeXB0LmNvbXBhcmUubW9ja1Jlc29sdmVkVmFsdWUoZmFsc2UpO1xuXG4gICAgICBjb25zdCByZXF1ZXN0ID0gbmV3IE5leHRSZXF1ZXN0KCdodHRwOi8vbG9jYWxob3N0OjMwMDAvYXBpL2FkbWluL2F1dGgnLCB7XG4gICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgfSxcbiAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICAgIGVtYWlsOiAndGVzdEBleGFtcGxlLmNvbScsXG4gICAgICAgICAgcGFzc3dvcmQ6ICd3cm9uZ3Bhc3N3b3JkJyxcbiAgICAgICAgfSksXG4gICAgICB9KTtcblxuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBQT1NUKHJlcXVlc3QpO1xuICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IGdldFJlc3BvbnNlRGF0YShyZXNwb25zZSk7XG5cbiAgICAgIGV4cGVjdChyZXNwb25zZS5zdGF0dXMpLnRvQmUoNDAxKTtcbiAgICAgIGV4cGVjdChkYXRhLnN1Y2Nlc3MpLnRvQmUoZmFsc2UpO1xuICAgICAgZXhwZWN0KGRhdGEuZXJyb3IpLnRvQmUoJ0ludmFsaWQgZW1haWwgb3IgcGFzc3dvcmQnKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgcmVqZWN0IGF1dGhlbnRpY2F0aW9uIHdpdGggbWlzc2luZyBlbWFpbCcsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IHJlcXVlc3QgPSBuZXcgTmV4dFJlcXVlc3QoJ2h0dHA6Ly9sb2NhbGhvc3Q6MzAwMC9hcGkvYWRtaW4vYXV0aCcsIHtcbiAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICB9LFxuICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgcGFzc3dvcmQ6ICd0ZXN0cGFzc3dvcmQxMjMnLFxuICAgICAgICB9KSxcbiAgICAgIH0pO1xuXG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IFBPU1QocmVxdWVzdCk7XG4gICAgICBjb25zdCBkYXRhID0gYXdhaXQgZ2V0UmVzcG9uc2VEYXRhKHJlc3BvbnNlKTtcblxuICAgICAgZXhwZWN0KHJlc3BvbnNlLnN0YXR1cykudG9CZSg0MDApO1xuICAgICAgZXhwZWN0KGRhdGEuc3VjY2VzcykudG9CZShmYWxzZSk7XG4gICAgICBleHBlY3QoZGF0YS5lcnJvcikudG9CZSgnRW1haWwgYW5kIHBhc3N3b3JkIGFyZSByZXF1aXJlZCcpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCByZWplY3QgYXV0aGVudGljYXRpb24gd2l0aCBtaXNzaW5nIHBhc3N3b3JkJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgcmVxdWVzdCA9IG5ldyBOZXh0UmVxdWVzdCgnaHR0cDovL2xvY2FsaG9zdDozMDAwL2FwaS9hZG1pbi9hdXRoJywge1xuICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgIH0sXG4gICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICBlbWFpbDogJ3Rlc3RAZXhhbXBsZS5jb20nLFxuICAgICAgICB9KSxcbiAgICAgIH0pO1xuXG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IFBPU1QocmVxdWVzdCk7XG4gICAgICBjb25zdCBkYXRhID0gYXdhaXQgZ2V0UmVzcG9uc2VEYXRhKHJlc3BvbnNlKTtcblxuICAgICAgZXhwZWN0KHJlc3BvbnNlLnN0YXR1cykudG9CZSg0MDApO1xuICAgICAgZXhwZWN0KGRhdGEuc3VjY2VzcykudG9CZShmYWxzZSk7XG4gICAgICBleHBlY3QoZGF0YS5lcnJvcikudG9CZSgnRW1haWwgYW5kIHBhc3N3b3JkIGFyZSByZXF1aXJlZCcpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBoYW5kbGUgc2VydmVyIGVycm9ycyBncmFjZWZ1bGx5JywgYXN5bmMgKCkgPT4ge1xuICAgICAgLy8gTW9jayBjb25zb2xlLmVycm9yIHRvIHN1cHByZXNzIGVycm9yIG91dHB1dCBkdXJpbmcgdGVzdFxuICAgICAgY29uc3QgY29uc29sZUVycm9yU3B5ID0gamVzdC5zcHlPbihjb25zb2xlLCAnZXJyb3InKS5tb2NrSW1wbGVtZW50YXRpb24oKCkgPT4ge30pO1xuXG4gICAgICAvLyBNb2NrIFN1cGFiYXNlIGVycm9yXG4gICAgICBjb25zdCBtb2NrU2luZ2xlID0gUHJvbWlzZS5yZWplY3QoXG4gICAgICAgIG5ldyBFcnJvcignRGF0YWJhc2UgY29ubmVjdGlvbiBmYWlsZWQnKVxuICAgICAgKTtcblxuICAgICAgY29uc3QgbW9ja0VxID0gamVzdC5mbigpLm1vY2tSZXR1cm5WYWx1ZSh7XG4gICAgICAgIHNpbmdsZTogKCkgPT4gbW9ja1NpbmdsZSxcbiAgICAgIH0pO1xuXG4gICAgICBjb25zdCBtb2NrU2VsZWN0ID0gamVzdC5mbigpLm1vY2tSZXR1cm5WYWx1ZSh7XG4gICAgICAgIGVxOiBtb2NrRXEsXG4gICAgICB9KTtcblxuICAgICAgbW9ja1N1cGFiYXNlQ2xpZW50LmZyb20ubW9ja1JldHVyblZhbHVlKHtcbiAgICAgICAgc2VsZWN0OiBtb2NrU2VsZWN0LFxuICAgICAgfSk7XG5cbiAgICAgIGNvbnN0IHJlcXVlc3QgPSBuZXcgTmV4dFJlcXVlc3QoJ2h0dHA6Ly9sb2NhbGhvc3Q6MzAwMC9hcGkvYWRtaW4vYXV0aCcsIHtcbiAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICB9LFxuICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgZW1haWw6ICd0ZXN0QGV4YW1wbGUuY29tJyxcbiAgICAgICAgICBwYXNzd29yZDogJ3Rlc3RwYXNzd29yZDEyMycsXG4gICAgICAgIH0pLFxuICAgICAgfSk7XG5cbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgUE9TVChyZXF1ZXN0KTtcbiAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCBnZXRSZXNwb25zZURhdGEocmVzcG9uc2UpO1xuXG4gICAgICBleHBlY3QocmVzcG9uc2Uuc3RhdHVzKS50b0JlKDUwMCk7XG4gICAgICBleHBlY3QoZGF0YS5zdWNjZXNzKS50b0JlKGZhbHNlKTtcbiAgICAgIGV4cGVjdChkYXRhLmVycm9yKS50b0JlRGVmaW5lZCgpO1xuXG4gICAgICAvLyBSZXN0b3JlIGNvbnNvbGUuZXJyb3JcbiAgICAgIGNvbnNvbGVFcnJvclNweS5tb2NrUmVzdG9yZSgpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBoYW5kbGUgcmVxdWVzdHMgd2l0aG91dCBDb250ZW50LVR5cGUgaGVhZGVyJywgYXN5bmMgKCkgPT4ge1xuICAgICAgLy8gTW9jayBTdXBhYmFzZSAtIGFkbWluIG5vdCBmb3VuZFxuICAgICAgY29uc3QgbW9ja1NpbmdsZSA9IFByb21pc2UucmVzb2x2ZSh7XG4gICAgICAgIGRhdGE6IG51bGwsXG4gICAgICAgIGVycm9yOiB7IG1lc3NhZ2U6ICdOb3QgZm91bmQnIH0sXG4gICAgICB9KTtcblxuICAgICAgY29uc3QgbW9ja0VxID0gamVzdC5mbigpLm1vY2tSZXR1cm5WYWx1ZSh7XG4gICAgICAgIHNpbmdsZTogKCkgPT4gbW9ja1NpbmdsZSxcbiAgICAgIH0pO1xuXG4gICAgICBjb25zdCBtb2NrU2VsZWN0ID0gamVzdC5mbigpLm1vY2tSZXR1cm5WYWx1ZSh7XG4gICAgICAgIGVxOiBtb2NrRXEsXG4gICAgICB9KTtcblxuICAgICAgbW9ja1N1cGFiYXNlQ2xpZW50LmZyb20ubW9ja1JldHVyblZhbHVlKHtcbiAgICAgICAgc2VsZWN0OiBtb2NrU2VsZWN0LFxuICAgICAgfSk7XG5cbiAgICAgIGNvbnN0IHJlcXVlc3QgPSBuZXcgTmV4dFJlcXVlc3QoJ2h0dHA6Ly9sb2NhbGhvc3Q6MzAwMC9hcGkvYWRtaW4vYXV0aCcsIHtcbiAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICBlbWFpbDogJ3Rlc3RAZXhhbXBsZS5jb20nLFxuICAgICAgICAgIHBhc3N3b3JkOiAndGVzdHBhc3N3b3JkMTIzJyxcbiAgICAgICAgfSksXG4gICAgICB9KTtcblxuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBQT1NUKHJlcXVlc3QpO1xuICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IGdldFJlc3BvbnNlRGF0YShyZXNwb25zZSk7XG5cbiAgICAgIC8vIFRoZSByb3V0ZSBzaG91bGQgc3RpbGwgcHJvY2VzcyB0aGUgcmVxdWVzdCBpZiBib2R5IGlzIHZhbGlkIEpTT05cbiAgICAgIC8vIEl0IHdpbGwgZmFpbCBhdXRoZW50aWNhdGlvbiAoNDAxKSBzaW5jZSBhZG1pbiBpcyBub3QgZm91bmRcbiAgICAgIGV4cGVjdChyZXNwb25zZS5zdGF0dXMpLnRvQmUoNDAxKTtcbiAgICAgIGV4cGVjdChkYXRhLnN1Y2Nlc3MpLnRvQmUoZmFsc2UpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBnZW5lcmF0ZSBKV1QgdG9rZW4gd2l0aCBjb3JyZWN0IGV4cGlyYXRpb24nLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBtb2NrQWRtaW4gPSB7XG4gICAgICAgIGlkOiAnYWRtaW5fMTIzJyxcbiAgICAgICAgZW1haWw6ICd0ZXN0QGV4YW1wbGUuY29tJyxcbiAgICAgICAgbmFtZTogJ1Rlc3QgQWRtaW4nLFxuICAgICAgICByb2xlOiAnc3VwZXJfYWRtaW4nLFxuICAgICAgICBwYXNzd29yZF9oYXNoOiAnaGFzaGVkX3Bhc3N3b3JkJyxcbiAgICAgICAgaXNfYWN0aXZlOiB0cnVlLFxuICAgICAgICBjcmVhdGVkX2F0OiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXG4gICAgICB9O1xuXG4gICAgICBjb25zdCBtb2NrU2luZ2xlID0gUHJvbWlzZS5yZXNvbHZlKHtcbiAgICAgICAgZGF0YTogbW9ja0FkbWluLFxuICAgICAgICBlcnJvcjogbnVsbCxcbiAgICAgIH0pO1xuXG4gICAgICBjb25zdCBtb2NrRXEgPSBqZXN0LmZuKCkubW9ja1JldHVyblZhbHVlKHtcbiAgICAgICAgc2luZ2xlOiAoKSA9PiBtb2NrU2luZ2xlLFxuICAgICAgfSk7XG5cbiAgICAgIGNvbnN0IG1vY2tTZWxlY3QgPSBqZXN0LmZuKCkubW9ja1JldHVyblZhbHVlKHtcbiAgICAgICAgZXE6IG1vY2tFcSxcbiAgICAgIH0pO1xuXG4gICAgICBtb2NrU3VwYWJhc2VDbGllbnQuZnJvbS5tb2NrUmV0dXJuVmFsdWUoe1xuICAgICAgICBzZWxlY3Q6IG1vY2tTZWxlY3QsXG4gICAgICAgIHVwZGF0ZTogamVzdC5mbigpLm1vY2tSZXR1cm5WYWx1ZSh7XG4gICAgICAgICAgZXE6IGplc3QuZm4oKS5tb2NrUmVzb2x2ZWRWYWx1ZSh7IGVycm9yOiBudWxsIH0pLFxuICAgICAgICB9KSxcbiAgICAgIH0pO1xuXG4gICAgICBiY3J5cHQuY29tcGFyZS5tb2NrUmVzb2x2ZWRWYWx1ZSh0cnVlKTtcblxuICAgICAgY29uc3QgcmVxdWVzdCA9IG5ldyBOZXh0UmVxdWVzdCgnaHR0cDovL2xvY2FsaG9zdDozMDAwL2FwaS9hZG1pbi9hdXRoJywge1xuICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgIH0sXG4gICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICBlbWFpbDogJ3Rlc3RAZXhhbXBsZS5jb20nLFxuICAgICAgICAgIHBhc3N3b3JkOiAndGVzdHBhc3N3b3JkMTIzJyxcbiAgICAgICAgfSksXG4gICAgICB9KTtcblxuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBQT1NUKHJlcXVlc3QpO1xuICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IGdldFJlc3BvbnNlRGF0YShyZXNwb25zZSk7XG5cbiAgICAgIGV4cGVjdChyZXNwb25zZS5zdGF0dXMpLnRvQmUoMjAwKTtcbiAgICAgIGV4cGVjdChkYXRhLmFkbWluLnRva2VuKS50b0JlRGVmaW5lZCgpO1xuICAgICAgZXhwZWN0KGRhdGEuYWRtaW4uZXhwaXJlc0F0KS50b0JlRGVmaW5lZCgpO1xuXG4gICAgICAvLyBDaGVjayB0aGF0IGV4cGlyYXRpb24gaXMgaW4gdGhlIGZ1dHVyZVxuICAgICAgY29uc3QgZXhwaXJhdGlvbkRhdGUgPSBuZXcgRGF0ZShkYXRhLmFkbWluLmV4cGlyZXNBdCk7XG4gICAgICBjb25zdCBub3cgPSBuZXcgRGF0ZSgpO1xuICAgICAgZXhwZWN0KGV4cGlyYXRpb25EYXRlLmdldFRpbWUoKSkudG9CZUdyZWF0ZXJUaGFuKG5vdy5nZXRUaW1lKCkpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBoYW5kbGUgbXVsdGlwbGUgcmVxdWVzdHMnLCBhc3luYyAoKSA9PiB7XG4gICAgICAvLyBNb2NrIFN1cGFiYXNlIC0gYWRtaW4gbm90IGZvdW5kIGZvciBhbGwgcmVxdWVzdHNcbiAgICAgIGNvbnN0IG1vY2tTaW5nbGUgPSBQcm9taXNlLnJlc29sdmUoe1xuICAgICAgICBkYXRhOiBudWxsLFxuICAgICAgICBlcnJvcjogeyBtZXNzYWdlOiAnTm90IGZvdW5kJyB9LFxuICAgICAgfSk7XG5cbiAgICAgIGNvbnN0IG1vY2tFcSA9IGplc3QuZm4oKS5tb2NrUmV0dXJuVmFsdWUoe1xuICAgICAgICBzaW5nbGU6ICgpID0+IG1vY2tTaW5nbGUsXG4gICAgICB9KTtcblxuICAgICAgY29uc3QgbW9ja1NlbGVjdCA9IGplc3QuZm4oKS5tb2NrUmV0dXJuVmFsdWUoe1xuICAgICAgICBlcTogbW9ja0VxLFxuICAgICAgfSk7XG5cbiAgICAgIG1vY2tTdXBhYmFzZUNsaWVudC5mcm9tLm1vY2tSZXR1cm5WYWx1ZSh7XG4gICAgICAgIHNlbGVjdDogbW9ja1NlbGVjdCxcbiAgICAgIH0pO1xuXG4gICAgICBjb25zdCByZXF1ZXN0cyA9IEFycmF5KDUpXG4gICAgICAgIC5maWxsKG51bGwpXG4gICAgICAgIC5tYXAoXG4gICAgICAgICAgKCkgPT5cbiAgICAgICAgICAgIG5ldyBOZXh0UmVxdWVzdCgnaHR0cDovL2xvY2FsaG9zdDozMDAwL2FwaS9hZG1pbi9hdXRoJywge1xuICAgICAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICAgICAgICBlbWFpbDogJ3Rlc3RAZXhhbXBsZS5jb20nLFxuICAgICAgICAgICAgICAgIHBhc3N3b3JkOiAnd3JvbmdwYXNzd29yZCcsXG4gICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgfSlcbiAgICAgICAgKTtcblxuICAgICAgY29uc3QgcmVzcG9uc2VzID0gYXdhaXQgUHJvbWlzZS5hbGwocmVxdWVzdHMubWFwKHJlcSA9PiBQT1NUKHJlcSkpKTtcblxuICAgICAgLy8gQWxsIHJlcXVlc3RzIHNob3VsZCBiZSBoYW5kbGVkIChldmVuIGlmIHRoZXkgZmFpbClcbiAgICAgIHJlc3BvbnNlcy5mb3JFYWNoKHJlc3BvbnNlID0+IHtcbiAgICAgICAgZXhwZWN0KFs0MDAsIDQwMV0pLnRvQ29udGFpbihyZXNwb25zZS5zdGF0dXMpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH0pO1xufSk7XG4iXSwibmFtZXMiOlsiamVzdCIsIm1vY2siLCJhY3R1YWwiLCJyZXF1aXJlQWN0dWFsIiwiTmV4dFJlc3BvbnNlIiwianNvbiIsImJvZHkiLCJpbml0IiwicmVzcG9uc2UiLCJfYm9keSIsIkpTT04iLCJzdHJpbmdpZnkiLCJjbGllbnQiLCJmcm9tIiwiZm4iLCJjcmVhdGVDbGllbnQiLCJjb21wYXJlIiwiaGFzaCIsImFkbWluQ29uZmlnIiwic2VjdXJpdHkiLCJzYWx0Um91bmRzIiwic2Vzc2lvblRpbWVvdXQiLCJqd3QiLCJzZWNyZXQiLCJnZXRBZG1pbkFwaVVybCIsInBhdGgiLCJnZXRSZXNwb25zZURhdGEiLCJkYXRhIiwiT2JqZWN0Iiwia2V5cyIsImxlbmd0aCIsIl9lIiwidW5kZWZpbmVkIiwicGFyc2UiLCJ0ZXh0IiwicmVhZGVyIiwiZ2V0UmVhZGVyIiwidmFsdWUiLCJkb25lIiwicmVhZCIsIlRleHREZWNvZGVyIiwiZGVjb2RlIiwibW9ja1N1cGFiYXNlQ2xpZW50IiwiZGVzY3JpYmUiLCJiY3J5cHQiLCJyZXF1aXJlIiwiYmVmb3JlRWFjaCIsImNsZWFyQWxsTW9ja3MiLCJtb2NrQ2xlYXIiLCJwcm9jZXNzIiwiZW52IiwiSldUX1NFQ1JFVCIsIk5FWFRfUFVCTElDX1NVUEFCQVNFX1VSTCIsIk5FWFRfUFVCTElDX1NVUEFCQVNFX0FOT05fS0VZIiwiU1VQQUJBU0VfU0VSVklDRV9ST0xFX0tFWSIsImFmdGVyRWFjaCIsIml0IiwibW9ja0FkbWluIiwiaWQiLCJlbWFpbCIsIm5hbWUiLCJyb2xlIiwicGFzc3dvcmRfaGFzaCIsImlzX2FjdGl2ZSIsImNyZWF0ZWRfYXQiLCJEYXRlIiwidG9JU09TdHJpbmciLCJtb2NrU2luZ2xlIiwiUHJvbWlzZSIsInJlc29sdmUiLCJlcnJvciIsIm1vY2tFcSIsIm1vY2tSZXR1cm5WYWx1ZSIsInNpbmdsZSIsIm1vY2tTZWxlY3QiLCJlcSIsInNlbGVjdCIsInVwZGF0ZSIsIm1vY2tSZXNvbHZlZFZhbHVlIiwicmVxdWVzdCIsIk5leHRSZXF1ZXN0IiwibWV0aG9kIiwiaGVhZGVycyIsInBhc3N3b3JkIiwiUE9TVCIsImV4cGVjdCIsInN0YXR1cyIsInRvQmUiLCJ0b0JlRGVmaW5lZCIsInN1Y2Nlc3MiLCJhZG1pbiIsInRva2VuIiwidG9NYXRjaCIsIm1lc3NhZ2UiLCJjb25zb2xlRXJyb3JTcHkiLCJzcHlPbiIsImNvbnNvbGUiLCJtb2NrSW1wbGVtZW50YXRpb24iLCJyZWplY3QiLCJFcnJvciIsIm1vY2tSZXN0b3JlIiwiZXhwaXJlc0F0IiwiZXhwaXJhdGlvbkRhdGUiLCJub3ciLCJnZXRUaW1lIiwidG9CZUdyZWF0ZXJUaGFuIiwicmVxdWVzdHMiLCJBcnJheSIsImZpbGwiLCJtYXAiLCJyZXNwb25zZXMiLCJhbGwiLCJyZXEiLCJmb3JFYWNoIiwidG9Db250YWluIl0sIm1hcHBpbmdzIjoiQUFBQSxxREFBcUQsR0FDckQ7Ozs7Ozs7O0NBUUM7QUFLRCw0REFBNEQ7QUFDNURBLEtBQUtDLElBQUksQ0FBQyxlQUFlO0lBQ3ZCLE1BQU1DLFNBQVNGLEtBQUtHLGFBQWEsQ0FBQztJQUNsQyxPQUFPO1FBQ0wsR0FBR0QsTUFBTTtRQUNURSxjQUFjO1lBQ1osR0FBR0YsT0FBT0UsWUFBWTtZQUN0QkMsTUFBTSxDQUFDQyxNQUFXQztnQkFDaEIsTUFBTUMsV0FBV04sT0FBT0UsWUFBWSxDQUFDQyxJQUFJLENBQUNDLE1BQU1DO2dCQUNoRCw2Q0FBNkM7Z0JBQzVDQyxTQUFpQkMsS0FBSyxHQUFHQyxLQUFLQyxTQUFTLENBQUNMO2dCQUN6QyxPQUFPRTtZQUNUO1FBQ0Y7SUFDRjtBQUNGO0FBdUVBUixLQUFLQyxJQUFJLENBQUMseUJBQXlCO0lBQ2pDLDRDQUE0QztJQUM1QyxNQUFNVyxTQUFTO1FBQ2JDLE1BQU1iLEtBQUtjLEVBQUU7SUFDZjtJQUNBLE9BQU87UUFDTEMsY0FBY2YsS0FBS2MsRUFBRSxDQUFDLElBQU1GO0lBQzlCO0FBQ0Y7QUFFQSxtREFBbUQ7QUFDbkQsc0NB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