fa51f6df56641499ad323f96439beb48
/**
 * Integration Tests for Get Started Page (G-IT-003, G-IT-004, G-IT-005)
 * Task: G-002 - Get Started Page
 */ "use strict";
// Mock shared contexts
jest.mock('@elzatona/shared-contexts', ()=>{
    const actual = jest.requireActual('../../test-utils/mocks/shared-contexts');
    return {
        ...actual,
        useUserType: jest.fn()
    };
});
jest.mock('../../context/LearningTypeContext', ()=>({
        useLearningType: jest.fn(()=>({
                learningType: null,
                setLearningType: mockSetLearningType
            }))
    }));
// Mock lucide-react icons
jest.mock('lucide-react', ()=>({
        ArrowRight: ()=>/*#__PURE__*/ (0, _jsxruntime.jsx)("span", {
                "data-testid": "arrow-right-icon",
                children: "→"
            }),
        Play: ()=>/*#__PURE__*/ (0, _jsxruntime.jsx)("span", {
                "data-testid": "play-icon",
                children: "▶"
            }),
        Code: ()=>/*#__PURE__*/ (0, _jsxruntime.jsx)("span", {
                "data-testid": "code-icon",
                children: "\uD83D\uDCBB"
            }),
        Target: ()=>/*#__PURE__*/ (0, _jsxruntime.jsx)("span", {
                "data-testid": "target-icon",
                children: "\uD83C\uDFAF"
            }),
        BookOpen: ()=>/*#__PURE__*/ (0, _jsxruntime.jsx)("span", {
                "data-testid": "book-icon",
                children: "\uD83D\uDCD6"
            }),
        CheckCircle: ()=>/*#__PURE__*/ (0, _jsxruntime.jsx)("span", {
                "data-testid": "check-icon",
                children: "✓"
            }),
        Star: ()=>/*#__PURE__*/ (0, _jsxruntime.jsx)("span", {
                "data-testid": "star-icon",
                children: "⭐"
            }),
        Users: ()=>/*#__PURE__*/ (0, _jsxruntime.jsx)("span", {
                "data-testid": "users-icon",
                children: "\uD83D\uDC65"
            }),
        Award: ()=>/*#__PURE__*/ (0, _jsxruntime.jsx)("span", {
                "data-testid": "award-icon",
                children: "\uD83C\uDFC6"
            }),
        Map: ()=>/*#__PURE__*/ (0, _jsxruntime.jsx)("span", {
                "data-testid": "map-icon",
                children: "\uD83D\uDDFA️"
            }),
        Compass: ()=>/*#__PURE__*/ (0, _jsxruntime.jsx)("span", {
                "data-testid": "compass-icon",
                children: "\uD83E\uDDED"
            }),
        ExternalLink: ()=>/*#__PURE__*/ (0, _jsxruntime.jsx)("span", {
                "data-testid": "external-icon",
                children: "\uD83D\uDD17"
            })
    }));
jest.mock('next/navigation', ()=>({
        useRouter: ()=>mockUseRouter()
    }));
Object.defineProperty(exports, "__esModule", {
    value: true
});
const _jsxruntime = require("react/jsx-runtime");
const _react = /*#__PURE__*/ _interop_require_default(require("react"));
const _react1 = require("@testing-library/react");
require("@testing-library/jest-dom");
const _page = /*#__PURE__*/ _interop_require_default(require("./page"));
const _sharedcontexts = /*#__PURE__*/ _interop_require_wildcard(require("../../../../../libs/shared-contexts/src"));
function _interop_require_default(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
function _getRequireWildcardCache(nodeInterop) {
    if (typeof WeakMap !== "function") return null;
    var cacheBabelInterop = new WeakMap();
    var cacheNodeInterop = new WeakMap();
    return (_getRequireWildcardCache = function(nodeInterop) {
        return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
    })(nodeInterop);
}
function _interop_require_wildcard(obj, nodeInterop) {
    if (!nodeInterop && obj && obj.__esModule) {
        return obj;
    }
    if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return {
            default: obj
        };
    }
    var cache = _getRequireWildcardCache(nodeInterop);
    if (cache && cache.has(obj)) {
        return cache.get(obj);
    }
    var newObj = {
        __proto__: null
    };
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for(var key in obj){
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
            if (desc && (desc.get || desc.set)) {
                Object.defineProperty(newObj, key, desc);
            } else {
                newObj[key] = obj[key];
            }
        }
    }
    newObj.default = obj;
    if (cache) {
        cache.set(obj, newObj);
    }
    return newObj;
}
// Mock LearningTypeContext
const mockSetLearningType = jest.fn();
const mockPush = jest.fn();
const mockSetUserType = jest.fn();
const mockUseRouter = jest.fn();
describe('G-IT-003: User Type Selection Updates State', ()=>{
    beforeEach(()=>{
        jest.clearAllMocks();
        jest.useFakeTimers();
        _sharedcontexts.useUserType.mockReturnValue({
            userType: null,
            setUserType: mockSetUserType
        });
        mockUseRouter.mockReturnValue({
            push: mockPush,
            replace: jest.fn(),
            prefetch: jest.fn()
        });
    });
    afterEach(()=>{
        jest.runOnlyPendingTimers();
        jest.useRealTimers();
    });
    it('should call setUserType when "I need guidance" is selected', async ()=>{
        (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_page.default, {}));
        const guidedOption = _react1.screen.getByText(/I need guidance/i).closest('div[class*="cursor-pointer"]');
        if (guidedOption) {
            _react1.fireEvent.click(guidedOption);
            jest.advanceTimersByTime(300);
            await (0, _react1.waitFor)(()=>{
                expect(mockSetUserType).toHaveBeenCalledWith('guided');
            });
        }
    });
    it('should call setUserType when "I\'m self-directed" is selected', async ()=>{
        (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_page.default, {}));
        const selfDirectedOption = _react1.screen.getByText(/I'm self-directed/i).closest('div[class*="cursor-pointer"]');
        if (selfDirectedOption) {
            _react1.fireEvent.click(selfDirectedOption);
            jest.advanceTimersByTime(300);
            await (0, _react1.waitFor)(()=>{
                expect(mockSetUserType).toHaveBeenCalledWith('self-directed');
            });
        }
    });
});
describe('G-IT-004: "I need guidance" Navigates to Guided Learning', ()=>{
    beforeEach(()=>{
        jest.clearAllMocks();
        jest.useFakeTimers();
        _sharedcontexts.useUserType.mockReturnValue({
            userType: null,
            setUserType: mockSetUserType
        });
        mockPush.mockClear();
        mockUseRouter.mockReturnValue({
            push: mockPush,
            replace: jest.fn(),
            prefetch: jest.fn()
        });
    });
    afterEach(()=>{
        jest.runOnlyPendingTimers();
        jest.useRealTimers();
    });
    it('should navigate to /features/guided-learning when "I need guidance" is selected', async ()=>{
        (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_page.default, {}));
        const guidedOption = _react1.screen.getByText(/I need guidance/i).closest('div[class*="cursor-pointer"]');
        if (guidedOption) {
            _react1.fireEvent.click(guidedOption);
            // Advance timers to trigger navigation (1500ms delay)
            jest.advanceTimersByTime(1800);
            await (0, _react1.waitFor)(()=>{
                expect(mockPush).toHaveBeenCalledWith('/features/guided-learning');
            });
        }
    });
    it('should set learning type to "guided" when navigating', async ()=>{
        (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_page.default, {}));
        const guidedOption = _react1.screen.getByText(/I need guidance/i).closest('div[class*="cursor-pointer"]');
        if (guidedOption) {
            _react1.fireEvent.click(guidedOption);
            jest.advanceTimersByTime(300);
            await (0, _react1.waitFor)(()=>{
                expect(mockSetLearningType).toHaveBeenCalledWith('guided');
            });
        }
    });
});
describe('G-IT-005: "I\'m self-directed" Navigates to Browse Page', ()=>{
    beforeEach(()=>{
        jest.clearAllMocks();
        jest.useFakeTimers();
        _sharedcontexts.useUserType.mockReturnValue({
            userType: null,
            setUserType: mockSetUserType
        });
        mockPush.mockClear();
        mockUseRouter.mockReturnValue({
            push: mockPush,
            replace: jest.fn(),
            prefetch: jest.fn()
        });
    });
    afterEach(()=>{
        jest.runOnlyPendingTimers();
        jest.useRealTimers();
    });
    it('should navigate to /browse-practice-questions when "I\'m self-directed" is selected', async ()=>{
        (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_page.default, {}));
        const selfDirectedOption = _react1.screen.getByText(/I'm self-directed/i).closest('div[class*="cursor-pointer"]');
        if (selfDirectedOption) {
            _react1.fireEvent.click(selfDirectedOption);
            // Advance timers to trigger navigation (1500ms delay)
            jest.advanceTimersByTime(1800);
            await (0, _react1.waitFor)(()=>{
                expect(mockPush).toHaveBeenCalledWith('/browse-practice-questions');
            });
        }
    });
    it('should set learning type to "free-style" when navigating', async ()=>{
        (0, _react1.render)(/*#__PURE__*/ (0, _jsxruntime.jsx)(_page.default, {}));
        const selfDirectedOption = _react1.screen.getByText(/I'm self-directed/i).closest('div[class*="cursor-pointer"]');
        if (selfDirectedOption) {
            _react1.fireEvent.click(selfDirectedOption);
            jest.advanceTimersByTime(300);
            await (0, _react1.waitFor)(()=>{
                expect(mockSetLearningType).toHaveBeenCalledWith('free-style');
            });
        }
    });
});

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9hLmZvdWFkL1NpZGVQcm9qZWN0cy9FbHphdG9uYS1hbGwvRWx6YXRvbmEtd2ViL2FwcHMvd2Vic2l0ZS9zcmMvYXBwL2dldC1zdGFydGVkL3BhZ2UuaW50ZWdyYXRpb24udGVzdC50c3giXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBJbnRlZ3JhdGlvbiBUZXN0cyBmb3IgR2V0IFN0YXJ0ZWQgUGFnZSAoRy1JVC0wMDMsIEctSVQtMDA0LCBHLUlULTAwNSlcbiAqIFRhc2s6IEctMDAyIC0gR2V0IFN0YXJ0ZWQgUGFnZVxuICovXG5cbmltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyByZW5kZXIsIHNjcmVlbiwgZmlyZUV2ZW50LCB3YWl0Rm9yIH0gZnJvbSAnQHRlc3RpbmctbGlicmFyeS9yZWFjdCc7XG5pbXBvcnQgJ0B0ZXN0aW5nLWxpYnJhcnkvamVzdC1kb20nO1xuaW1wb3J0IEdldFN0YXJ0ZWRQYWdlIGZyb20gJy4vcGFnZSc7XG5pbXBvcnQgKiBhcyBzaGFyZWRDb250ZXh0cyBmcm9tICdAZWx6YXRvbmEvc2hhcmVkLWNvbnRleHRzJztcblxuLy8gTW9jayBzaGFyZWQgY29udGV4dHNcbmplc3QubW9jaygnQGVsemF0b25hL3NoYXJlZC1jb250ZXh0cycsICgpID0+IHtcbiAgY29uc3QgYWN0dWFsID0gamVzdC5yZXF1aXJlQWN0dWFsKCcuLi8uLi90ZXN0LXV0aWxzL21vY2tzL3NoYXJlZC1jb250ZXh0cycpO1xuICByZXR1cm4ge1xuICAgIC4uLmFjdHVhbCxcbiAgICB1c2VVc2VyVHlwZTogamVzdC5mbigpLFxuICB9O1xufSk7XG5cbi8vIE1vY2sgTGVhcm5pbmdUeXBlQ29udGV4dFxuY29uc3QgbW9ja1NldExlYXJuaW5nVHlwZSA9IGplc3QuZm4oKTtcbmplc3QubW9jaygnLi4vLi4vY29udGV4dC9MZWFybmluZ1R5cGVDb250ZXh0JywgKCkgPT4gKHtcbiAgdXNlTGVhcm5pbmdUeXBlOiBqZXN0LmZuKCgpID0+ICh7XG4gICAgbGVhcm5pbmdUeXBlOiBudWxsLFxuICAgIHNldExlYXJuaW5nVHlwZTogbW9ja1NldExlYXJuaW5nVHlwZSxcbiAgfSkpLFxufSkpO1xuXG4vLyBNb2NrIGx1Y2lkZS1yZWFjdCBpY29uc1xuamVzdC5tb2NrKCdsdWNpZGUtcmVhY3QnLCAoKSA9PiAoe1xuICBBcnJvd1JpZ2h0OiAoKSA9PiA8c3BhbiBkYXRhLXRlc3RpZD1cImFycm93LXJpZ2h0LWljb25cIj7ihpI8L3NwYW4+LFxuICBQbGF5OiAoKSA9PiA8c3BhbiBkYXRhLXRlc3RpZD1cInBsYXktaWNvblwiPuKWtjwvc3Bhbj4sXG4gIENvZGU6ICgpID0+IDxzcGFuIGRhdGEtdGVzdGlkPVwiY29kZS1pY29uXCI+8J+Suzwvc3Bhbj4sXG4gIFRhcmdldDogKCkgPT4gPHNwYW4gZGF0YS10ZXN0aWQ9XCJ0YXJnZXQtaWNvblwiPvCfjq88L3NwYW4+LFxuICBCb29rT3BlbjogKCkgPT4gPHNwYW4gZGF0YS10ZXN0aWQ9XCJib29rLWljb25cIj7wn5OWPC9zcGFuPixcbiAgQ2hlY2tDaXJjbGU6ICgpID0+IDxzcGFuIGRhdGEtdGVzdGlkPVwiY2hlY2staWNvblwiPuKckzwvc3Bhbj4sXG4gIFN0YXI6ICgpID0+IDxzcGFuIGRhdGEtdGVzdGlkPVwic3Rhci1pY29uXCI+4q2QPC9zcGFuPixcbiAgVXNlcnM6ICgpID0+IDxzcGFuIGRhdGEtdGVzdGlkPVwidXNlcnMtaWNvblwiPvCfkaU8L3NwYW4+LFxuICBBd2FyZDogKCkgPT4gPHNwYW4gZGF0YS10ZXN0aWQ9XCJhd2FyZC1pY29uXCI+8J+Phjwvc3Bhbj4sXG4gIE1hcDogKCkgPT4gPHNwYW4gZGF0YS10ZXN0aWQ9XCJtYXAtaWNvblwiPvCfl7rvuI88L3NwYW4+LFxuICBDb21wYXNzOiAoKSA9PiA8c3BhbiBkYXRhLXRlc3RpZD1cImNvbXBhc3MtaWNvblwiPvCfp608L3NwYW4+LFxuICBFeHRlcm5hbExpbms6ICgpID0+IDxzcGFuIGRhdGEtdGVzdGlkPVwiZXh0ZXJuYWwtaWNvblwiPvCflJc8L3NwYW4+LFxufSkpO1xuXG5jb25zdCBtb2NrUHVzaCA9IGplc3QuZm4oKTtcbmNvbnN0IG1vY2tTZXRVc2VyVHlwZSA9IGplc3QuZm4oKTtcbmNvbnN0IG1vY2tVc2VSb3V0ZXIgPSBqZXN0LmZuKCk7XG5cbmplc3QubW9jaygnbmV4dC9uYXZpZ2F0aW9uJywgKCkgPT4gKHtcbiAgdXNlUm91dGVyOiAoKSA9PiBtb2NrVXNlUm91dGVyKCksXG59KSk7XG5cbmRlc2NyaWJlKCdHLUlULTAwMzogVXNlciBUeXBlIFNlbGVjdGlvbiBVcGRhdGVzIFN0YXRlJywgKCkgPT4ge1xuICBiZWZvcmVFYWNoKCgpID0+IHtcbiAgICBqZXN0LmNsZWFyQWxsTW9ja3MoKTtcbiAgICBqZXN0LnVzZUZha2VUaW1lcnMoKTtcbiAgICBcbiAgICAoc2hhcmVkQ29udGV4dHMudXNlVXNlclR5cGUgYXMgamVzdC5Nb2NrKS5tb2NrUmV0dXJuVmFsdWUoe1xuICAgICAgdXNlclR5cGU6IG51bGwsXG4gICAgICBzZXRVc2VyVHlwZTogbW9ja1NldFVzZXJUeXBlLFxuICAgIH0pO1xuICAgIFxuICAgIG1vY2tVc2VSb3V0ZXIubW9ja1JldHVyblZhbHVlKHtcbiAgICAgIHB1c2g6IG1vY2tQdXNoLFxuICAgICAgcmVwbGFjZTogamVzdC5mbigpLFxuICAgICAgcHJlZmV0Y2g6IGplc3QuZm4oKSxcbiAgICB9KTtcbiAgfSk7XG5cbiAgYWZ0ZXJFYWNoKCgpID0+IHtcbiAgICBqZXN0LnJ1bk9ubHlQZW5kaW5nVGltZXJzKCk7XG4gICAgamVzdC51c2VSZWFsVGltZXJzKCk7XG4gIH0pO1xuXG4gIGl0KCdzaG91bGQgY2FsbCBzZXRVc2VyVHlwZSB3aGVuIFwiSSBuZWVkIGd1aWRhbmNlXCIgaXMgc2VsZWN0ZWQnLCBhc3luYyAoKSA9PiB7XG4gICAgcmVuZGVyKDxHZXRTdGFydGVkUGFnZSAvPik7XG4gICAgXG4gICAgY29uc3QgZ3VpZGVkT3B0aW9uID0gc2NyZWVuLmdldEJ5VGV4dCgvSSBuZWVkIGd1aWRhbmNlL2kpLmNsb3Nlc3QoJ2RpdltjbGFzcyo9XCJjdXJzb3ItcG9pbnRlclwiXScpO1xuICAgIGlmIChndWlkZWRPcHRpb24pIHtcbiAgICAgIGZpcmVFdmVudC5jbGljayhndWlkZWRPcHRpb24pO1xuICAgICAgXG4gICAgICBqZXN0LmFkdmFuY2VUaW1lcnNCeVRpbWUoMzAwKTtcbiAgICAgIFxuICAgICAgYXdhaXQgd2FpdEZvcigoKSA9PiB7XG4gICAgICAgIGV4cGVjdChtb2NrU2V0VXNlclR5cGUpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKCdndWlkZWQnKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfSk7XG5cbiAgaXQoJ3Nob3VsZCBjYWxsIHNldFVzZXJUeXBlIHdoZW4gXCJJXFwnbSBzZWxmLWRpcmVjdGVkXCIgaXMgc2VsZWN0ZWQnLCBhc3luYyAoKSA9PiB7XG4gICAgcmVuZGVyKDxHZXRTdGFydGVkUGFnZSAvPik7XG4gICAgXG4gICAgY29uc3Qgc2VsZkRpcmVjdGVkT3B0aW9uID0gc2NyZWVuLmdldEJ5VGV4dCgvSSdtIHNlbGYtZGlyZWN0ZWQvaSkuY2xvc2VzdCgnZGl2W2NsYXNzKj1cImN1cnNvci1wb2ludGVyXCJdJyk7XG4gICAgaWYgKHNlbGZEaXJlY3RlZE9wdGlvbikge1xuICAgICAgZmlyZUV2ZW50LmNsaWNrKHNlbGZEaXJlY3RlZE9wdGlvbik7XG4gICAgICBcbiAgICAgIGplc3QuYWR2YW5jZVRpbWVyc0J5VGltZSgzMDApO1xuICAgICAgXG4gICAgICBhd2FpdCB3YWl0Rm9yKCgpID0+IHtcbiAgICAgICAgZXhwZWN0KG1vY2tTZXRVc2VyVHlwZSkudG9IYXZlQmVlbkNhbGxlZFdpdGgoJ3NlbGYtZGlyZWN0ZWQnKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfSk7XG59KTtcblxuZGVzY3JpYmUoJ0ctSVQtMDA0OiBcIkkgbmVlZCBndWlkYW5jZVwiIE5hdmlnYXRlcyB0byBHdWlkZWQgTGVhcm5pbmcnLCAoKSA9PiB7XG4gIGJlZm9yZUVhY2goKCkgPT4ge1xuICAgIGplc3QuY2xlYXJBbGxNb2NrcygpO1xuICAgIGplc3QudXNlRmFrZVRpbWVycygpO1xuICAgIFxuICAgIChzaGFyZWRDb250ZXh0cy51c2VVc2VyVHlwZSBhcyBqZXN0Lk1vY2spLm1vY2tSZXR1cm5WYWx1ZSh7XG4gICAgICB1c2VyVHlwZTogbnVsbCxcbiAgICAgIHNldFVzZXJUeXBlOiBtb2NrU2V0VXNlclR5cGUsXG4gICAgfSk7XG4gICAgXG4gICAgbW9ja1B1c2gubW9ja0NsZWFyKCk7XG4gICAgbW9ja1VzZVJvdXRlci5tb2NrUmV0dXJuVmFsdWUoe1xuICAgICAgcHVzaDogbW9ja1B1c2gsXG4gICAgICByZXBsYWNlOiBqZXN0LmZuKCksXG4gICAgICBwcmVmZXRjaDogamVzdC5mbigpLFxuICAgIH0pO1xuICB9KTtcblxuICBhZnRlckVhY2goKCkgPT4ge1xuICAgIGplc3QucnVuT25seVBlbmRpbmdUaW1lcnMoKTtcbiAgICBqZXN0LnVzZVJlYWxUaW1lcnMoKTtcbiAgfSk7XG5cbiAgaXQoJ3Nob3VsZCBuYXZpZ2F0ZSB0byAvZmVhdHVyZXMvZ3VpZGVkLWxlYXJuaW5nIHdoZW4gXCJJIG5lZWQgZ3VpZGFuY2VcIiBpcyBzZWxlY3RlZCcsIGFzeW5jICgpID0+IHtcbiAgICByZW5kZXIoPEdldFN0YXJ0ZWRQYWdlIC8+KTtcbiAgICBcbiAgICBjb25zdCBndWlkZWRPcHRpb24gPSBzY3JlZW4uZ2V0QnlUZXh0KC9JIG5lZWQgZ3VpZGFuY2UvaSkuY2xvc2VzdCgnZGl2W2NsYXNzKj1cImN1cnNvci1wb2ludGVyXCJdJyk7XG4gICAgaWYgKGd1aWRlZE9wdGlvbikge1xuICAgICAgZmlyZUV2ZW50LmNsaWNrKGd1aWRlZE9wdGlvbik7XG4gICAgICBcbiAgICAgIC8vIEFkdmFuY2UgdGltZXJzIHRvIHRyaWdnZXIgbmF2aWdhdGlvbiAoMTUwMG1zIGRlbGF5KVxuICAgICAgamVzdC5hZHZhbmNlVGltZXJzQnlUaW1lKDE4MDApO1xuICAgICAgXG4gICAgICBhd2FpdCB3YWl0Rm9yKCgpID0+IHtcbiAgICAgICAgZXhwZWN0KG1vY2tQdXNoKS50b0hhdmVCZWVuQ2FsbGVkV2l0aCgnL2ZlYXR1cmVzL2d1aWRlZC1sZWFybmluZycpO1xuICAgICAgfSk7XG4gICAgfVxuICB9KTtcblxuICBpdCgnc2hvdWxkIHNldCBsZWFybmluZyB0eXBlIHRvIFwiZ3VpZGVkXCIgd2hlbiBuYXZpZ2F0aW5nJywgYXN5bmMgKCkgPT4ge1xuICAgIHJlbmRlcig8R2V0U3RhcnRlZFBhZ2UgLz4pO1xuICAgIFxuICAgIGNvbnN0IGd1aWRlZE9wdGlvbiA9IHNjcmVlbi5nZXRCeVRleHQoL0kgbmVlZCBndWlkYW5jZS9pKS5jbG9zZXN0KCdkaXZbY2xhc3MqPVwiY3Vyc29yLXBvaW50ZXJcIl0nKTtcbiAgICBpZiAoZ3VpZGVkT3B0aW9uKSB7XG4gICAgICBmaXJlRXZlbnQuY2xpY2soZ3VpZGVkT3B0aW9uKTtcbiAgICAgIFxuICAgICAgamVzdC5hZHZhbmNlVGltZXJzQnlUaW1lKDMwMCk7XG4gICAgICBcbiAgICAgIGF3YWl0IHdhaXRGb3IoKCkgPT4ge1xuICAgICAgICBleHBlY3QobW9ja1NldExlYXJuaW5nVHlwZSkudG9IYXZlQmVlbkNhbGxlZFdpdGgoJ2d1aWRlZCcpO1xuICAgICAgfSk7XG4gICAgfVxuICB9KTtcbn0pO1xuXG5kZXNjcmliZSgnRy1JVC0wMDU6IFwiSVxcJ20gc2VsZi1kaXJlY3RlZFwiIE5hdmlnYXRlcyB0byBCcm93c2UgUGFnZScsICgpID0+IHtcbiAgYmVmb3JlRWFjaCgoKSA9PiB7XG4gICAgamVzdC5jbGVhckFsbE1vY2tzKCk7XG4gICAgamVzdC51c2VGYWtlVGltZXJzKCk7XG4gICAgXG4gICAgKHNoYXJlZENvbnRleHRzLnVzZVVzZXJUeXBlIGFzIGplc3QuTW9jaykubW9ja1JldHVyblZhbHVlKHtcbiAgICAgIHVzZXJUeXBlOiBudWxsLFxuICAgICAgc2V0VXNlclR5cGU6IG1vY2tTZXRVc2VyVHlwZSxcbiAgICB9KTtcbiAgICBcbiAgICBtb2NrUHVzaC5tb2NrQ2xlYXIoKTtcbiAgICBtb2NrVXNlUm91dGVyLm1vY2tSZXR1cm5WYWx1ZSh7XG4gICAgICBwdXNoOiBtb2NrUHVzaCxcbiAgICAgIHJlcGxhY2U6IGplc3QuZm4oKSxcbiAgICAgIHByZWZldGNoOiBqZXN0LmZuKCksXG4gICAgfSk7XG4gIH0pO1xuXG4gIGFmdGVyRWFjaCgoKSA9PiB7XG4gICAgamVzdC5ydW5Pbmx5UGVuZGluZ1RpbWVycygpO1xuICAgIGplc3QudXNlUmVhbFRpbWVycygpO1xuICB9KTtcblxuICBpdCgnc2hvdWxkIG5hdmlnYXRlIHRvIC9icm93c2UtcHJhY3RpY2UtcXVlc3Rpb25zIHdoZW4gXCJJXFwnbSBzZWxmLWRpcmVjdGVkXCIgaXMgc2VsZWN0ZWQnLCBhc3luYyAoKSA9PiB7XG4gICAgcmVuZGVyKDxHZXRTdGFydGVkUGFnZSAvPik7XG4gICAgXG4gICAgY29uc3Qgc2VsZkRpcmVjdGVkT3B0aW9uID0gc2NyZWVuLmdldEJ5VGV4dCgvSSdtIHNlbGYtZGlyZWN0ZWQvaSkuY2xvc2VzdCgnZGl2W2NsYXNzKj1cImN1cnNvci1wb2ludGVyXCJdJyk7XG4gICAgaWYgKHNlbGZEaXJlY3RlZE9wdGlvbikge1xuICAgICAgZmlyZUV2ZW50LmNsaWNrKHNlbGZEaXJlY3RlZE9wdGlvbik7XG4gICAgICBcbiAgICAgIC8vIEFkdmFuY2UgdGltZXJzIHRvIHRyaWdnZXIgbmF2aWdhdGlvbiAoMTUwMG1zIGRlbGF5KVxuICAgICAgamVzdC5hZHZhbmNlVGltZXJzQnlUaW1lKDE4MDApO1xuICAgICAgXG4gICAgICBhd2FpdCB3YWl0Rm9yKCgpID0+IHtcbiAgICAgICAgZXhwZWN0KG1vY2tQdXNoKS50b0hhdmVCZWVuQ2FsbGVkV2l0aCgnL2Jyb3dzZS1wcmFjdGljZS1xdWVzdGlvbnMnKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfSk7XG5cbiAgaXQoJ3Nob3VsZCBzZXQgbGVhcm5pbmcgdHlwZSB0byBcImZyZWUtc3R5bGVcIiB3aGVuIG5hdmlnYXRpbmcnLCBhc3luYyAoKSA9PiB7XG4gICAgcmVuZGVyKDxHZXRTdGFydGVkUGFnZSAvPik7XG4gICAgXG4gICAgY29uc3Qgc2VsZkRpcmVjdGVkT3B0aW9uID0gc2NyZWVuLmdldEJ5VGV4dCgvSSdtIHNlbGYtZGlyZWN0ZWQvaSkuY2xvc2VzdCgnZGl2W2NsYXNzKj1cImN1cnNvci1wb2ludGVyXCJdJyk7XG4gICAgaWYgKHNlbGZEaXJlY3RlZE9wdGlvbikge1xuICAgICAgZmlyZUV2ZW50LmNsaWNrKHNlbGZEaXJlY3RlZE9wdGlvbik7XG4gICAgICBcbiAgICAgIGplc3QuYWR2YW5jZVRpbWVyc0J5VGltZSgzMDApO1xuICAgICAgXG4gICAgICBhd2FpdCB3YWl0Rm9yKCgpID0+IHtcbiAgICAgICAgZXhwZWN0KG1vY2tTZXRMZWFybmluZ1R5cGUpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKCdmcmVlLXN0eWxlJyk7XG4gICAgICB9KTtcbiAgICB9XG4gIH0pO1xufSk7XG5cbiJdLCJuYW1lcyI6WyJqZXN0IiwibW9jayIsImFjdHVhbCIsInJlcXVpcmVBY3R1YWwiLCJ1c2VVc2VyVHlwZSIsImZuIiwidXNlTGVhcm5pbmdUeXBlIiwibGVhcm5pbmdUeXBlIiwic2V0TGVhcm5pbmdUeXBlIiwibW9ja1NldExlYXJuaW5nVHlwZSIsIkFycm93UmlnaHQiLCJzcGFuIiwiZGF0YS10ZXN0aWQiLCJQbGF5IiwiQ29kZSIsIlRhcmdldCIsIkJvb2tPcGVuIiwiQ2hlY2tDaXJjbGUiLCJTdGFyIiwiVXNlcnMiLCJBd2FyZCIsIk1hcCIsIkNvbXBhc3MiLCJFeHRlcm5hbExpbmsiLCJ1c2VSb3V0ZXIiLCJtb2NrVXNlUm91dGVyIiwibW9ja1B1c2giLCJtb2NrU2V0VXNlclR5cGUiLCJkZXNjcmliZSIsImJlZm9yZUVhY2giLCJjbGVhckFsbE1vY2tzIiwidXNlRmFrZVRpbWVycyIsInNoYXJlZENvbnRleHRzIiwibW9ja1JldHVyblZhbHVlIiwidXNlclR5cGUiLCJzZXRVc2VyVHlwZSIsInB1c2giLCJyZXBsYWNlIiwicHJlZmV0Y2giLCJhZnRlckVhY2giLCJydW5Pbmx5UGVuZGluZ1RpbWVycyIsInVzZVJlYWxUaW1lcnMiLCJpdCIsInJlbmRlciIsIkdldFN0YXJ0ZWRQYWdlIiwiZ3VpZGVkT3B0aW9uIiwic2NyZWVuIiwiZ2V0QnlUZXh0IiwiY2xvc2VzdCIsImZpcmVFdmVudCIsImNsaWNrIiwiYWR2YW5jZVRpbWVyc0J5VGltZSIsIndhaXRGb3IiLCJleHBlY3QiLCJ0b0hhdmVCZWVuQ2FsbGVkV2l0aCIsInNlbGZEaXJlY3RlZE9wdGlvbiIsIm1vY2tDbGVhciJdLCJtYXBwaW5ncyI6IkFBQUE7OztDQUdDO0FBUUQsdUJBQXVCO0FBQ3ZCQSxLQUFLQyxJQUFJLENBQUMsNkJBQTZCO0lBQ3JDLE1BQU1DLFNBQVNGLEtBQUtHLGFBQWEsQ0FBQztJQUNsQyxPQUFPO1FBQ0wsR0FBR0QsTUFBTTtRQUNURSxhQUFhSixLQUFLSyxFQUFFO0lBQ3RCO0FBQ0Y7QUFJQUwsS0FBS0MsSUFBSSxDQUFDLHFDQUFxQyxJQUFPLENBQUE7UUFDcERLLGlCQUFpQk4sS0FBS0ssRUFBRSxDQUFDLElBQU8sQ0FBQTtnQkFDOUJFLGNBQWM7Z0JBQ2RDLGlCQUFpQkM7WUFDbkIsQ0FBQTtJQUNGLENBQUE7QUFFQSwwQkFBMEI7QUFDMUJULEtBQUtDLElBQUksQ0FBQyxnQkFBZ0IsSUFBTyxDQUFBO1FBQy9CUyxZQUFZLGtCQUFNLHFCQUFDQztnQkFBS0MsZUFBWTswQkFBbUI7O1FBQ3ZEQyxNQUFNLGtCQUFNLHFCQUFDRjtnQkFBS0MsZUFBWTswQkFBWTs7UUFDMUNFLE1BQU0sa0JBQU0scUJBQUNIO2dCQUFLQyxlQUFZOzBCQUFZOztRQUMxQ0csUUFBUSxrQkFBTSxxQkFBQ0o7Z0JBQUtDLGVBQVk7MEJBQWM7O1FBQzlDSSxVQUFVLGtCQUFNLHFCQUFDTDtnQkFBS0MsZUFBWTswQkFBWTs7UUFDOUNLLGFBQWEsa0JBQU0scUJBQUNOO2dCQUFLQyxlQUFZOzBCQUFhOztRQUNsRE0sTUFBTSxrQkFBTSxxQkFBQ1A7Z0JBQUtDLGVBQVk7MEJB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