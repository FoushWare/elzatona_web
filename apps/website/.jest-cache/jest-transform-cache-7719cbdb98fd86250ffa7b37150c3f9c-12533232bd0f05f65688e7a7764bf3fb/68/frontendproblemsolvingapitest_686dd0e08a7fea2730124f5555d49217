08bd23db43445007b340fdb9c86f81e9
/**
 * Frontend Tasks & Problem Solving API Tests
 *
 * Comprehensive tests for CRUD operations in:
 * - Frontend Tasks API endpoints
 * - Problem Solving API endpoints
 */ "use strict";
// Mock Supabase instead of Firebase
jest.mock('@supabase/supabase-js', ()=>({
        createClient: jest.fn(()=>({
                from: jest.fn(()=>({
                        select: jest.fn(),
                        insert: jest.fn(),
                        update: jest.fn(),
                        delete: jest.fn(),
                        eq: jest.fn(),
                        single: jest.fn(),
                        order: jest.fn()
                    })),
                auth: {
                    onAuthStateChange: jest.fn(()=>({
                            data: {
                                subscription: null
                            },
                            error: null
                        })),
                    getSession: jest.fn().mockResolvedValue({
                        data: {
                            session: null
                        },
                        error: null
                    }),
                    getUser: jest.fn().mockResolvedValue({
                        data: {
                            user: null
                        },
                        error: null
                    })
                }
            }))
    }));
Object.defineProperty(exports, "__esModule", {
    value: true
});
const _server = require("next/server");
function _getRequireWildcardCache(nodeInterop) {
    if (typeof WeakMap !== "function") return null;
    var cacheBabelInterop = new WeakMap();
    var cacheNodeInterop = new WeakMap();
    return (_getRequireWildcardCache = function(nodeInterop) {
        return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
    })(nodeInterop);
}
function _interop_require_wildcard(obj, nodeInterop) {
    if (!nodeInterop && obj && obj.__esModule) {
        return obj;
    }
    if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return {
            default: obj
        };
    }
    var cache = _getRequireWildcardCache(nodeInterop);
    if (cache && cache.has(obj)) {
        return cache.get(obj);
    }
    var newObj = {
        __proto__: null
    };
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for(var key in obj){
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
            if (desc && (desc.get || desc.set)) {
                Object.defineProperty(newObj, key, desc);
            } else {
                newObj[key] = obj[key];
            }
        }
    }
    newObj.default = obj;
    if (cache) {
        cache.set(obj, newObj);
    }
    return newObj;
}
// Set up environment variables
process.env.NEXT_PUBLIC_SUPABASE_URL = 'https://test.supabase.co';
process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY = 'test-anon-key';
process.env.SUPABASE_SERVICE_ROLE_KEY = 'test-service-role-key';
describe('Frontend Tasks & Problem Solving API Tests', ()=>{
    // eslint-disable-next-line @typescript-eslint/no-require-imports
    const { createClient } = require('@supabase/supabase-js');
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    let mockSupabaseClient;
    beforeEach(()=>{
        jest.clearAllMocks();
        mockSupabaseClient = createClient();
        mockSupabaseClient.from.mockClear();
    });
    describe('Frontend Tasks API', ()=>{
        describe('GET /api/frontend-tasks', ()=>{
            it('should return all frontend tasks', async ()=>{
                const mockTasks = [
                    {
                        id: 'task-1',
                        title: 'Build a Todo App',
                        description: 'Create a React todo application',
                        difficulty: 'easy',
                        category: 'react',
                        estimatedTime: 120,
                        starterCode: 'const App = () => { return <div>Todo App</div>; };',
                        testCases: [
                            {
                                input: 'Add task "Learn React"',
                                expectedOutput: 'Task added successfully'
                            }
                        ],
                        createdAt: new Date().toISOString(),
                        updatedAt: new Date().toISOString()
                    }
                ];
                const mockOrder = jest.fn().mockResolvedValue({
                    data: mockTasks,
                    error: null
                });
                const mockSelect = jest.fn().mockReturnValue({
                    order: mockOrder
                });
                mockSupabaseClient.from.mockReturnValue({
                    select: mockSelect
                });
                const { GET } = await Promise.resolve().then(()=>/*#__PURE__*/ _interop_require_wildcard(require("../../apps/website/src/app/api/admin/frontend-tasks/route")));
                const request = new _server.NextRequest('http://localhost:3000/api/admin/frontend-tasks');
                const response = await GET(request);
                const data = await response.json();
                expect(response.status).toBe(200);
                expect(data.success).toBe(true);
                expect(data.data).toHaveLength(1);
                expect(data.data[0].title).toBe('Build a Todo App');
                expect(data.data[0].difficulty).toBe('easy');
            });
            it('should filter tasks by difficulty', async ()=>{
                const mockTasks = [
                    {
                        id: 'task-1',
                        title: 'Easy Task',
                        difficulty: 'easy',
                        category: 'react',
                        createdAt: new Date().toISOString(),
                        updatedAt: new Date().toISOString()
                    }
                ];
                const mockOrder = jest.fn().mockResolvedValue({
                    data: mockTasks,
                    error: null
                });
                const mockEq = jest.fn().mockReturnValue({
                    order: mockOrder
                });
                const mockSelect = jest.fn().mockReturnValue({
                    eq: mockEq
                });
                mockSupabaseClient.from.mockReturnValue({
                    select: mockSelect
                });
                const { GET } = await Promise.resolve().then(()=>/*#__PURE__*/ _interop_require_wildcard(require("../../apps/website/src/app/api/admin/frontend-tasks/route")));
                const request = new _server.NextRequest('http://localhost:3000/api/admin/frontend-tasks?difficulty=easy');
                const response = await GET(request);
                const data = await response.json();
                expect(response.status).toBe(200);
                expect(data.success).toBe(true);
                expect(data.data).toHaveLength(1);
                expect(data.data[0].difficulty).toBe('easy');
            });
        });
        describe('POST /api/frontend-tasks', ()=>{
            it('should create a new frontend task', async ()=>{
                const newTask = {
                    title: 'Build a Calculator',
                    description: 'Create a calculator app with React',
                    difficulty: 'medium',
                    category: 'react',
                    estimatedTime: 180,
                    starterCode: 'const Calculator = () => { return <div>Calculator</div>; };',
                    testCases: [
                        {
                            input: '2 + 2',
                            expectedOutput: '4'
                        }
                    ]
                };
                const mockSingle = jest.fn().mockResolvedValue({
                    data: {
                        id: 'test-task-id',
                        ...newTask
                    },
                    error: null
                });
                const mockInsert = jest.fn().mockReturnValue({
                    select: jest.fn().mockReturnValue({
                        single: mockSingle
                    })
                });
                mockSupabaseClient.from.mockReturnValue({
                    insert: mockInsert
                });
                const { POST } = await Promise.resolve().then(()=>/*#__PURE__*/ _interop_require_wildcard(require("../../apps/website/src/app/api/admin/frontend-tasks/route")));
                const request = new _server.NextRequest('http://localhost:3000/api/admin/frontend-tasks', {
                    method: 'POST',
                    body: JSON.stringify(newTask),
                    headers: {
                        'Content-Type': 'application/json'
                    }
                });
                const response = await POST(request);
                const data = await response.json();
                expect(response.status).toBe(201);
                expect(data.success).toBe(true);
                expect(data.data.id).toBe('test-task-id');
                expect(data.data.title).toBe('Build a Calculator');
            });
            it('should validate required fields for frontend tasks', async ()=>{
                const invalidTask = {
                    description: 'Missing title and difficulty'
                };
                const { POST } = await Promise.resolve().then(()=>/*#__PURE__*/ _interop_require_wildcard(require("../../apps/website/src/app/api/admin/frontend-tasks/route")));
                const request = new _server.NextRequest('http://localhost:3000/api/admin/frontend-tasks', {
                    method: 'POST',
                    body: JSON.stringify(invalidTask),
                    headers: {
                        'Content-Type': 'application/json'
                    }
                });
                const response = await POST(request);
                const data = await response.json();
                expect(response.status).toBe(400);
                expect(data.success).toBe(false);
                expect(data.error).toBeDefined();
            });
        });
        describe('PUT /api/admin/frontend-tasks/[id]', ()=>{
            it('should update an existing frontend task', async ()=>{
                const taskId = 'test-task-id';
                const updateData = {
                    title: 'Updated Task Title',
                    description: 'Updated description',
                    estimatedTime: 240
                };
                const mockSingle = jest.fn().mockResolvedValue({
                    data: {
                        id: taskId,
                        ...updateData
                    },
                    error: null
                });
                const mockEq = jest.fn().mockReturnValue({
                    select: jest.fn().mockReturnValue({
                        single: mockSingle
                    })
                });
                const mockUpdate = jest.fn().mockReturnValue({
                    eq: mockEq
                });
                mockSupabaseClient.from.mockReturnValue({
                    update: mockUpdate
                });
                const { PUT } = await Promise.resolve().then(()=>/*#__PURE__*/ _interop_require_wildcard(require("../../apps/website/src/app/api/admin/frontend-tasks/[id]/route")));
                const request = new _server.NextRequest(`http://localhost:3000/api/admin/frontend-tasks/${taskId}`, {
                    method: 'PUT',
                    body: JSON.stringify(updateData),
                    headers: {
                        'Content-Type': 'application/json'
                    }
                });
                const response = await PUT(request, {
                    params: {
                        id: taskId
                    }
                });
                const data = await response.json();
                expect(response.status).toBe(200);
                expect(data.success).toBe(true);
            });
        });
        describe('DELETE /api/admin/frontend-tasks/[id]', ()=>{
            it('should delete a frontend task', async ()=>{
                const taskId = 'test-task-id';
                const mockEq = jest.fn().mockResolvedValue({
                    data: null,
                    error: null
                });
                const mockDelete = jest.fn().mockReturnValue({
                    eq: mockEq
                });
                mockSupabaseClient.from.mockReturnValue({
                    delete: mockDelete
                });
                const { DELETE } = await Promise.resolve().then(()=>/*#__PURE__*/ _interop_require_wildcard(require("../../apps/website/src/app/api/admin/frontend-tasks/[id]/route")));
                const request = new _server.NextRequest(`http://localhost:3000/api/admin/frontend-tasks/${taskId}`, {
                    method: 'DELETE'
                });
                const response = await DELETE(request, {
                    params: {
                        id: taskId
                    }
                });
                const data = await response.json();
                expect(response.status).toBe(200);
                expect(data.success).toBe(true);
            });
        });
    });
    describe('Problem Solving API', ()=>{
        describe('GET /api/admin/problem-solving', ()=>{
            it('should return all problem solving tasks', async ()=>{
                const mockProblems = [
                    {
                        id: 'problem-1',
                        title: 'Two Sum',
                        description: 'Find two numbers that add up to target',
                        difficulty: 'easy',
                        category: 'arrays',
                        testCases: [
                            {
                                input: '[2,7,11,15], 9',
                                expectedOutput: '[0,1]'
                            }
                        ],
                        hints: [
                            'Use a hash map to store complements'
                        ],
                        created_at: new Date().toISOString(),
                        updated_at: new Date().toISOString()
                    }
                ];
                const mockOrder = jest.fn().mockResolvedValue({
                    data: mockProblems,
                    error: null
                });
                const mockSelect = jest.fn().mockReturnValue({
                    order: mockOrder
                });
                mockSupabaseClient.from.mockReturnValue({
                    select: mockSelect
                });
                const { GET } = await Promise.resolve().then(()=>/*#__PURE__*/ _interop_require_wildcard(require("../../apps/website/src/app/api/admin/problem-solving/route")));
                const request = new _server.NextRequest('http://localhost:3000/api/admin/problem-solving');
                const response = await GET(request);
                const data = await response.json();
                expect(response.status).toBe(200);
                expect(data.success).toBe(true);
                expect(data.data).toHaveLength(1);
                expect(data.data[0].title).toBe('Two Sum');
                expect(data.data[0].difficulty).toBe('easy');
            });
            it('should filter problems by category', async ()=>{
                const mockProblems = [
                    {
                        id: 'problem-1',
                        title: 'Array Problem',
                        category: 'arrays',
                        difficulty: 'easy',
                        created_at: new Date().toISOString(),
                        updated_at: new Date().toISOString()
                    }
                ];
                const mockOrder = jest.fn().mockResolvedValue({
                    data: mockProblems,
                    error: null
                });
                const mockEq = jest.fn().mockReturnValue({
                    order: mockOrder
                });
                const mockSelect = jest.fn().mockReturnValue({
                    eq: mockEq
                });
                mockSupabaseClient.from.mockReturnValue({
                    select: mockSelect
                });
                const { GET } = await Promise.resolve().then(()=>/*#__PURE__*/ _interop_require_wildcard(require("../../apps/website/src/app/api/admin/problem-solving/route")));
                const request = new _server.NextRequest('http://localhost:3000/api/admin/problem-solving?category=arrays');
                const response = await GET(request);
                const data = await response.json();
                expect(response.status).toBe(200);
                expect(data.success).toBe(true);
                expect(data.data).toHaveLength(1);
                expect(data.data[0].category).toBe('arrays');
            });
        });
        describe('POST /api/admin/problem-solving', ()=>{
            it('should create a new problem solving task', async ()=>{
                const newProblem = {
                    title: 'Reverse String',
                    description: 'Reverse a given string',
                    difficulty: 'easy',
                    category: 'strings',
                    testCases: [
                        {
                            input: '"hello"',
                            expectedOutput: '"olleh"'
                        }
                    ],
                    hints: [
                        'Use two pointers'
                    ]
                };
                const mockSingle = jest.fn().mockResolvedValue({
                    data: {
                        id: 'test-problem-id',
                        ...newProblem
                    },
                    error: null
                });
                const mockInsert = jest.fn().mockReturnValue({
                    select: jest.fn().mockReturnValue({
                        single: mockSingle
                    })
                });
                mockSupabaseClient.from.mockReturnValue({
                    insert: mockInsert
                });
                const { POST } = await Promise.resolve().then(()=>/*#__PURE__*/ _interop_require_wildcard(require("../../apps/website/src/app/api/admin/problem-solving/route")));
                const request = new _server.NextRequest('http://localhost:3000/api/admin/problem-solving', {
                    method: 'POST',
                    body: JSON.stringify(newProblem),
                    headers: {
                        'Content-Type': 'application/json'
                    }
                });
                const response = await POST(request);
                const data = await response.json();
                expect(response.status).toBe(201);
                expect(data.success).toBe(true);
                expect(data.data.id).toBe('test-problem-id');
                expect(data.data.title).toBe('Reverse String');
            });
            it('should validate required fields for problem solving tasks', async ()=>{
                const invalidProblem = {
                    description: 'Missing title and difficulty'
                };
                const { POST } = await Promise.resolve().then(()=>/*#__PURE__*/ _interop_require_wildcard(require("../../apps/website/src/app/api/admin/problem-solving/route")));
                const request = new _server.NextRequest('http://localhost:3000/api/admin/problem-solving', {
                    method: 'POST',
                    body: JSON.stringify(invalidProblem),
                    headers: {
                        'Content-Type': 'application/json'
                    }
                });
                const response = await POST(request);
                const data = await response.json();
                expect(response.status).toBe(400);
                expect(data.success).toBe(false);
                expect(data.error).toBeDefined();
            });
        });
        describe('PUT /api/admin/problem-solving/[id]', ()=>{
            it('should update an existing problem solving task', async ()=>{
                const problemId = 'test-problem-id';
                const updateData = {
                    title: 'Updated Problem Title',
                    description: 'Updated description',
                    hints: [
                        'Updated hint'
                    ]
                };
                const mockSingle = jest.fn().mockResolvedValue({
                    data: {
                        id: problemId,
                        ...updateData
                    },
                    error: null
                });
                const mockEq = jest.fn().mockReturnValue({
                    select: jest.fn().mockReturnValue({
                        single: mockSingle
                    })
                });
                const mockUpdate = jest.fn().mockReturnValue({
                    eq: mockEq
                });
                mockSupabaseClient.from.mockReturnValue({
                    update: mockUpdate
                });
                const { PUT } = await Promise.resolve().then(()=>/*#__PURE__*/ _interop_require_wildcard(require("../../apps/website/src/app/api/admin/problem-solving/[id]/route")));
                const request = new _server.NextRequest(`http://localhost:3000/api/admin/problem-solving/${problemId}`, {
                    method: 'PUT',
                    body: JSON.stringify(updateData),
                    headers: {
                        'Content-Type': 'application/json'
                    }
                });
                const response = await PUT(request, {
                    params: {
                        id: problemId
                    }
                });
                const data = await response.json();
                expect(response.status).toBe(200);
                expect(data.success).toBe(true);
            });
        });
        describe('DELETE /api/admin/problem-solving/[id]', ()=>{
            it('should delete a problem solving task', async ()=>{
                const problemId = 'test-problem-id';
                const mockEq = jest.fn().mockResolvedValue({
                    data: null,
                    error: null
                });
                const mockDelete = jest.fn().mockReturnValue({
                    eq: mockEq
                });
                mockSupabaseClient.from.mockReturnValue({
                    delete: mockDelete
                });
                const { DELETE } = await Promise.resolve().then(()=>/*#__PURE__*/ _interop_require_wildcard(require("../../apps/website/src/app/api/admin/problem-solving/[id]/route")));
                const request = new _server.NextRequest(`http://localhost:3000/api/admin/problem-solving/${problemId}`, {
                    method: 'DELETE'
                });
                const response = await DELETE(request, {
                    params: {
                        id: problemId
                    }
                });
                const data = await response.json();
                expect(response.status).toBe(200);
                expect(data.success).toBe(true);
            });
        });
    });
    describe('Error Handling', ()=>{
        it('should handle Supabase connection errors gracefully', async ()=>{
            const mockOrder = jest.fn().mockRejectedValue(new Error('Supabase connection failed'));
            const mockSelect = jest.fn().mockReturnValue({
                order: mockOrder
            });
            mockSupabaseClient.from.mockReturnValue({
                select: mockSelect
            });
            const { GET } = await Promise.resolve().then(()=>/*#__PURE__*/ _interop_require_wildcard(require("../../apps/website/src/app/api/admin/frontend-tasks/route")));
            const request = new _server.NextRequest('http://localhost:3000/api/admin/frontend-tasks');
            const response = await GET(request);
            const data = await response.json();
            expect(response.status).toBe(500);
            expect(data.success).toBe(false);
            expect(data.error).toBeDefined();
        });
        it('should handle invalid JSON in request body', async ()=>{
            const { POST } = await Promise.resolve().then(()=>/*#__PURE__*/ _interop_require_wildcard(require("../../apps/website/src/app/api/admin/frontend-tasks/route")));
            const request = new _server.NextRequest('http://localhost:3000/api/admin/frontend-tasks', {
                method: 'POST',
                body: 'invalid json',
                headers: {
                    'Content-Type': 'application/json'
                }
            });
            const response = await POST(request);
            const data = await response.json();
            expect(response.status).toBe(400);
            expect(data.success).toBe(false);
            expect(data.error).toBeDefined();
        });
        it('should handle missing Content-Type header', async ()=>{
            const { POST } = await Promise.resolve().then(()=>/*#__PURE__*/ _interop_require_wildcard(require("../../apps/website/src/app/api/admin/frontend-tasks/route")));
            const request = new _server.NextRequest('http://localhost:3000/api/admin/frontend-tasks', {
                method: 'POST',
                body: JSON.stringify({
                    title: 'Test Task'
                })
            });
            const response = await POST(request);
            const data = await response.json();
            expect(response.status).toBe(400);
            expect(data.success).toBe(false);
            expect(data.error).toBeDefined();
        });
    });
});

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9hLmZvdWFkL1NpZGVQcm9qZWN0cy9FbHphdG9uYS1hbGwvRWx6YXRvbmEtd2ViL3Rlc3RzL2FkbWluL2Zyb250ZW5kLXByb2JsZW0tc29sdmluZy1hcGkudGVzdC50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEZyb250ZW5kIFRhc2tzICYgUHJvYmxlbSBTb2x2aW5nIEFQSSBUZXN0c1xuICpcbiAqIENvbXByZWhlbnNpdmUgdGVzdHMgZm9yIENSVUQgb3BlcmF0aW9ucyBpbjpcbiAqIC0gRnJvbnRlbmQgVGFza3MgQVBJIGVuZHBvaW50c1xuICogLSBQcm9ibGVtIFNvbHZpbmcgQVBJIGVuZHBvaW50c1xuICovXG5cbmltcG9ydCB7IE5leHRSZXF1ZXN0IH0gZnJvbSAnbmV4dC9zZXJ2ZXInO1xuXG4vLyBTZXQgdXAgZW52aXJvbm1lbnQgdmFyaWFibGVzXG5wcm9jZXNzLmVudi5ORVhUX1BVQkxJQ19TVVBBQkFTRV9VUkwgPSAnaHR0cHM6Ly90ZXN0LnN1cGFiYXNlLmNvJztcbnByb2Nlc3MuZW52Lk5FWFRfUFVCTElDX1NVUEFCQVNFX0FOT05fS0VZID0gJ3Rlc3QtYW5vbi1rZXknO1xucHJvY2Vzcy5lbnYuU1VQQUJBU0VfU0VSVklDRV9ST0xFX0tFWSA9ICd0ZXN0LXNlcnZpY2Utcm9sZS1rZXknO1xuXG4vLyBNb2NrIFN1cGFiYXNlIGluc3RlYWQgb2YgRmlyZWJhc2Vcbmplc3QubW9jaygnQHN1cGFiYXNlL3N1cGFiYXNlLWpzJywgKCkgPT4gKHtcbiAgY3JlYXRlQ2xpZW50OiBqZXN0LmZuKCgpID0+ICh7XG4gICAgZnJvbTogamVzdC5mbigoKSA9PiAoe1xuICAgICAgc2VsZWN0OiBqZXN0LmZuKCksXG4gICAgICBpbnNlcnQ6IGplc3QuZm4oKSxcbiAgICAgIHVwZGF0ZTogamVzdC5mbigpLFxuICAgICAgZGVsZXRlOiBqZXN0LmZuKCksXG4gICAgICBlcTogamVzdC5mbigpLFxuICAgICAgc2luZ2xlOiBqZXN0LmZuKCksXG4gICAgICBvcmRlcjogamVzdC5mbigpLFxuICAgIH0pKSxcbiAgICBhdXRoOiB7XG4gICAgICBvbkF1dGhTdGF0ZUNoYW5nZTogamVzdC5mbigoKSA9PiAoe1xuICAgICAgICBkYXRhOiB7IHN1YnNjcmlwdGlvbjogbnVsbCB9LFxuICAgICAgICBlcnJvcjogbnVsbCxcbiAgICAgIH0pKSxcbiAgICAgIGdldFNlc3Npb246IGplc3QuZm4oKS5tb2NrUmVzb2x2ZWRWYWx1ZSh7IGRhdGE6IHsgc2Vzc2lvbjogbnVsbCB9LCBlcnJvcjogbnVsbCB9KSxcbiAgICAgIGdldFVzZXI6IGplc3QuZm4oKS5tb2NrUmVzb2x2ZWRWYWx1ZSh7IGRhdGE6IHsgdXNlcjogbnVsbCB9LCBlcnJvcjogbnVsbCB9KSxcbiAgICB9LFxuICB9KSksXG59KSk7XG5cbmRlc2NyaWJlKCdGcm9udGVuZCBUYXNrcyAmIFByb2JsZW0gU29sdmluZyBBUEkgVGVzdHMnLCAoKSA9PiB7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tcmVxdWlyZS1pbXBvcnRzXG4gIGNvbnN0IHsgY3JlYXRlQ2xpZW50IH0gPSByZXF1aXJlKCdAc3VwYWJhc2Uvc3VwYWJhc2UtanMnKTtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgbGV0IG1vY2tTdXBhYmFzZUNsaWVudDogYW55O1xuXG4gIGJlZm9yZUVhY2goKCkgPT4ge1xuICAgIGplc3QuY2xlYXJBbGxNb2NrcygpO1xuICAgIG1vY2tTdXBhYmFzZUNsaWVudCA9IGNyZWF0ZUNsaWVudCgpO1xuICAgIG1vY2tTdXBhYmFzZUNsaWVudC5mcm9tLm1vY2tDbGVhcigpO1xuICB9KTtcblxuICBkZXNjcmliZSgnRnJvbnRlbmQgVGFza3MgQVBJJywgKCkgPT4ge1xuICAgIGRlc2NyaWJlKCdHRVQgL2FwaS9mcm9udGVuZC10YXNrcycsICgpID0+IHtcbiAgICAgIGl0KCdzaG91bGQgcmV0dXJuIGFsbCBmcm9udGVuZCB0YXNrcycsIGFzeW5jICgpID0+IHtcbiAgICAgICAgY29uc3QgbW9ja1Rhc2tzID0gW1xuICAgICAgICAgIHtcbiAgICAgICAgICAgIGlkOiAndGFzay0xJyxcbiAgICAgICAgICAgIHRpdGxlOiAnQnVpbGQgYSBUb2RvIEFwcCcsXG4gICAgICAgICAgICBkZXNjcmlwdGlvbjogJ0NyZWF0ZSBhIFJlYWN0IHRvZG8gYXBwbGljYXRpb24nLFxuICAgICAgICAgICAgZGlmZmljdWx0eTogJ2Vhc3knLFxuICAgICAgICAgICAgY2F0ZWdvcnk6ICdyZWFjdCcsXG4gICAgICAgICAgICBlc3RpbWF0ZWRUaW1lOiAxMjAsXG4gICAgICAgICAgICBzdGFydGVyQ29kZTogJ2NvbnN0IEFwcCA9ICgpID0+IHsgcmV0dXJuIDxkaXY+VG9kbyBBcHA8L2Rpdj47IH07JyxcbiAgICAgICAgICAgIHRlc3RDYXNlczogW1xuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgaW5wdXQ6ICdBZGQgdGFzayBcIkxlYXJuIFJlYWN0XCInLFxuICAgICAgICAgICAgICAgIGV4cGVjdGVkT3V0cHV0OiAnVGFzayBhZGRlZCBzdWNjZXNzZnVsbHknLFxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIGNyZWF0ZWRBdDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxuICAgICAgICAgICAgdXBkYXRlZEF0OiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXG4gICAgICAgICAgfSxcbiAgICAgICAgXTtcblxuICAgICAgICBjb25zdCBtb2NrT3JkZXIgPSBqZXN0LmZuKCkubW9ja1Jlc29sdmVkVmFsdWUoe1xuICAgICAgICAgIGRhdGE6IG1vY2tUYXNrcyxcbiAgICAgICAgICBlcnJvcjogbnVsbCxcbiAgICAgICAgfSk7XG5cbiAgICAgICAgY29uc3QgbW9ja1NlbGVjdCA9IGplc3QuZm4oKS5tb2NrUmV0dXJuVmFsdWUoe1xuICAgICAgICAgIG9yZGVyOiBtb2NrT3JkZXIsXG4gICAgICAgIH0pO1xuXG4gICAgICAgIG1vY2tTdXBhYmFzZUNsaWVudC5mcm9tLm1vY2tSZXR1cm5WYWx1ZSh7XG4gICAgICAgICAgc2VsZWN0OiBtb2NrU2VsZWN0LFxuICAgICAgICB9KTtcblxuICAgICAgICBjb25zdCB7IEdFVCB9ID0gYXdhaXQgaW1wb3J0KCdAL2FwcC9hcGkvYWRtaW4vZnJvbnRlbmQtdGFza3Mvcm91dGUnKTtcbiAgICAgICAgY29uc3QgcmVxdWVzdCA9IG5ldyBOZXh0UmVxdWVzdChcbiAgICAgICAgICAnaHR0cDovL2xvY2FsaG9zdDozMDAwL2FwaS9hZG1pbi9mcm9udGVuZC10YXNrcydcbiAgICAgICAgKTtcblxuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IEdFVChyZXF1ZXN0KTtcbiAgICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcblxuICAgICAgICBleHBlY3QocmVzcG9uc2Uuc3RhdHVzKS50b0JlKDIwMCk7XG4gICAgICAgIGV4cGVjdChkYXRhLnN1Y2Nlc3MpLnRvQmUodHJ1ZSk7XG4gICAgICAgIGV4cGVjdChkYXRhLmRhdGEpLnRvSGF2ZUxlbmd0aCgxKTtcbiAgICAgICAgZXhwZWN0KGRhdGEuZGF0YVswXS50aXRsZSkudG9CZSgnQnVpbGQgYSBUb2RvIEFwcCcpO1xuICAgICAgICBleHBlY3QoZGF0YS5kYXRhWzBdLmRpZmZpY3VsdHkpLnRvQmUoJ2Vhc3knKTtcbiAgICAgIH0pO1xuXG4gICAgICBpdCgnc2hvdWxkIGZpbHRlciB0YXNrcyBieSBkaWZmaWN1bHR5JywgYXN5bmMgKCkgPT4ge1xuICAgICAgICBjb25zdCBtb2NrVGFza3MgPSBbXG4gICAgICAgICAge1xuICAgICAgICAgICAgaWQ6ICd0YXNrLTEnLFxuICAgICAgICAgICAgdGl0bGU6ICdFYXN5IFRhc2snLFxuICAgICAgICAgICAgZGlmZmljdWx0eTogJ2Vhc3knLFxuICAgICAgICAgICAgY2F0ZWdvcnk6ICdyZWFjdCcsXG4gICAgICAgICAgICBjcmVhdGVkQXQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcbiAgICAgICAgICAgIHVwZGF0ZWRBdDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxuICAgICAgICAgIH0sXG4gICAgICAgIF07XG5cbiAgICAgICAgY29uc3QgbW9ja09yZGVyID0gamVzdC5mbigpLm1vY2tSZXNvbHZlZFZhbHVlKHtcbiAgICAgICAgICBkYXRhOiBtb2NrVGFza3MsXG4gICAgICAgICAgZXJyb3I6IG51bGwsXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGNvbnN0IG1vY2tFcSA9IGplc3QuZm4oKS5tb2NrUmV0dXJuVmFsdWUoe1xuICAgICAgICAgIG9yZGVyOiBtb2NrT3JkZXIsXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGNvbnN0IG1vY2tTZWxlY3QgPSBqZXN0LmZuKCkubW9ja1JldHVyblZhbHVlKHtcbiAgICAgICAgICBlcTogbW9ja0VxLFxuICAgICAgICB9KTtcblxuICAgICAgICBtb2NrU3VwYWJhc2VDbGllbnQuZnJvbS5tb2NrUmV0dXJuVmFsdWUoe1xuICAgICAgICAgIHNlbGVjdDogbW9ja1NlbGVjdCxcbiAgICAgICAgfSk7XG5cbiAgICAgICAgY29uc3QgeyBHRVQgfSA9IGF3YWl0IGltcG9ydCgnQC9hcHAvYXBpL2FkbWluL2Zyb250ZW5kLXRhc2tzL3JvdXRlJyk7XG4gICAgICAgIGNvbnN0IHJlcXVlc3QgPSBuZXcgTmV4dFJlcXVlc3QoXG4gICAgICAgICAgJ2h0dHA6Ly9sb2NhbGhvc3Q6MzAwMC9hcGkvYWRtaW4vZnJvbnRlbmQtdGFza3M/ZGlmZmljdWx0eT1lYXN5J1xuICAgICAgICApO1xuXG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgR0VUKHJlcXVlc3QpO1xuICAgICAgICBjb25zdCBkYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuXG4gICAgICAgIGV4cGVjdChyZXNwb25zZS5zdGF0dXMpLnRvQmUoMjAwKTtcbiAgICAgICAgZXhwZWN0KGRhdGEuc3VjY2VzcykudG9CZSh0cnVlKTtcbiAgICAgICAgZXhwZWN0KGRhdGEuZGF0YSkudG9IYXZlTGVuZ3RoKDEpO1xuICAgICAgICBleHBlY3QoZGF0YS5kYXRhWzBdLmRpZmZpY3VsdHkpLnRvQmUoJ2Vhc3knKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgZGVzY3JpYmUoJ1BPU1QgL2FwaS9mcm9udGVuZC10YXNrcycsICgpID0+IHtcbiAgICAgIGl0KCdzaG91bGQgY3JlYXRlIGEgbmV3IGZyb250ZW5kIHRhc2snLCBhc3luYyAoKSA9PiB7XG4gICAgICAgIGNvbnN0IG5ld1Rhc2sgPSB7XG4gICAgICAgICAgdGl0bGU6ICdCdWlsZCBhIENhbGN1bGF0b3InLFxuICAgICAgICAgIGRlc2NyaXB0aW9uOiAnQ3JlYXRlIGEgY2FsY3VsYXRvciBhcHAgd2l0aCBSZWFjdCcsXG4gICAgICAgICAgZGlmZmljdWx0eTogJ21lZGl1bScsXG4gICAgICAgICAgY2F0ZWdvcnk6ICdyZWFjdCcsXG4gICAgICAgICAgZXN0aW1hdGVkVGltZTogMTgwLFxuICAgICAgICAgIHN0YXJ0ZXJDb2RlOlxuICAgICAgICAgICAgJ2NvbnN0IENhbGN1bGF0b3IgPSAoKSA9PiB7IHJldHVybiA8ZGl2PkNhbGN1bGF0b3I8L2Rpdj47IH07JyxcbiAgICAgICAgICB0ZXN0Q2FzZXM6IFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgaW5wdXQ6ICcyICsgMicsXG4gICAgICAgICAgICAgIGV4cGVjdGVkT3V0cHV0OiAnNCcsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgIF0sXG4gICAgICAgIH07XG5cbiAgICAgICAgY29uc3QgbW9ja1NpbmdsZSA9IGplc3QuZm4oKS5tb2NrUmVzb2x2ZWRWYWx1ZSh7XG4gICAgICAgICAgZGF0YTogeyBpZDogJ3Rlc3QtdGFzay1pZCcsIC4uLm5ld1Rhc2sgfSxcbiAgICAgICAgICBlcnJvcjogbnVsbCxcbiAgICAgICAgfSk7XG5cbiAgICAgICAgY29uc3QgbW9ja0luc2VydCA9IGplc3QuZm4oKS5tb2NrUmV0dXJuVmFsdWUoe1xuICAgICAgICAgIHNlbGVjdDogamVzdC5mbigpLm1vY2tSZXR1cm5WYWx1ZSh7XG4gICAgICAgICAgICBzaW5nbGU6IG1vY2tTaW5nbGUsXG4gICAgICAgICAgfSksXG4gICAgICAgIH0pO1xuXG4gICAgICAgIG1vY2tTdXBhYmFzZUNsaWVudC5mcm9tLm1vY2tSZXR1cm5WYWx1ZSh7XG4gICAgICAgICAgaW5zZXJ0OiBtb2NrSW5zZXJ0LFxuICAgICAgICB9KTtcblxuICAgICAgICBjb25zdCB7IFBPU1QgfSA9IGF3YWl0IGltcG9ydCgnQC9hcHAvYXBpL2FkbWluL2Zyb250ZW5kLXRhc2tzL3JvdXRlJyk7XG4gICAgICAgIGNvbnN0IHJlcXVlc3QgPSBuZXcgTmV4dFJlcXVlc3QoXG4gICAgICAgICAgJ2h0dHA6Ly9sb2NhbGhvc3Q6MzAwMC9hcGkvYWRtaW4vZnJvbnRlbmQtdGFza3MnLFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkobmV3VGFzayksXG4gICAgICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgIH1cbiAgICAgICAgKTtcblxuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IFBPU1QocmVxdWVzdCk7XG4gICAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG5cbiAgICAgICAgZXhwZWN0KHJlc3BvbnNlLnN0YXR1cykudG9CZSgyMDEpO1xuICAgICAgICBleHBlY3QoZGF0YS5zdWNjZXNzKS50b0JlKHRydWUpO1xuICAgICAgICBleHBlY3QoZGF0YS5kYXRhLmlkKS50b0JlKCd0ZXN0LXRhc2staWQnKTtcbiAgICAgICAgZXhwZWN0KGRhdGEuZGF0YS50aXRsZSkudG9CZSgnQnVpbGQgYSBDYWxjdWxhdG9yJyk7XG4gICAgICB9KTtcblxuICAgICAgaXQoJ3Nob3VsZCB2YWxpZGF0ZSByZXF1aXJlZCBmaWVsZHMgZm9yIGZyb250ZW5kIHRhc2tzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgICBjb25zdCBpbnZhbGlkVGFzayA9IHtcbiAgICAgICAgICBkZXNjcmlwdGlvbjogJ01pc3NpbmcgdGl0bGUgYW5kIGRpZmZpY3VsdHknLFxuICAgICAgICB9O1xuXG4gICAgICAgIGNvbnN0IHsgUE9TVCB9ID0gYXdhaXQgaW1wb3J0KCdAL2FwcC9hcGkvYWRtaW4vZnJvbnRlbmQtdGFza3Mvcm91dGUnKTtcbiAgICAgICAgY29uc3QgcmVxdWVzdCA9IG5ldyBOZXh0UmVxdWVzdChcbiAgICAgICAgICAnaHR0cDovL2xvY2FsaG9zdDozMDAwL2FwaS9hZG1pbi9mcm9udGVuZC10YXNrcycsXG4gICAgICAgICAge1xuICAgICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShpbnZhbGlkVGFzayksXG4gICAgICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgIH1cbiAgICAgICAgKTtcblxuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IFBPU1QocmVxdWVzdCk7XG4gICAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG5cbiAgICAgICAgZXhwZWN0KHJlc3BvbnNlLnN0YXR1cykudG9CZSg0MDApO1xuICAgICAgICBleHBlY3QoZGF0YS5zdWNjZXNzKS50b0JlKGZhbHNlKTtcbiAgICAgICAgZXhwZWN0KGRhdGEuZXJyb3IpLnRvQmVEZWZpbmVkKCk7XG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIGRlc2NyaWJlKCdQVVQgL2FwaS9hZG1pbi9mcm9udGVuZC10YXNrcy9baWRdJywgKCkgPT4ge1xuICAgICAgaXQoJ3Nob3VsZCB1cGRhdGUgYW4gZXhpc3RpbmcgZnJvbnRlbmQgdGFzaycsIGFzeW5jICgpID0+IHtcbiAgICAgICAgY29uc3QgdGFza0lkID0gJ3Rlc3QtdGFzay1pZCc7XG4gICAgICAgIGNvbnN0IHVwZGF0ZURhdGEgPSB7XG4gICAgICAgICAgdGl0bGU6ICdVcGRhdGVkIFRhc2sgVGl0bGUnLFxuICAgICAgICAgIGRlc2NyaXB0aW9uOiAnVXBkYXRlZCBkZXNjcmlwdGlvbicsXG4gICAgICAgICAgZXN0aW1hdGVkVGltZTogMjQwLFxuICAgICAgICB9O1xuXG4gICAgICAgIGNvbnN0IG1vY2tTaW5nbGUgPSBqZXN0LmZuKCkubW9ja1Jlc29sdmVkVmFsdWUoe1xuICAgICAgICAgIGRhdGE6IHsgaWQ6IHRhc2tJZCwgLi4udXBkYXRlRGF0YSB9LFxuICAgICAgICAgIGVycm9yOiBudWxsLFxuICAgICAgICB9KTtcblxuICAgICAgICBjb25zdCBtb2NrRXEgPSBqZXN0LmZuKCkubW9ja1JldHVyblZhbHVlKHtcbiAgICAgICAgICBzZWxlY3Q6IGplc3QuZm4oKS5tb2NrUmV0dXJuVmFsdWUoe1xuICAgICAgICAgICAgc2luZ2xlOiBtb2NrU2luZ2xlLFxuICAgICAgICAgIH0pLFxuICAgICAgICB9KTtcblxuICAgICAgICBjb25zdCBtb2NrVXBkYXRlID0gamVzdC5mbigpLm1vY2tSZXR1cm5WYWx1ZSh7XG4gICAgICAgICAgZXE6IG1vY2tFcSxcbiAgICAgICAgfSk7XG5cbiAgICAgICAgbW9ja1N1cGFiYXNlQ2xpZW50LmZyb20ubW9ja1JldHVyblZhbHVlKHtcbiAgICAgICAgICB1cGRhdGU6IG1vY2tVcGRhdGUsXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGNvbnN0IHsgUFVUIH0gPSBhd2FpdCBpbXBvcnQoXG4gICAgICAgICAgJ0AvYXBwL2FwaS9hZG1pbi9mcm9udGVuZC10YXNrcy9baWRdL3JvdXRlJ1xuICAgICAgICApO1xuICAgICAgICBjb25zdCByZXF1ZXN0ID0gbmV3IE5leHRSZXF1ZXN0KFxuICAgICAgICAgIGBodHRwOi8vbG9jYWxob3N0OjMwMDAvYXBpL2FkbWluL2Zyb250ZW5kLXRhc2tzLyR7dGFza0lkfWAsXG4gICAgICAgICAge1xuICAgICAgICAgICAgbWV0aG9kOiAnUFVUJyxcbiAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHVwZGF0ZURhdGEpLFxuICAgICAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICB9XG4gICAgICAgICk7XG5cbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBQVVQocmVxdWVzdCwgeyBwYXJhbXM6IHsgaWQ6IHRhc2tJZCB9IH0pO1xuICAgICAgICBjb25zdCBkYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuXG4gICAgICAgIGV4cGVjdChyZXNwb25zZS5zdGF0dXMpLnRvQmUoMjAwKTtcbiAgICAgICAgZXhwZWN0KGRhdGEuc3VjY2VzcykudG9CZSh0cnVlKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgZGVzY3JpYmUoJ0RFTEVURSAvYXBpL2FkbWluL2Zyb250ZW5kLXRhc2tzL1tpZF0nLCAoKSA9PiB7XG4gICAgICBpdCgnc2hvdWxkIGRlbGV0ZSBhIGZyb250ZW5kIHRhc2snLCBhc3luYyAoKSA9PiB7XG4gICAgICAgIGNvbnN0IHRhc2tJZCA9ICd0ZXN0LXRhc2staWQnO1xuXG4gICAgICAgIGNvbnN0IG1vY2tFcSA9IGplc3QuZm4oKS5tb2NrUmVzb2x2ZWRWYWx1ZSh7XG4gICAgICAgICAgZGF0YTogbnVsbCxcbiAgICAgICAgICBlcnJvcjogbnVsbCxcbiAgICAgICAgfSk7XG5cbiAgICAgICAgY29uc3QgbW9ja0RlbGV0ZSA9IGplc3QuZm4oKS5tb2NrUmV0dXJuVmFsdWUoe1xuICAgICAgICAgIGVxOiBtb2NrRXEsXG4gICAgICAgIH0pO1xuXG4gICAgICAgIG1vY2tTdXBhYmFzZUNsaWVudC5mcm9tLm1vY2tSZXR1cm5WYWx1ZSh7XG4gICAgICAgICAgZGVsZXRlOiBtb2NrRGVsZXRlLFxuICAgICAgICB9KTtcblxuICAgICAgICBjb25zdCB7IERFTEVURSB9ID0gYXdhaXQgaW1wb3J0KFxuICAgICAgICAgICdAL2FwcC9hcGkvYWRtaW4vZnJvbnRlbmQtdGFza3MvW2lkXS9yb3V0ZSdcbiAgICAgICAgKTtcbiAgICAgICAgY29uc3QgcmVxdWVzdCA9IG5ldyBOZXh0UmVxdWVzdChcbiAgICAgICAgICBgaHR0cDovL2xvY2FsaG9zdDozMDAwL2FwaS9hZG1pbi9mcm9udGVuZC10YXNrcy8ke3Rhc2tJZH1gLFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIG1ldGhvZDogJ0RFTEVURScsXG4gICAgICAgICAgfVxuICAgICAgICApO1xuXG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgREVMRVRFKHJlcXVlc3QsIHsgcGFyYW1zOiB7IGlkOiB0YXNrSWQgfSB9KTtcbiAgICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcblxuICAgICAgICBleHBlY3QocmVzcG9uc2Uuc3RhdHVzKS50b0JlKDIwMCk7XG4gICAgICAgIGV4cGVjdChkYXRhLnN1Y2Nlc3MpLnRvQmUodHJ1ZSk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ1Byb2JsZW0gU29sdmluZyBBUEknLCAoKSA9PiB7XG4gICAgZGVzY3JpYmUoJ0dFVCAvYXBpL2FkbWluL3Byb2JsZW0tc29sdmluZycsICgpID0+IHtcbiAgICAgIGl0KCdzaG91bGQgcmV0dXJuIGFsbCBwcm9ibGVtIHNvbHZpbmcgdGFza3MnLCBhc3luYyAoKSA9PiB7XG4gICAgICAgIGNvbnN0IG1vY2tQcm9ibGVtcyA9IFtcbiAgICAgICAgICB7XG4gICAgICAgICAgICBpZDogJ3Byb2JsZW0tMScsXG4gICAgICAgICAgICB0aXRsZTogJ1R3byBTdW0nLFxuICAgICAgICAgICAgZGVzY3JpcHRpb246ICdGaW5kIHR3byBudW1iZXJzIHRoYXQgYWRkIHVwIHRvIHRhcmdldCcsXG4gICAgICAgICAgICBkaWZmaWN1bHR5OiAnZWFzeScsXG4gICAgICAgICAgICBjYXRlZ29yeTogJ2FycmF5cycsXG4gICAgICAgICAgICB0ZXN0Q2FzZXM6IFtcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGlucHV0OiAnWzIsNywxMSwxNV0sIDknLFxuICAgICAgICAgICAgICAgIGV4cGVjdGVkT3V0cHV0OiAnWzAsMV0nLFxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIGhpbnRzOiBbJ1VzZSBhIGhhc2ggbWFwIHRvIHN0b3JlIGNvbXBsZW1lbnRzJ10sXG4gICAgICAgICAgICBjcmVhdGVkX2F0OiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXG4gICAgICAgICAgICB1cGRhdGVkX2F0OiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXG4gICAgICAgICAgfSxcbiAgICAgICAgXTtcblxuICAgICAgICBjb25zdCBtb2NrT3JkZXIgPSBqZXN0LmZuKCkubW9ja1Jlc29sdmVkVmFsdWUoe1xuICAgICAgICAgIGRhdGE6IG1vY2tQcm9ibGVtcyxcbiAgICAgICAgICBlcnJvcjogbnVsbCxcbiAgICAgICAgfSk7XG5cbiAgICAgICAgY29uc3QgbW9ja1NlbGVjdCA9IGplc3QuZm4oKS5tb2NrUmV0dXJuVmFsdWUoe1xuICAgICAgICAgIG9yZGVyOiBtb2NrT3JkZXIsXG4gICAgICAgIH0pO1xuXG4gICAgICAgIG1vY2tTdXBhYmFzZUNsaWVudC5mcm9tLm1vY2tSZXR1cm5WYWx1ZSh7XG4gICAgICAgICAgc2VsZWN0OiBtb2NrU2VsZWN0LFxuICAgICAgICB9KTtcblxuICAgICAgICBjb25zdCB7IEdFVCB9ID0gYXdhaXQgaW1wb3J0KCdAL2FwcC9hcGkvYWRtaW4vcHJvYmxlbS1zb2x2aW5nL3JvdXRlJyk7XG4gICAgICAgIGNvbnN0IHJlcXVlc3QgPSBuZXcgTmV4dFJlcXVlc3QoXG4gICAgICAgICAgJ2h0dHA6Ly9sb2NhbGhvc3Q6MzAwMC9hcGkvYWRtaW4vcHJvYmxlbS1zb2x2aW5nJ1xuICAgICAgICApO1xuXG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgR0VUKHJlcXVlc3QpO1xuICAgICAgICBjb25zdCBkYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuXG4gICAgICAgIGV4cGVjdChyZXNwb25zZS5zdGF0dXMpLnRvQmUoMjAwKTtcbiAgICAgICAgZXhwZWN0KGRhdGEuc3VjY2VzcykudG9CZSh0cnVlKTtcbiAgICAgICAgZXhwZWN0KGRhdGEuZGF0YSkudG9IYXZlTGVuZ3RoKDEpO1xuICAgICAgICBleHBlY3QoZGF0YS5kYXRhWzBdLnRpdGxlKS50b0JlKCdUd28gU3VtJyk7XG4gICAgICAgIGV4cGVjdChkYXRhLmRhdGFbMF0uZGlmZmljdWx0eSkudG9CZSgnZWFzeScpO1xuICAgICAgfSk7XG5cbiAgICAgIGl0KCdzaG91bGQgZmlsdGVyIHByb2JsZW1zIGJ5IGNhdGVnb3J5JywgYXN5bmMgKCkgPT4ge1xuICAgICAgICBjb25zdCBtb2NrUHJvYmxlbXMgPSBbXG4gICAgICAgICAge1xuICAgICAgICAgICAgaWQ6ICdwcm9ibGVtLTEnLFxuICAgICAgICAgICAgdGl0bGU6ICdBcnJheSBQcm9ibGVtJyxcbiAgICAgICAgICAgIGNhdGVnb3J5OiAnYXJyYXlzJyxcbiAgICAgICAgICAgIGRpZmZpY3VsdHk6ICdlYXN5JyxcbiAgICAgICAgICAgIGNyZWF0ZWRfYXQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcbiAgICAgICAgICAgIHVwZGF0ZWRfYXQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcbiAgICAgICAgICB9LFxuICAgICAgICBdO1xuXG4gICAgICAgIGNvbnN0IG1vY2tPcmRlciA9IGplc3QuZm4oKS5tb2NrUmVzb2x2ZWRWYWx1ZSh7XG4gICAgICAgICAgZGF0YTogbW9ja1Byb2JsZW1zLFxuICAgICAgICAgIGVycm9yOiBudWxsLFxuICAgICAgICB9KTtcblxuICAgICAgICBjb25zdCBtb2NrRXEgPSBqZXN0LmZuKCkubW9ja1JldHVyblZhbHVlKHtcbiAgICAgICAgICBvcmRlcjogbW9ja09yZGVyLFxuICAgICAgICB9KTtcblxuICAgICAgICBjb25zdCBtb2NrU2VsZWN0ID0gamVzdC5mbigpLm1vY2tSZXR1cm5WYWx1ZSh7XG4gICAgICAgICAgZXE6IG1vY2tFcSxcbiAgICAgICAgfSk7XG5cbiAgICAgICAgbW9ja1N1cGFiYXNlQ2xpZW50LmZyb20ubW9ja1JldHVyblZhbHVlKHtcbiAgICAgICAgICBzZWxlY3Q6IG1vY2tTZWxlY3QsXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGNvbnN0IHsgR0VUIH0gPSBhd2FpdCBpbXBvcnQoJ0AvYXBwL2FwaS9hZG1pbi9wcm9ibGVtLXNvbHZpbmcvcm91dGUnKTtcbiAgICAgICAgY29uc3QgcmVxdWVzdCA9IG5ldyBOZXh0UmVxdWVzdChcbiAgICAgICAgICAnaHR0cDovL2xvY2FsaG9zdDozMDAwL2FwaS9hZG1pbi9wcm9ibGVtLXNvbHZpbmc/Y2F0ZWdvcnk9YXJyYXlzJ1xuICAgICAgICApO1xuXG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgR0VUKHJlcXVlc3QpO1xuICAgICAgICBjb25zdCBkYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuXG4gICAgICAgIGV4cGVjdChyZXNwb25zZS5zdGF0dXMpLnRvQmUoMjAwKTtcbiAgICAgICAgZXhwZWN0KGRhdGEuc3VjY2VzcykudG9CZSh0cnVlKTtcbiAgICAgICAgZXhwZWN0KGRhdGEuZGF0YSkudG9IYXZlTGVuZ3RoKDEpO1xuICAgICAgICBleHBlY3QoZGF0YS5kYXRhWzBdLmNhdGVnb3J5KS50b0JlKCdhcnJheXMnKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgZGVzY3JpYmUoJ1BPU1QgL2FwaS9hZG1pbi9wcm9ibGVtLXNvbHZpbmcnLCAoKSA9PiB7XG4gICAgICBpdCgnc2hvdWxkIGNyZWF0ZSBhIG5ldyBwcm9ibGVtIHNvbHZpbmcgdGFzaycsIGFzeW5jICgpID0+IHtcbiAgICAgICAgY29uc3QgbmV3UHJvYmxlbSA9IHtcbiAgICAgICAgICB0aXRsZTogJ1JldmVyc2UgU3RyaW5nJyxcbiAgICAgICAgICBkZXNjcmlwdGlvbjogJ1JldmVyc2UgYSBnaXZlbiBzdHJpbmcnLFxuICAgICAgICAgIGRpZmZpY3VsdHk6ICdlYXN5JyxcbiAgICAgICAgICBjYXRlZ29yeTogJ3N0cmluZ3MnLFxuICAgICAgICAgIHRlc3RDYXNlczogW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBpbnB1dDogJ1wiaGVsbG9cIicsXG4gICAgICAgICAgICAgIGV4cGVjdGVkT3V0cHV0OiAnXCJvbGxlaFwiJyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgXSxcbiAgICAgICAgICBoaW50czogWydVc2UgdHdvIHBvaW50ZXJzJ10sXG4gICAgICAgIH07XG5cbiAgICAgICAgY29uc3QgbW9ja1NpbmdsZSA9IGplc3QuZm4oKS5tb2NrUmVzb2x2ZWRWYWx1ZSh7XG4gICAgICAgICAgZGF0YTogeyBpZDogJ3Rlc3QtcHJvYmxlbS1pZCcsIC4uLm5ld1Byb2JsZW0gfSxcbiAgICAgICAgICBlcnJvcjogbnVsbCxcbiAgICAgICAgfSk7XG5cbiAgICAgICAgY29uc3QgbW9ja0luc2VydCA9IGplc3QuZm4oKS5tb2NrUmV0dXJuVmFsdWUoe1xuICAgICAgICAgIHNlbGVjdDogamVzdC5mbigpLm1vY2tSZXR1cm5WYWx1ZSh7XG4gICAgICAgICAgICBzaW5nbGU6IG1vY2tTaW5nbGUsXG4gICAgICAgICAgfSksXG4gICAgICAgIH0pO1xuXG4gICAgICAgIG1vY2tTdXBhYmFzZUNsaWVudC5mcm9tLm1vY2tSZXR1cm5WYWx1ZSh7XG4gICAgICAgICAgaW5zZXJ0OiBtb2NrSW5zZXJ0LFxuICAgICAgICB9KTtcblxuICAgICAgICBjb25zdCB7IFBPU1QgfSA9IGF3YWl0IGltcG9ydCgnQC9hcHAvYXBpL2FkbWluL3Byb2JsZW0tc29sdmluZy9yb3V0ZScpO1xuICAgICAgICBjb25zdCByZXF1ZXN0ID0gbmV3IE5leHRSZXF1ZXN0KFxuICAgICAgICAgICdodHRwOi8vbG9jYWxob3N0OjMwMDAvYXBpL2FkbWluL3Byb2JsZW0tc29sdmluZycsXG4gICAgICAgICAge1xuICAgICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShuZXdQcm9ibGVtKSxcbiAgICAgICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgfVxuICAgICAgICApO1xuXG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgUE9TVChyZXF1ZXN0KTtcbiAgICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcblxuICAgICAgICBleHBlY3QocmVzcG9uc2Uuc3RhdHVzKS50b0JlKDIwMSk7XG4gICAgICAgIGV4cGVjdChkYXRhLnN1Y2Nlc3MpLnRvQmUodHJ1ZSk7XG4gICAgICAgIGV4cGVjdChkYXRhLmRhdGEuaWQpLnRvQmUoJ3Rlc3QtcHJvYmxlbS1pZCcpO1xuICAgICAgICBleHBlY3QoZGF0YS5kYXRhLnRpdGxlKS50b0JlKCdSZXZlcnNlIFN0cmluZycpO1xuICAgICAgfSk7XG5cbiAgICAgIGl0KCdzaG91bGQgdmFsaWRhdGUgcmVxdWlyZWQgZmllbGRzIGZvciBwcm9ibGVtIHNvbHZpbmcgdGFza3MnLCBhc3luYyAoKSA9PiB7XG4gICAgICAgIGNvbnN0IGludmFsaWRQcm9ibGVtID0ge1xuICAgICAgICAgIGRlc2NyaXB0aW9uOiAnTWlzc2luZyB0aXRsZSBhbmQgZGlmZmljdWx0eScsXG4gICAgICAgIH07XG5cbiAgICAgICAgY29uc3QgeyBQT1NUIH0gPSBhd2FpdCBpbXBvcnQoJ0AvYXBwL2FwaS9hZG1pbi9wcm9ibGVtLXNvbHZpbmcvcm91dGUnKTtcbiAgICAgICAgY29uc3QgcmVxdWVzdCA9IG5ldyBOZXh0UmVxdWVzdChcbiAgICAgICAgICAnaHR0cDovL2xvY2FsaG9zdDozMDAwL2FwaS9hZG1pbi9wcm9ibGVtLXNvbHZpbmcnLFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoaW52YWxpZFByb2JsZW0pLFxuICAgICAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICB9XG4gICAgICAgICk7XG5cbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBQT1NUKHJlcXVlc3QpO1xuICAgICAgICBjb25zdCBkYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuXG4gICAgICAgIGV4cGVjdChyZXNwb25zZS5zdGF0dXMpLnRvQmUoNDAwKTtcbiAgICAgICAgZXhwZWN0KGRhdGEuc3VjY2VzcykudG9CZShmYWxzZSk7XG4gICAgICAgIGV4cGVjdChkYXRhLmVycm9yKS50b0JlRGVmaW5lZCgpO1xuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICBkZXNjcmliZSgnUFVUIC9hcGkvYWRtaW4vcHJvYmxlbS1zb2x2aW5nL1tpZF0nLCAoKSA9PiB7XG4gICAgICBpdCgnc2hvdWxkIHVwZGF0ZSBhbiBleGlzdGluZyBwcm9ibGVtIHNvbHZpbmcgdGFzaycsIGFzeW5jICgpID0+IHtcbiAgICAgICAgY29uc3QgcHJvYmxlbUlkID0gJ3Rlc3QtcHJvYmxlbS1pZCc7XG4gICAgICAgIGNvbnN0IHVwZGF0ZURhdGEgPSB7XG4gICAgICAgICAgdGl0bGU6ICdVcGRhdGVkIFByb2JsZW0gVGl0bGUnLFxuICAgICAgICAgIGRlc2NyaXB0aW9uOiAnVXBkYXRlZCBkZXNjcmlwdGlvbicsXG4gICAgICAgICAgaGludHM6IFsnVXBkYXRlZCBoaW50J10sXG4gICAgICAgIH07XG5cbiAgICAgICAgY29uc3QgbW9ja1NpbmdsZSA9IGplc3QuZm4oKS5tb2NrUmVzb2x2ZWRWYWx1ZSh7XG4gICAgICAgICAgZGF0YTogeyBpZDogcHJvYmxlbUlkLCAuLi51cGRhdGVEYXRhIH0sXG4gICAgICAgICAgZXJyb3I6IG51bGwsXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGNvbnN0IG1vY2tFcSA9IGplc3QuZm4oKS5tb2NrUmV0dXJuVmFsdWUoe1xuICAgICAgICAgIHNlbGVjdDogamVzdC5mbigpLm1vY2tSZXR1cm5WYWx1ZSh7XG4gICAgICAgICAgICBzaW5nbGU6IG1vY2tTaW5nbGUsXG4gICAgICAgICAgfSksXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGNvbnN0IG1vY2tVcGRhdGUgPSBqZXN0LmZuKCkubW9ja1JldHVyblZhbHVlKHtcbiAgICAgICAgICBlcTogbW9ja0VxLFxuICAgICAgICB9KTtcblxuICAgICAgICBtb2NrU3VwYWJhc2VDbGllbnQuZnJvbS5tb2NrUmV0dXJuVmFsdWUoe1xuICAgICAgICAgIHVwZGF0ZTogbW9ja1VwZGF0ZSxcbiAgICAgICAgfSk7XG5cbiAgICAgICAgY29uc3QgeyBQVVQgfSA9IGF3YWl0IGltcG9ydChcbiAgICAgICAgICAnQC9hcHAvYXBpL2FkbWluL3Byb2JsZW0tc29sdmluZy9baWRdL3JvdXRlJ1xuICAgICAgICApO1xuICAgICAgICBjb25zdCByZXF1ZXN0ID0gbmV3IE5leHRSZXF1ZXN0KFxuICAgICAgICAgIGBodHRwOi8vbG9jYWxob3N0OjMwMDAvYXBpL2FkbWluL3Byb2JsZW0tc29sdmluZy8ke3Byb2JsZW1JZH1gLFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIG1ldGhvZDogJ1BVVCcsXG4gICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh1cGRhdGVEYXRhKSxcbiAgICAgICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgfVxuICAgICAgICApO1xuXG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgUFVUKHJlcXVlc3QsIHsgcGFyYW1zOiB7IGlkOiBwcm9ibGVtSWQgfSB9KTtcbiAgICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcblxuICAgICAgICBleHBlY3QocmVzcG9uc2Uuc3RhdHVzKS50b0JlKDIwMCk7XG4gICAgICAgIGV4cGVjdChkYXRhLnN1Y2Nlc3MpLnRvQmUodHJ1ZSk7XG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIGRlc2NyaWJlKCdERUxFVEUgL2FwaS9hZG1pbi9wcm9ibGVtLXNvbHZpbmcvW2lkXScsICgpID0+IHtcbiAgICAgIGl0KCdzaG91bGQgZGVsZXRlIGEgcHJvYmxlbSBzb2x2aW5nIHRhc2snLCBhc3luYyAoKSA9PiB7XG4gICAgICAgIGNvbnN0IHByb2JsZW1JZCA9ICd0ZXN0LXByb2JsZW0taWQnO1xuXG4gICAgICAgIGNvbnN0IG1vY2tFcSA9IGplc3QuZm4oKS5tb2NrUmVzb2x2ZWRWYWx1ZSh7XG4gICAgICAgICAgZGF0YTogbnVsbCxcbiAgICAgICAgICBlcnJvcjogbnVsbCxcbiAgICAgICAgfSk7XG5cbiAgICAgICAgY29uc3QgbW9ja0RlbGV0ZSA9IGplc3QuZm4oKS5tb2NrUmV0dXJuVmFsdWUoe1xuICAgICAgICAgIGVxOiBtb2NrRXEsXG4gICAgICAgIH0pO1xuXG4gICAgICAgIG1vY2tTdXBhYmFzZUNsaWVudC5mcm9tLm1vY2tSZXR1cm5WYWx1ZSh7XG4gICAgICAgICAgZGVsZXRlOiBtb2NrRGVsZXRlLFxuICAgICAgICB9KTtcblxuICAgICAgICBjb25zdCB7IERFTEVURSB9ID0gYXdhaXQgaW1wb3J0KFxuICAgICAgICAgICdAL2FwcC9hcGkvYWRtaW4vcHJvYmxlbS1zb2x2aW5nL1tpZF0vcm91dGUnXG4gICAgICAgICk7XG4gICAgICAgIGNvbnN0IHJlcXVlc3QgPSBuZXcgTmV4dFJlcXVlc3QoXG4gICAgICAgICAgYGh0dHA6Ly9sb2NhbGhvc3Q6MzAwMC9hcGkvYWRtaW4vcHJvYmxlbS1zb2x2aW5nLyR7cHJvYmxlbUlkfWAsXG4gICAgICAgICAge1xuICAgICAgICAgICAgbWV0aG9kOiAnREVMRVRFJyxcbiAgICAgICAgICB9XG4gICAgICAgICk7XG5cbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBERUxFVEUocmVxdWVzdCwgeyBwYXJhbXM6IHsgaWQ6IHByb2JsZW1JZCB9IH0pO1xuICAgICAgICBjb25zdCBkYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuXG4gICAgICAgIGV4cGVjdChyZXNwb25zZS5zdGF0dXMpLnRvQmUoMjAwKTtcbiAgICAgICAgZXhwZWN0KGRhdGEuc3VjY2VzcykudG9CZSh0cnVlKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgnRXJyb3IgSGFuZGxpbmcnLCAoKSA9PiB7XG4gICAgaXQoJ3Nob3VsZCBoYW5kbGUgU3VwYWJhc2UgY29ubmVjdGlvbiBlcnJvcnMgZ3JhY2VmdWxseScsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IG1vY2tPcmRlciA9IGplc3RcbiAgICAgICAgLmZuKClcbiAgICAgICAgLm1vY2tSZWplY3RlZFZhbHVlKG5ldyBFcnJvcignU3VwYWJhc2UgY29ubmVjdGlvbiBmYWlsZWQnKSk7XG5cbiAgICAgIGNvbnN0IG1vY2tTZWxlY3QgPSBqZXN0LmZuKCkubW9ja1JldHVyblZhbHVlKHtcbiAgICAgICAgb3JkZXI6IG1vY2tPcmRlcixcbiAgICAgIH0pO1xuXG4gICAgICBtb2NrU3VwYWJhc2VDbGllbnQuZnJvbS5tb2NrUmV0dXJuVmFsdWUoe1xuICAgICAgICBzZWxlY3Q6IG1vY2tTZWxlY3QsXG4gICAgICB9KTtcblxuICAgICAgY29uc3QgeyBHRVQgfSA9IGF3YWl0IGltcG9ydCgnQC9hcHAvYXBpL2FkbWluL2Zyb250ZW5kLXRhc2tzL3JvdXRlJyk7XG4gICAgICBjb25zdCByZXF1ZXN0ID0gbmV3IE5leHRSZXF1ZXN0KFxuICAgICAgICAnaHR0cDovL2xvY2FsaG9zdDozMDAwL2FwaS9hZG1pbi9mcm9udGVuZC10YXNrcydcbiAgICAgICk7XG5cbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgR0VUKHJlcXVlc3QpO1xuICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcblxuICAgICAgZXhwZWN0KHJlc3BvbnNlLnN0YXR1cykudG9CZSg1MDApO1xuICAgICAgZXhwZWN0KGRhdGEuc3VjY2VzcykudG9CZShmYWxzZSk7XG4gICAgICBleHBlY3QoZGF0YS5lcnJvcikudG9CZURlZmluZWQoKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgaGFuZGxlIGludmFsaWQgSlNPTiBpbiByZXF1ZXN0IGJvZHknLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCB7IFBPU1QgfSA9IGF3YWl0IGltcG9ydCgnQC9hcHAvYXBpL2FkbWluL2Zyb250ZW5kLXRhc2tzL3JvdXRlJyk7XG4gICAgICBjb25zdCByZXF1ZXN0ID0gbmV3IE5leHRSZXF1ZXN0KFxuICAgICAgICAnaHR0cDovL2xvY2FsaG9zdDozMDAwL2FwaS9hZG1pbi9mcm9udGVuZC10YXNrcycsXG4gICAgICAgIHtcbiAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICBib2R5OiAnaW52YWxpZCBqc29uJyxcbiAgICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICAgIH0sXG4gICAgICAgIH1cbiAgICAgICk7XG5cbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgUE9TVChyZXF1ZXN0KTtcbiAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG5cbiAgICAgIGV4cGVjdChyZXNwb25zZS5zdGF0dXMpLnRvQmUoNDAwKTtcbiAgICAgIGV4cGVjdChkYXRhLnN1Y2Nlc3MpLnRvQmUoZmFsc2UpO1xuICAgICAgZXhwZWN0KGRhdGEuZXJyb3IpLnRvQmVEZWZpbmVkKCk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIGhhbmRsZSBtaXNzaW5nIENvbnRlbnQtVHlwZSBoZWFkZXInLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCB7IFBPU1QgfSA9IGF3YWl0IGltcG9ydCgnQC9hcHAvYXBpL2FkbWluL2Zyb250ZW5kLXRhc2tzL3JvdXRlJyk7XG4gICAgICBjb25zdCByZXF1ZXN0ID0gbmV3IE5leHRSZXF1ZXN0KFxuICAgICAgICAnaHR0cDovL2xvY2FsaG9zdDozMDAwL2FwaS9hZG1pbi9mcm9udGVuZC10YXNrcycsXG4gICAgICAgIHtcbiAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7IHRpdGxlOiAnVGVzdCBUYXNrJyB9KSxcbiAgICAgICAgfVxuICAgICAgKTtcblxuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBQT1NUKHJlcXVlc3QpO1xuICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcblxuICAgICAgZXhwZWN0KHJlc3BvbnNlLnN0YXR1cykudG9CZSg0MDApO1xuICAgICAgZXhwZWN0KGRhdGEuc3VjY2VzcykudG9CZShmYWxzZSk7XG4gICAgICBleHBlY3QoZGF0YS5lcnJvcikudG9CZURlZmluZWQoKTtcbiAgICB9KTtcbiAgfSk7XG59KTtcbiJdLCJuYW1lcyI6WyJqZXN0IiwibW9jayIsImNyZWF0ZUNsaWVudCIsImZuIiwiZnJvbSIsInNlbGVjdCIsImluc2VydCIsInVwZGF0ZSIsImRlbGV0ZSIsImVxIiwic2luZ2xlIiwib3JkZXIiLCJhdXRoIiwib25BdXRoU3RhdGVDaGFuZ2UiLCJkYXRhIiwic3Vic2NyaXB0aW9uIiwiZXJyb3IiLCJnZXRTZXNzaW9uIiwibW9ja1Jlc29sdmVkVmFsdWUiLCJzZXNzaW9uIiwiZ2V0VXNlciIsInVzZXIiLCJwcm9jZXNzIiwiZW52IiwiTkVYVF9QVUJMSUNfU1VQQUJBU0VfVVJMIiwiTkVYVF9QVUJMSUNfU1VQQUJBU0VfQU5PTl9LRVkiLCJTVVBBQkFTRV9TRVJWSUNFX1JPTEVfS0VZIiwiZGVzY3JpYmUiLCJyZXF1aXJlIiwibW9ja1N1cGFiYXNlQ2xpZW50IiwiYmVmb3JlRWFjaCIsImNsZWFyQWxsTW9ja3MiLCJtb2NrQ2xlYXIiLCJpdCIsIm1vY2tUYXNrcyIsImlkIiwidGl0bGUiLCJkZXNjcmlwdGlvbiIsImRpZmZpY3VsdHkiLCJjYXRlZ29yeSIsImVzdGltYXRlZFRpbWUiLCJzdGFydGVyQ29kZSIsInRlc3RDYXNlcyIsImlucHV0IiwiZXhwZWN0ZWRPdXRwdXQiLCJjcmVhdGVkQXQiLCJEYXRlIiwidG9JU09TdHJpbmciLCJ1cGRhdGVkQXQiLCJtb2NrT3JkZXIiLCJtb2NrU2VsZWN0IiwibW9ja1JldHVyblZhbHVlIiwiR0VUIiwicmVxdWVzdCIsIk5leHRSZXF1ZXN0IiwicmVzcG9uc2UiLCJqc29uIiwiZXhwZWN0Iiwic3RhdHVzIiwidG9CZSIsInN1Y2Nlc3MiLCJ0b0hhdmVMZW5ndGgiLCJtb2NrRXEiLCJuZXdUYXNrIiwibW9ja1NpbmdsZSIsIm1vY2tJbnNlcnQiLCJQT1NUIiwibWV0aG9kIiwiYm9keSIsIkpTT04iLCJzdHJpbmdpZnkiLCJoZWFkZXJzIiwiaW52YWxpZFRhc2siLCJ0b0JlRGVmaW5lZCIsInRhc2tJZCIsInVwZGF0ZURhdGEiLCJtb2NrVXBkYXRlIiwiUFVUIiwicGFyYW1zIiwibW9ja0RlbGV0ZSIsIkRFTEVURSIsIm1vY2tQcm9ibGVtcyIsImhpbnRzIiwiY3JlYXRlZF9hdCIsInVwZGF0ZWRfYXQiLCJuZXdQcm9ibGVtIiwiaW52YWxpZFByb2JsZW0iLCJwcm9ibGVtSWQiLCJtb2NrUmVqZWN0ZWRWYWx1ZSIsIkVycm9yIl0sIm1hcHBpbmdz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