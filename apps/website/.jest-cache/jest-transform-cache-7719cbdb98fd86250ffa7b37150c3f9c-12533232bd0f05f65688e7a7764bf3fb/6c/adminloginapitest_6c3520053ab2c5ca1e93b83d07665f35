644fb1c2a378c959faaf20f06f94d4dc
/* eslint-disable @typescript-eslint/no-explicit-any */ /**
 * Admin Login API Tests
 *
 * Tests for the /api/admin/auth endpoint to ensure:
 * - Authentication works correctly
 * - Proper error handling
 * - JWT token generation
 * - Security measures
 */ "use strict";
// Mock NextResponse to ensure json() method works correctly
jest.mock('next/server', ()=>{
    const actual = jest.requireActual('next/server');
    return {
        ...actual,
        NextResponse: {
            ...actual.NextResponse,
            json: (body, init)=>{
                const response = actual.NextResponse.json(body, init);
                // Ensure _body is set for test compatibility
                response._body = JSON.stringify(body);
                return response;
            }
        }
    };
});
jest.mock('@supabase/supabase-js', ()=>{
    // Create the mock client inside the factory
    const client = {
        from: jest.fn()
    };
    return {
        createClient: jest.fn(()=>client)
    };
});
// Export the mock client so tests can configure it
// We'll get it from the mocked module
// Mock bcrypt
jest.mock('bcryptjs', ()=>({
        compare: jest.fn(),
        hash: jest.fn()
    }));
// Mock admin.config
jest.mock('@/admin.config', ()=>({
        adminConfig: {
            security: {
                saltRounds: 10,
                sessionTimeout: 24 * 60 * 60 * 1000
            },
            jwt: {
                secret: 'test-jwt-secret'
            }
        },
        getAdminApiUrl: jest.fn((path)=>`http://localhost:3000${path}`)
    }));
Object.defineProperty(exports, "__esModule", {
    value: true
});
const _server = require("next/server");
const _route = require("../../apps/website/src/app/api/admin/auth/route");
// Helper to extract JSON from NextResponse
async function getResponseData(response) {
    // NextResponse.json() stores data in response._body or response.body
    // Check all possible locations
    // Method 1: Try json() method
    try {
        const data = await response.json();
        if (data && typeof data === 'object' && Object.keys(data).length > 0) {
            return data;
        }
    } catch (_e) {
    // Continue to other methods
    }
    // Method 2: Check internal _body property (NextResponse might use this)
    if (response._body !== undefined) {
        const body = response._body;
        if (typeof body === 'string') {
            try {
                return JSON.parse(body);
            } catch  {
                return {};
            }
        }
        if (body && typeof body === 'object') {
            return body;
        }
    }
    // Method 3: Try text() method
    try {
        const text = await response.text();
        if (text) {
            return JSON.parse(text);
        }
    } catch (_e) {
    // Continue
    }
    // Method 4: Try body ReadableStream
    if (response.body) {
        try {
            const reader = response.body.getReader();
            const { value, done } = await reader.read();
            if (!done && value) {
                const text = new TextDecoder().decode(value);
                return JSON.parse(text);
            }
        } catch (_e) {
        // Continue
        }
    }
    // Method 5: Check if response has data property directly
    if (response.data) {
        return response.data;
    }
    return {};
}
// Mock Supabase - this needs to be set up before the route module is imported
// The route handler creates the client at module load, so we need a shared instance
// Define the mock client inside the factory to avoid hoisting issues
const mockSupabaseClient = {
    from: jest.fn()
};
describe('Admin Login API', ()=>{
    // eslint-disable-next-line @typescript-eslint/no-require-imports
    const bcrypt = require('bcryptjs');
    // eslint-disable-next-line @typescript-eslint/no-require-imports
    const { createClient } = require('@supabase/supabase-js');
    let mockSupabaseClient;
    let consoleErrorSpy;
    beforeEach(()=>{
        jest.clearAllMocks();
        // Mock console.error globally to suppress error output during tests
        consoleErrorSpy = jest.spyOn(console, 'error').mockImplementation(()=>{});
        // Get the mock client instance (same one used by the route handler)
        mockSupabaseClient = createClient();
        // Reset the from mock for each test
        mockSupabaseClient.from.mockClear();
        // Set up environment variables
        process.env.JWT_SECRET = 'test-jwt-secret';
        process.env.NEXT_PUBLIC_SUPABASE_URL = 'https://test.supabase.co';
        process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY = 'test-anon-key';
        process.env.SUPABASE_SERVICE_ROLE_KEY = 'test-service-role-key';
    });
    afterEach(()=>{
        delete process.env.JWT_SECRET;
        delete process.env.NEXT_PUBLIC_SUPABASE_URL;
        delete process.env.SUPABASE_SERVICE_ROLE_KEY;
        // Restore console.error after each test
        if (consoleErrorSpy) {
            consoleErrorSpy.mockRestore();
        }
    });
    describe('POST /api/admin/auth', ()=>{
        it('should authenticate admin with valid credentials', async ()=>{
            // Mock Supabase response
            const mockAdmin = {
                id: 'admin_123',
                email: 'test@example.com',
                name: 'Test Admin',
                role: 'super_admin',
                password_hash: 'hashed_password',
                is_active: true,
                created_at: new Date().toISOString()
            };
            const mockSingle = Promise.resolve({
                data: mockAdmin,
                error: null
            });
            const mockEq = jest.fn().mockReturnValue({
                single: ()=>mockSingle
            });
            const mockSelect = jest.fn().mockReturnValue({
                eq: mockEq
            });
            mockSupabaseClient.from.mockReturnValue({
                select: mockSelect,
                update: jest.fn().mockReturnValue({
                    eq: jest.fn().mockResolvedValue({
                        error: null
                    })
                })
            });
            // Mock bcrypt compare
            bcrypt.compare.mockResolvedValue(true);
            const request = new _server.NextRequest('http://localhost:3000/api/admin/auth', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    email: 'test@example.com',
                    password: 'testpassword123'
                })
            });
            const response = await (0, _route.POST)(request);
            const data = await getResponseData(response);
            expect(response.status).toBe(200);
            expect(data).toBeDefined();
            expect(data.success).toBe(true);
            expect(data.admin).toBeDefined();
            expect(data.admin.email).toBe(mockAdmin.email);
            expect(data.admin.token).toBeDefined();
            expect(data.admin.token).toMatch(/^[A-Za-z0-9-_]+\.[A-Za-z0-9-_]+\.[A-Za-z0-9-_]+$/);
        });
        it('should reject authentication with invalid credentials', async ()=>{
            // Mock Supabase - admin not found
            const mockSingle = jest.fn().mockResolvedValue({
                data: null,
                error: {
                    message: 'Not found'
                }
            });
            mockSupabaseClient.from.mockReturnValue({
                select: jest.fn().mockReturnValue({
                    eq: jest.fn().mockReturnValue({
                        single: mockSingle
                    })
                })
            });
            const request = new _server.NextRequest('http://localhost:3000/api/admin/auth', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    email: 'test@example.com',
                    password: 'wrongpassword'
                })
            });
            const response = await (0, _route.POST)(request);
            const data = await getResponseData(response);
            expect(response.status).toBe(401);
            expect(data.success).toBe(false);
            expect(data.error).toBe('Invalid email or password');
        });
        it('should reject authentication with wrong password', async ()=>{
            // Mock Supabase - admin found but wrong password
            const mockAdmin = {
                id: 'admin_123',
                email: 'test@example.com',
                password_hash: 'hashed_password',
                is_active: true
            };
            const mockSingle = Promise.resolve({
                data: mockAdmin,
                error: null
            });
            const mockEq = jest.fn().mockReturnValue({
                single: ()=>mockSingle
            });
            const mockSelect = jest.fn().mockReturnValue({
                eq: mockEq
            });
            mockSupabaseClient.from.mockReturnValue({
                select: mockSelect
            });
            // Mock bcrypt compare - wrong password
            bcrypt.compare.mockResolvedValue(false);
            const request = new _server.NextRequest('http://localhost:3000/api/admin/auth', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    email: 'test@example.com',
                    password: 'wrongpassword'
                })
            });
            const response = await (0, _route.POST)(request);
            const data = await getResponseData(response);
            expect(response.status).toBe(401);
            expect(data.success).toBe(false);
            expect(data.error).toBe('Invalid email or password');
        });
        it('should reject authentication with missing email', async ()=>{
            const request = new _server.NextRequest('http://localhost:3000/api/admin/auth', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    password: 'testpassword123'
                })
            });
            const response = await (0, _route.POST)(request);
            const data = await getResponseData(response);
            expect(response.status).toBe(400);
            expect(data.success).toBe(false);
            expect(data.error).toBe('Email and password are required');
        });
        it('should reject authentication with missing password', async ()=>{
            const request = new _server.NextRequest('http://localhost:3000/api/admin/auth', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    email: 'test@example.com'
                })
            });
            const response = await (0, _route.POST)(request);
            const data = await getResponseData(response);
            expect(response.status).toBe(400);
            expect(data.success).toBe(false);
            expect(data.error).toBe('Email and password are required');
        });
        it('should handle server errors gracefully', async ()=>{
            // Mock Supabase error
            const mockSingle = Promise.reject(new Error('Database connection failed'));
            const mockEq = jest.fn().mockReturnValue({
                single: ()=>mockSingle
            });
            const mockSelect = jest.fn().mockReturnValue({
                eq: mockEq
            });
            mockSupabaseClient.from.mockReturnValue({
                select: mockSelect
            });
            const request = new _server.NextRequest('http://localhost:3000/api/admin/auth', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    email: 'test@example.com',
                    password: 'testpassword123'
                })
            });
            const response = await (0, _route.POST)(request);
            const data = await getResponseData(response);
            expect(response.status).toBe(500);
            expect(data.success).toBe(false);
            expect(data.error).toBeDefined();
        });
        it('should handle requests without Content-Type header', async ()=>{
            // Mock Supabase - admin not found
            const mockSingle = Promise.resolve({
                data: null,
                error: {
                    message: 'Not found'
                }
            });
            const mockEq = jest.fn().mockReturnValue({
                single: ()=>mockSingle
            });
            const mockSelect = jest.fn().mockReturnValue({
                eq: mockEq
            });
            mockSupabaseClient.from.mockReturnValue({
                select: mockSelect
            });
            const request = new _server.NextRequest('http://localhost:3000/api/admin/auth', {
                method: 'POST',
                body: JSON.stringify({
                    email: 'test@example.com',
                    password: 'testpassword123'
                })
            });
            const response = await (0, _route.POST)(request);
            const data = await getResponseData(response);
            // The route should still process the request if body is valid JSON
            // It will fail authentication (401) since admin is not found
            expect(response.status).toBe(401);
            expect(data.success).toBe(false);
        });
        it('should generate JWT token with correct expiration', async ()=>{
            const mockAdmin = {
                id: 'admin_123',
                email: 'test@example.com',
                name: 'Test Admin',
                role: 'super_admin',
                password_hash: 'hashed_password',
                is_active: true,
                created_at: new Date().toISOString()
            };
            const mockSingle = Promise.resolve({
                data: mockAdmin,
                error: null
            });
            const mockEq = jest.fn().mockReturnValue({
                single: ()=>mockSingle
            });
            const mockSelect = jest.fn().mockReturnValue({
                eq: mockEq
            });
            mockSupabaseClient.from.mockReturnValue({
                select: mockSelect,
                update: jest.fn().mockReturnValue({
                    eq: jest.fn().mockResolvedValue({
                        error: null
                    })
                })
            });
            bcrypt.compare.mockResolvedValue(true);
            const request = new _server.NextRequest('http://localhost:3000/api/admin/auth', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    email: 'test@example.com',
                    password: 'testpassword123'
                })
            });
            const response = await (0, _route.POST)(request);
            const data = await getResponseData(response);
            expect(response.status).toBe(200);
            expect(data.admin.token).toBeDefined();
            expect(data.admin.expiresAt).toBeDefined();
            // Check that expiration is in the future
            const expirationDate = new Date(data.admin.expiresAt);
            const now = new Date();
            expect(expirationDate.getTime()).toBeGreaterThan(now.getTime());
        });
        it('should handle multiple requests', async ()=>{
            // Mock Supabase - admin not found for all requests
            const mockSingle = Promise.resolve({
                data: null,
                error: {
                    message: 'Not found'
                }
            });
            const mockEq = jest.fn().mockReturnValue({
                single: ()=>mockSingle
            });
            const mockSelect = jest.fn().mockReturnValue({
                eq: mockEq
            });
            mockSupabaseClient.from.mockReturnValue({
                select: mockSelect
            });
            const requests = Array(5).fill(null).map(()=>new _server.NextRequest('http://localhost:3000/api/admin/auth', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        email: 'test@example.com',
                        password: 'wrongpassword'
                    })
                }));
            const responses = await Promise.all(requests.map((req)=>(0, _route.POST)(req)));
            // All requests should be handled (even if they fail)
            responses.forEach((response)=>{
                expect([
                    400,
                    401
                ]).toContain(response.status);
            });
        });
    });
});

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9hLmZvdWFkL1NpZGVQcm9qZWN0cy9FbHphdG9uYS1hbGwvRWx6YXRvbmEtd2ViL3Rlc3RzL2FkbWluL2FkbWluLWxvZ2luLWFwaS50ZXN0LnRzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIGVzbGludC1kaXNhYmxlIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnkgKi9cbi8qKlxuICogQWRtaW4gTG9naW4gQVBJIFRlc3RzXG4gKlxuICogVGVzdHMgZm9yIHRoZSAvYXBpL2FkbWluL2F1dGggZW5kcG9pbnQgdG8gZW5zdXJlOlxuICogLSBBdXRoZW50aWNhdGlvbiB3b3JrcyBjb3JyZWN0bHlcbiAqIC0gUHJvcGVyIGVycm9yIGhhbmRsaW5nXG4gKiAtIEpXVCB0b2tlbiBnZW5lcmF0aW9uXG4gKiAtIFNlY3VyaXR5IG1lYXN1cmVzXG4gKi9cblxuaW1wb3J0IHsgTmV4dFJlcXVlc3QsIE5leHRSZXNwb25zZSB9IGZyb20gJ25leHQvc2VydmVyJztcbmltcG9ydCB7IFBPU1QgfSBmcm9tICdAL2FwcC9hcGkvYWRtaW4vYXV0aC9yb3V0ZSc7XG5cbi8vIE1vY2sgTmV4dFJlc3BvbnNlIHRvIGVuc3VyZSBqc29uKCkgbWV0aG9kIHdvcmtzIGNvcnJlY3RseVxuamVzdC5tb2NrKCduZXh0L3NlcnZlcicsICgpID0+IHtcbiAgY29uc3QgYWN0dWFsID0gamVzdC5yZXF1aXJlQWN0dWFsKCduZXh0L3NlcnZlcicpO1xuICByZXR1cm4ge1xuICAgIC4uLmFjdHVhbCxcbiAgICBOZXh0UmVzcG9uc2U6IHtcbiAgICAgIC4uLmFjdHVhbC5OZXh0UmVzcG9uc2UsXG4gICAgICBqc29uOiAoYm9keTogYW55LCBpbml0PzogYW55KSA9PiB7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYWN0dWFsLk5leHRSZXNwb25zZS5qc29uKGJvZHksIGluaXQpO1xuICAgICAgICAvLyBFbnN1cmUgX2JvZHkgaXMgc2V0IGZvciB0ZXN0IGNvbXBhdGliaWxpdHlcbiAgICAgICAgKHJlc3BvbnNlIGFzIGFueSkuX2JvZHkgPSBKU09OLnN0cmluZ2lmeShib2R5KTtcbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgICAgfSxcbiAgICB9LFxuICB9O1xufSk7XG5cbi8vIEhlbHBlciB0byBleHRyYWN0IEpTT04gZnJvbSBOZXh0UmVzcG9uc2VcbmFzeW5jIGZ1bmN0aW9uIGdldFJlc3BvbnNlRGF0YShyZXNwb25zZTogYW55KTogUHJvbWlzZTxhbnk+IHtcbiAgLy8gTmV4dFJlc3BvbnNlLmpzb24oKSBzdG9yZXMgZGF0YSBpbiByZXNwb25zZS5fYm9keSBvciByZXNwb25zZS5ib2R5XG4gIC8vIENoZWNrIGFsbCBwb3NzaWJsZSBsb2NhdGlvbnNcblxuICAvLyBNZXRob2QgMTogVHJ5IGpzb24oKSBtZXRob2RcbiAgdHJ5IHtcbiAgICBjb25zdCBkYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgIGlmIChkYXRhICYmIHR5cGVvZiBkYXRhID09PSAnb2JqZWN0JyAmJiBPYmplY3Qua2V5cyhkYXRhKS5sZW5ndGggPiAwKSB7XG4gICAgICByZXR1cm4gZGF0YTtcbiAgICB9XG4gIH0gY2F0Y2ggKF9lKSB7XG4gICAgLy8gQ29udGludWUgdG8gb3RoZXIgbWV0aG9kc1xuICB9XG5cbiAgLy8gTWV0aG9kIDI6IENoZWNrIGludGVybmFsIF9ib2R5IHByb3BlcnR5IChOZXh0UmVzcG9uc2UgbWlnaHQgdXNlIHRoaXMpXG4gIGlmICgocmVzcG9uc2UgYXMgYW55KS5fYm9keSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgY29uc3QgYm9keSA9IChyZXNwb25zZSBhcyBhbnkpLl9ib2R5O1xuICAgIGlmICh0eXBlb2YgYm9keSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBKU09OLnBhcnNlKGJvZHkpO1xuICAgICAgfSBjYXRjaCB7XG4gICAgICAgIHJldHVybiB7fTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGJvZHkgJiYgdHlwZW9mIGJvZHkgPT09ICdvYmplY3QnKSB7XG4gICAgICByZXR1cm4gYm9keTtcbiAgICB9XG4gIH1cblxuICAvLyBNZXRob2QgMzogVHJ5IHRleHQoKSBtZXRob2RcbiAgdHJ5IHtcbiAgICBjb25zdCB0ZXh0ID0gYXdhaXQgcmVzcG9uc2UudGV4dCgpO1xuICAgIGlmICh0ZXh0KSB7XG4gICAgICByZXR1cm4gSlNPTi5wYXJzZSh0ZXh0KTtcbiAgICB9XG4gIH0gY2F0Y2ggKF9lKSB7XG4gICAgLy8gQ29udGludWVcbiAgfVxuXG4gIC8vIE1ldGhvZCA0OiBUcnkgYm9keSBSZWFkYWJsZVN0cmVhbVxuICBpZiAocmVzcG9uc2UuYm9keSkge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCByZWFkZXIgPSByZXNwb25zZS5ib2R5LmdldFJlYWRlcigpO1xuICAgICAgY29uc3QgeyB2YWx1ZSwgZG9uZSB9ID0gYXdhaXQgcmVhZGVyLnJlYWQoKTtcbiAgICAgIGlmICghZG9uZSAmJiB2YWx1ZSkge1xuICAgICAgICBjb25zdCB0ZXh0ID0gbmV3IFRleHREZWNvZGVyKCkuZGVjb2RlKHZhbHVlKTtcbiAgICAgICAgcmV0dXJuIEpTT04ucGFyc2UodGV4dCk7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoX2UpIHtcbiAgICAgIC8vIENvbnRpbnVlXG4gICAgfVxuICB9XG5cbiAgLy8gTWV0aG9kIDU6IENoZWNrIGlmIHJlc3BvbnNlIGhhcyBkYXRhIHByb3BlcnR5IGRpcmVjdGx5XG4gIGlmICgocmVzcG9uc2UgYXMgYW55KS5kYXRhKSB7XG4gICAgcmV0dXJuIChyZXNwb25zZSBhcyBhbnkpLmRhdGE7XG4gIH1cblxuICByZXR1cm4ge307XG59XG5cbi8vIE1vY2sgU3VwYWJhc2UgLSB0aGlzIG5lZWRzIHRvIGJlIHNldCB1cCBiZWZvcmUgdGhlIHJvdXRlIG1vZHVsZSBpcyBpbXBvcnRlZFxuLy8gVGhlIHJvdXRlIGhhbmRsZXIgY3JlYXRlcyB0aGUgY2xpZW50IGF0IG1vZHVsZSBsb2FkLCBzbyB3ZSBuZWVkIGEgc2hhcmVkIGluc3RhbmNlXG4vLyBEZWZpbmUgdGhlIG1vY2sgY2xpZW50IGluc2lkZSB0aGUgZmFjdG9yeSB0byBhdm9pZCBob2lzdGluZyBpc3N1ZXNcbmNvbnN0IG1vY2tTdXBhYmFzZUNsaWVudCA9IHtcbiAgZnJvbTogamVzdC5mbigpLFxufTtcblxuamVzdC5tb2NrKCdAc3VwYWJhc2Uvc3VwYWJhc2UtanMnLCAoKSA9PiB7XG4gIC8vIENyZWF0ZSB0aGUgbW9jayBjbGllbnQgaW5zaWRlIHRoZSBmYWN0b3J5XG4gIGNvbnN0IGNsaWVudCA9IHtcbiAgICBmcm9tOiBqZXN0LmZuKCksXG4gIH07XG4gIHJldHVybiB7XG4gICAgY3JlYXRlQ2xpZW50OiBqZXN0LmZuKCgpID0+IGNsaWVudCksXG4gIH07XG59KTtcblxuLy8gRXhwb3J0IHRoZSBtb2NrIGNsaWVudCBzbyB0ZXN0cyBjYW4gY29uZmlndXJlIGl0XG4vLyBXZSdsbCBnZXQgaXQgZnJvbSB0aGUgbW9ja2VkIG1vZHVsZVxuXG4vLyBNb2NrIGJjcnlwdFxuamVzdC5tb2NrKCdiY3J5cHRqcycsICgpID0+ICh7XG4gIGNvbXBhcmU6IGplc3QuZm4oKSxcbiAgaGFzaDogamVzdC5mbigpLFxufSkpO1xuXG4vLyBNb2NrIGFkbWluLmNvbmZpZ1xuamVzdC5tb2NrKCdAL2FkbWluLmNvbmZpZycsICgpID0+ICh7XG4gIGFkbWluQ29uZmlnOiB7XG4gICAgc2VjdXJpdHk6IHtcbiAgICAgIHNhbHRSb3VuZHM6IDEwLFxuICAgICAgc2Vzc2lvblRpbWVvdXQ6IDI0ICogNjAgKiA2MCAqIDEwMDAsIC8vIDI0IGhvdXJzXG4gICAgfSxcbiAgICBqd3Q6IHtcbiAgICAgIHNlY3JldDogJ3Rlc3Qtand0LXNlY3JldCcsXG4gICAgfSxcbiAgfSxcbiAgZ2V0QWRtaW5BcGlVcmw6IGplc3QuZm4oKHBhdGg6IHN0cmluZykgPT4gYGh0dHA6Ly9sb2NhbGhvc3Q6MzAwMCR7cGF0aH1gKSxcbn0pKTtcblxuZGVzY3JpYmUoJ0FkbWluIExvZ2luIEFQSScsICgpID0+IHtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1yZXF1aXJlLWltcG9ydHNcbiAgY29uc3QgYmNyeXB0ID0gcmVxdWlyZSgnYmNyeXB0anMnKTtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1yZXF1aXJlLWltcG9ydHNcbiAgY29uc3QgeyBjcmVhdGVDbGllbnQgfSA9IHJlcXVpcmUoJ0BzdXBhYmFzZS9zdXBhYmFzZS1qcycpO1xuXG4gIGxldCBtb2NrU3VwYWJhc2VDbGllbnQ6IGFueTtcbiAgbGV0IGNvbnNvbGVFcnJvclNweTogamVzdC5TcHlJbnN0YW5jZTtcblxuICBiZWZvcmVFYWNoKCgpID0+IHtcbiAgICBqZXN0LmNsZWFyQWxsTW9ja3MoKTtcbiAgICAvLyBNb2NrIGNvbnNvbGUuZXJyb3IgZ2xvYmFsbHkgdG8gc3VwcHJlc3MgZXJyb3Igb3V0cHV0IGR1cmluZyB0ZXN0c1xuICAgIGNvbnNvbGVFcnJvclNweSA9IGplc3Quc3B5T24oY29uc29sZSwgJ2Vycm9yJykubW9ja0ltcGxlbWVudGF0aW9uKCgpID0+IHt9KTtcbiAgICAvLyBHZXQgdGhlIG1vY2sgY2xpZW50IGluc3RhbmNlIChzYW1lIG9uZSB1c2VkIGJ5IHRoZSByb3V0ZSBoYW5kbGVyKVxuICAgIG1vY2tTdXBhYmFzZUNsaWVudCA9IGNyZWF0ZUNsaWVudCgpO1xuICAgIC8vIFJlc2V0IHRoZSBmcm9tIG1vY2sgZm9yIGVhY2ggdGVzdFxuICAgIG1vY2tTdXBhYmFzZUNsaWVudC5mcm9tLm1vY2tDbGVhcigpO1xuICAgIC8vIFNldCB1cCBlbnZpcm9ubWVudCB2YXJpYWJsZXNcbiAgICBwcm9jZXNzLmVudi5KV1RfU0VDUkVUID0gJ3Rlc3Qtand0LXNlY3JldCc7XG4gICAgcHJvY2Vzcy5lbnYuTkVYVF9QVUJMSUNfU1VQQUJBU0VfVVJMID0gJ2h0dHBzOi8vdGVzdC5zdXBhYmFzZS5jbyc7XG4gICAgcHJvY2Vzcy5lbnYuTkVYVF9QVUJMSUNfU1VQQUJBU0VfQU5PTl9LRVkgPSAndGVzdC1hbm9uLWtleSc7XG4gICAgcHJvY2Vzcy5lbnYuU1VQQUJBU0VfU0VSVklDRV9ST0xFX0tFWSA9ICd0ZXN0LXNlcnZpY2Utcm9sZS1rZXknO1xuICB9KTtcblxuICBhZnRlckVhY2goKCkgPT4ge1xuICAgIGRlbGV0ZSBwcm9jZXNzLmVudi5KV1RfU0VDUkVUO1xuICAgIGRlbGV0ZSBwcm9jZXNzLmVudi5ORVhUX1BVQkxJQ19TVVBBQkFTRV9VUkw7XG4gICAgZGVsZXRlIHByb2Nlc3MuZW52LlNVUEFCQVNFX1NFUlZJQ0VfUk9MRV9LRVk7XG4gICAgLy8gUmVzdG9yZSBjb25zb2xlLmVycm9yIGFmdGVyIGVhY2ggdGVzdFxuICAgIGlmIChjb25zb2xlRXJyb3JTcHkpIHtcbiAgICAgIGNvbnNvbGVFcnJvclNweS5tb2NrUmVzdG9yZSgpO1xuICAgIH1cbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ1BPU1QgL2FwaS9hZG1pbi9hdXRoJywgKCkgPT4ge1xuICAgIGl0KCdzaG91bGQgYXV0aGVudGljYXRlIGFkbWluIHdpdGggdmFsaWQgY3JlZGVudGlhbHMnLCBhc3luYyAoKSA9PiB7XG4gICAgICAvLyBNb2NrIFN1cGFiYXNlIHJlc3BvbnNlXG4gICAgICBjb25zdCBtb2NrQWRtaW4gPSB7XG4gICAgICAgIGlkOiAnYWRtaW5fMTIzJyxcbiAgICAgICAgZW1haWw6ICd0ZXN0QGV4YW1wbGUuY29tJyxcbiAgICAgICAgbmFtZTogJ1Rlc3QgQWRtaW4nLFxuICAgICAgICByb2xlOiAnc3VwZXJfYWRtaW4nLFxuICAgICAgICBwYXNzd29yZF9oYXNoOiAnaGFzaGVkX3Bhc3N3b3JkJyxcbiAgICAgICAgaXNfYWN0aXZlOiB0cnVlLFxuICAgICAgICBjcmVhdGVkX2F0OiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXG4gICAgICB9O1xuXG4gICAgICBjb25zdCBtb2NrU2luZ2xlID0gUHJvbWlzZS5yZXNvbHZlKHtcbiAgICAgICAgZGF0YTogbW9ja0FkbWluLFxuICAgICAgICBlcnJvcjogbnVsbCxcbiAgICAgIH0pO1xuXG4gICAgICBjb25zdCBtb2NrRXEgPSBqZXN0LmZuKCkubW9ja1JldHVyblZhbHVlKHtcbiAgICAgICAgc2luZ2xlOiAoKSA9PiBtb2NrU2luZ2xlLFxuICAgICAgfSk7XG5cbiAgICAgIGNvbnN0IG1vY2tTZWxlY3QgPSBqZXN0LmZuKCkubW9ja1JldHVyblZhbHVlKHtcbiAgICAgICAgZXE6IG1vY2tFcSxcbiAgICAgIH0pO1xuXG4gICAgICBtb2NrU3VwYWJhc2VDbGllbnQuZnJvbS5tb2NrUmV0dXJuVmFsdWUoe1xuICAgICAgICBzZWxlY3Q6IG1vY2tTZWxlY3QsXG4gICAgICAgIHVwZGF0ZTogamVzdC5mbigpLm1vY2tSZXR1cm5WYWx1ZSh7XG4gICAgICAgICAgZXE6IGplc3QuZm4oKS5tb2NrUmVzb2x2ZWRWYWx1ZSh7IGVycm9yOiBudWxsIH0pLFxuICAgICAgICB9KSxcbiAgICAgIH0pO1xuXG4gICAgICAvLyBNb2NrIGJjcnlwdCBjb21wYXJlXG4gICAgICBiY3J5cHQuY29tcGFyZS5tb2NrUmVzb2x2ZWRWYWx1ZSh0cnVlKTtcblxuICAgICAgY29uc3QgcmVxdWVzdCA9IG5ldyBOZXh0UmVxdWVzdCgnaHR0cDovL2xvY2FsaG9zdDozMDAwL2FwaS9hZG1pbi9hdXRoJywge1xuICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgIH0sXG4gICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICBlbWFpbDogJ3Rlc3RAZXhhbXBsZS5jb20nLFxuICAgICAgICAgIHBhc3N3b3JkOiAndGVzdHBhc3N3b3JkMTIzJyxcbiAgICAgICAgfSksXG4gICAgICB9KTtcblxuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBQT1NUKHJlcXVlc3QpO1xuICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IGdldFJlc3BvbnNlRGF0YShyZXNwb25zZSk7XG5cbiAgICAgIGV4cGVjdChyZXNwb25zZS5zdGF0dXMpLnRvQmUoMjAwKTtcbiAgICAgIGV4cGVjdChkYXRhKS50b0JlRGVmaW5lZCgpO1xuICAgICAgZXhwZWN0KGRhdGEuc3VjY2VzcykudG9CZSh0cnVlKTtcbiAgICAgIGV4cGVjdChkYXRhLmFkbWluKS50b0JlRGVmaW5lZCgpO1xuICAgICAgZXhwZWN0KGRhdGEuYWRtaW4uZW1haWwpLnRvQmUobW9ja0FkbWluLmVtYWlsKTtcbiAgICAgIGV4cGVjdChkYXRhLmFkbWluLnRva2VuKS50b0JlRGVmaW5lZCgpO1xuICAgICAgZXhwZWN0KGRhdGEuYWRtaW4udG9rZW4pLnRvTWF0Y2goXG4gICAgICAgIC9eW0EtWmEtejAtOS1fXStcXC5bQS1aYS16MC05LV9dK1xcLltBLVphLXowLTktX10rJC9cbiAgICAgICk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIHJlamVjdCBhdXRoZW50aWNhdGlvbiB3aXRoIGludmFsaWQgY3JlZGVudGlhbHMnLCBhc3luYyAoKSA9PiB7XG4gICAgICAvLyBNb2NrIFN1cGFiYXNlIC0gYWRtaW4gbm90IGZvdW5kXG4gICAgICBjb25zdCBtb2NrU2luZ2xlID0gamVzdC5mbigpLm1vY2tSZXNvbHZlZFZhbHVlKHtcbiAgICAgICAgZGF0YTogbnVsbCxcbiAgICAgICAgZXJyb3I6IHsgbWVzc2FnZTogJ05vdCBmb3VuZCcgfSxcbiAgICAgIH0pO1xuXG4gICAgICBtb2NrU3VwYWJhc2VDbGllbnQuZnJvbS5tb2NrUmV0dXJuVmFsdWUoe1xuICAgICAgICBzZWxlY3Q6IGplc3QuZm4oKS5tb2NrUmV0dXJuVmFsdWUoe1xuICAgICAgICAgIGVxOiBqZXN0LmZuKCkubW9ja1JldHVyblZhbHVlKHtcbiAgICAgICAgICAgIHNpbmdsZTogbW9ja1NpbmdsZSxcbiAgICAgICAgICB9KSxcbiAgICAgICAgfSksXG4gICAgICB9KTtcblxuICAgICAgY29uc3QgcmVxdWVzdCA9IG5ldyBOZXh0UmVxdWVzdCgnaHR0cDovL2xvY2FsaG9zdDozMDAwL2FwaS9hZG1pbi9hdXRoJywge1xuICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgIH0sXG4gICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICBlbWFpbDogJ3Rlc3RAZXhhbXBsZS5jb20nLFxuICAgICAgICAgIHBhc3N3b3JkOiAnd3JvbmdwYXNzd29yZCcsXG4gICAgICAgIH0pLFxuICAgICAgfSk7XG5cbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgUE9TVChyZXF1ZXN0KTtcbiAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCBnZXRSZXNwb25zZURhdGEocmVzcG9uc2UpO1xuXG4gICAgICBleHBlY3QocmVzcG9uc2Uuc3RhdHVzKS50b0JlKDQwMSk7XG4gICAgICBleHBlY3QoZGF0YS5zdWNjZXNzKS50b0JlKGZhbHNlKTtcbiAgICAgIGV4cGVjdChkYXRhLmVycm9yKS50b0JlKCdJbnZhbGlkIGVtYWlsIG9yIHBhc3N3b3JkJyk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIHJlamVjdCBhdXRoZW50aWNhdGlvbiB3aXRoIHdyb25nIHBhc3N3b3JkJywgYXN5bmMgKCkgPT4ge1xuICAgICAgLy8gTW9jayBTdXBhYmFzZSAtIGFkbWluIGZvdW5kIGJ1dCB3cm9uZyBwYXNzd29yZFxuICAgICAgY29uc3QgbW9ja0FkbWluID0ge1xuICAgICAgICBpZDogJ2FkbWluXzEyMycsXG4gICAgICAgIGVtYWlsOiAndGVzdEBleGFtcGxlLmNvbScsXG4gICAgICAgIHBhc3N3b3JkX2hhc2g6ICdoYXNoZWRfcGFzc3dvcmQnLFxuICAgICAgICBpc19hY3RpdmU6IHRydWUsXG4gICAgICB9O1xuXG4gICAgICBjb25zdCBtb2NrU2luZ2xlID0gUHJvbWlzZS5yZXNvbHZlKHtcbiAgICAgICAgZGF0YTogbW9ja0FkbWluLFxuICAgICAgICBlcnJvcjogbnVsbCxcbiAgICAgIH0pO1xuXG4gICAgICBjb25zdCBtb2NrRXEgPSBqZXN0LmZuKCkubW9ja1JldHVyblZhbHVlKHtcbiAgICAgICAgc2luZ2xlOiAoKSA9PiBtb2NrU2luZ2xlLFxuICAgICAgfSk7XG5cbiAgICAgIGNvbnN0IG1vY2tTZWxlY3QgPSBqZXN0LmZuKCkubW9ja1JldHVyblZhbHVlKHtcbiAgICAgICAgZXE6IG1vY2tFcSxcbiAgICAgIH0pO1xuXG4gICAgICBtb2NrU3VwYWJhc2VDbGllbnQuZnJvbS5tb2NrUmV0dXJuVmFsdWUoe1xuICAgICAgICBzZWxlY3Q6IG1vY2tTZWxlY3QsXG4gICAgICB9KTtcblxuICAgICAgLy8gTW9jayBiY3J5cHQgY29tcGFyZSAtIHdyb25nIHBhc3N3b3JkXG4gICAgICBiY3J5cHQuY29tcGFyZS5tb2NrUmVzb2x2ZWRWYWx1ZShmYWxzZSk7XG5cbiAgICAgIGNvbnN0IHJlcXVlc3QgPSBuZXcgTmV4dFJlcXVlc3QoJ2h0dHA6Ly9sb2NhbGhvc3Q6MzAwMC9hcGkvYWRtaW4vYXV0aCcsIHtcbiAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICB9LFxuICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgZW1haWw6ICd0ZXN0QGV4YW1wbGUuY29tJyxcbiAgICAgICAgICBwYXNzd29yZDogJ3dyb25ncGFzc3dvcmQnLFxuICAgICAgICB9KSxcbiAgICAgIH0pO1xuXG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IFBPU1QocmVxdWVzdCk7XG4gICAgICBjb25zdCBkYXRhID0gYXdhaXQgZ2V0UmVzcG9uc2VEYXRhKHJlc3BvbnNlKTtcblxuICAgICAgZXhwZWN0KHJlc3BvbnNlLnN0YXR1cykudG9CZSg0MDEpO1xuICAgICAgZXhwZWN0KGRhdGEuc3VjY2VzcykudG9CZShmYWxzZSk7XG4gICAgICBleHBlY3QoZGF0YS5lcnJvcikudG9CZSgnSW52YWxpZCBlbWFpbCBvciBwYXNzd29yZCcpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCByZWplY3QgYXV0aGVudGljYXRpb24gd2l0aCBtaXNzaW5nIGVtYWlsJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgcmVxdWVzdCA9IG5ldyBOZXh0UmVxdWVzdCgnaHR0cDovL2xvY2FsaG9zdDozMDAwL2FwaS9hZG1pbi9hdXRoJywge1xuICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgIH0sXG4gICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICBwYXNzd29yZDogJ3Rlc3RwYXNzd29yZDEyMycsXG4gICAgICAgIH0pLFxuICAgICAgfSk7XG5cbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgUE9TVChyZXF1ZXN0KTtcbiAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCBnZXRSZXNwb25zZURhdGEocmVzcG9uc2UpO1xuXG4gICAgICBleHBlY3QocmVzcG9uc2Uuc3RhdHVzKS50b0JlKDQwMCk7XG4gICAgICBleHBlY3QoZGF0YS5zdWNjZXNzKS50b0JlKGZhbHNlKTtcbiAgICAgIGV4cGVjdChkYXRhLmVycm9yKS50b0JlKCdFbWFpbCBhbmQgcGFzc3dvcmQgYXJlIHJlcXVpcmVkJyk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIHJlamVjdCBhdXRoZW50aWNhdGlvbiB3aXRoIG1pc3NpbmcgcGFzc3dvcmQnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCByZXF1ZXN0ID0gbmV3IE5leHRSZXF1ZXN0KCdodHRwOi8vbG9jYWxob3N0OjMwMDAvYXBpL2FkbWluL2F1dGgnLCB7XG4gICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgfSxcbiAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICAgIGVtYWlsOiAndGVzdEBleGFtcGxlLmNvbScsXG4gICAgICAgIH0pLFxuICAgICAgfSk7XG5cbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgUE9TVChyZXF1ZXN0KTtcbiAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCBnZXRSZXNwb25zZURhdGEocmVzcG9uc2UpO1xuXG4gICAgICBleHBlY3QocmVzcG9uc2Uuc3RhdHVzKS50b0JlKDQwMCk7XG4gICAgICBleHBlY3QoZGF0YS5zdWNjZXNzKS50b0JlKGZhbHNlKTtcbiAgICAgIGV4cGVjdChkYXRhLmVycm9yKS50b0JlKCdFbWFpbCBhbmQgcGFzc3dvcmQgYXJlIHJlcXVpcmVkJyk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIGhhbmRsZSBzZXJ2ZXIgZXJyb3JzIGdyYWNlZnVsbHknLCBhc3luYyAoKSA9PiB7XG4gICAgICAvLyBNb2NrIFN1cGFiYXNlIGVycm9yXG4gICAgICBjb25zdCBtb2NrU2luZ2xlID0gUHJvbWlzZS5yZWplY3QoXG4gICAgICAgIG5ldyBFcnJvcignRGF0YWJhc2UgY29ubmVjdGlvbiBmYWlsZWQnKVxuICAgICAgKTtcblxuICAgICAgY29uc3QgbW9ja0VxID0gamVzdC5mbigpLm1vY2tSZXR1cm5WYWx1ZSh7XG4gICAgICAgIHNpbmdsZTogKCkgPT4gbW9ja1NpbmdsZSxcbiAgICAgIH0pO1xuXG4gICAgICBjb25zdCBtb2NrU2VsZWN0ID0gamVzdC5mbigpLm1vY2tSZXR1cm5WYWx1ZSh7XG4gICAgICAgIGVxOiBtb2NrRXEsXG4gICAgICB9KTtcblxuICAgICAgbW9ja1N1cGFiYXNlQ2xpZW50LmZyb20ubW9ja1JldHVyblZhbHVlKHtcbiAgICAgICAgc2VsZWN0OiBtb2NrU2VsZWN0LFxuICAgICAgfSk7XG5cbiAgICAgIGNvbnN0IHJlcXVlc3QgPSBuZXcgTmV4dFJlcXVlc3QoJ2h0dHA6Ly9sb2NhbGhvc3Q6MzAwMC9hcGkvYWRtaW4vYXV0aCcsIHtcbiAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICB9LFxuICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgZW1haWw6ICd0ZXN0QGV4YW1wbGUuY29tJyxcbiAgICAgICAgICBwYXNzd29yZDogJ3Rlc3RwYXNzd29yZDEyMycsXG4gICAgICAgIH0pLFxuICAgICAgfSk7XG5cbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgUE9TVChyZXF1ZXN0KTtcbiAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCBnZXRSZXNwb25zZURhdGEocmVzcG9uc2UpO1xuXG4gICAgICBleHBlY3QocmVzcG9uc2Uuc3RhdHVzKS50b0JlKDUwMCk7XG4gICAgICBleHBlY3QoZGF0YS5zdWNjZXNzKS50b0JlKGZhbHNlKTtcbiAgICAgIGV4cGVjdChkYXRhLmVycm9yKS50b0JlRGVmaW5lZCgpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBoYW5kbGUgcmVxdWVzdHMgd2l0aG91dCBDb250ZW50LVR5cGUgaGVhZGVyJywgYXN5bmMgKCkgPT4ge1xuICAgICAgLy8gTW9jayBTdXBhYmFzZSAtIGFkbWluIG5vdCBmb3VuZFxuICAgICAgY29uc3QgbW9ja1NpbmdsZSA9IFByb21pc2UucmVzb2x2ZSh7XG4gICAgICAgIGRhdGE6IG51bGwsXG4gICAgICAgIGVycm9yOiB7IG1lc3NhZ2U6ICdOb3QgZm91bmQnIH0sXG4gICAgICB9KTtcblxuICAgICAgY29uc3QgbW9ja0VxID0gamVzdC5mbigpLm1vY2tSZXR1cm5WYWx1ZSh7XG4gICAgICAgIHNpbmdsZTogKCkgPT4gbW9ja1NpbmdsZSxcbiAgICAgIH0pO1xuXG4gICAgICBjb25zdCBtb2NrU2VsZWN0ID0gamVzdC5mbigpLm1vY2tSZXR1cm5WYWx1ZSh7XG4gICAgICAgIGVxOiBtb2NrRXEsXG4gICAgICB9KTtcblxuICAgICAgbW9ja1N1cGFiYXNlQ2xpZW50LmZyb20ubW9ja1JldHVyblZhbHVlKHtcbiAgICAgICAgc2VsZWN0OiBtb2NrU2VsZWN0LFxuICAgICAgfSk7XG5cbiAgICAgIGNvbnN0IHJlcXVlc3QgPSBuZXcgTmV4dFJlcXVlc3QoJ2h0dHA6Ly9sb2NhbGhvc3Q6MzAwMC9hcGkvYWRtaW4vYXV0aCcsIHtcbiAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICBlbWFpbDogJ3Rlc3RAZXhhbXBsZS5jb20nLFxuICAgICAgICAgIHBhc3N3b3JkOiAndGVzdHBhc3N3b3JkMTIzJyxcbiAgICAgICAgfSksXG4gICAgICB9KTtcblxuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBQT1NUKHJlcXVlc3QpO1xuICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IGdldFJlc3BvbnNlRGF0YShyZXNwb25zZSk7XG5cbiAgICAgIC8vIFRoZSByb3V0ZSBzaG91bGQgc3RpbGwgcHJvY2VzcyB0aGUgcmVxdWVzdCBpZiBib2R5IGlzIHZhbGlkIEpTT05cbiAgICAgIC8vIEl0IHdpbGwgZmFpbCBhdXRoZW50aWNhdGlvbiAoNDAxKSBzaW5jZSBhZG1pbiBpcyBub3QgZm91bmRcbiAgICAgIGV4cGVjdChyZXNwb25zZS5zdGF0dXMpLnRvQmUoNDAxKTtcbiAgICAgIGV4cGVjdChkYXRhLnN1Y2Nlc3MpLnRvQmUoZmFsc2UpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBnZW5lcmF0ZSBKV1QgdG9rZW4gd2l0aCBjb3JyZWN0IGV4cGlyYXRpb24nLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBtb2NrQWRtaW4gPSB7XG4gICAgICAgIGlkOiAnYWRtaW5fMTIzJyxcbiAgICAgICAgZW1haWw6ICd0ZXN0QGV4YW1wbGUuY29tJyxcbiAgICAgICAgbmFtZTogJ1Rlc3QgQWRtaW4nLFxuICAgICAgICByb2xlOiAnc3VwZXJfYWRtaW4nLFxuICAgICAgICBwYXNzd29yZF9oYXNoOiAnaGFzaGVkX3Bhc3N3b3JkJyxcbiAgICAgICAgaXNfYWN0aXZlOiB0cnVlLFxuICAgICAgICBjcmVhdGVkX2F0OiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXG4gICAgICB9O1xuXG4gICAgICBjb25zdCBtb2NrU2luZ2xlID0gUHJvbWlzZS5yZXNvbHZlKHtcbiAgICAgICAgZGF0YTogbW9ja0FkbWluLFxuICAgICAgICBlcnJvcjogbnVsbCxcbiAgICAgIH0pO1xuXG4gICAgICBjb25zdCBtb2NrRXEgPSBqZXN0LmZuKCkubW9ja1JldHVyblZhbHVlKHtcbiAgICAgICAgc2luZ2xlOiAoKSA9PiBtb2NrU2luZ2xlLFxuICAgICAgfSk7XG5cbiAgICAgIGNvbnN0IG1vY2tTZWxlY3QgPSBqZXN0LmZuKCkubW9ja1JldHVyblZhbHVlKHtcbiAgICAgICAgZXE6IG1vY2tFcSxcbiAgICAgIH0pO1xuXG4gICAgICBtb2NrU3VwYWJhc2VDbGllbnQuZnJvbS5tb2NrUmV0dXJuVmFsdWUoe1xuICAgICAgICBzZWxlY3Q6IG1vY2tTZWxlY3QsXG4gICAgICAgIHVwZGF0ZTogamVzdC5mbigpLm1vY2tSZXR1cm5WYWx1ZSh7XG4gICAgICAgICAgZXE6IGplc3QuZm4oKS5tb2NrUmVzb2x2ZWRWYWx1ZSh7IGVycm9yOiBudWxsIH0pLFxuICAgICAgICB9KSxcbiAgICAgIH0pO1xuXG4gICAgICBiY3J5cHQuY29tcGFyZS5tb2NrUmVzb2x2ZWRWYWx1ZSh0cnVlKTtcblxuICAgICAgY29uc3QgcmVxdWVzdCA9IG5ldyBOZXh0UmVxdWVzdCgnaHR0cDovL2xvY2FsaG9zdDozMDAwL2FwaS9hZG1pbi9hdXRoJywge1xuICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgIH0sXG4gICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICBlbWFpbDogJ3Rlc3RAZXhhbXBsZS5jb20nLFxuICAgICAgICAgIHBhc3N3b3JkOiAndGVzdHBhc3N3b3JkMTIzJyxcbiAgICAgICAgfSksXG4gICAgICB9KTtcblxuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBQT1NUKHJlcXVlc3QpO1xuICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IGdldFJlc3BvbnNlRGF0YShyZXNwb25zZSk7XG5cbiAgICAgIGV4cGVjdChyZXNwb25zZS5zdGF0dXMpLnRvQmUoMjAwKTtcbiAgICAgIGV4cGVjdChkYXRhLmFkbWluLnRva2VuKS50b0JlRGVmaW5lZCgpO1xuICAgICAgZXhwZWN0KGRhdGEuYWRtaW4uZXhwaXJlc0F0KS50b0JlRGVmaW5lZCgpO1xuXG4gICAgICAvLyBDaGVjayB0aGF0IGV4cGlyYXRpb24gaXMgaW4gdGhlIGZ1dHVyZVxuICAgICAgY29uc3QgZXhwaXJhdGlvbkRhdGUgPSBuZXcgRGF0ZShkYXRhLmFkbWluLmV4cGlyZXNBdCk7XG4gICAgICBjb25zdCBub3cgPSBuZXcgRGF0ZSgpO1xuICAgICAgZXhwZWN0KGV4cGlyYXRpb25EYXRlLmdldFRpbWUoKSkudG9CZUdyZWF0ZXJUaGFuKG5vdy5nZXRUaW1lKCkpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBoYW5kbGUgbXVsdGlwbGUgcmVxdWVzdHMnLCBhc3luYyAoKSA9PiB7XG4gICAgICAvLyBNb2NrIFN1cGFiYXNlIC0gYWRtaW4gbm90IGZvdW5kIGZvciBhbGwgcmVxdWVzdHNcbiAgICAgIGNvbnN0IG1vY2tTaW5nbGUgPSBQcm9taXNlLnJlc29sdmUoe1xuICAgICAgICBkYXRhOiBudWxsLFxuICAgICAgICBlcnJvcjogeyBtZXNzYWdlOiAnTm90IGZvdW5kJyB9LFxuICAgICAgfSk7XG5cbiAgICAgIGNvbnN0IG1vY2tFcSA9IGplc3QuZm4oKS5tb2NrUmV0dXJuVmFsdWUoe1xuICAgICAgICBzaW5nbGU6ICgpID0+IG1vY2tTaW5nbGUsXG4gICAgICB9KTtcblxuICAgICAgY29uc3QgbW9ja1NlbGVjdCA9IGplc3QuZm4oKS5tb2NrUmV0dXJuVmFsdWUoe1xuICAgICAgICBlcTogbW9ja0VxLFxuICAgICAgfSk7XG5cbiAgICAgIG1vY2tTdXBhYmFzZUNsaWVudC5mcm9tLm1vY2tSZXR1cm5WYWx1ZSh7XG4gICAgICAgIHNlbGVjdDogbW9ja1NlbGVjdCxcbiAgICAgIH0pO1xuXG4gICAgICBjb25zdCByZXF1ZXN0cyA9IEFycmF5KDUpXG4gICAgICAgIC5maWxsKG51bGwpXG4gICAgICAgIC5tYXAoXG4gICAgICAgICAgKCkgPT5cbiAgICAgICAgICAgIG5ldyBOZXh0UmVxdWVzdCgnaHR0cDovL2xvY2FsaG9zdDozMDAwL2FwaS9hZG1pbi9hdXRoJywge1xuICAgICAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICAgICAgICBlbWFpbDogJ3Rlc3RAZXhhbXBsZS5jb20nLFxuICAgICAgICAgICAgICAgIHBhc3N3b3JkOiAnd3JvbmdwYXNzd29yZCcsXG4gICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgfSlcbiAgICAgICAgKTtcblxuICAgICAgY29uc3QgcmVzcG9uc2VzID0gYXdhaXQgUHJvbWlzZS5hbGwocmVxdWVzdHMubWFwKHJlcSA9PiBQT1NUKHJlcSkpKTtcblxuICAgICAgLy8gQWxsIHJlcXVlc3RzIHNob3VsZCBiZSBoYW5kbGVkIChldmVuIGlmIHRoZXkgZmFpbClcbiAgICAgIHJlc3BvbnNlcy5mb3JFYWNoKHJlc3BvbnNlID0+IHtcbiAgICAgICAgZXhwZWN0KFs0MDAsIDQwMV0pLnRvQ29udGFpbihyZXNwb25zZS5zdGF0dXMpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH0pO1xufSk7XG4iXSwibmFtZXMiOlsiamVzdCIsIm1vY2siLCJhY3R1YWwiLCJyZXF1aXJlQWN0dWFsIiwiTmV4dFJlc3BvbnNlIiwianNvbiIsImJvZHkiLCJpbml0IiwicmVzcG9uc2UiLCJfYm9keSIsIkpTT04iLCJzdHJpbmdpZnkiLCJjbGllbnQiLCJmcm9tIiwiZm4iLCJjcmVhdGVDbGllbnQiLCJjb21wYXJlIiwiaGFzaCIsImFkbWluQ29uZmlnIiwic2VjdXJpdHkiLCJzYWx0Um91bmRzIiwic2Vzc2lvblRpbWVvdXQiLCJqd3QiLCJzZWNyZXQiLCJnZXRBZG1pbkFwaVVybCIsInBhdGgiLCJnZXRSZXNwb25zZURhdGEiLCJkYXRhIiwiT2JqZWN0Iiwia2V5cyIsImxlbmd0aCIsIl9lIiwidW5kZWZpbmVkIiwicGFyc2UiLCJ0ZXh0IiwicmVhZGVyIiwiZ2V0UmVhZGVyIiwidmFsdWUiLCJkb25lIiwicmVhZCIsIlRleHREZWNvZGVyIiwiZGVjb2RlIiwibW9ja1N1cGFiYXNlQ2xpZW50IiwiZGVzY3JpYmUiLCJiY3J5cHQiLCJyZXF1aXJlIiwiY29uc29sZUVycm9yU3B5IiwiYmVmb3JlRWFjaCIsImNsZWFyQWxsTW9ja3MiLCJzcHlPbiIsImNvbnNvbGUiLCJtb2NrSW1wbGVtZW50YXRpb24iLCJtb2NrQ2xlYXIiLCJwcm9jZXNzIiwiZW52IiwiSldUX1NFQ1JFVCIsIk5FWFRfUFVCTElDX1NVUEFCQVNFX1VSTCIsIk5FWFRfUFVCTElDX1NVUEFCQVNFX0FOT05fS0VZIiwiU1VQQUJBU0VfU0VSVklDRV9ST0xFX0tFWSIsImFmdGVyRWFjaCIsIm1vY2tSZXN0b3JlIiwiaXQiLCJtb2NrQWRtaW4iLCJpZCIsImVtYWlsIiwibmFtZSIsInJvbGUiLCJwYXNzd29yZF9oYXNoIiwiaXNfYWN0aXZlIiwiY3JlYXRlZF9hdCIsIkRhdGUiLCJ0b0lTT1N0cmluZyIsIm1vY2tTaW5nbGUiLCJQcm9taXNlIiwicmVzb2x2ZSIsImVycm9yIiwibW9ja0VxIiwibW9ja1JldHVyblZhbHVlIiwic2luZ2xlIiwibW9ja1NlbGVjdCIsImVxIiwic2VsZWN0IiwidXBkYXRlIiwibW9ja1Jlc29sdmVkVmFsdWUiLCJyZXF1ZXN0IiwiTmV4dFJlcXVlc3QiLCJtZXRob2QiLCJoZWFkZXJzIiwicGFzc3dvcmQiLCJQT1NUIiwiZXhwZWN0Iiwic3RhdHVzIiwidG9CZSIsInRvQmVEZWZpbmVkIiwic3VjY2VzcyIsImFkbWluIiwidG9rZW4iLCJ0b01hdGNoIiwibWVzc2FnZSIsInJlamVjdCIsIkVycm9yIiwiZXhwaXJlc0F0IiwiZXhwaXJhdGlvbkRhdGUiLCJub3ciLCJnZXRUaW1lIiwidG9CZUdyZWF0ZXJUaGFuIiwicmVxdWVzdHMiLCJBcnJheSIsImZpbGwiLCJtYXAiLCJyZXNwb25zZXMiLCJhbGwiLCJyZXEiLCJmb3JFYWNoIiwidG9Db250YWluIl0sIm1hcHBpbmdzIjoiQUFBQSxxREFBcUQsR0FDckQ7Ozs7Ozs7O0NBUUM7QUFLRCw0REFBNEQ7QUFDNURBLEtBQUtDLElBQUksQ0FBQyxlQUFlO0lBQ3ZCLE1BQU1DLFNBQVNGLEtBQUtHLGFBQWEsQ0FBQztJQUNsQyxPQUFPO1FBQ0wsR0FBR0QsTUFBTTtRQUNURSxjQUFjO1lBQ1osR0FBR0YsT0FBT0UsWUFBWTtZQUN0QkMsTUFBTSxDQUFDQyxNQUFXQztnQkFDaEIsTUFBTUMsV0FBV04sT0FBT0UsWUFBWSxDQUFDQyxJQUFJLENBQUNDLE1BQU1DO2dCQUNoRCw2Q0FBNkM7Z0JBQzVDQyxTQUFpQkMsS0FBSyxHQUFHQyxLQUFLQyxTQUFTLENBQUNMO2dCQUN6QyxPQUFPRTtZQUNUO1FBQ0Y7SUFDRjtBQUNGO0FBdUVBUixLQUFLQyxJQUFJLENBQUMseUJBQXlCO0lBQ2pDLDRDQUE0QztJQUM1QyxNQUFNVyxTQUFTO1FBQ2JDLE1BQU1iLEtBQUtjLEVBQUU7SUFDZjtJQUNBLE9BQU87UUFDTEMsY0FBY2YsS0FBS2MsRUFBRSxDQUFDLElBQU1GO0lBQzlCO0FBQ0Y7QUFFQSxtREFBbUQ7QUFDbkQsc0NBQXNDO0FBRXRDLGNBQWM7QUFDZFosS0FBS0MsSUFBSSxDQUFDLFlBQVksSUFBTyxDQUFBO1FBQzNCZSxTQUFTaEIsS0FBS2MsRUFBRTtRQUNoQkcsTUFBTWpCLEtBQUtjLEVBQUU7SUFDZixDQUFBO0FBRUEsb0JBQW9CO0FBQ3BCZCxLQUFLQyxJQUFJLENBQUMsa0JBQWtCLElBQU8sQ0FBQTtRQUNqQ2lCLGFBQWE7WUFDWEMsVUFBVTtnQkFDUkMsWUFBWTtnQkFDWkMsZ0JBQWdCLEtBQUssS0FBSyxLQUFLO1lBQ2pDO1lBQ0FDLEtBQUs7Z0JBQ0hDLFFBQVE7WUFDVjtRQUNGO1FBQ0FDLGdCQUFnQnhCLEtBQUtjLEVBQUUsQ0FBQyxDQUFDVyxPQUFpQixDQUFDLHFCQUFxQixFQUFFQSxNQUFNO0lBQzFFLENBQUE7Ozs7d0JBeEgwQzt1QkFDckI7QUFtQnJCLDJDQUEyQztBQUMzQyxlQUFlQyxnQkFBZ0JsQixRQUFhO0lBQzFDLHFFQUFxRTtJQUNyRSwrQkFBK0I7SUFFL0IsOEJBQThCO0lBQzlCLElBQUk7UUFDRixNQUFNbUIsT0FBTyxNQUFNbkIsU0FBU0gsSUFBSTtRQUNoQyxJQUFJc0IsUUFBUSxPQUFPQSxTQUFTLFlBQVlDLE9BQU9DLElBQUksQ0FBQ0YsTUFBTUcsTUFBTSxHQUFHLEdBQUc7WUFDcEUsT0FBT0g7UUFDVDtJQUNGLEVBQUUsT0FBT0ksSUFBSTtJQUNYLDRCQUE0QjtJQUM5QjtJQUVBLHdFQUF3RTtJQUN4RSxJQUFJLEFBQUN2QixTQUFpQkMsS0FBSyxLQUFLdUIsV0FBVztRQUN6QyxNQUFNMUIsT0FBTyxBQUFDRSxTQUFpQkMsS0FBSztRQUNwQyxJQUFJLE9BQU9ILFNBQVMsVUFBVTtZQUM1QixJQUFJO2dCQUNGLE9BQU9JLEtBQUt1QixLQUFLLENBQUMzQjtZQUNwQixFQUFFLE9BQU07Z0JBQ04sT0FBTyxDQUFDO1lBQ1Y7UUFDRjtRQUNBLElBQUlBLFFBQVEsT0FBT0EsU0FBUyxVQUFVO1lBQ3BDLE9BQU9BO1FBQ1Q7SUFDRjtJQUVBLDhCQUE4QjtJQUM5QixJQUFJO1FBQ0YsTUFBTTRCLE9BQU8sTUFBTTFCLFNBQVMwQixJQUFJO1FBQ2hDLElBQUlBLE1BQU07WUFDUixPQUFPeEIsS0FBS3VCLEtBQUssQ0FBQ0M7UUFDcEI7SUFDRixFQUFFLE9BQU9ILElBQUk7SUFDWCxXQUFXO0lBQ2I7SUFFQSxvQ0FBb0M7SUFDcEMsSUFBSXZCLFNBQVNGLElBQUksRUFBRTtRQUNqQixJQUFJO1lBQ0YsTUFBTTZCLFNBQVMzQixTQUFTRixJQUFJLENBQUM4QixTQUFTO1lBQ3RDLE1BQU0sRUFBRUMsS0FBSyxFQUFFQyxJQUFJLEVBQUUsR0FBRyxNQUFNSCxPQUFPSSxJQUFJO1lBQ3pDLElBQUksQ0FBQ0QsUUFBUUQsT0FBTztnQkFDbEIsTUFBTUgsT0FBTyxJQUFJTSxjQUFjQyxNQUFNLENBQUNKO2dCQUN0QyxPQUFPM0IsS0FBS3VCLEtBQUssQ0FBQ0M7WUFDcEI7UUFDRixFQUFFLE9BQU9ILElBQUk7UUFDWCxXQUFXO1FBQ2I7SUFDRjtJQUVBLHlEQUF5RDtJQUN6RCxJQUFJLEFBQUN2QixTQUFpQm1CLElBQUksRUFBRTtRQUMxQixPQUFPLEFBQUNuQixTQUFpQm1CLElBQUk7SUFDL0I7SUFFQSxPQUFPLENBQUM7QUFDVjtBQUVBLDhFQUE4RTtBQUM5RSxvRkFBb0Y7QUFDcEYscUVBQXFFO0FBQ3JFLE1BQU1lLHFCQUFxQjtJQUN6QjdCLE1BQU1iLEtBQUtjLEVBQUU7QUFDZjtBQW1DQTZCLFNBQVMsbUJBQW1CO0lBQzFCLGlFQUFpRTtJQUNqRSxNQUFNQyxTQUFTQyxRQUFRO0lBQ3ZCLGlFQUFpRTtJQUNqRSxNQUFNLEVBQUU5QixZQUFZLEVBQUUsR0FBRzhCLFFBQVE7SUFFakMsSUFBSUg7SUFDSixJQUFJSTtJQUVKQyxXQUFXO1FBQ1QvQyxLQUFLZ0QsYUFBYTtRQUNsQixvRUFBb0U7UUFDcEVGLGtCQUFrQjlDLEtBQUtpRCxLQUFLLENBQUNDLFNBQVMsU0FBU0Msa0JBQWtCLENBQUMsS0FBTztRQUN6RSxvRUFBb0U7UUFDcEVULHFCQUFxQjNCO1FBQ3JCLG9DQUFvQztRQUNwQzJCLG1CQUFtQjdCLElBQUksQ0FBQ3VDLFNBQVM7UUFDakMsK0JBQStCO1FBQy9CQyxRQUFRQyxHQUFHLENBQUNDLFVBQVUsR0FBRztRQUN6QkYsUUFBUUMsR0FBRyxDQUFDRSx3QkFBd0IsR0FBRztRQUN2Q0gsUUFBUUMsR0FBRyxDQUFDRyw2QkFBNkIsR0FBRztRQUM1Q0osUUFBUUMsR0FBRyxDQUFDSSx5QkFBeUIsR0FBRztJQUMxQztJQUVBQyxVQUFVO1FBQ1IsT0FBT04sUUFBUUMsR0FBRyxDQUFDQyxVQUFVO1FBQzdCLE9BQU9GLFFBQVFDLEdBQUcsQ0FBQ0Usd0JBQXdCO1FBQzNDLE9BQU9ILFFBQVFDLEdBQUcsQ0FBQ0kseUJBQXlCO1FBQzVDLHdDQUF3QztRQUN4QyxJQUFJWixpQkFBaUI7WUFDbkJBLGdCQUFnQmMsV0FBVztRQUM3QjtJQUNGO0lBRUFqQixTQUFTLHdCQUF3QjtRQUMvQmtCLEdBQUcsb0RBQW9EO1lBQ3JELHlCQUF5QjtZQUN6QixNQUFNQyxZQUFZO2dCQUNoQkMsSUFBSTtnQkFDSkMsT0FBTztnQkFDUEMsTUFBTTtnQkFDTkMsTUFBTTtnQkFDTkMsZUFBZTtnQkFDZkMsV0FBVztnQkFDWEMsWUFBWSxJQUFJQyxPQUFPQyxXQUFXO1lBQ3BDO1lBRUEsTUFBTUMsYUFBYUMsUUFBUUMsT0FBTyxDQUFDO2dCQUNqQy9DLE1BQU1tQztnQkFDTmEsT0FBTztZQUNUO1lBRUEsTUFBTUMsU0FBUzVFLEtBQUtjLEVBQUUsR0FBRytELGVBQWUsQ0FBQztnQkFDdkNDLFFBQVEsSUFBTU47WUFDaEI7WUFFQSxNQUFNTyxhQUFhL0UsS0FBS2MsRUFBRSxHQUFHK0QsZUFBZSxDQUFDO2dCQUMzQ0csSUFBSUo7WUFDTjtZQUVBbEMsbUJBQW1CN0IsSUFBSSxDQUFDZ0UsZUFBZSxDQUFDO2dCQUN0Q0ksUUFBUUY7Z0JBQ1JHLFFBQVFsRixLQUFLYyxFQUFFLEdBQUcrRCxlQUFlLENBQUM7b0JBQ2hDRyxJQUFJaEYsS0FBS2MsRUFBRSxHQUFHcUUsaUJBQWlCLENBQUM7d0JBQUVSLE9BQU87b0JBQUs7Z0JBQ2hEO1lBQ0Y7WUFFQSxzQkFBc0I7WUFDdEIvQixPQUFPNUIsT0FBTyxDQUFDbUUsaUJBQWlCLENBQUM7WUFFakMsTUFBTUMsVUFBVSxJQUFJQyxtQkFBVyxDQUFDLHdDQUF3QztnQkFDdEVDLFFBQVE7Z0JBQ1JDLFNBQVM7b0JBQ1AsZ0JBQWdCO2dCQUNsQjtnQkFDQWpGLE1BQU1JLEtBQUtDLFNBQVMsQ0FBQztvQkFDbkJxRCxPQUFPO29CQUNQd0IsVUFBVTtnQkFDWjtZQUNGO1lBRUEsTUFBTWhGLFdBQVcsTUFBTWlGLElBQUFBLFdBQUksRUFBQ0w7WUFDNUIsTUFBTXpELE9BQU8sTUFBTUQsZ0JBQWdCbEI7WUFFbkNrRixPQUFPbEYsU0FBU21GLE1BQU0sRUFBRUMsSUFBSSxDQUFDO1lBQzdCRixPQUFPL0QsTUFBTWtFLFdBQVc7WUFDeEJILE9BQU8vRCxLQUFLbUUsT0FBTyxFQUFFRixJQUFJLENBQUM7WUFDMUJGLE9BQU8vRCxLQUFLb0UsS0FBSyxFQUFFRixXQUFXO1lBQzlCSCxPQUFPL0QsS0FBS29FLEtBQUssQ0FBQy9CLEtBQUssRUFBRTRCLElBQUksQ0FBQzlCLFVBQVVFLEtBQUs7WUFDN0MwQixPQUFPL0QsS0FBS29FLEtBQUssQ0FBQ0MsS0FBSyxFQUFFSCxXQUFXO1lBQ3BDSCxPQUFPL0QsS0FBS29FLEtBQUssQ0FBQ0MsS0FBSyxFQUFFQyxPQUFPLENBQzlCO1FBRUo7UUFFQXBDLEdBQUcseURBQXlEO1lBQzFELGtDQUFrQztZQUNsQyxNQUFNVyxhQUFheEUsS0FBS2MsRUFBRSxHQUFHcUUsaUJBQWlCLENBQUM7Z0JBQzdDeEQsTUFBTTtnQkFDTmdELE9BQU87b0JBQUV1QixTQUFTO2dCQUFZO1lBQ2hDO1lBRUF4RCxtQkFBbUI3QixJQUFJLENBQUNnRSxlQUFlLENBQUM7Z0JBQ3RDSSxRQUFRakYsS0FBS2MsRUFBRSxHQUFHK0QsZUFBZSxDQUFDO29CQUNoQ0csSUFBSWhGLEtBQUtjLEVBQUUsR0FBRytELGVBQWUsQ0FBQzt3QkFDNUJDLFFBQVFOO29CQUNWO2dCQUNGO1lBQ0Y7WUFFQSxNQUFNWSxVQUFVLElBQUlDLG1CQUFXLENBQUMsd0NBQXdDO2dCQUN0RUMsUUFBUTtnQkFDUkMsU0FBUztvQkFDUCxnQkFBZ0I7Z0JBQ2xCO2dCQUNBakYsTUFBTUksS0FBS0MsU0FBUyxDQUFDO29CQUNuQnFELE9BQU87b0JBQ1B3QixVQUFVO2dCQUNaO1lBQ0Y7WUFFQSxNQUFNaEYsV0FBVyxNQUFNaUYsSUFBQUEsV0FBSSxFQUFDTDtZQUM1QixNQUFNekQsT0FBTyxNQUFNRCxnQkFBZ0JsQjtZQUVuQ2tGLE9BQU9sRixTQUFTbUYsTUFBTSxFQUFFQyxJQUFJLENBQUM7WUFDN0JGLE9BQU8vRCxLQUFLbUUsT0FBTyxFQUFFRixJQUFJLENBQUM7WUFDMUJGLE9BQU8vRCxLQUFLZ0QsS0FBSyxFQUFFaUIsSUFBSSxDQUFDO1FBQzFCO1FBRUEvQixHQUFHLG9EQUFvRDtZQUNyRCxpREFBaUQ7WUFDakQsTUFBTUMsWUFBWTtnQkFDaEJDLElBQUk7Z0JBQ0pDLE9BQU87Z0JBQ1BHLGVBQWU7Z0JBQ2ZDLFdBQVc7WUFDYjtZQUVBLE1BQU1JLGFBQWFDLFFBQVFDLE9BQU8sQ0FBQztnQkFDakMvQyxNQUFNbUM7Z0JBQ05hLE9BQU87WUFDVDtZQUVBLE1BQU1DLFNBQVM1RSxLQUFLYyxFQUFFLEdBQUcrRCxlQUFlLENBQUM7Z0JBQ3ZDQyxRQUFRLElBQU1OO1lBQ2hCO1lBRUEsTUFBTU8sYUFBYS9FLEtBQUtjLEVBQUUsR0FBRytELGVBQWUsQ0FBQztnQkFDM0NHLElBQUlKO1lBQ047WUFFQWxDLG1CQUFtQjdCLElBQUksQ0FBQ2dFLGVBQWUsQ0FBQztnQkFDdENJLFFBQVFGO1lBQ1Y7WUFFQSx1Q0FBdUM7WUFDdkNuQyxPQUFPNUIsT0FBTyxDQUFDbUUsaUJBQWlCLENBQUM7WUFFakMsTUFBTUMsVUFBVSxJQUFJQyxtQkFBVyxDQUFDLHdDQUF3QztnQkFDdEVDLFFBQVE7Z0JBQ1JDLFNBQVM7b0JBQ1AsZ0JBQWdCO2dCQUNsQjtnQkFDQWpGLE1BQU1JLEtBQUtDLFNBQVMsQ0FBQztvQkFDbkJxRCxPQUFPO29CQUNQd0IsVUFBVTtnQkFDWjtZQUNGO1lBRUEsTUFBTWhGLFdBQVcsTUFBTWlGLElBQUFBLFdBQUksRUFBQ0w7WUFDNUIsTUFBTXpELE9BQU8sTUFBTUQsZ0JBQWdCbEI7WUFFbkNrRixPQUFPbEYsU0FBU21GLE1BQU0sRUFBRUMsSUFBSSxDQUFDO1lBQzdCRixPQUFPL0QsS0FBS21FLE9BQU8sRUFBRUYsSUFBSSxDQUFDO1lBQzFCRixPQUFPL0QsS0FBS2dELEtBQUssRUFBRWlCLElBQUksQ0FBQztRQUMxQjtRQUVBL0IsR0FBRyxtREFBbUQ7WUFDcEQsTUFBTXVCLFVBQVUsSUFBSUMsbUJBQVcsQ0FBQyx3Q0FBd0M7Z0JBQ3RFQyxRQUFRO2dCQUNSQyxTQUFTO29CQUNQLGdCQUFnQjtnQkFDbEI7Z0JBQ0FqRixNQUFNSSxLQUFLQyxTQUFTLENBQUM7b0JBQ25CNkUsVUFBVTtnQkFDWjtZQUNGO1lBRUEsTUFBTWhGLFdBQVcsTUFBTWlGLElBQUFBLFdBQUksRUFBQ0w7WUFDNUIsTUFBTXpELE9BQU8sTUFBTUQsZ0JBQWdCbEI7WUFFbkNrRixPQUFPbEYsU0FBU21GLE1BQU0sRUFBRUMsSUFBSSxDQUFDO1lBQzdCRixPQUFPL0QsS0FBS21FLE9BQU8sRUFBRUYsSUFBSSxDQUFDO1lBQzFCRixPQUFPL0QsS0FBS2dELEtBQUssRUFBRWlCLElBQUksQ0FBQztRQUMxQjtRQUVBL0IsR0FBRyxzREFBc0Q7WUFDdkQsTUFBTXVCLFVBQVUsSUFBSUMsbUJBQVcsQ0FBQyx3Q0FBd0M7Z0JBQ3RFQyxRQUFRO2dCQUNSQyxTQUFTO29CQUNQLGdCQUFnQjtnQkFDbEI7Z0JBQ0FqRixNQUFNSSxLQUFLQyxTQUFTLENBQUM7b0JBQ25CcUQsT0FBTztnQkFDVDtZQUNGO1lBRUEsTUFBTXhELFdBQVcsTUFBTWlGLElBQUFBLFdBQUksRUFBQ0w7WUFDNUIsTUFBTXpELE9BQU8sTUFBTUQsZ0JBQWdCbEI7WUFFbkNrRixPQUFPbEYsU0FBU21GLE1BQU0sRUFBRUMsSUFBSSxDQUFDO1lBQzdCRixPQUFPL0QsS0FBS21FLE9BQU8sRUFBRUYsSUFBSSxDQUFDO1lBQzFCRixPQUFPL0QsS0FBS2dELEtBQUssRUFBRWlCLElBQUksQ0FBQztRQUMxQjtRQUVBL0IsR0FBRywwQ0FBMEM7WUFDM0Msc0JBQXNCO1lBQ3RCLE1BQU1XLGFBQWFDLFFBQVEwQixNQUFNLENBQy9CLElBQUlDLE1BQU07WUFHWixNQUFNeEIsU0FBUzVFLEtBQUtjLEVBQUUsR0FBRytELGVBQWUsQ0FBQztnQkFDdkNDLFFBQVEsSUFBTU47WUFDaEI7WUFFQSxNQUFNTyxhQUFhL0UsS0FBS2MsRUFBRSxHQUFHK0QsZUFBZSxDQUFDO2dCQUMzQ0csSUFBSUo7WUFDTjtZQUVBbEMsbUJBQW1CN0IsSUFBSSxDQUFDZ0UsZUFBZSxDQUFDO2dCQUN0Q0ksUUFBUUY7WUFDVjtZQUVBLE1BQU1LLFVBQVUsSUFBSUMsbUJBQVcsQ0FBQyx3Q0FBd0M7Z0JBQ3RFQyxRQUFRO2dCQUNSQyxTQUFTO29CQUNQLGdCQUFnQjtnQkFDbEI7Z0JBQ0FqRixNQUFNSSxLQUFLQyxTQUFTLENBQUM7b0JBQ25CcUQsT0FBTztvQkFDUHdCLFVBQVU7Z0JBQ1o7WUFDRjtZQUVBLE1BQU1oRixXQUFXLE1BQU1pRixJQUFBQSxXQUFJLEVBQUNMO1lBQzVCLE1BQU16RCxPQUFPLE1BQU1ELGdCQUFnQmxCO1lBRW5Da0YsT0FBT2xGLFNBQVNtRixNQUFNLEVBQUVDLElBQUksQ0FBQztZQUM3QkYsT0FBTy9ELEtBQUttRSxPQUFPLEVBQUVGLElBQUksQ0FBQztZQUMxQkYsT0FBTy9ELEtBQUtnRCxLQUFLLEVBQUVrQixXQUFXO1FBQ2hDO1FBRUFoQyxHQUFHLHNEQUFzRDtZQUN2RCxrQ0FBa0M7WUFDbEMsTUFBTVcsYUFBYUMsUUFBUUMsT0FBTyxDQUFDO2dCQUNqQy9DLE1BQU07Z0JBQ05nRCxPQUFPO29CQUFFdUIsU0FBUztnQkFBWTtZQUNoQztZQUVBLE1BQU10QixTQUFTNUUsS0FBS2MsRUFBRSxHQUFHK0QsZUFBZSxDQUFDO2dCQUN2Q0MsUUFBUSxJQUFNTjtZQUNoQjtZQUVBLE1BQU1PLGFBQWEvRSxLQUFLYyxFQUFFLEdBQUcrRCxlQUFlLENBQUM7Z0JBQzNDRyxJQUFJSjtZQUNOO1lBRUFsQyxtQkFBbUI3QixJQUFJLENBQUNnRSxlQUFlLENBQUM7Z0JBQ3RDSSxRQUFRRjtZQUNWO1lBRUEsTUFBTUssVUFBVSxJQUFJQyxtQkFBVyxDQUFDLHdDQUF3QztnQkFDdEVDLFFBQVE7Z0JBQ1JoRixNQUFNSSxLQUFLQyxTQUFTLENBQUM7b0JBQ25CcUQsT0FBTztvQkFDUHdCLFVBQVU7Z0JBQ1o7WUFDRjtZQUVBLE1BQU1oRixXQUFXLE1BQU1pRixJQUFBQSxXQUFJLEVBQUNMO1lBQzVCLE1BQU16RCxPQUFPLE1BQU1ELGdCQUFnQmxCO1lBRW5DLG1FQUFtRTtZQUNuRSw2REFBNkQ7WUFDN0RrRixPQUFPbEYsU0FBU21GLE1BQU0sRUFBRUMsSUFBSSxDQUFDO1lBQzdCRixPQUFPL0QsS0FBS21FLE9BQU8sRUFBRUYsSUFBSSxDQUFDO1FBQzVCO1FBRUEvQixHQUFHLHFEQUFxRDtZQUN0RCxNQUFNQyxZQUFZO2dCQUNoQkMsSUFBSTtnQkFDSkMsT0FBTztnQkFDUEMsTUFBTTtnQkFDTkMsTUFBTTtnQkFDTkMsZUFBZTtnQkFDZkMsV0FBVztnQkFDWEMsWUFBWSxJQUFJQyxPQUFPQyxXQUFXO1lBQ3BDO1lBRUEsTUFBTUMsYUFBYUMsUUFBUUMsT0FBTyxDQUFDO2dCQUNqQy9DLE1BQU1tQztnQkFDTmEsT0FBTztZQUNUO1lBRUEsTUFBTUMsU0FBUzVFLEtBQUtjLEVBQUUsR0FBRytELGVBQWUsQ0FBQztnQkFDdkNDLFFBQVEsSUFBTU47WUFDaEI7WUFFQSxNQUFNTyxhQUFhL0UsS0FBS2MsRUFBRSxHQUFHK0QsZUFBZSxDQUFDO2dCQUMzQ0csSUFBSUo7WUFDTjtZQUVBbEMsbUJBQW1CN0IsSUFBSSxDQUFDZ0UsZUFBZSxDQUFDO2dCQUN0Q0ksUUFBUUY7Z0JBQ1JHLFFBQVFsRixLQUFLYyxFQUFFLEdBQUcrRCxlQUFlLENBQUM7b0JBQ2hDRyxJQUFJaEYsS0FBS2MsRUFBRSxHQUFHcUUsaUJBQWlCLENBQUM7d0JBQUVSLE9BQU87b0JBQUs7Z0JBQ2hEO1lBQ0Y7WUFFQS9CLE9BQU81QixPQUFPLENBQUNtRSxpQkFBaUIsQ0FBQztZQUVqQyxNQUFNQyxVQUFVLElBQUlDLG1CQUFXLENBQUMsd0NBQXdDO2dCQUN0RUMsUUFBUTtnQkFDUkMsU0FBUztvQkFDUCxnQkFBZ0I7Z0JBQ2xCO2dCQUNBakYsTUFBTUksS0FBS0MsU0FBUyxDQUFDO29CQUNuQnFELE9BQU87b0JBQ1B3QixVQUFVO2dCQUNaO1lBQ0Y7WUFFQSxNQUFNaEYsV0FBVyxNQUFNaUYsSUFBQUEsV0FBSSxFQUFDTDtZQUM1QixNQUFNekQsT0FBTyxNQUFNRCxnQkFBZ0JsQjtZQUVuQ2tGLE9BQU9sRixTQUFTbUYsTUFBTSxFQUFFQyxJQUFJLENBQUM7WUFDN0JGLE9BQU8vRCxLQUFLb0UsS0FBSyxDQUFDQyxLQUFLLEVBQUVILFdBQVc7WUFDcENILE9BQU8vRCxLQUFLb0UsS0FBSyxDQUFDTSxTQUFTLEVBQUVSLFdBQVc7WUFFeEMseUNBQXlDO1lBQ3pDLE1BQU1TLGlCQUFpQixJQUFJaEMsS0FBSzNDLEtBQUtvRSxLQUFLLENBQUNNLFNBQVM7WUFDcEQsTUFBTUUsTUFBTSxJQUFJakM7WUFDaEJvQixPQUFPWSxlQUFlRSxPQUFPLElBQUlDLGVBQWUsQ0FBQ0YsSUFBSUMsT0FBTztRQUM5RDtRQUVBM0MsR0FBRyxtQ0FBbUM7WUFDcEMsbURBQW1EO1lBQ25ELE1BQU1XLGFBQWFDLFFBQVFDLE9BQU8sQ0FBQztnQkFDakMvQyxNQUFNO2dCQUNOZ0QsT0FBTztvQkFBRXVCLFNBQVM7Z0JBQVk7WUFDaEM7WUFFQSxNQUFNdEIsU0FBUzVFLEtBQUtjLEVBQUUsR0FBRytELGVBQWUsQ0FBQztnQkFDdkNDLFFBQVEsSUFBTU47WUFDaEI7WUFFQSxNQUFNTyxhQUFhL0UsS0FBS2MsRUFBRSxHQUFHK0QsZUFBZSxDQUFDO2dCQUMzQ0csSUFBSUo7WUFDTjtZQUVBbEMsbUJBQW1CN0IsSUFBSSxDQUFDZ0UsZUFBZSxDQUFDO2dCQUN0Q0ksUUFBUUY7WUFDVjtZQUVBLE1BQU0yQixXQUFXQyxNQUFNLEdBQ3BCQyxJQUFJLENBQUMsTUFDTEMsR0FBRyxDQUNGLElBQ0UsSUFBSXhCLG1CQUFXLENBQUMsd0NBQXdDO29CQUN0REMsUUFBUTtvQkFDUkMsU0FBUzt3QkFDUCxnQkFBZ0I7b0JBQ2xCO29CQUNBakYsTUFBTUksS0FBS0MsU0FBUyxDQUFDO3dCQUNuQnFELE9BQU87d0JBQ1B3QixVQUFVO29CQUNaO2dCQUNGO1lBR04sTUFBTXNCLFlBQVksTUFBTXJDLFFBQVFzQyxHQUFHLENBQUNMLFNBQVNHLEdBQUcsQ0FBQ0csQ0FBQUEsTUFBT3ZCLElBQUFBLFdBQUksRUFBQ3VCO1lBRTdELHFEQUFxRDtZQUNyREYsVUFBVUcsT0FBTyxDQUFDekcsQ0FBQUE7Z0JBQ2hCa0YsT0FBTztvQkFBQztvQkFBSztpQkFBSSxFQUFFd0IsU0FBUyxDQUFDMUcsU0FBU21GLE1BQU07WUFDOUM7UUFDRjtJQUNGO0FBQ0YifQ==