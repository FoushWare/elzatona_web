2ab385295c5e8da5ed4ce0f237829d6e
'use client';
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: Object.getOwnPropertyDescriptor(all, name).get
    });
}
_export(exports, {
    get AlzatonaLogo () {
        return AlzatonaLogo;
    },
    get default () {
        return _default;
    }
});
const _jsxruntime = require("react/jsx-runtime");
const _react = /*#__PURE__*/ _interop_require_wildcard(require("react"));
const _image = /*#__PURE__*/ _interop_require_default(require("next/image"));
const _sharedcontexts = require("../../../../shared-contexts/src");
function _interop_require_default(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
function _getRequireWildcardCache(nodeInterop) {
    if (typeof WeakMap !== "function") return null;
    var cacheBabelInterop = new WeakMap();
    var cacheNodeInterop = new WeakMap();
    return (_getRequireWildcardCache = function(nodeInterop) {
        return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
    })(nodeInterop);
}
function _interop_require_wildcard(obj, nodeInterop) {
    if (!nodeInterop && obj && obj.__esModule) {
        return obj;
    }
    if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return {
            default: obj
        };
    }
    var cache = _getRequireWildcardCache(nodeInterop);
    if (cache && cache.has(obj)) {
        return cache.get(obj);
    }
    var newObj = {
        __proto__: null
    };
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for(var key in obj){
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
            if (desc && (desc.get || desc.set)) {
                Object.defineProperty(newObj, key, desc);
            } else {
                newObj[key] = obj[key];
            }
        }
    }
    newObj.default = obj;
    if (cache) {
        cache.set(obj, newObj);
    }
    return newObj;
}
const AlzatonaLogo = ({ size = 'md', className = '', showText = true, variant = 'horizontal', forceDarkMode = false })=>{
    const { isDarkMode } = (0, _sharedcontexts.useTheme)();
    const [isClient, setIsClient] = (0, _react.useState)(false);
    // Prevent hydration mismatch by only using theme after client-side hydration
    (0, _react.useEffect)(()=>{
        setIsClient(true);
    }, []);
    const sizeConfig = {
        xs: {
            class: 'w-20 h-20',
            width: 80,
            height: 80
        },
        sm: {
            class: 'w-28 h-28',
            width: 112,
            height: 112
        },
        md: {
            class: 'w-36 h-36',
            width: 144,
            height: 144
        },
        lg: {
            class: 'w-44 h-44',
            width: 176,
            height: 176
        }
    };
    const config = sizeConfig[size];
    // Determine which logo to use based on dark mode
    // Use forceDarkMode as the primary decision factor to avoid hydration issues
    // Only use theme after client-side hydration to prevent mismatches
    const shouldUseDarkLogo = forceDarkMode || isClient && isDarkMode;
    const logoSrc = shouldUseDarkLogo ? '/Elzatona-web01.png' : '/Elzatona-black-all.png';
    // Use a consistent alt text to avoid hydration mismatches
    const logoAlt = 'Elzatona Logo';
    return /*#__PURE__*/ (0, _jsxruntime.jsx)("div", {
        className: `${className}`,
        children: /*#__PURE__*/ (0, _jsxruntime.jsx)(_image.default, {
            src: logoSrc,
            alt: logoAlt,
            width: config.width,
            height: config.height,
            className: `${config.class} object-contain`,
            priority: true,
            suppressHydrationWarning: true
        })
    });
};
const _default = AlzatonaLogo;

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9hLmZvdWFkL1NpZGVQcm9qZWN0cy9FbHphdG9uYS1hbGwvRWx6YXRvbmEtd2ViL2xpYnMvc2hhcmVkLWNvbXBvbmVudHMvc3JjL2xpYi9jb21tb24vQWx6YXRvbmFMb2dvLnRzeCJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIGNsaWVudCc7XG5cbmltcG9ydCBSZWFjdCwgeyB1c2VTdGF0ZSwgdXNlRWZmZWN0IH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IEltYWdlIGZyb20gJ25leHQvaW1hZ2UnO1xuaW1wb3J0IHsgdXNlVGhlbWUgfSBmcm9tICdAZWx6YXRvbmEvc2hhcmVkLWNvbnRleHRzJztcblxuaW50ZXJmYWNlIEFsemF0b25hTG9nb1Byb3BzIHtcbiAgc2l6ZT86ICd4cycgfCAnc20nIHwgJ21kJyB8ICdsZyc7XG4gIGNsYXNzTmFtZT86IHN0cmluZztcbiAgc2hvd1RleHQ/OiBib29sZWFuO1xuICB2YXJpYW50PzogJ2hvcml6b250YWwnIHwgJ3N0YWNrZWQnO1xuICBmb3JjZURhcmtNb2RlPzogYm9vbGVhbjsgLy8gRm9yIGNhc2VzIHdoZXJlIHdlIG5lZWQgdG8gZm9yY2UgZGFyayBtb2RlIGxvZ29cbn1cblxuZXhwb3J0IGNvbnN0IEFsemF0b25hTG9nbzogUmVhY3QuRkM8QWx6YXRvbmFMb2dvUHJvcHM+ID0gKHtcbiAgc2l6ZSA9ICdtZCcsXG4gIGNsYXNzTmFtZSA9ICcnLFxuICBzaG93VGV4dCA9IHRydWUsXG4gIHZhcmlhbnQgPSAnaG9yaXpvbnRhbCcsXG4gIGZvcmNlRGFya01vZGUgPSBmYWxzZSxcbn0pID0+IHtcbiAgY29uc3QgeyBpc0RhcmtNb2RlIH0gPSB1c2VUaGVtZSgpO1xuICBjb25zdCBbaXNDbGllbnQsIHNldElzQ2xpZW50XSA9IHVzZVN0YXRlKGZhbHNlKTtcblxuICAvLyBQcmV2ZW50IGh5ZHJhdGlvbiBtaXNtYXRjaCBieSBvbmx5IHVzaW5nIHRoZW1lIGFmdGVyIGNsaWVudC1zaWRlIGh5ZHJhdGlvblxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIHNldElzQ2xpZW50KHRydWUpO1xuICB9LCBbXSk7XG5cbiAgY29uc3Qgc2l6ZUNvbmZpZyA9IHtcbiAgICB4czogeyBjbGFzczogJ3ctMjAgaC0yMCcsIHdpZHRoOiA4MCwgaGVpZ2h0OiA4MCB9LCAvLyBJbmNyZWFzZWQgZnJvbSAxNngxNlxuICAgIHNtOiB7IGNsYXNzOiAndy0yOCBoLTI4Jywgd2lkdGg6IDExMiwgaGVpZ2h0OiAxMTIgfSwgLy8gSW5jcmVhc2VkIGZyb20gMjR4MjRcbiAgICBtZDogeyBjbGFzczogJ3ctMzYgaC0zNicsIHdpZHRoOiAxNDQsIGhlaWdodDogMTQ0IH0sIC8vIEluY3JlYXNlZCBmcm9tIDMyeDMyXG4gICAgbGc6IHsgY2xhc3M6ICd3LTQ0IGgtNDQnLCB3aWR0aDogMTc2LCBoZWlnaHQ6IDE3NiB9LCAvLyBJbmNyZWFzZWQgZnJvbSA0MHg0MFxuICB9O1xuXG4gIGNvbnN0IGNvbmZpZyA9IHNpemVDb25maWdbc2l6ZV07XG5cbiAgLy8gRGV0ZXJtaW5lIHdoaWNoIGxvZ28gdG8gdXNlIGJhc2VkIG9uIGRhcmsgbW9kZVxuICAvLyBVc2UgZm9yY2VEYXJrTW9kZSBhcyB0aGUgcHJpbWFyeSBkZWNpc2lvbiBmYWN0b3IgdG8gYXZvaWQgaHlkcmF0aW9uIGlzc3Vlc1xuICAvLyBPbmx5IHVzZSB0aGVtZSBhZnRlciBjbGllbnQtc2lkZSBoeWRyYXRpb24gdG8gcHJldmVudCBtaXNtYXRjaGVzXG4gIGNvbnN0IHNob3VsZFVzZURhcmtMb2dvID0gZm9yY2VEYXJrTW9kZSB8fCAoaXNDbGllbnQgJiYgaXNEYXJrTW9kZSk7XG4gIGNvbnN0IGxvZ29TcmMgPSBzaG91bGRVc2VEYXJrTG9nb1xuICAgID8gJy9FbHphdG9uYS13ZWIwMS5wbmcnXG4gICAgOiAnL0VsemF0b25hLWJsYWNrLWFsbC5wbmcnO1xuICAvLyBVc2UgYSBjb25zaXN0ZW50IGFsdCB0ZXh0IHRvIGF2b2lkIGh5ZHJhdGlvbiBtaXNtYXRjaGVzXG4gIGNvbnN0IGxvZ29BbHQgPSAnRWx6YXRvbmEgTG9nbyc7XG5cbiAgcmV0dXJuIChcbiAgICA8ZGl2IGNsYXNzTmFtZT17YCR7Y2xhc3NOYW1lfWB9PlxuICAgICAgPEltYWdlXG4gICAgICAgIHNyYz17bG9nb1NyY31cbiAgICAgICAgYWx0PXtsb2dvQWx0fVxuICAgICAgICB3aWR0aD17Y29uZmlnLndpZHRofVxuICAgICAgICBoZWlnaHQ9e2NvbmZpZy5oZWlnaHR9XG4gICAgICAgIGNsYXNzTmFtZT17YCR7Y29uZmlnLmNsYXNzfSBvYmplY3QtY29udGFpbmB9XG4gICAgICAgIHByaW9yaXR5XG4gICAgICAgIHN1cHByZXNzSHlkcmF0aW9uV2FybmluZ1xuICAgICAgLz5cbiAgICA8L2Rpdj5cbiAgKTtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IEFsemF0b25hTG9nbztcbiJdLCJuYW1lcyI6WyJBbHphdG9uYUxvZ28iLCJzaXplIiwiY2xhc3NOYW1lIiwic2hvd1RleHQiLCJ2YXJpYW50IiwiZm9yY2VEYXJrTW9kZSIsImlzRGFya01vZGUiLCJ1c2VUaGVtZSIsImlzQ2xpZW50Iiwic2V0SXNDbGllbnQiLCJ1c2VTdGF0ZSIsInVzZUVmZmVjdCIsInNpemVDb25maWciLCJ4cyIsImNsYXNzIiwid2lkdGgiLCJoZWlnaHQiLCJzbSIsIm1kIiwibGciLCJjb25maWciLCJzaG91bGRVc2VEYXJrTG9nbyIsImxvZ29TcmMiLCJsb2dvQWx0IiwiZGl2IiwiSW1hZ2UiLCJzcmMiLCJhbHQiLCJwcmlvcml0eSIsInN1cHByZXNzSHlkcmF0aW9uV2FybmluZyJdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7Ozs7Ozs7OztRQWNhQTtlQUFBQTs7UUFpRGI7ZUFBQTs7OzsrREE3RDJDOzhEQUN6QjtnQ0FDTzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFVbEIsTUFBTUEsZUFBNEMsQ0FBQyxFQUN4REMsT0FBTyxJQUFJLEVBQ1hDLFlBQVksRUFBRSxFQUNkQyxXQUFXLElBQUksRUFDZkMsVUFBVSxZQUFZLEVBQ3RCQyxnQkFBZ0IsS0FBSyxFQUN0QjtJQUNDLE1BQU0sRUFBRUMsVUFBVSxFQUFFLEdBQUdDLElBQUFBLHdCQUFRO0lBQy9CLE1BQU0sQ0FBQ0MsVUFBVUMsWUFBWSxHQUFHQyxJQUFBQSxlQUFRLEVBQUM7SUFFekMsNkVBQTZFO0lBQzdFQyxJQUFBQSxnQkFBUyxFQUFDO1FBQ1JGLFlBQVk7SUFDZCxHQUFHLEVBQUU7SUFFTCxNQUFNRyxhQUFhO1FBQ2pCQyxJQUFJO1lBQUVDLE9BQU87WUFBYUMsT0FBTztZQUFJQyxRQUFRO1FBQUc7UUFDaERDLElBQUk7WUFBRUgsT0FBTztZQUFhQyxPQUFPO1lBQUtDLFFBQVE7UUFBSTtRQUNsREUsSUFBSTtZQUFFSixPQUFPO1lBQWFDLE9BQU87WUFBS0MsUUFBUTtRQUFJO1FBQ2xERyxJQUFJO1lBQUVMLE9BQU87WUFBYUMsT0FBTztZQUFLQyxRQUFRO1FBQUk7SUFDcEQ7SUFFQSxNQUFNSSxTQUFTUixVQUFVLENBQUNYLEtBQUs7SUFFL0IsaURBQWlEO0lBQ2pELDZFQUE2RTtJQUM3RSxtRUFBbUU7SUFDbkUsTUFBTW9CLG9CQUFvQmhCLGlCQUFrQkcsWUFBWUY7SUFDeEQsTUFBTWdCLFVBQVVELG9CQUNaLHdCQUNBO0lBQ0osMERBQTBEO0lBQzFELE1BQU1FLFVBQVU7SUFFaEIscUJBQ0UscUJBQUNDO1FBQUl0QixXQUFXLEdBQUdBLFdBQVc7a0JBQzVCLGNBQUEscUJBQUN1QixjQUFLO1lBQ0pDLEtBQUtKO1lBQ0xLLEtBQUtKO1lBQ0xSLE9BQU9LLE9BQU9MLEtBQUs7WUFDbkJDLFFBQVFJLE9BQU9KLE1BQU07WUFDckJkLFdBQVcsR0FBR2tCLE9BQU9OLEtBQUssQ0FBQyxlQUFlLENBQUM7WUFDM0NjLFFBQVE7WUFDUkMsd0JBQXdCOzs7QUFJaEM7TUFFQSxXQUFlN0IifQ==