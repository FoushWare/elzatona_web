1708fd8e8ca2ee98b512c426c04bf09a
/* eslint-disable @typescript-eslint/no-explicit-any */ /**
 * Admin Login API Tests
 *
 * Tests for the /api/admin/auth endpoint to ensure:
 * - Authentication works correctly
 * - Proper error handling
 * - JWT token generation
 * - Security measures
 */ "use strict";
// Mock NextResponse to ensure json() method works correctly
jest.mock('next/server', ()=>{
    const actual = jest.requireActual('next/server');
    return {
        ...actual,
        NextResponse: {
            ...actual.NextResponse,
            json: (body, init)=>{
                const response = actual.NextResponse.json(body, init);
                // Ensure _body is set for test compatibility
                response._body = JSON.stringify(body);
                return response;
            }
        }
    };
});
jest.mock('@supabase/supabase-js', ()=>{
    // Create the mock client inside the factory
    const client = {
        from: jest.fn()
    };
    return {
        createClient: jest.fn(()=>client)
    };
});
// Export the mock client so tests can configure it
// We'll get it from the mocked module
// Mock bcrypt
jest.mock('bcryptjs', ()=>({
        compare: jest.fn(),
        hash: jest.fn()
    }));
// Mock admin.config
jest.mock('@/admin.config', ()=>({
        adminConfig: {
            security: {
                saltRounds: 10,
                sessionTimeout: 24 * 60 * 60 * 1000
            },
            jwt: {
                secret: 'test-jwt-secret'
            }
        },
        getAdminApiUrl: jest.fn((path)=>`http://localhost:3000${path}`)
    }));
Object.defineProperty(exports, "__esModule", {
    value: true
});
const _server = require("next/server");
const _route = require("../../apps/website/src/app/api/admin/auth/route");
// Helper to extract JSON from NextResponse
async function getResponseData(response) {
    // NextResponse.json() stores data in response._body or response.body
    // Check all possible locations
    // Method 1: Try json() method
    try {
        const data = await response.json();
        if (data && typeof data === 'object' && Object.keys(data).length > 0) {
            return data;
        }
    } catch (_e) {
    // Continue to other methods
    }
    // Method 2: Check internal _body property (NextResponse might use this)
    if (response._body !== undefined) {
        const body = response._body;
        if (typeof body === 'string') {
            try {
                return JSON.parse(body);
            } catch  {
                return {};
            }
        }
        if (body && typeof body === 'object') {
            return body;
        }
    }
    // Method 3: Try text() method
    try {
        const text = await response.text();
        if (text) {
            return JSON.parse(text);
        }
    } catch (_e) {
    // Continue
    }
    // Method 4: Try body ReadableStream
    if (response.body) {
        try {
            const reader = response.body.getReader();
            const { value, done } = await reader.read();
            if (!done && value) {
                const text = new TextDecoder().decode(value);
                return JSON.parse(text);
            }
        } catch (_e) {
        // Continue
        }
    }
    // Method 5: Check if response has data property directly
    if (response.data) {
        return response.data;
    }
    return {};
}
// Mock Supabase - this needs to be set up before the route module is imported
// The route handler creates the client at module load, so we need a shared instance
// Define the mock client inside the factory to avoid hoisting issues
const mockSupabaseClient = {
    from: jest.fn()
};
describe('Admin Login API', ()=>{
    // eslint-disable-next-line @typescript-eslint/no-require-imports
    const bcrypt = require('bcryptjs');
    // eslint-disable-next-line @typescript-eslint/no-require-imports
    const { createClient } = require('@supabase/supabase-js');
    let mockSupabaseClient;
    let consoleErrorSpy;
    beforeEach(()=>{
        jest.clearAllMocks();
        // Mock console.error globally to suppress error output during tests
        consoleErrorSpy = jest.spyOn(console, 'error').mockImplementation(()=>{});
        // Get the mock client instance (same one used by the route handler)
        mockSupabaseClient = createClient();
        // Reset the from mock for each test
        mockSupabaseClient.from.mockClear();
        // Set up environment variables
        process.env.JWT_SECRET = 'test-jwt-secret';
        process.env.NEXT_PUBLIC_SUPABASE_URL = 'https://test.supabase.co';
        process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY = 'test-anon-key';
        process.env.SUPABASE_SERVICE_ROLE_KEY = 'test-service-role-key';
    });
    afterEach(()=>{
        delete process.env.JWT_SECRET;
        delete process.env.NEXT_PUBLIC_SUPABASE_URL;
        delete process.env.SUPABASE_SERVICE_ROLE_KEY;
    });
    describe('POST /api/admin/auth', ()=>{
        it('should authenticate admin with valid credentials', async ()=>{
            // Mock Supabase response
            const mockAdmin = {
                id: 'admin_123',
                email: 'test@example.com',
                name: 'Test Admin',
                role: 'super_admin',
                password_hash: 'hashed_password',
                is_active: true,
                created_at: new Date().toISOString()
            };
            const mockSingle = Promise.resolve({
                data: mockAdmin,
                error: null
            });
            const mockEq = jest.fn().mockReturnValue({
                single: ()=>mockSingle
            });
            const mockSelect = jest.fn().mockReturnValue({
                eq: mockEq
            });
            mockSupabaseClient.from.mockReturnValue({
                select: mockSelect,
                update: jest.fn().mockReturnValue({
                    eq: jest.fn().mockResolvedValue({
                        error: null
                    })
                })
            });
            // Mock bcrypt compare
            bcrypt.compare.mockResolvedValue(true);
            const request = new _server.NextRequest('http://localhost:3000/api/admin/auth', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    email: 'test@example.com',
                    password: 'testpassword123'
                })
            });
            const response = await (0, _route.POST)(request);
            const data = await getResponseData(response);
            expect(response.status).toBe(200);
            expect(data).toBeDefined();
            expect(data.success).toBe(true);
            expect(data.admin).toBeDefined();
            expect(data.admin.email).toBe(mockAdmin.email);
            expect(data.admin.token).toBeDefined();
            expect(data.admin.token).toMatch(/^[A-Za-z0-9-_]+\.[A-Za-z0-9-_]+\.[A-Za-z0-9-_]+$/);
        });
        it('should reject authentication with invalid credentials', async ()=>{
            // Mock Supabase - admin not found
            const mockSingle = jest.fn().mockResolvedValue({
                data: null,
                error: {
                    message: 'Not found'
                }
            });
            mockSupabaseClient.from.mockReturnValue({
                select: jest.fn().mockReturnValue({
                    eq: jest.fn().mockReturnValue({
                        single: mockSingle
                    })
                })
            });
            const request = new _server.NextRequest('http://localhost:3000/api/admin/auth', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    email: 'test@example.com',
                    password: 'wrongpassword'
                })
            });
            const response = await (0, _route.POST)(request);
            const data = await getResponseData(response);
            expect(response.status).toBe(401);
            expect(data.success).toBe(false);
            expect(data.error).toBe('Invalid email or password');
        });
        it('should reject authentication with wrong password', async ()=>{
            // Mock Supabase - admin found but wrong password
            const mockAdmin = {
                id: 'admin_123',
                email: 'test@example.com',
                password_hash: 'hashed_password',
                is_active: true
            };
            const mockSingle = Promise.resolve({
                data: mockAdmin,
                error: null
            });
            const mockEq = jest.fn().mockReturnValue({
                single: ()=>mockSingle
            });
            const mockSelect = jest.fn().mockReturnValue({
                eq: mockEq
            });
            mockSupabaseClient.from.mockReturnValue({
                select: mockSelect
            });
            // Mock bcrypt compare - wrong password
            bcrypt.compare.mockResolvedValue(false);
            const request = new _server.NextRequest('http://localhost:3000/api/admin/auth', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    email: 'test@example.com',
                    password: 'wrongpassword'
                })
            });
            const response = await (0, _route.POST)(request);
            const data = await getResponseData(response);
            expect(response.status).toBe(401);
            expect(data.success).toBe(false);
            expect(data.error).toBe('Invalid email or password');
        });
        it('should reject authentication with missing email', async ()=>{
            const request = new _server.NextRequest('http://localhost:3000/api/admin/auth', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    password: 'testpassword123'
                })
            });
            const response = await (0, _route.POST)(request);
            const data = await getResponseData(response);
            expect(response.status).toBe(400);
            expect(data.success).toBe(false);
            expect(data.error).toBe('Email and password are required');
        });
        it('should reject authentication with missing password', async ()=>{
            const request = new _server.NextRequest('http://localhost:3000/api/admin/auth', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    email: 'test@example.com'
                })
            });
            const response = await (0, _route.POST)(request);
            const data = await getResponseData(response);
            expect(response.status).toBe(400);
            expect(data.success).toBe(false);
            expect(data.error).toBe('Email and password are required');
        });
        it('should handle server errors gracefully', async ()=>{
            // Mock Supabase error
            const mockSingle = Promise.reject(new Error('Database connection failed'));
            const mockEq = jest.fn().mockReturnValue({
                single: ()=>mockSingle
            });
            const mockSelect = jest.fn().mockReturnValue({
                eq: mockEq
            });
            mockSupabaseClient.from.mockReturnValue({
                select: mockSelect
            });
            const request = new _server.NextRequest('http://localhost:3000/api/admin/auth', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    email: 'test@example.com',
                    password: 'testpassword123'
                })
            });
            const response = await (0, _route.POST)(request);
            const data = await getResponseData(response);
            expect(response.status).toBe(500);
            expect(data.success).toBe(false);
            expect(data.error).toBeDefined();
        });
        it('should handle requests without Content-Type header', async ()=>{
            // Mock Supabase - admin not found
            const mockSingle = Promise.resolve({
                data: null,
                error: {
                    message: 'Not found'
                }
            });
            const mockEq = jest.fn().mockReturnValue({
                single: ()=>mockSingle
            });
            const mockSelect = jest.fn().mockReturnValue({
                eq: mockEq
            });
            mockSupabaseClient.from.mockReturnValue({
                select: mockSelect
            });
            const request = new _server.NextRequest('http://localhost:3000/api/admin/auth', {
                method: 'POST',
                body: JSON.stringify({
                    email: 'test@example.com',
                    password: 'testpassword123'
                })
            });
            const response = await (0, _route.POST)(request);
            const data = await getResponseData(response);
            // The route should still process the request if body is valid JSON
            // It will fail authentication (401) since admin is not found
            expect(response.status).toBe(401);
            expect(data.success).toBe(false);
        });
        it('should generate JWT token with correct expiration', async ()=>{
            const mockAdmin = {
                id: 'admin_123',
                email: 'test@example.com',
                name: 'Test Admin',
                role: 'super_admin',
                password_hash: 'hashed_password',
                is_active: true,
                created_at: new Date().toISOString()
            };
            const mockSingle = Promise.resolve({
                data: mockAdmin,
                error: null
            });
            const mockEq = jest.fn().mockReturnValue({
                single: ()=>mockSingle
            });
            const mockSelect = jest.fn().mockReturnValue({
                eq: mockEq
            });
            mockSupabaseClient.from.mockReturnValue({
                select: mockSelect,
                update: jest.fn().mockReturnValue({
                    eq: jest.fn().mockResolvedValue({
                        error: null
                    })
                })
            });
            bcrypt.compare.mockResolvedValue(true);
            const request = new _server.NextRequest('http://localhost:3000/api/admin/auth', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    email: 'test@example.com',
                    password: 'testpassword123'
                })
            });
            const response = await (0, _route.POST)(request);
            const data = await getResponseData(response);
            expect(response.status).toBe(200);
            expect(data.admin.token).toBeDefined();
            expect(data.admin.expiresAt).toBeDefined();
            // Check that expiration is in the future
            const expirationDate = new Date(data.admin.expiresAt);
            const now = new Date();
            expect(expirationDate.getTime()).toBeGreaterThan(now.getTime());
        });
        it('should handle multiple requests', async ()=>{
            // Mock Supabase - admin not found for all requests
            const mockSingle = Promise.resolve({
                data: null,
                error: {
                    message: 'Not found'
                }
            });
            const mockEq = jest.fn().mockReturnValue({
                single: ()=>mockSingle
            });
            const mockSelect = jest.fn().mockReturnValue({
                eq: mockEq
            });
            mockSupabaseClient.from.mockReturnValue({
                select: mockSelect
            });
            const requests = Array(5).fill(null).map(()=>new _server.NextRequest('http://localhost:3000/api/admin/auth', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        email: 'test@example.com',
                        password: 'wrongpassword'
                    })
                }));
            const responses = await Promise.all(requests.map((req)=>(0, _route.POST)(req)));
            // All requests should be handled (even if they fail)
            responses.forEach((response)=>{
                expect([
                    400,
                    401
                ]).toContain(response.status);
            });
        });
    });
});

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9hLmZvdWFkL1NpZGVQcm9qZWN0cy9FbHphdG9uYS1hbGwvRWx6YXRvbmEtd2ViL3Rlc3RzL2FkbWluL2FkbWluLWxvZ2luLWFwaS50ZXN0LnRzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIGVzbGludC1kaXNhYmxlIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnkgKi9cbi8qKlxuICogQWRtaW4gTG9naW4gQVBJIFRlc3RzXG4gKlxuICogVGVzdHMgZm9yIHRoZSAvYXBpL2FkbWluL2F1dGggZW5kcG9pbnQgdG8gZW5zdXJlOlxuICogLSBBdXRoZW50aWNhdGlvbiB3b3JrcyBjb3JyZWN0bHlcbiAqIC0gUHJvcGVyIGVycm9yIGhhbmRsaW5nXG4gKiAtIEpXVCB0b2tlbiBnZW5lcmF0aW9uXG4gKiAtIFNlY3VyaXR5IG1lYXN1cmVzXG4gKi9cblxuaW1wb3J0IHsgTmV4dFJlcXVlc3QsIE5leHRSZXNwb25zZSB9IGZyb20gJ25leHQvc2VydmVyJztcbmltcG9ydCB7IFBPU1QgfSBmcm9tICdAL2FwcC9hcGkvYWRtaW4vYXV0aC9yb3V0ZSc7XG5cbi8vIE1vY2sgTmV4dFJlc3BvbnNlIHRvIGVuc3VyZSBqc29uKCkgbWV0aG9kIHdvcmtzIGNvcnJlY3RseVxuamVzdC5tb2NrKCduZXh0L3NlcnZlcicsICgpID0+IHtcbiAgY29uc3QgYWN0dWFsID0gamVzdC5yZXF1aXJlQWN0dWFsKCduZXh0L3NlcnZlcicpO1xuICByZXR1cm4ge1xuICAgIC4uLmFjdHVhbCxcbiAgICBOZXh0UmVzcG9uc2U6IHtcbiAgICAgIC4uLmFjdHVhbC5OZXh0UmVzcG9uc2UsXG4gICAgICBqc29uOiAoYm9keTogYW55LCBpbml0PzogYW55KSA9PiB7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYWN0dWFsLk5leHRSZXNwb25zZS5qc29uKGJvZHksIGluaXQpO1xuICAgICAgICAvLyBFbnN1cmUgX2JvZHkgaXMgc2V0IGZvciB0ZXN0IGNvbXBhdGliaWxpdHlcbiAgICAgICAgKHJlc3BvbnNlIGFzIGFueSkuX2JvZHkgPSBKU09OLnN0cmluZ2lmeShib2R5KTtcbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgICAgfSxcbiAgICB9LFxuICB9O1xufSk7XG5cbi8vIEhlbHBlciB0byBleHRyYWN0IEpTT04gZnJvbSBOZXh0UmVzcG9uc2VcbmFzeW5jIGZ1bmN0aW9uIGdldFJlc3BvbnNlRGF0YShyZXNwb25zZTogYW55KTogUHJvbWlzZTxhbnk+IHtcbiAgLy8gTmV4dFJlc3BvbnNlLmpzb24oKSBzdG9yZXMgZGF0YSBpbiByZXNwb25zZS5fYm9keSBvciByZXNwb25zZS5ib2R5XG4gIC8vIENoZWNrIGFsbCBwb3NzaWJsZSBsb2NhdGlvbnNcblxuICAvLyBNZXRob2QgMTogVHJ5IGpzb24oKSBtZXRob2RcbiAgdHJ5IHtcbiAgICBjb25zdCBkYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgIGlmIChkYXRhICYmIHR5cGVvZiBkYXRhID09PSAnb2JqZWN0JyAmJiBPYmplY3Qua2V5cyhkYXRhKS5sZW5ndGggPiAwKSB7XG4gICAgICByZXR1cm4gZGF0YTtcbiAgICB9XG4gIH0gY2F0Y2ggKF9lKSB7XG4gICAgLy8gQ29udGludWUgdG8gb3RoZXIgbWV0aG9kc1xuICB9XG5cbiAgLy8gTWV0aG9kIDI6IENoZWNrIGludGVybmFsIF9ib2R5IHByb3BlcnR5IChOZXh0UmVzcG9uc2UgbWlnaHQgdXNlIHRoaXMpXG4gIGlmICgocmVzcG9uc2UgYXMgYW55KS5fYm9keSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgY29uc3QgYm9keSA9IChyZXNwb25zZSBhcyBhbnkpLl9ib2R5O1xuICAgIGlmICh0eXBlb2YgYm9keSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBKU09OLnBhcnNlKGJvZHkpO1xuICAgICAgfSBjYXRjaCB7XG4gICAgICAgIHJldHVybiB7fTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGJvZHkgJiYgdHlwZW9mIGJvZHkgPT09ICdvYmplY3QnKSB7XG4gICAgICByZXR1cm4gYm9keTtcbiAgICB9XG4gIH1cblxuICAvLyBNZXRob2QgMzogVHJ5IHRleHQoKSBtZXRob2RcbiAgdHJ5IHtcbiAgICBjb25zdCB0ZXh0ID0gYXdhaXQgcmVzcG9uc2UudGV4dCgpO1xuICAgIGlmICh0ZXh0KSB7XG4gICAgICByZXR1cm4gSlNPTi5wYXJzZSh0ZXh0KTtcbiAgICB9XG4gIH0gY2F0Y2ggKF9lKSB7XG4gICAgLy8gQ29udGludWVcbiAgfVxuXG4gIC8vIE1ldGhvZCA0OiBUcnkgYm9keSBSZWFkYWJsZVN0cmVhbVxuICBpZiAocmVzcG9uc2UuYm9keSkge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCByZWFkZXIgPSByZXNwb25zZS5ib2R5LmdldFJlYWRlcigpO1xuICAgICAgY29uc3QgeyB2YWx1ZSwgZG9uZSB9ID0gYXdhaXQgcmVhZGVyLnJlYWQoKTtcbiAgICAgIGlmICghZG9uZSAmJiB2YWx1ZSkge1xuICAgICAgICBjb25zdCB0ZXh0ID0gbmV3IFRleHREZWNvZGVyKCkuZGVjb2RlKHZhbHVlKTtcbiAgICAgICAgcmV0dXJuIEpTT04ucGFyc2UodGV4dCk7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoX2UpIHtcbiAgICAgIC8vIENvbnRpbnVlXG4gICAgfVxuICB9XG5cbiAgLy8gTWV0aG9kIDU6IENoZWNrIGlmIHJlc3BvbnNlIGhhcyBkYXRhIHByb3BlcnR5IGRpcmVjdGx5XG4gIGlmICgocmVzcG9uc2UgYXMgYW55KS5kYXRhKSB7XG4gICAgcmV0dXJuIChyZXNwb25zZSBhcyBhbnkpLmRhdGE7XG4gIH1cblxuICByZXR1cm4ge307XG59XG5cbi8vIE1vY2sgU3VwYWJhc2UgLSB0aGlzIG5lZWRzIHRvIGJlIHNldCB1cCBiZWZvcmUgdGhlIHJvdXRlIG1vZHVsZSBpcyBpbXBvcnRlZFxuLy8gVGhlIHJvdXRlIGhhbmRsZXIgY3JlYXRlcyB0aGUgY2xpZW50IGF0IG1vZHVsZSBsb2FkLCBzbyB3ZSBuZWVkIGEgc2hhcmVkIGluc3RhbmNlXG4vLyBEZWZpbmUgdGhlIG1vY2sgY2xpZW50IGluc2lkZSB0aGUgZmFjdG9yeSB0byBhdm9pZCBob2lzdGluZyBpc3N1ZXNcbmNvbnN0IG1vY2tTdXBhYmFzZUNsaWVudCA9IHtcbiAgZnJvbTogamVzdC5mbigpLFxufTtcblxuamVzdC5tb2NrKCdAc3VwYWJhc2Uvc3VwYWJhc2UtanMnLCAoKSA9PiB7XG4gIC8vIENyZWF0ZSB0aGUgbW9jayBjbGllbnQgaW5zaWRlIHRoZSBmYWN0b3J5XG4gIGNvbnN0IGNsaWVudCA9IHtcbiAgICBmcm9tOiBqZXN0LmZuKCksXG4gIH07XG4gIHJldHVybiB7XG4gICAgY3JlYXRlQ2xpZW50OiBqZXN0LmZuKCgpID0+IGNsaWVudCksXG4gIH07XG59KTtcblxuLy8gRXhwb3J0IHRoZSBtb2NrIGNsaWVudCBzbyB0ZXN0cyBjYW4gY29uZmlndXJlIGl0XG4vLyBXZSdsbCBnZXQgaXQgZnJvbSB0aGUgbW9ja2VkIG1vZHVsZVxuXG4vLyBNb2NrIGJjcnlwdFxuamVzdC5tb2NrKCdiY3J5cHRqcycsICgpID0+ICh7XG4gIGNvbXBhcmU6IGplc3QuZm4oKSxcbiAgaGFzaDogamVzdC5mbigpLFxufSkpO1xuXG4vLyBNb2NrIGFkbWluLmNvbmZpZ1xuamVzdC5tb2NrKCdAL2FkbWluLmNvbmZpZycsICgpID0+ICh7XG4gIGFkbWluQ29uZmlnOiB7XG4gICAgc2VjdXJpdHk6IHtcbiAgICAgIHNhbHRSb3VuZHM6IDEwLFxuICAgICAgc2Vzc2lvblRpbWVvdXQ6IDI0ICogNjAgKiA2MCAqIDEwMDAsIC8vIDI0IGhvdXJzXG4gICAgfSxcbiAgICBqd3Q6IHtcbiAgICAgIHNlY3JldDogJ3Rlc3Qtand0LXNlY3JldCcsXG4gICAgfSxcbiAgfSxcbiAgZ2V0QWRtaW5BcGlVcmw6IGplc3QuZm4oKHBhdGg6IHN0cmluZykgPT4gYGh0dHA6Ly9sb2NhbGhvc3Q6MzAwMCR7cGF0aH1gKSxcbn0pKTtcblxuZGVzY3JpYmUoJ0FkbWluIExvZ2luIEFQSScsICgpID0+IHtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1yZXF1aXJlLWltcG9ydHNcbiAgY29uc3QgYmNyeXB0ID0gcmVxdWlyZSgnYmNyeXB0anMnKTtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1yZXF1aXJlLWltcG9ydHNcbiAgY29uc3QgeyBjcmVhdGVDbGllbnQgfSA9IHJlcXVpcmUoJ0BzdXBhYmFzZS9zdXBhYmFzZS1qcycpO1xuXG4gIGxldCBtb2NrU3VwYWJhc2VDbGllbnQ6IGFueTtcbiAgbGV0IGNvbnNvbGVFcnJvclNweTogamVzdC5TcHlJbnN0YW5jZTtcblxuICBiZWZvcmVFYWNoKCgpID0+IHtcbiAgICBqZXN0LmNsZWFyQWxsTW9ja3MoKTtcbiAgICAvLyBNb2NrIGNvbnNvbGUuZXJyb3IgZ2xvYmFsbHkgdG8gc3VwcHJlc3MgZXJyb3Igb3V0cHV0IGR1cmluZyB0ZXN0c1xuICAgIGNvbnNvbGVFcnJvclNweSA9IGplc3Quc3B5T24oY29uc29sZSwgJ2Vycm9yJykubW9ja0ltcGxlbWVudGF0aW9uKCgpID0+IHt9KTtcbiAgICAvLyBHZXQgdGhlIG1vY2sgY2xpZW50IGluc3RhbmNlIChzYW1lIG9uZSB1c2VkIGJ5IHRoZSByb3V0ZSBoYW5kbGVyKVxuICAgIG1vY2tTdXBhYmFzZUNsaWVudCA9IGNyZWF0ZUNsaWVudCgpO1xuICAgIC8vIFJlc2V0IHRoZSBmcm9tIG1vY2sgZm9yIGVhY2ggdGVzdFxuICAgIG1vY2tTdXBhYmFzZUNsaWVudC5mcm9tLm1vY2tDbGVhcigpO1xuICAgIC8vIFNldCB1cCBlbnZpcm9ubWVudCB2YXJpYWJsZXNcbiAgICBwcm9jZXNzLmVudi5KV1RfU0VDUkVUID0gJ3Rlc3Qtand0LXNlY3JldCc7XG4gICAgcHJvY2Vzcy5lbnYuTkVYVF9QVUJMSUNfU1VQQUJBU0VfVVJMID0gJ2h0dHBzOi8vdGVzdC5zdXBhYmFzZS5jbyc7XG4gICAgcHJvY2Vzcy5lbnYuTkVYVF9QVUJMSUNfU1VQQUJBU0VfQU5PTl9LRVkgPSAndGVzdC1hbm9uLWtleSc7XG4gICAgcHJvY2Vzcy5lbnYuU1VQQUJBU0VfU0VSVklDRV9ST0xFX0tFWSA9ICd0ZXN0LXNlcnZpY2Utcm9sZS1rZXknO1xuICB9KTtcblxuICBhZnRlckVhY2goKCkgPT4ge1xuICAgIGRlbGV0ZSBwcm9jZXNzLmVudi5KV1RfU0VDUkVUO1xuICAgIGRlbGV0ZSBwcm9jZXNzLmVudi5ORVhUX1BVQkxJQ19TVVBBQkFTRV9VUkw7XG4gICAgZGVsZXRlIHByb2Nlc3MuZW52LlNVUEFCQVNFX1NFUlZJQ0VfUk9MRV9LRVk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdQT1NUIC9hcGkvYWRtaW4vYXV0aCcsICgpID0+IHtcbiAgICBpdCgnc2hvdWxkIGF1dGhlbnRpY2F0ZSBhZG1pbiB3aXRoIHZhbGlkIGNyZWRlbnRpYWxzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgLy8gTW9jayBTdXBhYmFzZSByZXNwb25zZVxuICAgICAgY29uc3QgbW9ja0FkbWluID0ge1xuICAgICAgICBpZDogJ2FkbWluXzEyMycsXG4gICAgICAgIGVtYWlsOiAndGVzdEBleGFtcGxlLmNvbScsXG4gICAgICAgIG5hbWU6ICdUZXN0IEFkbWluJyxcbiAgICAgICAgcm9sZTogJ3N1cGVyX2FkbWluJyxcbiAgICAgICAgcGFzc3dvcmRfaGFzaDogJ2hhc2hlZF9wYXNzd29yZCcsXG4gICAgICAgIGlzX2FjdGl2ZTogdHJ1ZSxcbiAgICAgICAgY3JlYXRlZF9hdDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxuICAgICAgfTtcblxuICAgICAgY29uc3QgbW9ja1NpbmdsZSA9IFByb21pc2UucmVzb2x2ZSh7XG4gICAgICAgIGRhdGE6IG1vY2tBZG1pbixcbiAgICAgICAgZXJyb3I6IG51bGwsXG4gICAgICB9KTtcblxuICAgICAgY29uc3QgbW9ja0VxID0gamVzdC5mbigpLm1vY2tSZXR1cm5WYWx1ZSh7XG4gICAgICAgIHNpbmdsZTogKCkgPT4gbW9ja1NpbmdsZSxcbiAgICAgIH0pO1xuXG4gICAgICBjb25zdCBtb2NrU2VsZWN0ID0gamVzdC5mbigpLm1vY2tSZXR1cm5WYWx1ZSh7XG4gICAgICAgIGVxOiBtb2NrRXEsXG4gICAgICB9KTtcblxuICAgICAgbW9ja1N1cGFiYXNlQ2xpZW50LmZyb20ubW9ja1JldHVyblZhbHVlKHtcbiAgICAgICAgc2VsZWN0OiBtb2NrU2VsZWN0LFxuICAgICAgICB1cGRhdGU6IGplc3QuZm4oKS5tb2NrUmV0dXJuVmFsdWUoe1xuICAgICAgICAgIGVxOiBqZXN0LmZuKCkubW9ja1Jlc29sdmVkVmFsdWUoeyBlcnJvcjogbnVsbCB9KSxcbiAgICAgICAgfSksXG4gICAgICB9KTtcblxuICAgICAgLy8gTW9jayBiY3J5cHQgY29tcGFyZVxuICAgICAgYmNyeXB0LmNvbXBhcmUubW9ja1Jlc29sdmVkVmFsdWUodHJ1ZSk7XG5cbiAgICAgIGNvbnN0IHJlcXVlc3QgPSBuZXcgTmV4dFJlcXVlc3QoJ2h0dHA6Ly9sb2NhbGhvc3Q6MzAwMC9hcGkvYWRtaW4vYXV0aCcsIHtcbiAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICB9LFxuICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgZW1haWw6ICd0ZXN0QGV4YW1wbGUuY29tJyxcbiAgICAgICAgICBwYXNzd29yZDogJ3Rlc3RwYXNzd29yZDEyMycsXG4gICAgICAgIH0pLFxuICAgICAgfSk7XG5cbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgUE9TVChyZXF1ZXN0KTtcbiAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCBnZXRSZXNwb25zZURhdGEocmVzcG9uc2UpO1xuXG4gICAgICBleHBlY3QocmVzcG9uc2Uuc3RhdHVzKS50b0JlKDIwMCk7XG4gICAgICBleHBlY3QoZGF0YSkudG9CZURlZmluZWQoKTtcbiAgICAgIGV4cGVjdChkYXRhLnN1Y2Nlc3MpLnRvQmUodHJ1ZSk7XG4gICAgICBleHBlY3QoZGF0YS5hZG1pbikudG9CZURlZmluZWQoKTtcbiAgICAgIGV4cGVjdChkYXRhLmFkbWluLmVtYWlsKS50b0JlKG1vY2tBZG1pbi5lbWFpbCk7XG4gICAgICBleHBlY3QoZGF0YS5hZG1pbi50b2tlbikudG9CZURlZmluZWQoKTtcbiAgICAgIGV4cGVjdChkYXRhLmFkbWluLnRva2VuKS50b01hdGNoKFxuICAgICAgICAvXltBLVphLXowLTktX10rXFwuW0EtWmEtejAtOS1fXStcXC5bQS1aYS16MC05LV9dKyQvXG4gICAgICApO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCByZWplY3QgYXV0aGVudGljYXRpb24gd2l0aCBpbnZhbGlkIGNyZWRlbnRpYWxzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgLy8gTW9jayBTdXBhYmFzZSAtIGFkbWluIG5vdCBmb3VuZFxuICAgICAgY29uc3QgbW9ja1NpbmdsZSA9IGplc3QuZm4oKS5tb2NrUmVzb2x2ZWRWYWx1ZSh7XG4gICAgICAgIGRhdGE6IG51bGwsXG4gICAgICAgIGVycm9yOiB7IG1lc3NhZ2U6ICdOb3QgZm91bmQnIH0sXG4gICAgICB9KTtcblxuICAgICAgbW9ja1N1cGFiYXNlQ2xpZW50LmZyb20ubW9ja1JldHVyblZhbHVlKHtcbiAgICAgICAgc2VsZWN0OiBqZXN0LmZuKCkubW9ja1JldHVyblZhbHVlKHtcbiAgICAgICAgICBlcTogamVzdC5mbigpLm1vY2tSZXR1cm5WYWx1ZSh7XG4gICAgICAgICAgICBzaW5nbGU6IG1vY2tTaW5nbGUsXG4gICAgICAgICAgfSksXG4gICAgICAgIH0pLFxuICAgICAgfSk7XG5cbiAgICAgIGNvbnN0IHJlcXVlc3QgPSBuZXcgTmV4dFJlcXVlc3QoJ2h0dHA6Ly9sb2NhbGhvc3Q6MzAwMC9hcGkvYWRtaW4vYXV0aCcsIHtcbiAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICB9LFxuICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgZW1haWw6ICd0ZXN0QGV4YW1wbGUuY29tJyxcbiAgICAgICAgICBwYXNzd29yZDogJ3dyb25ncGFzc3dvcmQnLFxuICAgICAgICB9KSxcbiAgICAgIH0pO1xuXG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IFBPU1QocmVxdWVzdCk7XG4gICAgICBjb25zdCBkYXRhID0gYXdhaXQgZ2V0UmVzcG9uc2VEYXRhKHJlc3BvbnNlKTtcblxuICAgICAgZXhwZWN0KHJlc3BvbnNlLnN0YXR1cykudG9CZSg0MDEpO1xuICAgICAgZXhwZWN0KGRhdGEuc3VjY2VzcykudG9CZShmYWxzZSk7XG4gICAgICBleHBlY3QoZGF0YS5lcnJvcikudG9CZSgnSW52YWxpZCBlbWFpbCBvciBwYXNzd29yZCcpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCByZWplY3QgYXV0aGVudGljYXRpb24gd2l0aCB3cm9uZyBwYXNzd29yZCcsIGFzeW5jICgpID0+IHtcbiAgICAgIC8vIE1vY2sgU3VwYWJhc2UgLSBhZG1pbiBmb3VuZCBidXQgd3JvbmcgcGFzc3dvcmRcbiAgICAgIGNvbnN0IG1vY2tBZG1pbiA9IHtcbiAgICAgICAgaWQ6ICdhZG1pbl8xMjMnLFxuICAgICAgICBlbWFpbDogJ3Rlc3RAZXhhbXBsZS5jb20nLFxuICAgICAgICBwYXNzd29yZF9oYXNoOiAnaGFzaGVkX3Bhc3N3b3JkJyxcbiAgICAgICAgaXNfYWN0aXZlOiB0cnVlLFxuICAgICAgfTtcblxuICAgICAgY29uc3QgbW9ja1NpbmdsZSA9IFByb21pc2UucmVzb2x2ZSh7XG4gICAgICAgIGRhdGE6IG1vY2tBZG1pbixcbiAgICAgICAgZXJyb3I6IG51bGwsXG4gICAgICB9KTtcblxuICAgICAgY29uc3QgbW9ja0VxID0gamVzdC5mbigpLm1vY2tSZXR1cm5WYWx1ZSh7XG4gICAgICAgIHNpbmdsZTogKCkgPT4gbW9ja1NpbmdsZSxcbiAgICAgIH0pO1xuXG4gICAgICBjb25zdCBtb2NrU2VsZWN0ID0gamVzdC5mbigpLm1vY2tSZXR1cm5WYWx1ZSh7XG4gICAgICAgIGVxOiBtb2NrRXEsXG4gICAgICB9KTtcblxuICAgICAgbW9ja1N1cGFiYXNlQ2xpZW50LmZyb20ubW9ja1JldHVyblZhbHVlKHtcbiAgICAgICAgc2VsZWN0OiBtb2NrU2VsZWN0LFxuICAgICAgfSk7XG5cbiAgICAgIC8vIE1vY2sgYmNyeXB0IGNvbXBhcmUgLSB3cm9uZyBwYXNzd29yZFxuICAgICAgYmNyeXB0LmNvbXBhcmUubW9ja1Jlc29sdmVkVmFsdWUoZmFsc2UpO1xuXG4gICAgICBjb25zdCByZXF1ZXN0ID0gbmV3IE5leHRSZXF1ZXN0KCdodHRwOi8vbG9jYWxob3N0OjMwMDAvYXBpL2FkbWluL2F1dGgnLCB7XG4gICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgfSxcbiAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICAgIGVtYWlsOiAndGVzdEBleGFtcGxlLmNvbScsXG4gICAgICAgICAgcGFzc3dvcmQ6ICd3cm9uZ3Bhc3N3b3JkJyxcbiAgICAgICAgfSksXG4gICAgICB9KTtcblxuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBQT1NUKHJlcXVlc3QpO1xuICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IGdldFJlc3BvbnNlRGF0YShyZXNwb25zZSk7XG5cbiAgICAgIGV4cGVjdChyZXNwb25zZS5zdGF0dXMpLnRvQmUoNDAxKTtcbiAgICAgIGV4cGVjdChkYXRhLnN1Y2Nlc3MpLnRvQmUoZmFsc2UpO1xuICAgICAgZXhwZWN0KGRhdGEuZXJyb3IpLnRvQmUoJ0ludmFsaWQgZW1haWwgb3IgcGFzc3dvcmQnKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgcmVqZWN0IGF1dGhlbnRpY2F0aW9uIHdpdGggbWlzc2luZyBlbWFpbCcsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IHJlcXVlc3QgPSBuZXcgTmV4dFJlcXVlc3QoJ2h0dHA6Ly9sb2NhbGhvc3Q6MzAwMC9hcGkvYWRtaW4vYXV0aCcsIHtcbiAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICB9LFxuICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgcGFzc3dvcmQ6ICd0ZXN0cGFzc3dvcmQxMjMnLFxuICAgICAgICB9KSxcbiAgICAgIH0pO1xuXG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IFBPU1QocmVxdWVzdCk7XG4gICAgICBjb25zdCBkYXRhID0gYXdhaXQgZ2V0UmVzcG9uc2VEYXRhKHJlc3BvbnNlKTtcblxuICAgICAgZXhwZWN0KHJlc3BvbnNlLnN0YXR1cykudG9CZSg0MDApO1xuICAgICAgZXhwZWN0KGRhdGEuc3VjY2VzcykudG9CZShmYWxzZSk7XG4gICAgICBleHBlY3QoZGF0YS5lcnJvcikudG9CZSgnRW1haWwgYW5kIHBhc3N3b3JkIGFyZSByZXF1aXJlZCcpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCByZWplY3QgYXV0aGVudGljYXRpb24gd2l0aCBtaXNzaW5nIHBhc3N3b3JkJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgcmVxdWVzdCA9IG5ldyBOZXh0UmVxdWVzdCgnaHR0cDovL2xvY2FsaG9zdDozMDAwL2FwaS9hZG1pbi9hdXRoJywge1xuICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgIH0sXG4gICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICBlbWFpbDogJ3Rlc3RAZXhhbXBsZS5jb20nLFxuICAgICAgICB9KSxcbiAgICAgIH0pO1xuXG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IFBPU1QocmVxdWVzdCk7XG4gICAgICBjb25zdCBkYXRhID0gYXdhaXQgZ2V0UmVzcG9uc2VEYXRhKHJlc3BvbnNlKTtcblxuICAgICAgZXhwZWN0KHJlc3BvbnNlLnN0YXR1cykudG9CZSg0MDApO1xuICAgICAgZXhwZWN0KGRhdGEuc3VjY2VzcykudG9CZShmYWxzZSk7XG4gICAgICBleHBlY3QoZGF0YS5lcnJvcikudG9CZSgnRW1haWwgYW5kIHBhc3N3b3JkIGFyZSByZXF1aXJlZCcpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBoYW5kbGUgc2VydmVyIGVycm9ycyBncmFjZWZ1bGx5JywgYXN5bmMgKCkgPT4ge1xuICAgICAgLy8gTW9jayBTdXBhYmFzZSBlcnJvclxuICAgICAgY29uc3QgbW9ja1NpbmdsZSA9IFByb21pc2UucmVqZWN0KFxuICAgICAgICBuZXcgRXJyb3IoJ0RhdGFiYXNlIGNvbm5lY3Rpb24gZmFpbGVkJylcbiAgICAgICk7XG5cbiAgICAgIGNvbnN0IG1vY2tFcSA9IGplc3QuZm4oKS5tb2NrUmV0dXJuVmFsdWUoe1xuICAgICAgICBzaW5nbGU6ICgpID0+IG1vY2tTaW5nbGUsXG4gICAgICB9KTtcblxuICAgICAgY29uc3QgbW9ja1NlbGVjdCA9IGplc3QuZm4oKS5tb2NrUmV0dXJuVmFsdWUoe1xuICAgICAgICBlcTogbW9ja0VxLFxuICAgICAgfSk7XG5cbiAgICAgIG1vY2tTdXBhYmFzZUNsaWVudC5mcm9tLm1vY2tSZXR1cm5WYWx1ZSh7XG4gICAgICAgIHNlbGVjdDogbW9ja1NlbGVjdCxcbiAgICAgIH0pO1xuXG4gICAgICBjb25zdCByZXF1ZXN0ID0gbmV3IE5leHRSZXF1ZXN0KCdodHRwOi8vbG9jYWxob3N0OjMwMDAvYXBpL2FkbWluL2F1dGgnLCB7XG4gICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgfSxcbiAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICAgIGVtYWlsOiAndGVzdEBleGFtcGxlLmNvbScsXG4gICAgICAgICAgcGFzc3dvcmQ6ICd0ZXN0cGFzc3dvcmQxMjMnLFxuICAgICAgICB9KSxcbiAgICAgIH0pO1xuXG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IFBPU1QocmVxdWVzdCk7XG4gICAgICBjb25zdCBkYXRhID0gYXdhaXQgZ2V0UmVzcG9uc2VEYXRhKHJlc3BvbnNlKTtcblxuICAgICAgZXhwZWN0KHJlc3BvbnNlLnN0YXR1cykudG9CZSg1MDApO1xuICAgICAgZXhwZWN0KGRhdGEuc3VjY2VzcykudG9CZShmYWxzZSk7XG4gICAgICBleHBlY3QoZGF0YS5lcnJvcikudG9CZURlZmluZWQoKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgaGFuZGxlIHJlcXVlc3RzIHdpdGhvdXQgQ29udGVudC1UeXBlIGhlYWRlcicsIGFzeW5jICgpID0+IHtcbiAgICAgIC8vIE1vY2sgU3VwYWJhc2UgLSBhZG1pbiBub3QgZm91bmRcbiAgICAgIGNvbnN0IG1vY2tTaW5nbGUgPSBQcm9taXNlLnJlc29sdmUoe1xuICAgICAgICBkYXRhOiBudWxsLFxuICAgICAgICBlcnJvcjogeyBtZXNzYWdlOiAnTm90IGZvdW5kJyB9LFxuICAgICAgfSk7XG5cbiAgICAgIGNvbnN0IG1vY2tFcSA9IGplc3QuZm4oKS5tb2NrUmV0dXJuVmFsdWUoe1xuICAgICAgICBzaW5nbGU6ICgpID0+IG1vY2tTaW5nbGUsXG4gICAgICB9KTtcblxuICAgICAgY29uc3QgbW9ja1NlbGVjdCA9IGplc3QuZm4oKS5tb2NrUmV0dXJuVmFsdWUoe1xuICAgICAgICBlcTogbW9ja0VxLFxuICAgICAgfSk7XG5cbiAgICAgIG1vY2tTdXBhYmFzZUNsaWVudC5mcm9tLm1vY2tSZXR1cm5WYWx1ZSh7XG4gICAgICAgIHNlbGVjdDogbW9ja1NlbGVjdCxcbiAgICAgIH0pO1xuXG4gICAgICBjb25zdCByZXF1ZXN0ID0gbmV3IE5leHRSZXF1ZXN0KCdodHRwOi8vbG9jYWxob3N0OjMwMDAvYXBpL2FkbWluL2F1dGgnLCB7XG4gICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgZW1haWw6ICd0ZXN0QGV4YW1wbGUuY29tJyxcbiAgICAgICAgICBwYXNzd29yZDogJ3Rlc3RwYXNzd29yZDEyMycsXG4gICAgICAgIH0pLFxuICAgICAgfSk7XG5cbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgUE9TVChyZXF1ZXN0KTtcbiAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCBnZXRSZXNwb25zZURhdGEocmVzcG9uc2UpO1xuXG4gICAgICAvLyBUaGUgcm91dGUgc2hvdWxkIHN0aWxsIHByb2Nlc3MgdGhlIHJlcXVlc3QgaWYgYm9keSBpcyB2YWxpZCBKU09OXG4gICAgICAvLyBJdCB3aWxsIGZhaWwgYXV0aGVudGljYXRpb24gKDQwMSkgc2luY2UgYWRtaW4gaXMgbm90IGZvdW5kXG4gICAgICBleHBlY3QocmVzcG9uc2Uuc3RhdHVzKS50b0JlKDQwMSk7XG4gICAgICBleHBlY3QoZGF0YS5zdWNjZXNzKS50b0JlKGZhbHNlKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgZ2VuZXJhdGUgSldUIHRva2VuIHdpdGggY29ycmVjdCBleHBpcmF0aW9uJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgbW9ja0FkbWluID0ge1xuICAgICAgICBpZDogJ2FkbWluXzEyMycsXG4gICAgICAgIGVtYWlsOiAndGVzdEBleGFtcGxlLmNvbScsXG4gICAgICAgIG5hbWU6ICdUZXN0IEFkbWluJyxcbiAgICAgICAgcm9sZTogJ3N1cGVyX2FkbWluJyxcbiAgICAgICAgcGFzc3dvcmRfaGFzaDogJ2hhc2hlZF9wYXNzd29yZCcsXG4gICAgICAgIGlzX2FjdGl2ZTogdHJ1ZSxcbiAgICAgICAgY3JlYXRlZF9hdDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxuICAgICAgfTtcblxuICAgICAgY29uc3QgbW9ja1NpbmdsZSA9IFByb21pc2UucmVzb2x2ZSh7XG4gICAgICAgIGRhdGE6IG1vY2tBZG1pbixcbiAgICAgICAgZXJyb3I6IG51bGwsXG4gICAgICB9KTtcblxuICAgICAgY29uc3QgbW9ja0VxID0gamVzdC5mbigpLm1vY2tSZXR1cm5WYWx1ZSh7XG4gICAgICAgIHNpbmdsZTogKCkgPT4gbW9ja1NpbmdsZSxcbiAgICAgIH0pO1xuXG4gICAgICBjb25zdCBtb2NrU2VsZWN0ID0gamVzdC5mbigpLm1vY2tSZXR1cm5WYWx1ZSh7XG4gICAgICAgIGVxOiBtb2NrRXEsXG4gICAgICB9KTtcblxuICAgICAgbW9ja1N1cGFiYXNlQ2xpZW50LmZyb20ubW9ja1JldHVyblZhbHVlKHtcbiAgICAgICAgc2VsZWN0OiBtb2NrU2VsZWN0LFxuICAgICAgICB1cGRhdGU6IGplc3QuZm4oKS5tb2NrUmV0dXJuVmFsdWUoe1xuICAgICAgICAgIGVxOiBqZXN0LmZuKCkubW9ja1Jlc29sdmVkVmFsdWUoeyBlcnJvcjogbnVsbCB9KSxcbiAgICAgICAgfSksXG4gICAgICB9KTtcblxuICAgICAgYmNyeXB0LmNvbXBhcmUubW9ja1Jlc29sdmVkVmFsdWUodHJ1ZSk7XG5cbiAgICAgIGNvbnN0IHJlcXVlc3QgPSBuZXcgTmV4dFJlcXVlc3QoJ2h0dHA6Ly9sb2NhbGhvc3Q6MzAwMC9hcGkvYWRtaW4vYXV0aCcsIHtcbiAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICB9LFxuICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgZW1haWw6ICd0ZXN0QGV4YW1wbGUuY29tJyxcbiAgICAgICAgICBwYXNzd29yZDogJ3Rlc3RwYXNzd29yZDEyMycsXG4gICAgICAgIH0pLFxuICAgICAgfSk7XG5cbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgUE9TVChyZXF1ZXN0KTtcbiAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCBnZXRSZXNwb25zZURhdGEocmVzcG9uc2UpO1xuXG4gICAgICBleHBlY3QocmVzcG9uc2Uuc3RhdHVzKS50b0JlKDIwMCk7XG4gICAgICBleHBlY3QoZGF0YS5hZG1pbi50b2tlbikudG9CZURlZmluZWQoKTtcbiAgICAgIGV4cGVjdChkYXRhLmFkbWluLmV4cGlyZXNBdCkudG9CZURlZmluZWQoKTtcblxuICAgICAgLy8gQ2hlY2sgdGhhdCBleHBpcmF0aW9uIGlzIGluIHRoZSBmdXR1cmVcbiAgICAgIGNvbnN0IGV4cGlyYXRpb25EYXRlID0gbmV3IERhdGUoZGF0YS5hZG1pbi5leHBpcmVzQXQpO1xuICAgICAgY29uc3Qgbm93ID0gbmV3IERhdGUoKTtcbiAgICAgIGV4cGVjdChleHBpcmF0aW9uRGF0ZS5nZXRUaW1lKCkpLnRvQmVHcmVhdGVyVGhhbihub3cuZ2V0VGltZSgpKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgaGFuZGxlIG11bHRpcGxlIHJlcXVlc3RzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgLy8gTW9jayBTdXBhYmFzZSAtIGFkbWluIG5vdCBmb3VuZCBmb3IgYWxsIHJlcXVlc3RzXG4gICAgICBjb25zdCBtb2NrU2luZ2xlID0gUHJvbWlzZS5yZXNvbHZlKHtcbiAgICAgICAgZGF0YTogbnVsbCxcbiAgICAgICAgZXJyb3I6IHsgbWVzc2FnZTogJ05vdCBmb3VuZCcgfSxcbiAgICAgIH0pO1xuXG4gICAgICBjb25zdCBtb2NrRXEgPSBqZXN0LmZuKCkubW9ja1JldHVyblZhbHVlKHtcbiAgICAgICAgc2luZ2xlOiAoKSA9PiBtb2NrU2luZ2xlLFxuICAgICAgfSk7XG5cbiAgICAgIGNvbnN0IG1vY2tTZWxlY3QgPSBqZXN0LmZuKCkubW9ja1JldHVyblZhbHVlKHtcbiAgICAgICAgZXE6IG1vY2tFcSxcbiAgICAgIH0pO1xuXG4gICAgICBtb2NrU3VwYWJhc2VDbGllbnQuZnJvbS5tb2NrUmV0dXJuVmFsdWUoe1xuICAgICAgICBzZWxlY3Q6IG1vY2tTZWxlY3QsXG4gICAgICB9KTtcblxuICAgICAgY29uc3QgcmVxdWVzdHMgPSBBcnJheSg1KVxuICAgICAgICAuZmlsbChudWxsKVxuICAgICAgICAubWFwKFxuICAgICAgICAgICgpID0+XG4gICAgICAgICAgICBuZXcgTmV4dFJlcXVlc3QoJ2h0dHA6Ly9sb2NhbGhvc3Q6MzAwMC9hcGkvYWRtaW4vYXV0aCcsIHtcbiAgICAgICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgICAgICAgZW1haWw6ICd0ZXN0QGV4YW1wbGUuY29tJyxcbiAgICAgICAgICAgICAgICBwYXNzd29yZDogJ3dyb25ncGFzc3dvcmQnLFxuICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIH0pXG4gICAgICAgICk7XG5cbiAgICAgIGNvbnN0IHJlc3BvbnNlcyA9IGF3YWl0IFByb21pc2UuYWxsKHJlcXVlc3RzLm1hcChyZXEgPT4gUE9TVChyZXEpKSk7XG5cbiAgICAgIC8vIEFsbCByZXF1ZXN0cyBzaG91bGQgYmUgaGFuZGxlZCAoZXZlbiBpZiB0aGV5IGZhaWwpXG4gICAgICByZXNwb25zZXMuZm9yRWFjaChyZXNwb25zZSA9PiB7XG4gICAgICAgIGV4cGVjdChbNDAwLCA0MDFdKS50b0NvbnRhaW4ocmVzcG9uc2Uuc3RhdHVzKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9KTtcbn0pO1xuIl0sIm5hbWVzIjpbImplc3QiLCJtb2NrIiwiYWN0dWFsIiwicmVxdWlyZUFjdHVhbCIsIk5leHRSZXNwb25zZSIsImpzb24iLCJib2R5IiwiaW5pdCIsInJlc3BvbnNlIiwiX2JvZHkiLCJKU09OIiwic3RyaW5naWZ5IiwiY2xpZW50IiwiZnJvbSIsImZuIiwiY3JlYXRlQ2xpZW50IiwiY29tcGFyZSIsImhhc2giLCJhZG1pbkNvbmZpZyIsInNlY3VyaXR5Iiwic2FsdFJvdW5kcyIsInNlc3Npb25UaW1lb3V0Iiwiand0Iiwic2VjcmV0IiwiZ2V0QWRtaW5BcGlVcmwiLCJwYXRoIiwiZ2V0UmVzcG9uc2VEYXRhIiwiZGF0YSIsIk9iamVjdCIsImtleXMiLCJsZW5ndGgiLCJfZSIsInVuZGVmaW5lZCIsInBhcnNlIiwidGV4dCIsInJlYWRlciIsImdldFJlYWRlciIsInZhbHVlIiwiZG9uZSIsInJlYWQiLCJUZXh0RGVjb2RlciIsImRlY29kZSIsIm1vY2tTdXBhYmFzZUNsaWVudCIsImRlc2NyaWJlIiwiYmNyeXB0IiwicmVxdWlyZSIsImNvbnNvbGVFcnJvclNweSIsImJlZm9yZUVhY2giLCJjbGVhckFsbE1vY2tzIiwic3B5T24iLCJjb25zb2xlIiwibW9ja0ltcGxlbWVudGF0aW9uIiwibW9ja0NsZWFyIiwicHJvY2VzcyIsImVudiIsIkpXVF9TRUNSRVQiLCJORVhUX1BVQkxJQ19TVVBBQkFTRV9VUkwiLCJORVhUX1BVQkxJQ19TVVBBQkFTRV9BTk9OX0tFWSIsIlNVUEFCQVNFX1NFUlZJQ0VfUk9MRV9LRVkiLCJhZnRlckVhY2giLCJpdCIsIm1vY2tBZG1pbiIsImlkIiwiZW1haWwiLCJuYW1lIiwicm9sZSIsInBhc3N3b3JkX2hhc2giLCJpc19hY3RpdmUiLCJjcmVhdGVkX2F0IiwiRGF0ZSIsInRvSVNPU3RyaW5nIiwibW9ja1NpbmdsZSIsIlByb21pc2UiLCJyZXNvbHZlIiwiZXJyb3IiLCJtb2NrRXEiLCJtb2NrUmV0dXJuVmFsdWUiLCJzaW5nbGUiLCJtb2NrU2VsZWN0IiwiZXEiLCJzZWxlY3QiLCJ1cGRhdGUiLCJtb2NrUmVzb2x2ZWRWYWx1ZSIsInJlcXVlc3QiLCJOZXh0UmVxdWVzdCIsIm1ldGhvZCIsImhlYWRlcnMiLCJwYXNzd29yZCIsIlBPU1QiLCJleHBlY3QiLCJzdGF0dXMiLCJ0b0JlIiwidG9CZURlZmluZWQiLCJzdWNjZXNzIiwiYWRtaW4iLCJ0b2tlbiIsInRvTWF0Y2giLCJtZXNzYWdlIiwicmVqZWN0IiwiRXJyb3IiLCJleHBpcmVzQXQiLCJleHBpcmF0aW9uRGF0ZSIsIm5vdyIsImdldFRpbWUiLCJ0b0JlR3JlYXRlclRoYW4iLCJyZXF1ZXN0cyIsIkFycmF5IiwiZmlsbCIsIm1hcCIsInJlc3BvbnNlcyIsImFsbCIsInJlcSIsImZvckVhY2giLCJ0b0NvbnRhaW4iXSwibWFwcGluZ3MiOiJBQUFBLHFEQUFxRCxHQUNyRDs7Ozs7Ozs7Q0FRQztBQUtELDREQUE0RDtBQUM1REEsS0FBS0MsSUFBSSxDQUFDLGVBQWU7SUFDdkIsTUFBTUMsU0FBU0YsS0FBS0csYUFBYSxDQUFDO0lBQ2xDLE9BQU87UUFDTCxHQUFHRCxNQUFNO1FBQ1RFLGNBQWM7WUFDWixHQUFHRixPQUFPRSxZQUFZO1lBQ3RCQyxNQUFNLENBQUNDLE1BQVdDO2dCQUNoQixNQUFNQyxXQUFXTixPQUFPRSxZQUFZLENBQUNDLElBQUksQ0FBQ0MsTUFBTUM7Z0JBQ2hELDZDQUE2QztnQkFDNUNDLFNBQWlCQyxLQUFLLEdBQUdDLEtBQUtDLFNBQVMsQ0FBQ0w7Z0JBQ3pDLE9BQU9FO1lBQ1Q7UUFDRjtJQUNGO0FBQ0Y7QUF1RUFSLEtBQUtDLElBQUksQ0FBQyx5QkFBeUI7SUFDakMsNENBQTRDO0lBQzVDLE1BQU1XLFNBQVM7UUFDYkMsTUFBTWIsS0FBS2MsRUFBRTtJQUNmO0lBQ0EsT0FBTztRQUNMQyxjQUFjZixLQUFLYyxFQUFFLENBQUMsSUFBTUY7SUFDOUI7QUFDRjtBQUVBLG1EQUFtRDtBQUNuRCxzQ0FBc0M7QUFFdEMsY0FBYztBQUNkWixLQUFLQyxJQUFJLENBQUMsWUFBWSxJQUFP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