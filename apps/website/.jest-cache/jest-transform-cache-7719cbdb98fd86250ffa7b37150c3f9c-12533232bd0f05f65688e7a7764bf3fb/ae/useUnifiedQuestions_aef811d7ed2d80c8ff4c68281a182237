6b4a9bb53d96b6836b12f6a798371934
// v1.0 - Unified Questions Hook
// React hook for managing questions from the unified Firebase system
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "useUnifiedQuestions", {
    enumerable: true,
    get: function() {
        return useUnifiedQuestions;
    }
});
const _react = require("react");
function useUnifiedQuestions(options = {}) {
    const { autoLoad = true, initialFilters } = options;
    // State
    const [questions, setQuestions] = (0, _react.useState)([]);
    const [currentQuestion, setCurrentQuestion] = (0, _react.useState)(null);
    const [learningPaths, setLearningPaths] = (0, _react.useState)([]);
    const [stats, setStats] = (0, _react.useState)(null);
    // Loading states
    const [isLoading, setIsLoading] = (0, _react.useState)(false);
    const [isCreating, setIsCreating] = (0, _react.useState)(false);
    const [isUpdating, setIsUpdating] = (0, _react.useState)(false);
    const [isDeleting, setIsDeleting] = (0, _react.useState)(false);
    // Error state
    const [error, setError] = (0, _react.useState)(null);
    // Pagination state
    const [currentPage, setCurrentPage] = (0, _react.useState)(1);
    const [pageSize, setPageSize] = (0, _react.useState)(10);
    const [totalCount, setTotalCount] = (0, _react.useState)(0);
    const [totalPages, setTotalPages] = (0, _react.useState)(0);
    const [hasNext, setHasNext] = (0, _react.useState)(false);
    const [hasPrev, setHasPrev] = (0, _react.useState)(false);
    // API calls
    const apiCall = (0, _react.useCallback)(async (url, options = {})=>{
        try {
            const response = await fetch(url, {
                headers: {
                    'Content-Type': 'application/json',
                    ...options.headers
                },
                ...options
            });
            if (!response.ok) {
                const errorData = await response.json().catch(()=>({
                        error: 'Unknown error'
                    }));
                throw new Error(errorData.error || `HTTP ${response.status}`);
            }
            return response.json();
        } catch (err) {
            // Handle Firebase "Target ID already exists" errors gracefully
            if (err instanceof Error && err.message.includes('Target ID already exists')) {
                console.warn('Firebase listener conflict, retrying in 500ms...', err.message);
                // Wait a bit and retry once
                await new Promise((resolve)=>setTimeout(resolve, 500));
                const response = await fetch(url, {
                    headers: {
                        'Content-Type': 'application/json',
                        ...options.headers
                    },
                    ...options
                });
                if (!response.ok) {
                    const errorData = await response.json().catch(()=>({
                            error: 'Unknown error'
                        }));
                    throw new Error(errorData.error || `HTTP ${response.status}`);
                }
                return response.json();
            }
            throw err;
        }
    }, []);
    // Load questions
    const loadQuestions = (0, _react.useCallback)(async (filters, page = currentPage)=>{
        console.log('ðŸ”„ useUnifiedQuestions: loadQuestions called with filters:', filters, 'page:', page);
        setIsLoading(true);
        setError(null);
        try {
            const queryParams = new URLSearchParams();
            // Add pagination parameters
            queryParams.append('page', String(page));
            queryParams.append('pageSize', String(pageSize));
            queryParams.append('includePagination', 'true');
            if (filters) {
                Object.entries(filters).forEach(([key, value])=>{
                    if (value !== undefined && value !== null) {
                        queryParams.append(key, String(value));
                    }
                });
            }
            const url = `/api/questions/unified${queryParams.toString() ? `?${queryParams.toString()}` : ''}`;
            console.log('ðŸ”„ useUnifiedQuestions: Making API call to:', url);
            const response = await apiCall(url);
            console.log('ðŸ”„ useUnifiedQuestions: API response received:', response);
            if (response.success) {
                console.log('âœ… useUnifiedQuestions: Questions loaded successfully:', response.data);
                console.log('âœ… useUnifiedQuestions: Setting questions with data length:', response.data?.length);
                setQuestions(response.data);
                // Update pagination state
                if (response.pagination) {
                    setCurrentPage(response.pagination.page);
                    setTotalCount(response.pagination.totalCount);
                    setTotalPages(response.pagination.totalPages);
                    setHasNext(response.pagination.hasNext);
                    setHasPrev(response.pagination.hasPrev);
                    console.log('ðŸ“„ Pagination updated:', response.pagination);
                }
            } else {
                console.error('âŒ useUnifiedQuestions: Failed to load questions:', response.error);
                throw new Error(response.error || 'Failed to load questions');
            }
        } catch (err) {
            const errorMessage = err instanceof Error ? err.message : 'Failed to load questions';
            setError(errorMessage);
            console.error('Error loading questions:', err);
        } finally{
            setIsLoading(false);
        }
    }, [
        apiCall,
        currentPage,
        pageSize
    ]);
    // Load single question
    const loadQuestion = (0, _react.useCallback)(async (id)=>{
        setIsLoading(true);
        setError(null);
        try {
            const response = await apiCall(`/api/questions/unified/${id}`);
            if (response.success) {
                setCurrentQuestion(response.data);
            } else {
                throw new Error(response.error || 'Failed to load question');
            }
        } catch (err) {
            const errorMessage = err instanceof Error ? err.message : 'Failed to load question';
            setError(errorMessage);
            console.error('Error loading question:', err);
        } finally{
            setIsLoading(false);
        }
    }, []);
    // Load learning paths
    const loadLearningPaths = (0, _react.useCallback)(async ()=>{
        try {
            const response = await apiCall('/api/questions/learning-paths');
            if (response.success) {
                setLearningPaths(response.data);
            } else {
                throw new Error(response.error || 'Failed to load learning paths');
            }
        } catch (err) {
            const errorMessage = err instanceof Error ? err.message : 'Failed to load learning paths';
            setError(errorMessage);
            console.error('Error loading learning paths:', err);
        // Don't throw the error to prevent breaking the component
        }
    }, [
        apiCall
    ]);
    // Load statistics
    const loadStats = (0, _react.useCallback)(async ()=>{
        try {
            const response = await apiCall('/api/questions/stats');
            if (response.success) {
                setStats(response.data);
            } else {
                throw new Error(response.error || 'Failed to load statistics');
            }
        } catch (err) {
            const errorMessage = err instanceof Error ? err.message : 'Failed to load statistics';
            setError(errorMessage);
            console.error('Error loading statistics:', err);
        // Don't throw the error to prevent breaking the component
        }
    }, [
        apiCall
    ]);
    // Create question
    const createQuestion = (0, _react.useCallback)(async (questionData)=>{
        setIsCreating(true);
        setError(null);
        try {
            const response = await apiCall('/api/questions/unified', {
                method: 'POST',
                body: JSON.stringify(questionData)
            });
            if (response.success) {
                // Reload questions to include the new one
                await loadQuestions(initialFilters);
                return response.data.id;
            } else {
                throw new Error(response.error || 'Failed to create question');
            }
        } catch (err) {
            const errorMessage = err instanceof Error ? err.message : 'Failed to create question';
            setError(errorMessage);
            console.error('Error creating question:', err);
            return null;
        } finally{
            setIsCreating(false);
        }
    }, [
        loadQuestions,
        initialFilters
    ]);
    // Update question
    const updateQuestion = (0, _react.useCallback)(async (id, updates)=>{
        setIsUpdating(true);
        setError(null);
        try {
            const response = await apiCall(`/api/questions/unified/${id}`, {
                method: 'PUT',
                body: JSON.stringify(updates)
            });
            if (response.success) {
                // Update local state
                setQuestions((prev)=>prev.map((q)=>q.id === id ? {
                            ...q,
                            ...updates
                        } : q));
                if (currentQuestion?.id === id) {
                    setCurrentQuestion((prev)=>prev ? {
                            ...prev,
                            ...updates
                        } : null);
                }
            } else {
                throw new Error(response.error || 'Failed to update question');
            }
        } catch (err) {
            const errorMessage = err instanceof Error ? err.message : 'Failed to update question';
            setError(errorMessage);
            console.error('Error updating question:', err);
        } finally{
            setIsUpdating(false);
        }
    }, [
        currentQuestion
    ]);
    // Delete question
    const deleteQuestion = (0, _react.useCallback)(async (id)=>{
        setIsDeleting(true);
        setError(null);
        try {
            const response = await apiCall(`/api/questions/unified/${id}`, {
                method: 'DELETE'
            });
            if (response.success) {
                // Remove from local state
                setQuestions((prev)=>prev.filter((q)=>q.id !== id));
                if (currentQuestion?.id === id) {
                    setCurrentQuestion(null);
                }
            } else {
                throw new Error(response.error || 'Failed to delete question');
            }
        } catch (err) {
            const errorMessage = err instanceof Error ? err.message : 'Failed to delete question';
            setError(errorMessage);
            console.error('Error deleting question:', err);
        } finally{
            setIsDeleting(false);
        }
    }, [
        currentQuestion
    ]);
    // Bulk import questions
    const bulkImportQuestions = (0, _react.useCallback)(async (questionsData)=>{
        setIsCreating(true);
        setError(null);
        try {
            // Flatten all questions from all BulkQuestionData objects
            const allQuestions = questionsData.flatMap((bulkData)=>bulkData.questions);
            console.log('ðŸš€ Sending questions to API:', {
                totalQuestions: allQuestions.length,
                firstQuestion: allQuestions[0]?.title || 'No title',
                questionsDataLength: questionsData.length
            });
            const response = await apiCall('/api/questions/unified', {
                method: 'POST',
                body: JSON.stringify({
                    questions: allQuestions,
                    isBulkImport: true
                })
            });
            console.log('ðŸ“¥ API Response:', response);
            if (response.success) {
                // Reload questions to include the new ones
                await loadQuestions(initialFilters);
                return {
                    success: response.data?.length || allQuestions.length,
                    failed: 0,
                    errors: []
                };
            } else {
                throw new Error(response.error || 'Failed to bulk import questions');
            }
        } catch (err) {
            const errorMessage = err instanceof Error ? err.message : 'Failed to bulk import questions';
            setError(errorMessage);
            console.error('Error bulk importing questions:', err);
            return {
                success: 0,
                failed: questionsData.flatMap((bd)=>bd.questions).length,
                errors: [
                    errorMessage
                ]
            };
        } finally{
            setIsCreating(false);
        }
    }, [
        loadQuestions,
        initialFilters
    ]);
    // Search questions
    const searchQuestions = (0, _react.useCallback)(async (searchTerm, filters)=>{
        setIsLoading(true);
        setError(null);
        try {
            const queryParams = new URLSearchParams();
            queryParams.append('search', searchTerm);
            if (filters) {
                Object.entries(filters).forEach(([key, value])=>{
                    if (value !== undefined && value !== null) {
                        queryParams.append(key, String(value));
                    }
                });
            }
            const url = `/api/questions/unified/search?${queryParams.toString()}`;
            const response = await apiCall(url);
            if (response.success) {
                setQuestions(response.data);
            } else {
                throw new Error(response.error || 'Failed to search questions');
            }
        } catch (err) {
            const errorMessage = err instanceof Error ? err.message : 'Failed to search questions';
            setError(errorMessage);
            console.error('Error searching questions:', err);
        } finally{
            setIsLoading(false);
        }
    }, []);
    // Get random questions
    const getRandomQuestions = (0, _react.useCallback)(async (count, filters)=>{
        setIsLoading(true);
        setError(null);
        try {
            const queryParams = new URLSearchParams();
            queryParams.append('random', 'true');
            queryParams.append('count', String(count));
            if (filters) {
                Object.entries(filters).forEach(([key, value])=>{
                    if (value !== undefined && value !== null) {
                        queryParams.append(key, String(value));
                    }
                });
            }
            const url = `/api/questions/unified?${queryParams.toString()}`;
            const response = await apiCall(url);
            if (response.success) {
                setQuestions(response.data);
            } else {
                throw new Error(response.error || 'Failed to get random questions');
            }
        } catch (err) {
            const errorMessage = err instanceof Error ? err.message : 'Failed to get random questions';
            setError(errorMessage);
            console.error('Error getting random questions:', err);
        } finally{
            setIsLoading(false);
        }
    }, []);
    // Utility functions
    const clearError = (0, _react.useCallback)(()=>{
        setError(null);
    }, []);
    const clearQuestions = (0, _react.useCallback)(()=>{
        setQuestions([]);
        setCurrentQuestion(null);
    }, []);
    // Auto-load on mount
    (0, _react.useEffect)(()=>{
        console.log('ðŸ”„ useUnifiedQuestions: useEffect called with autoLoad:', autoLoad);
        if (autoLoad) {
            console.log('ðŸ”„ useUnifiedQuestions: autoLoad is true, calling loadQuestions');
            // Load questions first, then other data with delays to prevent Firebase conflicts
            const loadDataSequentially = async ()=>{
                try {
                    await loadQuestions(initialFilters);
                    // Add small delays between API calls to prevent Firebase "Target ID already exists" errors
                    setTimeout(()=>{
                        loadLearningPaths().catch((err)=>console.error('Error loading learning paths:', err));
                    }, 100);
                    setTimeout(()=>{
                        loadStats().catch((err)=>console.error('Error loading stats:', err));
                    }, 200);
                } catch (err) {
                    console.error('Error in sequential data loading:', err);
                }
            };
            loadDataSequentially();
        }
    }, [
        autoLoad,
        loadQuestions,
        loadLearningPaths,
        loadStats,
        initialFilters
    ]);
    // Pagination functions
    const goToPage = (0, _react.useCallback)((page)=>{
        if (page >= 1 && page <= totalPages) {
            setCurrentPage(page);
            loadQuestions(initialFilters, page);
        }
    }, [
        totalPages,
        loadQuestions,
        initialFilters
    ]);
    const nextPage = (0, _react.useCallback)(()=>{
        if (hasNext) {
            goToPage(currentPage + 1);
        }
    }, [
        hasNext,
        currentPage,
        goToPage
    ]);
    const prevPage = (0, _react.useCallback)(()=>{
        if (hasPrev) {
            goToPage(currentPage - 1);
        }
    }, [
        hasPrev,
        currentPage,
        goToPage
    ]);
    const changePageSize = (0, _react.useCallback)((newPageSize)=>{
        setPageSize(newPageSize);
        setCurrentPage(1);
        loadQuestions(initialFilters, 1);
    }, [
        loadQuestions,
        initialFilters
    ]);
    return {
        // Data
        questions,
        currentQuestion,
        learningPaths,
        stats,
        // Loading states
        isLoading,
        isCreating,
        isUpdating,
        isDeleting,
        // Error state
        error,
        // Pagination state
        currentPage,
        pageSize,
        totalCount,
        totalPages,
        hasNext,
        hasPrev,
        // Actions
        loadQuestions,
        loadQuestion,
        loadLearningPaths,
        loadStats,
        createQuestion,
        updateQuestion,
        deleteQuestion,
        bulkImportQuestions,
        searchQuestions,
        getRandomQuestions,
        // Pagination actions
        goToPage,
        nextPage,
        prevPage,
        changePageSize,
        // Utilities
        clearError,
        clearQuestions
    };
} // export default useUnifiedQuestions; // Removed default export, use named export instead

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9hLmZvdWFkL1NpZGVQcm9qZWN0cy9FbHphdG9uYS1hbGwvRWx6YXRvbmEtd2ViL2xpYnMvc2hhcmVkLWhvb2tzL3NyYy9saWIvdXNlVW5pZmllZFF1ZXN0aW9ucy50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyB2MS4wIC0gVW5pZmllZCBRdWVzdGlvbnMgSG9va1xuLy8gUmVhY3QgaG9vayBmb3IgbWFuYWdpbmcgcXVlc3Rpb25zIGZyb20gdGhlIHVuaWZpZWQgRmlyZWJhc2Ugc3lzdGVtXG5cbmltcG9ydCB7IHVzZVN0YXRlLCB1c2VFZmZlY3QsIHVzZUNhbGxiYWNrIH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHtcbiAgVW5pZmllZFF1ZXN0aW9uLFxuICBCdWxrUXVlc3Rpb25EYXRhLFxuICBRdWVzdGlvblN0YXRzLFxuICBMZWFybmluZ1BhdGgsXG59IGZyb20gJ0BlbHphdG9uYS9zaGFyZWQtdHlwZXMnO1xuXG5pbnRlcmZhY2UgVXNlVW5pZmllZFF1ZXN0aW9uc09wdGlvbnMge1xuICBhdXRvTG9hZD86IGJvb2xlYW47XG4gIGluaXRpYWxGaWx0ZXJzPzoge1xuICAgIGNhdGVnb3J5Pzogc3RyaW5nO1xuICAgIHN1YmNhdGVnb3J5Pzogc3RyaW5nO1xuICAgIGRpZmZpY3VsdHk/OiBzdHJpbmc7XG4gICAgbGVhcm5pbmdQYXRoPzogc3RyaW5nO1xuICAgIHRvcGljPzogc3RyaW5nO1xuICAgIHNlY3Rpb25JZD86IHN0cmluZztcbiAgICBpc0FjdGl2ZT86IGJvb2xlYW47XG4gICAgaXNDb21wbGV0ZT86IGJvb2xlYW47XG4gICAgbGltaXQ/OiBudW1iZXI7XG4gIH07XG59XG5cbmludGVyZmFjZSBVc2VVbmlmaWVkUXVlc3Rpb25zUmV0dXJuIHtcbiAgLy8gRGF0YVxuICBxdWVzdGlvbnM6IFVuaWZpZWRRdWVzdGlvbltdO1xuICBjdXJyZW50UXVlc3Rpb246IFVuaWZpZWRRdWVzdGlvbiB8IG51bGw7XG4gIGxlYXJuaW5nUGF0aHM6IExlYXJuaW5nUGF0aFtdO1xuICBzdGF0czogUXVlc3Rpb25TdGF0cyB8IG51bGw7XG5cbiAgLy8gTG9hZGluZyBzdGF0ZXNcbiAgaXNMb2FkaW5nOiBib29sZWFuO1xuICBpc0NyZWF0aW5nOiBib29sZWFuO1xuICBpc1VwZGF0aW5nOiBib29sZWFuO1xuICBpc0RlbGV0aW5nOiBib29sZWFuO1xuXG4gIC8vIEVycm9yIHN0YXRlc1xuICBlcnJvcjogc3RyaW5nIHwgbnVsbDtcblxuICAvLyBQYWdpbmF0aW9uIHN0YXRlXG4gIGN1cnJlbnRQYWdlOiBudW1iZXI7XG4gIHBhZ2VTaXplOiBudW1iZXI7XG4gIHRvdGFsQ291bnQ6IG51bWJlcjtcbiAgdG90YWxQYWdlczogbnVtYmVyO1xuICBoYXNOZXh0OiBib29sZWFuO1xuICBoYXNQcmV2OiBib29sZWFuO1xuXG4gIC8vIEFjdGlvbnNcbiAgbG9hZFF1ZXN0aW9uczogKFxuICAgIGZpbHRlcnM/OiBVc2VVbmlmaWVkUXVlc3Rpb25zT3B0aW9uc1snaW5pdGlhbEZpbHRlcnMnXVxuICApID0+IFByb21pc2U8dm9pZD47XG4gIGxvYWRRdWVzdGlvbjogKGlkOiBzdHJpbmcpID0+IFByb21pc2U8dm9pZD47XG4gIGxvYWRMZWFybmluZ1BhdGhzOiAoKSA9PiBQcm9taXNlPHZvaWQ+O1xuICBsb2FkU3RhdHM6ICgpID0+IFByb21pc2U8dm9pZD47XG4gIGNyZWF0ZVF1ZXN0aW9uOiAoXG4gICAgcXVlc3Rpb25EYXRhOiBPbWl0PFVuaWZpZWRRdWVzdGlvbiwgJ2lkJyB8ICdjcmVhdGVkQXQnIHwgJ3VwZGF0ZWRBdCc+XG4gICkgPT4gUHJvbWlzZTxzdHJpbmcgfCBudWxsPjtcbiAgdXBkYXRlUXVlc3Rpb246IChcbiAgICBpZDogc3RyaW5nLFxuICAgIHVwZGF0ZXM6IFBhcnRpYWw8VW5pZmllZFF1ZXN0aW9uPlxuICApID0+IFByb21pc2U8dm9pZD47XG4gIGRlbGV0ZVF1ZXN0aW9uOiAoaWQ6IHN0cmluZykgPT4gUHJvbWlzZTx2b2lkPjtcbiAgYnVsa0ltcG9ydFF1ZXN0aW9uczogKFxuICAgIHF1ZXN0aW9uczogQnVsa1F1ZXN0aW9uRGF0YVtdXG4gICkgPT4gUHJvbWlzZTx7IHN1Y2Nlc3M6IG51bWJlcjsgZmFpbGVkOiBudW1iZXI7IGVycm9yczogc3RyaW5nW10gfT47XG4gIHNlYXJjaFF1ZXN0aW9uczogKFxuICAgIHNlYXJjaFRlcm06IHN0cmluZyxcbiAgICBmaWx0ZXJzPzogVXNlVW5pZmllZFF1ZXN0aW9uc09wdGlvbnNbJ2luaXRpYWxGaWx0ZXJzJ11cbiAgKSA9PiBQcm9taXNlPHZvaWQ+O1xuICBnZXRSYW5kb21RdWVzdGlvbnM6IChcbiAgICBjb3VudDogbnVtYmVyLFxuICAgIGZpbHRlcnM/OiBVc2VVbmlmaWVkUXVlc3Rpb25zT3B0aW9uc1snaW5pdGlhbEZpbHRlcnMnXVxuICApID0+IFByb21pc2U8dm9pZD47XG5cbiAgLy8gUGFnaW5hdGlvbiBhY3Rpb25zXG4gIGdvVG9QYWdlOiAocGFnZTogbnVtYmVyKSA9PiB2b2lkO1xuICBuZXh0UGFnZTogKCkgPT4gdm9pZDtcbiAgcHJldlBhZ2U6ICgpID0+IHZvaWQ7XG4gIGNoYW5nZVBhZ2VTaXplOiAocGFnZVNpemU6IG51bWJlcikgPT4gdm9pZDtcblxuICAvLyBVdGlsaXRpZXNcbiAgY2xlYXJFcnJvcjogKCkgPT4gdm9pZDtcbiAgY2xlYXJRdWVzdGlvbnM6ICgpID0+IHZvaWQ7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB1c2VVbmlmaWVkUXVlc3Rpb25zKFxuICBvcHRpb25zOiBVc2VVbmlmaWVkUXVlc3Rpb25zT3B0aW9ucyA9IHt9XG4pOiBVc2VVbmlmaWVkUXVlc3Rpb25zUmV0dXJuIHtcbiAgY29uc3QgeyBhdXRvTG9hZCA9IHRydWUsIGluaXRpYWxGaWx0ZXJzIH0gPSBvcHRpb25zO1xuXG4gIC8vIFN0YXRlXG4gIGNvbnN0IFtxdWVzdGlvbnMsIHNldFF1ZXN0aW9uc10gPSB1c2VTdGF0ZTxVbmlmaWVkUXVlc3Rpb25bXT4oW10pO1xuICBjb25zdCBbY3VycmVudFF1ZXN0aW9uLCBzZXRDdXJyZW50UXVlc3Rpb25dID1cbiAgICB1c2VTdGF0ZTxVbmlmaWVkUXVlc3Rpb24gfCBudWxsPihudWxsKTtcbiAgY29uc3QgW2xlYXJuaW5nUGF0aHMsIHNldExlYXJuaW5nUGF0aHNdID0gdXNlU3RhdGU8TGVhcm5pbmdQYXRoW10+KFtdKTtcbiAgY29uc3QgW3N0YXRzLCBzZXRTdGF0c10gPSB1c2VTdGF0ZTxRdWVzdGlvblN0YXRzIHwgbnVsbD4obnVsbCk7XG5cbiAgLy8gTG9hZGluZyBzdGF0ZXNcbiAgY29uc3QgW2lzTG9hZGluZywgc2V0SXNMb2FkaW5nXSA9IHVzZVN0YXRlKGZhbHNlKTtcbiAgY29uc3QgW2lzQ3JlYXRpbmcsIHNldElzQ3JlYXRpbmddID0gdXNlU3RhdGUoZmFsc2UpO1xuICBjb25zdCBbaXNVcGRhdGluZywgc2V0SXNVcGRhdGluZ10gPSB1c2VTdGF0ZShmYWxzZSk7XG4gIGNvbnN0IFtpc0RlbGV0aW5nLCBzZXRJc0RlbGV0aW5nXSA9IHVzZVN0YXRlKGZhbHNlKTtcblxuICAvLyBFcnJvciBzdGF0ZVxuICBjb25zdCBbZXJyb3IsIHNldEVycm9yXSA9IHVzZVN0YXRlPHN0cmluZyB8IG51bGw+KG51bGwpO1xuXG4gIC8vIFBhZ2luYXRpb24gc3RhdGVcbiAgY29uc3QgW2N1cnJlbnRQYWdlLCBzZXRDdXJyZW50UGFnZV0gPSB1c2VTdGF0ZSgxKTtcbiAgY29uc3QgW3BhZ2VTaXplLCBzZXRQYWdlU2l6ZV0gPSB1c2VTdGF0ZSgxMCk7XG4gIGNvbnN0IFt0b3RhbENvdW50LCBzZXRUb3RhbENvdW50XSA9IHVzZVN0YXRlKDApO1xuICBjb25zdCBbdG90YWxQYWdlcywgc2V0VG90YWxQYWdlc10gPSB1c2VTdGF0ZSgwKTtcbiAgY29uc3QgW2hhc05leHQsIHNldEhhc05leHRdID0gdXNlU3RhdGUoZmFsc2UpO1xuICBjb25zdCBbaGFzUHJldiwgc2V0SGFzUHJldl0gPSB1c2VTdGF0ZShmYWxzZSk7XG5cbiAgLy8gQVBJIGNhbGxzXG4gIGNvbnN0IGFwaUNhbGwgPSB1c2VDYWxsYmFjayhcbiAgICBhc3luYyAodXJsOiBzdHJpbmcsIG9wdGlvbnM6IFJlcXVlc3RJbml0ID0ge30pID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2godXJsLCB7XG4gICAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgICAgIC4uLm9wdGlvbnMuaGVhZGVycyxcbiAgICAgICAgICB9LFxuICAgICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgICBjb25zdCBlcnJvckRhdGEgPSBhd2FpdCByZXNwb25zZVxuICAgICAgICAgICAgLmpzb24oKVxuICAgICAgICAgICAgLmNhdGNoKCgpID0+ICh7IGVycm9yOiAnVW5rbm93biBlcnJvcicgfSkpO1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvckRhdGEuZXJyb3IgfHwgYEhUVFAgJHtyZXNwb25zZS5zdGF0dXN9YCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzcG9uc2UuanNvbigpO1xuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIC8vIEhhbmRsZSBGaXJlYmFzZSBcIlRhcmdldCBJRCBhbHJlYWR5IGV4aXN0c1wiIGVycm9ycyBncmFjZWZ1bGx5XG4gICAgICAgIGlmIChcbiAgICAgICAgICBlcnIgaW5zdGFuY2VvZiBFcnJvciAmJlxuICAgICAgICAgIGVyci5tZXNzYWdlLmluY2x1ZGVzKCdUYXJnZXQgSUQgYWxyZWFkeSBleGlzdHMnKVxuICAgICAgICApIHtcbiAgICAgICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgICAgICAnRmlyZWJhc2UgbGlzdGVuZXIgY29uZmxpY3QsIHJldHJ5aW5nIGluIDUwMG1zLi4uJyxcbiAgICAgICAgICAgIGVyci5tZXNzYWdlXG4gICAgICAgICAgKTtcbiAgICAgICAgICAvLyBXYWl0IGEgYml0IGFuZCByZXRyeSBvbmNlXG4gICAgICAgICAgYXdhaXQgbmV3IFByb21pc2UocmVzb2x2ZSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIDUwMCkpO1xuICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2godXJsLCB7XG4gICAgICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgICAgICAgIC4uLm9wdGlvbnMuaGVhZGVycyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgICAgICAgY29uc3QgZXJyb3JEYXRhID0gYXdhaXQgcmVzcG9uc2VcbiAgICAgICAgICAgICAgLmpzb24oKVxuICAgICAgICAgICAgICAuY2F0Y2goKCkgPT4gKHsgZXJyb3I6ICdVbmtub3duIGVycm9yJyB9KSk7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JEYXRhLmVycm9yIHx8IGBIVFRQICR7cmVzcG9uc2Uuc3RhdHVzfWApO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiByZXNwb25zZS5qc29uKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgfVxuICAgIH0sXG4gICAgW11cbiAgKTtcblxuICAvLyBMb2FkIHF1ZXN0aW9uc1xuICBjb25zdCBsb2FkUXVlc3Rpb25zID0gdXNlQ2FsbGJhY2soXG4gICAgYXN5bmMgKFxuICAgICAgZmlsdGVycz86IFVzZVVuaWZpZWRRdWVzdGlvbnNPcHRpb25zWydpbml0aWFsRmlsdGVycyddLFxuICAgICAgcGFnZTogbnVtYmVyID0gY3VycmVudFBhZ2VcbiAgICApID0+IHtcbiAgICAgIGNvbnNvbGUubG9nKFxuICAgICAgICAn8J+UhCB1c2VVbmlmaWVkUXVlc3Rpb25zOiBsb2FkUXVlc3Rpb25zIGNhbGxlZCB3aXRoIGZpbHRlcnM6JyxcbiAgICAgICAgZmlsdGVycyxcbiAgICAgICAgJ3BhZ2U6JyxcbiAgICAgICAgcGFnZVxuICAgICAgKTtcbiAgICAgIHNldElzTG9hZGluZyh0cnVlKTtcbiAgICAgIHNldEVycm9yKG51bGwpO1xuXG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCBxdWVyeVBhcmFtcyA9IG5ldyBVUkxTZWFyY2hQYXJhbXMoKTtcblxuICAgICAgICAvLyBBZGQgcGFnaW5hdGlvbiBwYXJhbWV0ZXJzXG4gICAgICAgIHF1ZXJ5UGFyYW1zLmFwcGVuZCgncGFnZScsIFN0cmluZyhwYWdlKSk7XG4gICAgICAgIHF1ZXJ5UGFyYW1zLmFwcGVuZCgncGFnZVNpemUnLCBTdHJpbmcocGFnZVNpemUpKTtcbiAgICAgICAgcXVlcnlQYXJhbXMuYXBwZW5kKCdpbmNsdWRlUGFnaW5hdGlvbicsICd0cnVlJyk7XG5cbiAgICAgICAgaWYgKGZpbHRlcnMpIHtcbiAgICAgICAgICBPYmplY3QuZW50cmllcyhmaWx0ZXJzKS5mb3JFYWNoKChba2V5LCB2YWx1ZV0pID0+IHtcbiAgICAgICAgICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkICYmIHZhbHVlICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgIHF1ZXJ5UGFyYW1zLmFwcGVuZChrZXksIFN0cmluZyh2YWx1ZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgdXJsID0gYC9hcGkvcXVlc3Rpb25zL3VuaWZpZWQke3F1ZXJ5UGFyYW1zLnRvU3RyaW5nKCkgPyBgPyR7cXVlcnlQYXJhbXMudG9TdHJpbmcoKX1gIDogJyd9YDtcbiAgICAgICAgY29uc29sZS5sb2coJ/CflIQgdXNlVW5pZmllZFF1ZXN0aW9uczogTWFraW5nIEFQSSBjYWxsIHRvOicsIHVybCk7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgYXBpQ2FsbCh1cmwpO1xuICAgICAgICBjb25zb2xlLmxvZygn8J+UhCB1c2VVbmlmaWVkUXVlc3Rpb25zOiBBUEkgcmVzcG9uc2UgcmVjZWl2ZWQ6JywgcmVzcG9uc2UpO1xuXG4gICAgICAgIGlmIChyZXNwb25zZS5zdWNjZXNzKSB7XG4gICAgICAgICAgY29uc29sZS5sb2coXG4gICAgICAgICAgICAn4pyFIHVzZVVuaWZpZWRRdWVzdGlvbnM6IFF1ZXN0aW9ucyBsb2FkZWQgc3VjY2Vzc2Z1bGx5OicsXG4gICAgICAgICAgICByZXNwb25zZS5kYXRhXG4gICAgICAgICAgKTtcbiAgICAgICAgICBjb25zb2xlLmxvZyhcbiAgICAgICAgICAgICfinIUgdXNlVW5pZmllZFF1ZXN0aW9uczogU2V0dGluZyBxdWVzdGlvbnMgd2l0aCBkYXRhIGxlbmd0aDonLFxuICAgICAgICAgICAgcmVzcG9uc2UuZGF0YT8ubGVuZ3RoXG4gICAgICAgICAgKTtcbiAgICAgICAgICBzZXRRdWVzdGlvbnMocmVzcG9uc2UuZGF0YSk7XG5cbiAgICAgICAgICAvLyBVcGRhdGUgcGFnaW5hdGlvbiBzdGF0ZVxuICAgICAgICAgIGlmIChyZXNwb25zZS5wYWdpbmF0aW9uKSB7XG4gICAgICAgICAgICBzZXRDdXJyZW50UGFnZShyZXNwb25zZS5wYWdpbmF0aW9uLnBhZ2UpO1xuICAgICAgICAgICAgc2V0VG90YWxDb3VudChyZXNwb25zZS5wYWdpbmF0aW9uLnRvdGFsQ291bnQpO1xuICAgICAgICAgICAgc2V0VG90YWxQYWdlcyhyZXNwb25zZS5wYWdpbmF0aW9uLnRvdGFsUGFnZXMpO1xuICAgICAgICAgICAgc2V0SGFzTmV4dChyZXNwb25zZS5wYWdpbmF0aW9uLmhhc05leHQpO1xuICAgICAgICAgICAgc2V0SGFzUHJldihyZXNwb25zZS5wYWdpbmF0aW9uLmhhc1ByZXYpO1xuICAgICAgICAgICAgY29uc29sZS5sb2coJ/Cfk4QgUGFnaW5hdGlvbiB1cGRhdGVkOicsIHJlc3BvbnNlLnBhZ2luYXRpb24pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgJ+KdjCB1c2VVbmlmaWVkUXVlc3Rpb25zOiBGYWlsZWQgdG8gbG9hZCBxdWVzdGlvbnM6JyxcbiAgICAgICAgICAgIHJlc3BvbnNlLmVycm9yXG4gICAgICAgICAgKTtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IocmVzcG9uc2UuZXJyb3IgfHwgJ0ZhaWxlZCB0byBsb2FkIHF1ZXN0aW9ucycpO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgY29uc3QgZXJyb3JNZXNzYWdlID1cbiAgICAgICAgICBlcnIgaW5zdGFuY2VvZiBFcnJvciA/IGVyci5tZXNzYWdlIDogJ0ZhaWxlZCB0byBsb2FkIHF1ZXN0aW9ucyc7XG4gICAgICAgIHNldEVycm9yKGVycm9yTWVzc2FnZSk7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGxvYWRpbmcgcXVlc3Rpb25zOicsIGVycik7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBzZXRJc0xvYWRpbmcoZmFsc2UpO1xuICAgICAgfVxuICAgIH0sXG4gICAgW2FwaUNhbGwsIGN1cnJlbnRQYWdlLCBwYWdlU2l6ZV1cbiAgKTtcblxuICAvLyBMb2FkIHNpbmdsZSBxdWVzdGlvblxuICBjb25zdCBsb2FkUXVlc3Rpb24gPSB1c2VDYWxsYmFjayhhc3luYyAoaWQ6IHN0cmluZykgPT4ge1xuICAgIHNldElzTG9hZGluZyh0cnVlKTtcbiAgICBzZXRFcnJvcihudWxsKTtcblxuICAgIHRyeSB7XG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGFwaUNhbGwoYC9hcGkvcXVlc3Rpb25zL3VuaWZpZWQvJHtpZH1gKTtcblxuICAgICAgaWYgKHJlc3BvbnNlLnN1Y2Nlc3MpIHtcbiAgICAgICAgc2V0Q3VycmVudFF1ZXN0aW9uKHJlc3BvbnNlLmRhdGEpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKHJlc3BvbnNlLmVycm9yIHx8ICdGYWlsZWQgdG8gbG9hZCBxdWVzdGlvbicpO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgY29uc3QgZXJyb3JNZXNzYWdlID1cbiAgICAgICAgZXJyIGluc3RhbmNlb2YgRXJyb3IgPyBlcnIubWVzc2FnZSA6ICdGYWlsZWQgdG8gbG9hZCBxdWVzdGlvbic7XG4gICAgICBzZXRFcnJvcihlcnJvck1lc3NhZ2UpO1xuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgbG9hZGluZyBxdWVzdGlvbjonLCBlcnIpO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBzZXRJc0xvYWRpbmcoZmFsc2UpO1xuICAgIH1cbiAgfSwgW10pO1xuXG4gIC8vIExvYWQgbGVhcm5pbmcgcGF0aHNcbiAgY29uc3QgbG9hZExlYXJuaW5nUGF0aHMgPSB1c2VDYWxsYmFjayhhc3luYyAoKSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgYXBpQ2FsbCgnL2FwaS9xdWVzdGlvbnMvbGVhcm5pbmctcGF0aHMnKTtcblxuICAgICAgaWYgKHJlc3BvbnNlLnN1Y2Nlc3MpIHtcbiAgICAgICAgc2V0TGVhcm5pbmdQYXRocyhyZXNwb25zZS5kYXRhKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihyZXNwb25zZS5lcnJvciB8fCAnRmFpbGVkIHRvIGxvYWQgbGVhcm5pbmcgcGF0aHMnKTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGNvbnN0IGVycm9yTWVzc2FnZSA9XG4gICAgICAgIGVyciBpbnN0YW5jZW9mIEVycm9yID8gZXJyLm1lc3NhZ2UgOiAnRmFpbGVkIHRvIGxvYWQgbGVhcm5pbmcgcGF0aHMnO1xuICAgICAgc2V0RXJyb3IoZXJyb3JNZXNzYWdlKTtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGxvYWRpbmcgbGVhcm5pbmcgcGF0aHM6JywgZXJyKTtcbiAgICAgIC8vIERvbid0IHRocm93IHRoZSBlcnJvciB0byBwcmV2ZW50IGJyZWFraW5nIHRoZSBjb21wb25lbnRcbiAgICB9XG4gIH0sIFthcGlDYWxsXSk7XG5cbiAgLy8gTG9hZCBzdGF0aXN0aWNzXG4gIGNvbnN0IGxvYWRTdGF0cyA9IHVzZUNhbGxiYWNrKGFzeW5jICgpID0+IHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBhcGlDYWxsKCcvYXBpL3F1ZXN0aW9ucy9zdGF0cycpO1xuXG4gICAgICBpZiAocmVzcG9uc2Uuc3VjY2Vzcykge1xuICAgICAgICBzZXRTdGF0cyhyZXNwb25zZS5kYXRhKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihyZXNwb25zZS5lcnJvciB8fCAnRmFpbGVkIHRvIGxvYWQgc3RhdGlzdGljcycpO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgY29uc3QgZXJyb3JNZXNzYWdlID1cbiAgICAgICAgZXJyIGluc3RhbmNlb2YgRXJyb3IgPyBlcnIubWVzc2FnZSA6ICdGYWlsZWQgdG8gbG9hZCBzdGF0aXN0aWNzJztcbiAgICAgIHNldEVycm9yKGVycm9yTWVzc2FnZSk7XG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBsb2FkaW5nIHN0YXRpc3RpY3M6JywgZXJyKTtcbiAgICAgIC8vIERvbid0IHRocm93IHRoZSBlcnJvciB0byBwcmV2ZW50IGJyZWFraW5nIHRoZSBjb21wb25lbnRcbiAgICB9XG4gIH0sIFthcGlDYWxsXSk7XG5cbiAgLy8gQ3JlYXRlIHF1ZXN0aW9uXG4gIGNvbnN0IGNyZWF0ZVF1ZXN0aW9uID0gdXNlQ2FsbGJhY2soXG4gICAgYXN5bmMgKFxuICAgICAgcXVlc3Rpb25EYXRhOiBPbWl0PFVuaWZpZWRRdWVzdGlvbiwgJ2lkJyB8ICdjcmVhdGVkQXQnIHwgJ3VwZGF0ZWRBdCc+XG4gICAgKTogUHJvbWlzZTxzdHJpbmcgfCBudWxsPiA9PiB7XG4gICAgICBzZXRJc0NyZWF0aW5nKHRydWUpO1xuICAgICAgc2V0RXJyb3IobnVsbCk7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgYXBpQ2FsbCgnL2FwaS9xdWVzdGlvbnMvdW5pZmllZCcsIHtcbiAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShxdWVzdGlvbkRhdGEpLFxuICAgICAgICB9KTtcblxuICAgICAgICBpZiAocmVzcG9uc2Uuc3VjY2Vzcykge1xuICAgICAgICAgIC8vIFJlbG9hZCBxdWVzdGlvbnMgdG8gaW5jbHVkZSB0aGUgbmV3IG9uZVxuICAgICAgICAgIGF3YWl0IGxvYWRRdWVzdGlvbnMoaW5pdGlhbEZpbHRlcnMpO1xuICAgICAgICAgIHJldHVybiByZXNwb25zZS5kYXRhLmlkO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihyZXNwb25zZS5lcnJvciB8fCAnRmFpbGVkIHRvIGNyZWF0ZSBxdWVzdGlvbicpO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgY29uc3QgZXJyb3JNZXNzYWdlID1cbiAgICAgICAgICBlcnIgaW5zdGFuY2VvZiBFcnJvciA/IGVyci5tZXNzYWdlIDogJ0ZhaWxlZCB0byBjcmVhdGUgcXVlc3Rpb24nO1xuICAgICAgICBzZXRFcnJvcihlcnJvck1lc3NhZ2UpO1xuICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBjcmVhdGluZyBxdWVzdGlvbjonLCBlcnIpO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIHNldElzQ3JlYXRpbmcoZmFsc2UpO1xuICAgICAgfVxuICAgIH0sXG4gICAgW2xvYWRRdWVzdGlvbnMsIGluaXRpYWxGaWx0ZXJzXVxuICApO1xuXG4gIC8vIFVwZGF0ZSBxdWVzdGlvblxuICBjb25zdCB1cGRhdGVRdWVzdGlvbiA9IHVzZUNhbGxiYWNrKFxuICAgIGFzeW5jIChpZDogc3RyaW5nLCB1cGRhdGVzOiBQYXJ0aWFsPFVuaWZpZWRRdWVzdGlvbj4pID0+IHtcbiAgICAgIHNldElzVXBkYXRpbmcodHJ1ZSk7XG4gICAgICBzZXRFcnJvcihudWxsKTtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBhcGlDYWxsKGAvYXBpL3F1ZXN0aW9ucy91bmlmaWVkLyR7aWR9YCwge1xuICAgICAgICAgIG1ldGhvZDogJ1BVVCcsXG4gICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkodXBkYXRlcyksXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmIChyZXNwb25zZS5zdWNjZXNzKSB7XG4gICAgICAgICAgLy8gVXBkYXRlIGxvY2FsIHN0YXRlXG4gICAgICAgICAgc2V0UXVlc3Rpb25zKHByZXYgPT5cbiAgICAgICAgICAgIHByZXYubWFwKHEgPT4gKHEuaWQgPT09IGlkID8geyAuLi5xLCAuLi51cGRhdGVzIH0gOiBxKSlcbiAgICAgICAgICApO1xuICAgICAgICAgIGlmIChjdXJyZW50UXVlc3Rpb24/LmlkID09PSBpZCkge1xuICAgICAgICAgICAgc2V0Q3VycmVudFF1ZXN0aW9uKHByZXYgPT4gKHByZXYgPyB7IC4uLnByZXYsIC4uLnVwZGF0ZXMgfSA6IG51bGwpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKHJlc3BvbnNlLmVycm9yIHx8ICdGYWlsZWQgdG8gdXBkYXRlIHF1ZXN0aW9uJyk7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBjb25zdCBlcnJvck1lc3NhZ2UgPVxuICAgICAgICAgIGVyciBpbnN0YW5jZW9mIEVycm9yID8gZXJyLm1lc3NhZ2UgOiAnRmFpbGVkIHRvIHVwZGF0ZSBxdWVzdGlvbic7XG4gICAgICAgIHNldEVycm9yKGVycm9yTWVzc2FnZSk7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIHVwZGF0aW5nIHF1ZXN0aW9uOicsIGVycik7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBzZXRJc1VwZGF0aW5nKGZhbHNlKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIFtjdXJyZW50UXVlc3Rpb25dXG4gICk7XG5cbiAgLy8gRGVsZXRlIHF1ZXN0aW9uXG4gIGNvbnN0IGRlbGV0ZVF1ZXN0aW9uID0gdXNlQ2FsbGJhY2soXG4gICAgYXN5bmMgKGlkOiBzdHJpbmcpID0+IHtcbiAgICAgIHNldElzRGVsZXRpbmcodHJ1ZSk7XG4gICAgICBzZXRFcnJvcihudWxsKTtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBhcGlDYWxsKGAvYXBpL3F1ZXN0aW9ucy91bmlmaWVkLyR7aWR9YCwge1xuICAgICAgICAgIG1ldGhvZDogJ0RFTEVURScsXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmIChyZXNwb25zZS5zdWNjZXNzKSB7XG4gICAgICAgICAgLy8gUmVtb3ZlIGZyb20gbG9jYWwgc3RhdGVcbiAgICAgICAgICBzZXRRdWVzdGlvbnMocHJldiA9PiBwcmV2LmZpbHRlcihxID0+IHEuaWQgIT09IGlkKSk7XG4gICAgICAgICAgaWYgKGN1cnJlbnRRdWVzdGlvbj8uaWQgPT09IGlkKSB7XG4gICAgICAgICAgICBzZXRDdXJyZW50UXVlc3Rpb24obnVsbCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihyZXNwb25zZS5lcnJvciB8fCAnRmFpbGVkIHRvIGRlbGV0ZSBxdWVzdGlvbicpO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgY29uc3QgZXJyb3JNZXNzYWdlID1cbiAgICAgICAgICBlcnIgaW5zdGFuY2VvZiBFcnJvciA/IGVyci5tZXNzYWdlIDogJ0ZhaWxlZCB0byBkZWxldGUgcXVlc3Rpb24nO1xuICAgICAgICBzZXRFcnJvcihlcnJvck1lc3NhZ2UpO1xuICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBkZWxldGluZyBxdWVzdGlvbjonLCBlcnIpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgc2V0SXNEZWxldGluZyhmYWxzZSk7XG4gICAgICB9XG4gICAgfSxcbiAgICBbY3VycmVudFF1ZXN0aW9uXVxuICApO1xuXG4gIC8vIEJ1bGsgaW1wb3J0IHF1ZXN0aW9uc1xuICBjb25zdCBidWxrSW1wb3J0UXVlc3Rpb25zID0gdXNlQ2FsbGJhY2soXG4gICAgYXN5bmMgKFxuICAgICAgcXVlc3Rpb25zRGF0YTogQnVsa1F1ZXN0aW9uRGF0YVtdXG4gICAgKTogUHJvbWlzZTx7IHN1Y2Nlc3M6IG51bWJlcjsgZmFpbGVkOiBudW1iZXI7IGVycm9yczogc3RyaW5nW10gfT4gPT4ge1xuICAgICAgc2V0SXNDcmVhdGluZyh0cnVlKTtcbiAgICAgIHNldEVycm9yKG51bGwpO1xuXG4gICAgICB0cnkge1xuICAgICAgICAvLyBGbGF0dGVuIGFsbCBxdWVzdGlvbnMgZnJvbSBhbGwgQnVsa1F1ZXN0aW9uRGF0YSBvYmplY3RzXG4gICAgICAgIGNvbnN0IGFsbFF1ZXN0aW9ucyA9IHF1ZXN0aW9uc0RhdGEuZmxhdE1hcChcbiAgICAgICAgICBidWxrRGF0YSA9PiBidWxrRGF0YS5xdWVzdGlvbnNcbiAgICAgICAgKTtcblxuICAgICAgICBjb25zb2xlLmxvZygn8J+agCBTZW5kaW5nIHF1ZXN0aW9ucyB0byBBUEk6Jywge1xuICAgICAgICAgIHRvdGFsUXVlc3Rpb25zOiBhbGxRdWVzdGlvbnMubGVuZ3RoLFxuICAgICAgICAgIGZpcnN0UXVlc3Rpb246IGFsbFF1ZXN0aW9uc1swXT8udGl0bGUgfHwgJ05vIHRpdGxlJyxcbiAgICAgICAgICBxdWVzdGlvbnNEYXRhTGVuZ3RoOiBxdWVzdGlvbnNEYXRhLmxlbmd0aCxcbiAgICAgICAgfSk7XG5cbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBhcGlDYWxsKCcvYXBpL3F1ZXN0aW9ucy91bmlmaWVkJywge1xuICAgICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICAgIHF1ZXN0aW9uczogYWxsUXVlc3Rpb25zLFxuICAgICAgICAgICAgaXNCdWxrSW1wb3J0OiB0cnVlLFxuICAgICAgICAgIH0pLFxuICAgICAgICB9KTtcblxuICAgICAgICBjb25zb2xlLmxvZygn8J+TpSBBUEkgUmVzcG9uc2U6JywgcmVzcG9uc2UpO1xuXG4gICAgICAgIGlmIChyZXNwb25zZS5zdWNjZXNzKSB7XG4gICAgICAgICAgLy8gUmVsb2FkIHF1ZXN0aW9ucyB0byBpbmNsdWRlIHRoZSBuZXcgb25lc1xuICAgICAgICAgIGF3YWl0IGxvYWRRdWVzdGlvbnMoaW5pdGlhbEZpbHRlcnMpO1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBzdWNjZXNzOiByZXNwb25zZS5kYXRhPy5sZW5ndGggfHwgYWxsUXVlc3Rpb25zLmxlbmd0aCxcbiAgICAgICAgICAgIGZhaWxlZDogMCxcbiAgICAgICAgICAgIGVycm9yczogW10sXG4gICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IocmVzcG9uc2UuZXJyb3IgfHwgJ0ZhaWxlZCB0byBidWxrIGltcG9ydCBxdWVzdGlvbnMnKTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGNvbnN0IGVycm9yTWVzc2FnZSA9XG4gICAgICAgICAgZXJyIGluc3RhbmNlb2YgRXJyb3JcbiAgICAgICAgICAgID8gZXJyLm1lc3NhZ2VcbiAgICAgICAgICAgIDogJ0ZhaWxlZCB0byBidWxrIGltcG9ydCBxdWVzdGlvbnMnO1xuICAgICAgICBzZXRFcnJvcihlcnJvck1lc3NhZ2UpO1xuICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBidWxrIGltcG9ydGluZyBxdWVzdGlvbnM6JywgZXJyKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBzdWNjZXNzOiAwLFxuICAgICAgICAgIGZhaWxlZDogcXVlc3Rpb25zRGF0YS5mbGF0TWFwKGJkID0+IGJkLnF1ZXN0aW9ucykubGVuZ3RoLFxuICAgICAgICAgIGVycm9yczogW2Vycm9yTWVzc2FnZV0sXG4gICAgICAgIH07XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBzZXRJc0NyZWF0aW5nKGZhbHNlKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIFtsb2FkUXVlc3Rpb25zLCBpbml0aWFsRmlsdGVyc11cbiAgKTtcblxuICAvLyBTZWFyY2ggcXVlc3Rpb25zXG4gIGNvbnN0IHNlYXJjaFF1ZXN0aW9ucyA9IHVzZUNhbGxiYWNrKFxuICAgIGFzeW5jIChcbiAgICAgIHNlYXJjaFRlcm06IHN0cmluZyxcbiAgICAgIGZpbHRlcnM/OiBVc2VVbmlmaWVkUXVlc3Rpb25zT3B0aW9uc1snaW5pdGlhbEZpbHRlcnMnXVxuICAgICkgPT4ge1xuICAgICAgc2V0SXNMb2FkaW5nKHRydWUpO1xuICAgICAgc2V0RXJyb3IobnVsbCk7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHF1ZXJ5UGFyYW1zID0gbmV3IFVSTFNlYXJjaFBhcmFtcygpO1xuICAgICAgICBxdWVyeVBhcmFtcy5hcHBlbmQoJ3NlYXJjaCcsIHNlYXJjaFRlcm0pO1xuXG4gICAgICAgIGlmIChmaWx0ZXJzKSB7XG4gICAgICAgICAgT2JqZWN0LmVudHJpZXMoZmlsdGVycykuZm9yRWFjaCgoW2tleSwgdmFsdWVdKSA9PiB7XG4gICAgICAgICAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCAmJiB2YWx1ZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICBxdWVyeVBhcmFtcy5hcHBlbmQoa2V5LCBTdHJpbmcodmFsdWUpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHVybCA9IGAvYXBpL3F1ZXN0aW9ucy91bmlmaWVkL3NlYXJjaD8ke3F1ZXJ5UGFyYW1zLnRvU3RyaW5nKCl9YDtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBhcGlDYWxsKHVybCk7XG5cbiAgICAgICAgaWYgKHJlc3BvbnNlLnN1Y2Nlc3MpIHtcbiAgICAgICAgICBzZXRRdWVzdGlvbnMocmVzcG9uc2UuZGF0YSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKHJlc3BvbnNlLmVycm9yIHx8ICdGYWlsZWQgdG8gc2VhcmNoIHF1ZXN0aW9ucycpO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgY29uc3QgZXJyb3JNZXNzYWdlID1cbiAgICAgICAgICBlcnIgaW5zdGFuY2VvZiBFcnJvciA/IGVyci5tZXNzYWdlIDogJ0ZhaWxlZCB0byBzZWFyY2ggcXVlc3Rpb25zJztcbiAgICAgICAgc2V0RXJyb3IoZXJyb3JNZXNzYWdlKTtcbiAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3Igc2VhcmNoaW5nIHF1ZXN0aW9uczonLCBlcnIpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgc2V0SXNMb2FkaW5nKGZhbHNlKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIFtdXG4gICk7XG5cbiAgLy8gR2V0IHJhbmRvbSBxdWVzdGlvbnNcbiAgY29uc3QgZ2V0UmFuZG9tUXVlc3Rpb25zID0gdXNlQ2FsbGJhY2soXG4gICAgYXN5bmMgKFxuICAgICAgY291bnQ6IG51bWJlcixcbiAgICAgIGZpbHRlcnM/OiBVc2VVbmlmaWVkUXVlc3Rpb25zT3B0aW9uc1snaW5pdGlhbEZpbHRlcnMnXVxuICAgICkgPT4ge1xuICAgICAgc2V0SXNMb2FkaW5nKHRydWUpO1xuICAgICAgc2V0RXJyb3IobnVsbCk7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHF1ZXJ5UGFyYW1zID0gbmV3IFVSTFNlYXJjaFBhcmFtcygpO1xuICAgICAgICBxdWVyeVBhcmFtcy5hcHBlbmQoJ3JhbmRvbScsICd0cnVlJyk7XG4gICAgICAgIHF1ZXJ5UGFyYW1zLmFwcGVuZCgnY291bnQnLCBTdHJpbmcoY291bnQpKTtcblxuICAgICAgICBpZiAoZmlsdGVycykge1xuICAgICAgICAgIE9iamVjdC5lbnRyaWVzKGZpbHRlcnMpLmZvckVhY2goKFtrZXksIHZhbHVlXSkgPT4ge1xuICAgICAgICAgICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQgJiYgdmFsdWUgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgcXVlcnlQYXJhbXMuYXBwZW5kKGtleSwgU3RyaW5nKHZhbHVlKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCB1cmwgPSBgL2FwaS9xdWVzdGlvbnMvdW5pZmllZD8ke3F1ZXJ5UGFyYW1zLnRvU3RyaW5nKCl9YDtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBhcGlDYWxsKHVybCk7XG5cbiAgICAgICAgaWYgKHJlc3BvbnNlLnN1Y2Nlc3MpIHtcbiAgICAgICAgICBzZXRRdWVzdGlvbnMocmVzcG9uc2UuZGF0YSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKHJlc3BvbnNlLmVycm9yIHx8ICdGYWlsZWQgdG8gZ2V0IHJhbmRvbSBxdWVzdGlvbnMnKTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGNvbnN0IGVycm9yTWVzc2FnZSA9XG4gICAgICAgICAgZXJyIGluc3RhbmNlb2YgRXJyb3IgPyBlcnIubWVzc2FnZSA6ICdGYWlsZWQgdG8gZ2V0IHJhbmRvbSBxdWVzdGlvbnMnO1xuICAgICAgICBzZXRFcnJvcihlcnJvck1lc3NhZ2UpO1xuICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBnZXR0aW5nIHJhbmRvbSBxdWVzdGlvbnM6JywgZXJyKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIHNldElzTG9hZGluZyhmYWxzZSk7XG4gICAgICB9XG4gICAgfSxcbiAgICBbXVxuICApO1xuXG4gIC8vIFV0aWxpdHkgZnVuY3Rpb25zXG4gIGNvbnN0IGNsZWFyRXJyb3IgPSB1c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgc2V0RXJyb3IobnVsbCk7XG4gIH0sIFtdKTtcblxuICBjb25zdCBjbGVhclF1ZXN0aW9ucyA9IHVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICBzZXRRdWVzdGlvbnMoW10pO1xuICAgIHNldEN1cnJlbnRRdWVzdGlvbihudWxsKTtcbiAgfSwgW10pO1xuXG4gIC8vIEF1dG8tbG9hZCBvbiBtb3VudFxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGNvbnNvbGUubG9nKFxuICAgICAgJ/CflIQgdXNlVW5pZmllZFF1ZXN0aW9uczogdXNlRWZmZWN0IGNhbGxlZCB3aXRoIGF1dG9Mb2FkOicsXG4gICAgICBhdXRvTG9hZFxuICAgICk7XG4gICAgaWYgKGF1dG9Mb2FkKSB7XG4gICAgICBjb25zb2xlLmxvZyhcbiAgICAgICAgJ/CflIQgdXNlVW5pZmllZFF1ZXN0aW9uczogYXV0b0xvYWQgaXMgdHJ1ZSwgY2FsbGluZyBsb2FkUXVlc3Rpb25zJ1xuICAgICAgKTtcblxuICAgICAgLy8gTG9hZCBxdWVzdGlvbnMgZmlyc3QsIHRoZW4gb3RoZXIgZGF0YSB3aXRoIGRlbGF5cyB0byBwcmV2ZW50IEZpcmViYXNlIGNvbmZsaWN0c1xuICAgICAgY29uc3QgbG9hZERhdGFTZXF1ZW50aWFsbHkgPSBhc3luYyAoKSA9PiB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgYXdhaXQgbG9hZFF1ZXN0aW9ucyhpbml0aWFsRmlsdGVycyk7XG5cbiAgICAgICAgICAvLyBBZGQgc21hbGwgZGVsYXlzIGJldHdlZW4gQVBJIGNhbGxzIHRvIHByZXZlbnQgRmlyZWJhc2UgXCJUYXJnZXQgSUQgYWxyZWFkeSBleGlzdHNcIiBlcnJvcnNcbiAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIGxvYWRMZWFybmluZ1BhdGhzKCkuY2F0Y2goZXJyID0+XG4gICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGxvYWRpbmcgbGVhcm5pbmcgcGF0aHM6JywgZXJyKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9LCAxMDApO1xuXG4gICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICBsb2FkU3RhdHMoKS5jYXRjaChlcnIgPT5cbiAgICAgICAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgbG9hZGluZyBzdGF0czonLCBlcnIpXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH0sIDIwMCk7XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGluIHNlcXVlbnRpYWwgZGF0YSBsb2FkaW5nOicsIGVycik7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIGxvYWREYXRhU2VxdWVudGlhbGx5KCk7XG4gICAgfVxuICB9LCBbYXV0b0xvYWQsIGxvYWRRdWVzdGlvbnMsIGxvYWRMZWFybmluZ1BhdGhzLCBsb2FkU3RhdHMsIGluaXRpYWxGaWx0ZXJzXSk7XG5cbiAgLy8gUGFnaW5hdGlvbiBmdW5jdGlvbnNcbiAgY29uc3QgZ29Ub1BhZ2UgPSB1c2VDYWxsYmFjayhcbiAgICAocGFnZTogbnVtYmVyKSA9PiB7XG4gICAgICBpZiAocGFnZSA+PSAxICYmIHBhZ2UgPD0gdG90YWxQYWdlcykge1xuICAgICAgICBzZXRDdXJyZW50UGFnZShwYWdlKTtcbiAgICAgICAgbG9hZFF1ZXN0aW9ucyhpbml0aWFsRmlsdGVycywgcGFnZSk7XG4gICAgICB9XG4gICAgfSxcbiAgICBbdG90YWxQYWdlcywgbG9hZFF1ZXN0aW9ucywgaW5pdGlhbEZpbHRlcnNdXG4gICk7XG5cbiAgY29uc3QgbmV4dFBhZ2UgPSB1c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgaWYgKGhhc05leHQpIHtcbiAgICAgIGdvVG9QYWdlKGN1cnJlbnRQYWdlICsgMSk7XG4gICAgfVxuICB9LCBbaGFzTmV4dCwgY3VycmVudFBhZ2UsIGdvVG9QYWdlXSk7XG5cbiAgY29uc3QgcHJldlBhZ2UgPSB1c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgaWYgKGhhc1ByZXYpIHtcbiAgICAgIGdvVG9QYWdlKGN1cnJlbnRQYWdlIC0gMSk7XG4gICAgfVxuICB9LCBbaGFzUHJldiwgY3VycmVudFBhZ2UsIGdvVG9QYWdlXSk7XG5cbiAgY29uc3QgY2hhbmdlUGFnZVNpemUgPSB1c2VDYWxsYmFjayhcbiAgICAobmV3UGFnZVNpemU6IG51bWJlcikgPT4ge1xuICAgICAgc2V0UGFnZVNpemUobmV3UGFnZVNpemUpO1xuICAgICAgc2V0Q3VycmVudFBhZ2UoMSk7XG4gICAgICBsb2FkUXVlc3Rpb25zKGluaXRpYWxGaWx0ZXJzLCAxKTtcbiAgICB9LFxuICAgIFtsb2FkUXVlc3Rpb25zLCBpbml0aWFsRmlsdGVyc11cbiAgKTtcblxuICByZXR1cm4ge1xuICAgIC8vIERhdGFcbiAgICBxdWVzdGlvbnMsXG4gICAgY3VycmVudFF1ZXN0aW9uLFxuICAgIGxlYXJuaW5nUGF0aHMsXG4gICAgc3RhdHMsXG5cbiAgICAvLyBMb2FkaW5nIHN0YXRlc1xuICAgIGlzTG9hZGluZyxcbiAgICBpc0NyZWF0aW5nLFxuICAgIGlzVXBkYXRpbmcsXG4gICAgaXNEZWxldGluZyxcblxuICAgIC8vIEVycm9yIHN0YXRlXG4gICAgZXJyb3IsXG5cbiAgICAvLyBQYWdpbmF0aW9uIHN0YXRlXG4gICAgY3VycmVudFBhZ2UsXG4gICAgcGFnZVNpemUsXG4gICAgdG90YWxDb3VudCxcbiAgICB0b3RhbFBhZ2VzLFxuICAgIGhhc05leHQsXG4gICAgaGFzUHJldixcblxuICAgIC8vIEFjdGlvbnNcbiAgICBsb2FkUXVlc3Rpb25zLFxuICAgIGxvYWRRdWVzdGlvbixcbiAgICBsb2FkTGVhcm5pbmdQYXRocyxcbiAgICBsb2FkU3RhdHMsXG4gICAgY3JlYXRlUXVlc3Rpb24sXG4gICAgdXBkYXRlUXVlc3Rpb24sXG4gICAgZGVsZXRlUXVlc3Rpb24sXG4gICAgYnVsa0ltcG9ydFF1ZXN0aW9ucyxcbiAgICBzZWFyY2hRdWVzdGlvbnMsXG4gICAgZ2V0UmFuZG9tUXVlc3Rpb25zLFxuXG4gICAgLy8gUGFnaW5hdGlvbiBhY3Rpb25zXG4gICAgZ29Ub1BhZ2UsXG4gICAgbmV4dFBhZ2UsXG4gICAgcHJldlBhZ2UsXG4gICAgY2hhbmdlUGFnZVNpemUsXG5cbiAgICAvLyBVdGlsaXRpZXNcbiAgICBjbGVhckVycm9yLFxuICAgIGNsZWFyUXVlc3Rpb25zLFxuICB9O1xufVxuXG4vLyBleHBvcnQgZGVmYXVsdCB1c2VVbmlmaWVkUXVlc3Rpb25zOyAvLyBSZW1vdmVkIGRlZmF1bHQgZXhwb3J0LCB1c2UgbmFtZWQgZXhwb3J0IGluc3RlYWRcbiJdLCJuYW1lcyI6WyJ1c2VVbmlmaWVkUXVlc3Rpb25zIiwib3B0aW9ucyIsImF1dG9Mb2FkIiwiaW5pdGlhbEZpbHRlcnMiLCJxdWVzdGlvbnMiLCJzZXRRdWVzdGlvbnMiLCJ1c2VTdGF0ZSIsImN1cnJlbnRRdWVzdGlvbiIsInNldEN1cnJlbnRRdWVzdGlvbiIsImxlYXJuaW5nUGF0aHMiLCJzZXRMZWFybmluZ1BhdGhzIiwic3RhdHMiLCJzZXRTdGF0cyIsImlzTG9hZGluZyIsInNldElzTG9hZGluZyIsImlzQ3JlYXRpbmciLCJzZXRJc0NyZWF0aW5nIiwiaXNVcGRhdGluZyIsInNldElzVXBkYXRpbmciLCJpc0RlbGV0aW5nIiwic2V0SXNEZWxldGluZyIsImVycm9yIiwic2V0RXJyb3IiLCJjdXJyZW50UGFnZSIsInNldEN1cnJlbnRQYWdlIiwicGFnZVNpemUiLCJzZXRQYWdlU2l6ZSIsInRvdGFsQ291bnQiLCJzZXRUb3RhbENvdW50IiwidG90YWxQYWdlcyIsInNldFRvdGFsUGFnZXMiLCJoYXNOZXh0Iiwic2V0SGFzTmV4dCIsImhhc1ByZXYiLCJzZXRIYXNQcmV2IiwiYXBpQ2FsbCIsInVzZUNhbGxiYWNrIiwidXJsIiwicmVzcG9uc2UiLCJmZXRjaCIsImhlYWRlcnMiLCJvayIsImVycm9yRGF0YSIsImpzb24iLCJjYXRjaCIsIkVycm9yIiwic3RhdHVzIiwiZXJyIiwibWVzc2FnZSIsImluY2x1ZGVzIiwiY29uc29sZSIsIndhcm4iLCJQcm9taXNlIiwicmVzb2x2ZSIsInNldFRpbWVvdXQiLCJsb2FkUXVlc3Rpb25zIiwiZmlsdGVycyIsInBhZ2UiLCJsb2ciLCJxdWVyeVBhcmFtcyIsIlVSTFNlYXJjaFBhcmFtcyIsImFwcGVuZCIsIlN0cmluZyIsIk9iamVjdCIsImVudHJpZXMiLCJmb3JFYWNoIiwia2V5IiwidmFsdWUiLCJ1bmRlZmluZWQiLCJ0b1N0cmluZyIsInN1Y2Nlc3MiLCJkYXRhIiwibGVuZ3RoIiwicGFnaW5hdGlvbiIsImVycm9yTWVzc2FnZSIsImxvYWRRdWVzdGlvbiIsImlkIiwibG9hZExlYXJuaW5nUGF0aHMiLCJsb2FkU3RhdHMiLCJjcmVhdGVRdWVzdGlvbiIsInF1ZXN0aW9uRGF0YSIsIm1ldGhvZCIsImJvZHkiLCJKU09OIiwic3RyaW5naWZ5IiwidXBkYXRlUXVlc3Rpb24iLCJ1cGRhdGVzIiwicHJldiIsIm1hcCIsInEiLCJkZWxldGVRdWVzdGlvbiIsImZpbHRlciIsImJ1bGtJbXBvcnRRdWVzdGlvbnMiLCJxdWVzdGlvbnNEYXRhIiwiYWxsUXVlc3Rpb25zIiwiZmxhdE1hcCIsImJ1bGtEYXRhIiwidG90YWxRdWVzdGlvbnMiLCJmaXJzdFF1ZXN0aW9uIiwidGl0bGUiLCJxdWVzdGlvbnNEYXRhTGVuZ3RoIiwiaXNCdWxrSW1wb3J0IiwiZmFpbGVkIiwiZXJyb3JzIiwiYmQiLCJzZWFyY2hRdWVzdGlvbnMiLCJzZWFyY2hUZXJtIiwiZ2V0UmFuZG9tUXVlc3Rpb25zIiwiY291bnQiLCJjbGVhckVycm9yIiwiY2xlYXJRdWVzdGlvbnMiLCJ1c2VFZmZlY3QiLCJsb2FkRGF0YVNlcXVlbnRpYWxseSIsImdvVG9QYWdlIiwibmV4dFBhZ2UiLCJwcmV2UGFnZSIsImNoYW5nZVBhZ2VTaXplIiwibmV3UGFnZVNpemUiXSwibWFwcGluZ3MiOiJBQUFBLGdD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