2a752d6beb80fea2c588e56196464869
/* eslint-disable @typescript-eslint/no-explicit-any */ /**
 * Admin Authentication Integration Tests
 *
 * End-to-end tests for the complete admin authentication flow:
 * - Login process
 * - Session management
 * - Route protection
 * - Logout functionality
 * - Token validation
 */ "use strict";
// Mock NextResponse to ensure json() method works correctly
jest.mock('next/server', ()=>{
    const actual = jest.requireActual('next/server');
    return {
        ...actual,
        NextResponse: {
            ...actual.NextResponse,
            json: (body, init)=>{
                const response = actual.NextResponse.json(body, init);
                // Ensure _body is set for test compatibility
                response._body = JSON.stringify(body);
                return response;
            }
        }
    };
});
// Mock Supabase - shared instance for route handler
// Define inside factory to avoid hoisting issues
jest.mock('@supabase/supabase-js', ()=>{
    const mockSupabaseClient = {
        from: jest.fn()
    };
    return {
        createClient: jest.fn(()=>mockSupabaseClient)
    };
});
// Mock bcrypt
jest.mock('bcryptjs', ()=>({
        compare: jest.fn(),
        hash: jest.fn()
    }));
// Mock admin.config
jest.mock('@/admin.config', ()=>({
        adminConfig: {
            security: {
                saltRounds: 10,
                sessionTimeout: 24 * 60 * 60 * 1000
            },
            jwt: {
                secret: 'test-jwt-secret-key-for-testing'
            }
        }
    }));
Object.defineProperty(exports, "__esModule", {
    value: true
});
const _server = require("next/server");
const _route = require("../../apps/website/src/app/api/admin/auth/route");
const _jsonwebtoken = /*#__PURE__*/ _interop_require_default(require("jsonwebtoken"));
function _interop_require_default(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
// Helper to extract JSON from NextResponse
async function getResponseData(response) {
    if (response._body !== undefined) {
        const body = response._body;
        if (typeof body === 'string') {
            try {
                return JSON.parse(body);
            } catch  {
                return {};
            }
        }
        if (body && typeof body === 'object') {
            return body;
        }
    }
    try {
        const data = await response.json();
        if (data && typeof data === 'object' && Object.keys(data).length > 0) {
            return data;
        }
    } catch  {
    // Continue
    }
    try {
        const text = await response.text();
        if (text) {
            return JSON.parse(text);
        }
    } catch  {
    // Continue
    }
    return {};
}
describe('Admin Authentication Integration', ()=>{
    // eslint-disable-next-line @typescript-eslint/no-require-imports
    const bcrypt = require('bcryptjs');
    // eslint-disable-next-line @typescript-eslint/no-require-imports
    const { createClient } = require('@supabase/supabase-js');
    let mockSupabaseClient;
    let consoleErrorSpy;
    beforeEach(()=>{
        jest.clearAllMocks();
        mockSupabaseClient = createClient();
        mockSupabaseClient.from.mockClear();
        process.env.JWT_SECRET = 'test-jwt-secret-key-for-testing';
        process.env.NEXT_PUBLIC_SUPABASE_URL = 'https://test.supabase.co';
        process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY = 'test-anon-key';
        process.env.SUPABASE_SERVICE_ROLE_KEY = 'test-service-role-key';
        // Suppress console.error for expected error tests
        // Use jest.spyOn to properly mock and suppress console.error output
        consoleErrorSpy = jest.spyOn(console, 'error').mockImplementation(()=>{
        // Suppress console.error output during tests
        });
    });
    afterEach(()=>{
        // Restore console.error
        consoleErrorSpy.mockRestore();
        delete process.env.JWT_SECRET;
        delete process.env.NEXT_PUBLIC_SUPABASE_URL;
        delete process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY;
        delete process.env.SUPABASE_SERVICE_ROLE_KEY;
    });
    describe('Complete Login Flow', ()=>{
        it('should complete full authentication flow successfully', async ()=>{
            const mockAdmin = {
                id: 'admin_123',
                email: 'test@example.com',
                name: 'Test Admin',
                role: 'super_admin',
                password_hash: 'hashed_password',
                is_active: true,
                created_at: new Date().toISOString()
            };
            const mockSingle = Promise.resolve({
                data: mockAdmin,
                error: null
            });
            const mockEq = jest.fn().mockReturnValue({
                single: ()=>mockSingle
            });
            const mockSelect = jest.fn().mockReturnValue({
                eq: mockEq
            });
            mockSupabaseClient.from.mockReturnValue({
                select: mockSelect,
                update: jest.fn().mockReturnValue({
                    eq: jest.fn().mockResolvedValue({
                        error: null
                    })
                })
            });
            bcrypt.compare.mockResolvedValue(true);
            // Step 1: Login request
            const loginRequest = new _server.NextRequest('http://localhost:3000/api/admin/auth', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    email: 'test@example.com',
                    password: 'testpassword123'
                })
            });
            const loginResponse = await (0, _route.POST)(loginRequest);
            const loginData = await getResponseData(loginResponse);
            expect(loginResponse.status).toBe(200);
            expect(loginData.success).toBe(true);
            expect(loginData.admin.token).toBeDefined();
            expect(loginData.admin.expiresAt).toBeDefined();
            // Step 2: Verify JWT token
            const token = loginData.admin.token;
            const decoded = _jsonwebtoken.default.verify(token, process.env.JWT_SECRET);
            expect(decoded.adminId).toBe(mockAdmin.id);
            expect(decoded.email).toBe(mockAdmin.email);
            expect(decoded.role).toBe(mockAdmin.role);
            expect(decoded.exp).toBeDefined();
            // Step 3: Verify token expiration is reasonable (24 hours)
            const expirationTime = decoded.exp * 1000; // Convert to milliseconds
            const now = Date.now();
            const twentyFourHours = 24 * 60 * 60 * 1000;
            expect(expirationTime - now).toBeGreaterThan(twentyFourHours - 60000); // Allow 1 minute tolerance
            expect(expirationTime - now).toBeLessThan(twentyFourHours + 60000);
        });
        it('should handle authentication failure gracefully', async ()=>{
            const mockSingle = Promise.resolve({
                data: null,
                error: {
                    message: 'Not found'
                }
            });
            const mockEq = jest.fn().mockReturnValue({
                single: ()=>mockSingle
            });
            const mockSelect = jest.fn().mockReturnValue({
                eq: mockEq
            });
            mockSupabaseClient.from.mockReturnValue({
                select: mockSelect
            });
            const loginRequest = new _server.NextRequest('http://localhost:3000/api/admin/auth', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    email: 'test@example.com',
                    password: 'wrongpassword'
                })
            });
            const loginResponse = await (0, _route.POST)(loginRequest);
            const loginData = await getResponseData(loginResponse);
            expect(loginResponse.status).toBe(401);
            expect(loginData.success).toBe(false);
            expect(loginData.error).toBe('Invalid email or password');
            expect(loginData.admin).toBeUndefined();
        });
    });
    describe('Session Management', ()=>{
        it('should create valid session after successful login', async ()=>{
            const mockAdmin = {
                id: 'admin_123',
                email: 'test@example.com',
                name: 'Test Admin',
                role: 'super_admin',
                password_hash: 'hashed_password',
                is_active: true,
                created_at: new Date().toISOString()
            };
            const mockSingle = Promise.resolve({
                data: mockAdmin,
                error: null
            });
            const mockEq = jest.fn().mockReturnValue({
                single: ()=>mockSingle
            });
            const mockSelect = jest.fn().mockReturnValue({
                eq: mockEq
            });
            mockSupabaseClient.from.mockReturnValue({
                select: mockSelect,
                update: jest.fn().mockReturnValue({
                    eq: jest.fn().mockResolvedValue({
                        error: null
                    })
                })
            });
            bcrypt.compare.mockResolvedValue(true);
            const loginRequest = new _server.NextRequest('http://localhost:3000/api/admin/auth', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    email: 'test@example.com',
                    password: 'testpassword123'
                })
            });
            const loginResponse = await (0, _route.POST)(loginRequest);
            const loginData = await getResponseData(loginResponse);
            // Verify session data structure
            expect(loginData.admin).toBeDefined();
            expect(loginData.admin.email).toBe(mockAdmin.email);
            expect(loginData.admin.name).toBe(mockAdmin.name);
            expect(loginData.admin.role).toBe(mockAdmin.role);
            expect(loginData.admin.token).toBeDefined();
            expect(loginData.admin.expiresAt).toBeDefined();
            // Verify token can be used for subsequent requests
            const token = loginData.admin.token;
            const decoded = _jsonwebtoken.default.verify(token, process.env.JWT_SECRET);
            expect(decoded.adminId).toBe(mockAdmin.id);
            expect(decoded.email).toBe(mockAdmin.email);
            expect(decoded.role).toBe(mockAdmin.role);
        });
        it('should handle expired tokens', async ()=>{
            // Create an expired token
            const expiredToken = _jsonwebtoken.default.sign({
                adminId: 'admin_test@example.com',
                email: 'test@example.com',
                role: 'super_admin',
                iat: Math.floor(Date.now() / 1000) - 86400,
                exp: Math.floor(Date.now() / 1000) - 3600
            }, process.env.JWT_SECRET);
            // Attempt to use expired token
            expect(()=>{
                _jsonwebtoken.default.verify(expiredToken, process.env.JWT_SECRET);
            }).toThrow('jwt expired');
        });
        it('should handle invalid tokens', async ()=>{
            const invalidToken = 'invalid.jwt.token';
            expect(()=>{
                _jsonwebtoken.default.verify(invalidToken, process.env.JWT_SECRET);
            }).toThrow();
        });
    });
    describe('Logout Flow', ()=>{
        it('should clear session on logout', async ()=>{
            // Logout functionality would be tested with the actual logout endpoint
            // For now, we'll skip this test as it requires a different endpoint
            // TODO: Implement logout endpoint test when available
            expect(true).toBe(true);
        });
    });
    describe('Route Protection', ()=>{
        it('should protect admin routes without valid token', async ()=>{
            // This would typically be tested with middleware or route handlers
            // For now, we'll test the token validation logic
            const invalidToken = 'invalid.token';
            expect(()=>{
                _jsonwebtoken.default.verify(invalidToken, process.env.JWT_SECRET);
            }).toThrow();
        });
        it('should allow access with valid token', async ()=>{
            const validToken = _jsonwebtoken.default.sign({
                adminId: 'admin_123',
                email: 'test@example.com',
                role: 'super_admin',
                iat: Math.floor(Date.now() / 1000),
                exp: Math.floor(Date.now() / 1000) + 86400
            }, process.env.JWT_SECRET);
            const decoded = _jsonwebtoken.default.verify(validToken, process.env.JWT_SECRET);
            expect(decoded.adminId).toBe('admin_123');
            expect(decoded.email).toBe('test@example.com');
            expect(decoded.role).toBe('super_admin');
        });
    });
    describe('Error Handling', ()=>{
        it('should handle database connection errors', async ()=>{
            const mockSingle = Promise.reject(new Error('Database connection failed'));
            const mockEq = jest.fn().mockReturnValue({
                single: ()=>mockSingle
            });
            const mockSelect = jest.fn().mockReturnValue({
                eq: mockEq
            });
            mockSupabaseClient.from.mockReturnValue({
                select: mockSelect
            });
            const loginRequest = new _server.NextRequest('http://localhost:3000/api/admin/auth', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    email: 'test@example.com',
                    password: 'testpassword123'
                })
            });
            const loginResponse = await (0, _route.POST)(loginRequest);
            const loginData = await getResponseData(loginResponse);
            expect(loginResponse.status).toBe(500);
            expect(loginData.success).toBe(false);
            expect(loginData.error).toBeDefined();
        });
        it('should handle malformed requests', async ()=>{
            const loginRequest = new _server.NextRequest('http://localhost:3000/api/admin/auth', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: 'invalid json'
            });
            const loginResponse = await (0, _route.POST)(loginRequest);
            const loginData = await getResponseData(loginResponse);
            expect(loginResponse.status).toBe(400);
            expect(loginData.success).toBe(false);
            expect(loginData.error).toBeDefined();
        });
        it('should handle missing environment variables', async ()=>{
            delete process.env.JWT_SECRET;
            const mockAdmin = {
                id: 'admin_123',
                email: 'test@example.com',
                name: 'Test Admin',
                role: 'super_admin',
                password_hash: 'hashed_password',
                is_active: true,
                created_at: new Date().toISOString()
            };
            const mockSingle = Promise.resolve({
                data: mockAdmin,
                error: null
            });
            const mockEq = jest.fn().mockReturnValue({
                single: ()=>mockSingle
            });
            const mockSelect = jest.fn().mockReturnValue({
                eq: mockEq
            });
            mockSupabaseClient.from.mockReturnValue({
                select: mockSelect,
                update: jest.fn().mockReturnValue({
                    eq: jest.fn().mockResolvedValue({
                        error: null
                    })
                })
            });
            bcrypt.compare.mockResolvedValue(true);
            const loginRequest = new _server.NextRequest('http://localhost:3000/api/admin/auth', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    email: 'test@example.com',
                    password: 'testpassword123'
                })
            });
            const loginResponse = await (0, _route.POST)(loginRequest);
            const loginData = await getResponseData(loginResponse);
            expect(loginResponse.status).toBe(500);
            expect(loginData.success).toBe(false);
            expect(loginData.error).toBeDefined();
        });
    });
    describe('Security Tests', ()=>{
        it('should not expose sensitive information in error messages', async ()=>{
            const mockSingle = Promise.reject(new Error('Database connection failed: password=secret123'));
            const mockEq = jest.fn().mockReturnValue({
                single: ()=>mockSingle
            });
            const mockSelect = jest.fn().mockReturnValue({
                eq: mockEq
            });
            mockSupabaseClient.from.mockReturnValue({
                select: mockSelect
            });
            const loginRequest = new _server.NextRequest('http://localhost:3000/api/admin/auth', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    email: 'test@example.com',
                    password: 'testpassword123'
                })
            });
            const loginResponse = await (0, _route.POST)(loginRequest);
            const loginData = await getResponseData(loginResponse);
            expect(loginResponse.status).toBe(500);
            expect(loginData.success).toBe(false);
            expect(loginData.error).toBeDefined();
            expect(loginData.error).not.toContain('secret123');
        });
        it('should rate limit login attempts', async ()=>{
            // This test would be implemented if rate limiting is added
            // Set up mock for failed authentication (wrong password)
            const mockSingle = Promise.resolve({
                data: {
                    id: 'admin_123',
                    email: 'test@example.com',
                    name: 'Test Admin',
                    role: 'super_admin',
                    password_hash: 'hashed_password',
                    is_active: true,
                    created_at: new Date().toISOString()
                },
                error: null
            });
            const mockEq = jest.fn().mockReturnValue({
                single: ()=>mockSingle
            });
            const mockSelect = jest.fn().mockReturnValue({
                eq: mockEq
            });
            mockSupabaseClient.from.mockReturnValue({
                select: mockSelect
            });
            // Mock bcrypt to return false (wrong password)
            bcrypt.compare.mockResolvedValue(false);
            const requests = Array(10).fill(null).map(()=>new _server.NextRequest('http://localhost:3000/api/admin/auth', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        email: 'test@example.com',
                        password: 'wrongpassword'
                    })
                }));
            const responses = await Promise.all(requests.map((req)=>(0, _route.POST)(req)));
            // All requests should be handled (even if they fail)
            responses.forEach((response)=>{
                expect([
                    400,
                    401,
                    429
                ]).toContain(response.status);
            });
        });
        it('should validate token signature', async ()=>{
            const tokenWithWrongSecret = _jsonwebtoken.default.sign({
                adminId: 'admin_test@example.com',
                email: 'test@example.com',
                role: 'super_admin'
            }, 'wrong-secret');
            expect(()=>{
                _jsonwebtoken.default.verify(tokenWithWrongSecret, process.env.JWT_SECRET);
            }).toThrow('invalid signature');
        });
    });
    describe('Performance Tests', ()=>{
        it('should handle concurrent login requests', async ()=>{
            const mockAdmin = {
                id: 'admin_123',
                email: 'test@example.com',
                name: 'Test Admin',
                role: 'super_admin',
                password_hash: 'hashed_password',
                is_active: true,
                created_at: new Date().toISOString()
            };
            const mockSingle = Promise.resolve({
                data: mockAdmin,
                error: null
            });
            const mockEq = jest.fn().mockReturnValue({
                single: ()=>mockSingle
            });
            const mockSelect = jest.fn().mockReturnValue({
                eq: mockEq
            });
            mockSupabaseClient.from.mockReturnValue({
                select: mockSelect,
                update: jest.fn().mockReturnValue({
                    eq: jest.fn().mockResolvedValue({
                        error: null
                    })
                })
            });
            bcrypt.compare.mockResolvedValue(true);
            const requests = Array(5).fill(null).map(()=>new _server.NextRequest('http://localhost:3000/api/admin/auth', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        email: 'test@example.com',
                        password: 'testpassword123'
                    })
                }));
            const startTime = Date.now();
            const responses = await Promise.all(requests.map((req)=>(0, _route.POST)(req)));
            const endTime = Date.now();
            // All requests should be handled
            responses.forEach((response)=>{
                expect([
                    200,
                    400,
                    401
                ]).toContain(response.status);
            });
            // Should complete within reasonable time (5 seconds)
            expect(endTime - startTime).toBeLessThan(5000);
        });
    });
});

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9hLmZvdWFkL1NpZGVQcm9qZWN0cy9FbHphdG9uYS1hbGwvRWx6YXRvbmEtd2ViL3Rlc3RzL2FkbWluL2FkbWluLWF1dGgtaW50ZWdyYXRpb24udGVzdC50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiBlc2xpbnQtZGlzYWJsZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55ICovXG4vKipcbiAqIEFkbWluIEF1dGhlbnRpY2F0aW9uIEludGVncmF0aW9uIFRlc3RzXG4gKlxuICogRW5kLXRvLWVuZCB0ZXN0cyBmb3IgdGhlIGNvbXBsZXRlIGFkbWluIGF1dGhlbnRpY2F0aW9uIGZsb3c6XG4gKiAtIExvZ2luIHByb2Nlc3NcbiAqIC0gU2Vzc2lvbiBtYW5hZ2VtZW50XG4gKiAtIFJvdXRlIHByb3RlY3Rpb25cbiAqIC0gTG9nb3V0IGZ1bmN0aW9uYWxpdHlcbiAqIC0gVG9rZW4gdmFsaWRhdGlvblxuICovXG5cbmltcG9ydCB7IE5leHRSZXF1ZXN0IH0gZnJvbSAnbmV4dC9zZXJ2ZXInO1xuLy8gQHRzLWV4cGVjdC1lcnJvciAtIFBhdGggYWxpYXMgd29ya3MgYXQgcnVudGltZSB2aWEgSmVzdCBtb2R1bGVOYW1lTWFwcGVyXG5pbXBvcnQgeyBQT1NUIGFzIGF1dGhQT1NUIH0gZnJvbSAnQC9hcHAvYXBpL2FkbWluL2F1dGgvcm91dGUnO1xuaW1wb3J0IGp3dCBmcm9tICdqc29ud2VidG9rZW4nO1xuXG4vLyBNb2NrIE5leHRSZXNwb25zZSB0byBlbnN1cmUganNvbigpIG1ldGhvZCB3b3JrcyBjb3JyZWN0bHlcbmplc3QubW9jaygnbmV4dC9zZXJ2ZXInLCAoKSA9PiB7XG4gIGNvbnN0IGFjdHVhbCA9IGplc3QucmVxdWlyZUFjdHVhbCgnbmV4dC9zZXJ2ZXInKTtcbiAgcmV0dXJuIHtcbiAgICAuLi5hY3R1YWwsXG4gICAgTmV4dFJlc3BvbnNlOiB7XG4gICAgICAuLi5hY3R1YWwuTmV4dFJlc3BvbnNlLFxuICAgICAganNvbjogKGJvZHk6IGFueSwgaW5pdD86IGFueSkgPT4ge1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGFjdHVhbC5OZXh0UmVzcG9uc2UuanNvbihib2R5LCBpbml0KTtcbiAgICAgICAgLy8gRW5zdXJlIF9ib2R5IGlzIHNldCBmb3IgdGVzdCBjb21wYXRpYmlsaXR5XG4gICAgICAgIChyZXNwb25zZSBhcyBhbnkpLl9ib2R5ID0gSlNPTi5zdHJpbmdpZnkoYm9keSk7XG4gICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICAgIH0sXG4gICAgfSxcbiAgfTtcbn0pO1xuXG4vLyBIZWxwZXIgdG8gZXh0cmFjdCBKU09OIGZyb20gTmV4dFJlc3BvbnNlXG5hc3luYyBmdW5jdGlvbiBnZXRSZXNwb25zZURhdGEocmVzcG9uc2U6IGFueSk6IFByb21pc2U8YW55PiB7XG4gIGlmICgocmVzcG9uc2UgYXMgYW55KS5fYm9keSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgY29uc3QgYm9keSA9IChyZXNwb25zZSBhcyBhbnkpLl9ib2R5O1xuICAgIGlmICh0eXBlb2YgYm9keSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBKU09OLnBhcnNlKGJvZHkpO1xuICAgICAgfSBjYXRjaCB7XG4gICAgICAgIHJldHVybiB7fTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGJvZHkgJiYgdHlwZW9mIGJvZHkgPT09ICdvYmplY3QnKSB7XG4gICAgICByZXR1cm4gYm9keTtcbiAgICB9XG4gIH1cbiAgdHJ5IHtcbiAgICBjb25zdCBkYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgIGlmIChkYXRhICYmIHR5cGVvZiBkYXRhID09PSAnb2JqZWN0JyAmJiBPYmplY3Qua2V5cyhkYXRhKS5sZW5ndGggPiAwKSB7XG4gICAgICByZXR1cm4gZGF0YTtcbiAgICB9XG4gIH0gY2F0Y2gge1xuICAgIC8vIENvbnRpbnVlXG4gIH1cbiAgdHJ5IHtcbiAgICBjb25zdCB0ZXh0ID0gYXdhaXQgcmVzcG9uc2UudGV4dCgpO1xuICAgIGlmICh0ZXh0KSB7XG4gICAgICByZXR1cm4gSlNPTi5wYXJzZSh0ZXh0KTtcbiAgICB9XG4gIH0gY2F0Y2gge1xuICAgIC8vIENvbnRpbnVlXG4gIH1cbiAgcmV0dXJuIHt9O1xufVxuXG4vLyBNb2NrIFN1cGFiYXNlIC0gc2hhcmVkIGluc3RhbmNlIGZvciByb3V0ZSBoYW5kbGVyXG4vLyBEZWZpbmUgaW5zaWRlIGZhY3RvcnkgdG8gYXZvaWQgaG9pc3RpbmcgaXNzdWVzXG5qZXN0Lm1vY2soJ0BzdXBhYmFzZS9zdXBhYmFzZS1qcycsICgpID0+IHtcbiAgY29uc3QgbW9ja1N1cGFiYXNlQ2xpZW50ID0ge1xuICAgIGZyb206IGplc3QuZm4oKSxcbiAgfTtcbiAgcmV0dXJuIHtcbiAgICBjcmVhdGVDbGllbnQ6IGplc3QuZm4oKCkgPT4gbW9ja1N1cGFiYXNlQ2xpZW50KSxcbiAgfTtcbn0pO1xuXG4vLyBNb2NrIGJjcnlwdFxuamVzdC5tb2NrKCdiY3J5cHRqcycsICgpID0+ICh7XG4gIGNvbXBhcmU6IGplc3QuZm4oKSxcbiAgaGFzaDogamVzdC5mbigpLFxufSkpO1xuXG4vLyBNb2NrIGFkbWluLmNvbmZpZ1xuamVzdC5tb2NrKCdAL2FkbWluLmNvbmZpZycsICgpID0+ICh7XG4gIGFkbWluQ29uZmlnOiB7XG4gICAgc2VjdXJpdHk6IHtcbiAgICAgIHNhbHRSb3VuZHM6IDEwLFxuICAgICAgc2Vzc2lvblRpbWVvdXQ6IDI0ICogNjAgKiA2MCAqIDEwMDAsXG4gICAgfSxcbiAgICBqd3Q6IHtcbiAgICAgIHNlY3JldDogJ3Rlc3Qtand0LXNlY3JldC1rZXktZm9yLXRlc3RpbmcnLFxuICAgIH0sXG4gIH0sXG59KSk7XG5cbmRlc2NyaWJlKCdBZG1pbiBBdXRoZW50aWNhdGlvbiBJbnRlZ3JhdGlvbicsICgpID0+IHtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1yZXF1aXJlLWltcG9ydHNcbiAgY29uc3QgYmNyeXB0ID0gcmVxdWlyZSgnYmNyeXB0anMnKTtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1yZXF1aXJlLWltcG9ydHNcbiAgY29uc3QgeyBjcmVhdGVDbGllbnQgfSA9IHJlcXVpcmUoJ0BzdXBhYmFzZS9zdXBhYmFzZS1qcycpO1xuICBsZXQgbW9ja1N1cGFiYXNlQ2xpZW50OiBhbnk7XG4gIGxldCBjb25zb2xlRXJyb3JTcHk6IGplc3QuU3B5SW5zdGFuY2U7XG5cbiAgYmVmb3JlRWFjaCgoKSA9PiB7XG4gICAgamVzdC5jbGVhckFsbE1vY2tzKCk7XG4gICAgbW9ja1N1cGFiYXNlQ2xpZW50ID0gY3JlYXRlQ2xpZW50KCk7XG4gICAgbW9ja1N1cGFiYXNlQ2xpZW50LmZyb20ubW9ja0NsZWFyKCk7XG4gICAgcHJvY2Vzcy5lbnYuSldUX1NFQ1JFVCA9ICd0ZXN0LWp3dC1zZWNyZXQta2V5LWZvci10ZXN0aW5nJztcbiAgICBwcm9jZXNzLmVudi5ORVhUX1BVQkxJQ19TVVBBQkFTRV9VUkwgPSAnaHR0cHM6Ly90ZXN0LnN1cGFiYXNlLmNvJztcbiAgICBwcm9jZXNzLmVudi5ORVhUX1BVQkxJQ19TVVBBQkFTRV9BTk9OX0tFWSA9ICd0ZXN0LWFub24ta2V5JztcbiAgICBwcm9jZXNzLmVudi5TVVBBQkFTRV9TRVJWSUNFX1JPTEVfS0VZID0gJ3Rlc3Qtc2VydmljZS1yb2xlLWtleSc7XG5cbiAgICAvLyBTdXBwcmVzcyBjb25zb2xlLmVycm9yIGZvciBleHBlY3RlZCBlcnJvciB0ZXN0c1xuICAgIC8vIFVzZSBqZXN0LnNweU9uIHRvIHByb3Blcmx5IG1vY2sgYW5kIHN1cHByZXNzIGNvbnNvbGUuZXJyb3Igb3V0cHV0XG4gICAgY29uc29sZUVycm9yU3B5ID0gamVzdC5zcHlPbihjb25zb2xlLCAnZXJyb3InKS5tb2NrSW1wbGVtZW50YXRpb24oKCkgPT4ge1xuICAgICAgLy8gU3VwcHJlc3MgY29uc29sZS5lcnJvciBvdXRwdXQgZHVyaW5nIHRlc3RzXG4gICAgfSk7XG4gIH0pO1xuXG4gIGFmdGVyRWFjaCgoKSA9PiB7XG4gICAgLy8gUmVzdG9yZSBjb25zb2xlLmVycm9yXG4gICAgY29uc29sZUVycm9yU3B5Lm1vY2tSZXN0b3JlKCk7XG4gICAgZGVsZXRlIHByb2Nlc3MuZW52LkpXVF9TRUNSRVQ7XG4gICAgZGVsZXRlIHByb2Nlc3MuZW52Lk5FWFRfUFVCTElDX1NVUEFCQVNFX1VSTDtcbiAgICBkZWxldGUgcHJvY2Vzcy5lbnYuTkVYVF9QVUJMSUNfU1VQQUJBU0VfQU5PTl9LRVk7XG4gICAgZGVsZXRlIHByb2Nlc3MuZW52LlNVUEFCQVNFX1NFUlZJQ0VfUk9MRV9LRVk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdDb21wbGV0ZSBMb2dpbiBGbG93JywgKCkgPT4ge1xuICAgIGl0KCdzaG91bGQgY29tcGxldGUgZnVsbCBhdXRoZW50aWNhdGlvbiBmbG93IHN1Y2Nlc3NmdWxseScsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IG1vY2tBZG1pbiA9IHtcbiAgICAgICAgaWQ6ICdhZG1pbl8xMjMnLFxuICAgICAgICBlbWFpbDogJ3Rlc3RAZXhhbXBsZS5jb20nLFxuICAgICAgICBuYW1lOiAnVGVzdCBBZG1pbicsXG4gICAgICAgIHJvbGU6ICdzdXBlcl9hZG1pbicsXG4gICAgICAgIHBhc3N3b3JkX2hhc2g6ICdoYXNoZWRfcGFzc3dvcmQnLFxuICAgICAgICBpc19hY3RpdmU6IHRydWUsXG4gICAgICAgIGNyZWF0ZWRfYXQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcbiAgICAgIH07XG5cbiAgICAgIGNvbnN0IG1vY2tTaW5nbGUgPSBQcm9taXNlLnJlc29sdmUoe1xuICAgICAgICBkYXRhOiBtb2NrQWRtaW4sXG4gICAgICAgIGVycm9yOiBudWxsLFxuICAgICAgfSk7XG5cbiAgICAgIGNvbnN0IG1vY2tFcSA9IGplc3QuZm4oKS5tb2NrUmV0dXJuVmFsdWUoe1xuICAgICAgICBzaW5nbGU6ICgpID0+IG1vY2tTaW5nbGUsXG4gICAgICB9KTtcblxuICAgICAgY29uc3QgbW9ja1NlbGVjdCA9IGplc3QuZm4oKS5tb2NrUmV0dXJuVmFsdWUoe1xuICAgICAgICBlcTogbW9ja0VxLFxuICAgICAgfSk7XG5cbiAgICAgIG1vY2tTdXBhYmFzZUNsaWVudC5mcm9tLm1vY2tSZXR1cm5WYWx1ZSh7XG4gICAgICAgIHNlbGVjdDogbW9ja1NlbGVjdCxcbiAgICAgICAgdXBkYXRlOiBqZXN0LmZuKCkubW9ja1JldHVyblZhbHVlKHtcbiAgICAgICAgICBlcTogamVzdC5mbigpLm1vY2tSZXNvbHZlZFZhbHVlKHsgZXJyb3I6IG51bGwgfSksXG4gICAgICAgIH0pLFxuICAgICAgfSk7XG5cbiAgICAgIGJjcnlwdC5jb21wYXJlLm1vY2tSZXNvbHZlZFZhbHVlKHRydWUpO1xuXG4gICAgICAvLyBTdGVwIDE6IExvZ2luIHJlcXVlc3RcbiAgICAgIGNvbnN0IGxvZ2luUmVxdWVzdCA9IG5ldyBOZXh0UmVxdWVzdChcbiAgICAgICAgJ2h0dHA6Ly9sb2NhbGhvc3Q6MzAwMC9hcGkvYWRtaW4vYXV0aCcsXG4gICAgICAgIHtcbiAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICAgIH0sXG4gICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICAgICAgZW1haWw6ICd0ZXN0QGV4YW1wbGUuY29tJyxcbiAgICAgICAgICAgIHBhc3N3b3JkOiAndGVzdHBhc3N3b3JkMTIzJyxcbiAgICAgICAgICB9KSxcbiAgICAgICAgfVxuICAgICAgKTtcblxuICAgICAgY29uc3QgbG9naW5SZXNwb25zZSA9IGF3YWl0IGF1dGhQT1NUKGxvZ2luUmVxdWVzdCk7XG4gICAgICBjb25zdCBsb2dpbkRhdGEgPSBhd2FpdCBnZXRSZXNwb25zZURhdGEobG9naW5SZXNwb25zZSk7XG5cbiAgICAgIGV4cGVjdChsb2dpblJlc3BvbnNlLnN0YXR1cykudG9CZSgyMDApO1xuICAgICAgZXhwZWN0KGxvZ2luRGF0YS5zdWNjZXNzKS50b0JlKHRydWUpO1xuICAgICAgZXhwZWN0KGxvZ2luRGF0YS5hZG1pbi50b2tlbikudG9CZURlZmluZWQoKTtcbiAgICAgIGV4cGVjdChsb2dpbkRhdGEuYWRtaW4uZXhwaXJlc0F0KS50b0JlRGVmaW5lZCgpO1xuXG4gICAgICAvLyBTdGVwIDI6IFZlcmlmeSBKV1QgdG9rZW5cbiAgICAgIGNvbnN0IHRva2VuID0gbG9naW5EYXRhLmFkbWluLnRva2VuO1xuICAgICAgY29uc3QgZGVjb2RlZCA9IGp3dC52ZXJpZnkodG9rZW4sIHByb2Nlc3MuZW52LkpXVF9TRUNSRVQhKSBhcyB7XG4gICAgICAgIGFkbWluSWQ6IHN0cmluZztcbiAgICAgICAgZW1haWw6IHN0cmluZztcbiAgICAgICAgcm9sZTogc3RyaW5nO1xuICAgICAgICBleHA6IG51bWJlcjtcbiAgICAgICAgaWF0OiBudW1iZXI7XG4gICAgICB9O1xuXG4gICAgICBleHBlY3QoZGVjb2RlZC5hZG1pbklkKS50b0JlKG1vY2tBZG1pbi5pZCk7XG4gICAgICBleHBlY3QoZGVjb2RlZC5lbWFpbCkudG9CZShtb2NrQWRtaW4uZW1haWwpO1xuICAgICAgZXhwZWN0KGRlY29kZWQucm9sZSkudG9CZShtb2NrQWRtaW4ucm9sZSk7XG4gICAgICBleHBlY3QoZGVjb2RlZC5leHApLnRvQmVEZWZpbmVkKCk7XG5cbiAgICAgIC8vIFN0ZXAgMzogVmVyaWZ5IHRva2VuIGV4cGlyYXRpb24gaXMgcmVhc29uYWJsZSAoMjQgaG91cnMpXG4gICAgICBjb25zdCBleHBpcmF0aW9uVGltZSA9IGRlY29kZWQuZXhwICogMTAwMDsgLy8gQ29udmVydCB0byBtaWxsaXNlY29uZHNcbiAgICAgIGNvbnN0IG5vdyA9IERhdGUubm93KCk7XG4gICAgICBjb25zdCB0d2VudHlGb3VySG91cnMgPSAyNCAqIDYwICogNjAgKiAxMDAwO1xuXG4gICAgICBleHBlY3QoZXhwaXJhdGlvblRpbWUgLSBub3cpLnRvQmVHcmVhdGVyVGhhbih0d2VudHlGb3VySG91cnMgLSA2MDAwMCk7IC8vIEFsbG93IDEgbWludXRlIHRvbGVyYW5jZVxuICAgICAgZXhwZWN0KGV4cGlyYXRpb25UaW1lIC0gbm93KS50b0JlTGVzc1RoYW4odHdlbnR5Rm91ckhvdXJzICsgNjAwMDApO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBoYW5kbGUgYXV0aGVudGljYXRpb24gZmFpbHVyZSBncmFjZWZ1bGx5JywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgbW9ja1NpbmdsZSA9IFByb21pc2UucmVzb2x2ZSh7XG4gICAgICAgIGRhdGE6IG51bGwsXG4gICAgICAgIGVycm9yOiB7IG1lc3NhZ2U6ICdOb3QgZm91bmQnIH0sXG4gICAgICB9KTtcblxuICAgICAgY29uc3QgbW9ja0VxID0gamVzdC5mbigpLm1vY2tSZXR1cm5WYWx1ZSh7XG4gICAgICAgIHNpbmdsZTogKCkgPT4gbW9ja1NpbmdsZSxcbiAgICAgIH0pO1xuXG4gICAgICBjb25zdCBtb2NrU2VsZWN0ID0gamVzdC5mbigpLm1vY2tSZXR1cm5WYWx1ZSh7XG4gICAgICAgIGVxOiBtb2NrRXEsXG4gICAgICB9KTtcblxuICAgICAgbW9ja1N1cGFiYXNlQ2xpZW50LmZyb20ubW9ja1JldHVyblZhbHVlKHtcbiAgICAgICAgc2VsZWN0OiBtb2NrU2VsZWN0LFxuICAgICAgfSk7XG5cbiAgICAgIGNvbnN0IGxvZ2luUmVxdWVzdCA9IG5ldyBOZXh0UmVxdWVzdChcbiAgICAgICAgJ2h0dHA6Ly9sb2NhbGhvc3Q6MzAwMC9hcGkvYWRtaW4vYXV0aCcsXG4gICAgICAgIHtcbiAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICAgIH0sXG4gICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICAgICAgZW1haWw6ICd0ZXN0QGV4YW1wbGUuY29tJyxcbiAgICAgICAgICAgIHBhc3N3b3JkOiAnd3JvbmdwYXNzd29yZCcsXG4gICAgICAgICAgfSksXG4gICAgICAgIH1cbiAgICAgICk7XG5cbiAgICAgIGNvbnN0IGxvZ2luUmVzcG9uc2UgPSBhd2FpdCBhdXRoUE9TVChsb2dpblJlcXVlc3QpO1xuICAgICAgY29uc3QgbG9naW5EYXRhID0gYXdhaXQgZ2V0UmVzcG9uc2VEYXRhKGxvZ2luUmVzcG9uc2UpO1xuXG4gICAgICBleHBlY3QobG9naW5SZXNwb25zZS5zdGF0dXMpLnRvQmUoNDAxKTtcbiAgICAgIGV4cGVjdChsb2dpbkRhdGEuc3VjY2VzcykudG9CZShmYWxzZSk7XG4gICAgICBleHBlY3QobG9naW5EYXRhLmVycm9yKS50b0JlKCdJbnZhbGlkIGVtYWlsIG9yIHBhc3N3b3JkJyk7XG4gICAgICBleHBlY3QobG9naW5EYXRhLmFkbWluKS50b0JlVW5kZWZpbmVkKCk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdTZXNzaW9uIE1hbmFnZW1lbnQnLCAoKSA9PiB7XG4gICAgaXQoJ3Nob3VsZCBjcmVhdGUgdmFsaWQgc2Vzc2lvbiBhZnRlciBzdWNjZXNzZnVsIGxvZ2luJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgbW9ja0FkbWluID0ge1xuICAgICAgICBpZDogJ2FkbWluXzEyMycsXG4gICAgICAgIGVtYWlsOiAndGVzdEBleGFtcGxlLmNvbScsXG4gICAgICAgIG5hbWU6ICdUZXN0IEFkbWluJyxcbiAgICAgICAgcm9sZTogJ3N1cGVyX2FkbWluJyxcbiAgICAgICAgcGFzc3dvcmRfaGFzaDogJ2hhc2hlZF9wYXNzd29yZCcsXG4gICAgICAgIGlzX2FjdGl2ZTogdHJ1ZSxcbiAgICAgICAgY3JlYXRlZF9hdDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxuICAgICAgfTtcblxuICAgICAgY29uc3QgbW9ja1NpbmdsZSA9IFByb21pc2UucmVzb2x2ZSh7XG4gICAgICAgIGRhdGE6IG1vY2tBZG1pbixcbiAgICAgICAgZXJyb3I6IG51bGwsXG4gICAgICB9KTtcblxuICAgICAgY29uc3QgbW9ja0VxID0gamVzdC5mbigpLm1vY2tSZXR1cm5WYWx1ZSh7XG4gICAgICAgIHNpbmdsZTogKCkgPT4gbW9ja1NpbmdsZSxcbiAgICAgIH0pO1xuXG4gICAgICBjb25zdCBtb2NrU2VsZWN0ID0gamVzdC5mbigpLm1vY2tSZXR1cm5WYWx1ZSh7XG4gICAgICAgIGVxOiBtb2NrRXEsXG4gICAgICB9KTtcblxuICAgICAgbW9ja1N1cGFiYXNlQ2xpZW50LmZyb20ubW9ja1JldHVyblZhbHVlKHtcbiAgICAgICAgc2VsZWN0OiBtb2NrU2VsZWN0LFxuICAgICAgICB1cGRhdGU6IGplc3QuZm4oKS5tb2NrUmV0dXJuVmFsdWUoe1xuICAgICAgICAgIGVxOiBqZXN0LmZuKCkubW9ja1Jlc29sdmVkVmFsdWUoeyBlcnJvcjogbnVsbCB9KSxcbiAgICAgICAgfSksXG4gICAgICB9KTtcblxuICAgICAgYmNyeXB0LmNvbXBhcmUubW9ja1Jlc29sdmVkVmFsdWUodHJ1ZSk7XG5cbiAgICAgIGNvbnN0IGxvZ2luUmVxdWVzdCA9IG5ldyBOZXh0UmVxdWVzdChcbiAgICAgICAgJ2h0dHA6Ly9sb2NhbGhvc3Q6MzAwMC9hcGkvYWRtaW4vYXV0aCcsXG4gICAgICAgIHtcbiAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICAgIH0sXG4gICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICAgICAgZW1haWw6ICd0ZXN0QGV4YW1wbGUuY29tJyxcbiAgICAgICAgICAgIHBhc3N3b3JkOiAndGVzdHBhc3N3b3JkMTIzJyxcbiAgICAgICAgICB9KSxcbiAgICAgICAgfVxuICAgICAgKTtcblxuICAgICAgY29uc3QgbG9naW5SZXNwb25zZSA9IGF3YWl0IGF1dGhQT1NUKGxvZ2luUmVxdWVzdCk7XG4gICAgICBjb25zdCBsb2dpbkRhdGEgPSBhd2FpdCBnZXRSZXNwb25zZURhdGEobG9naW5SZXNwb25zZSk7XG5cbiAgICAgIC8vIFZlcmlmeSBzZXNzaW9uIGRhdGEgc3RydWN0dXJlXG4gICAgICBleHBlY3QobG9naW5EYXRhLmFkbWluKS50b0JlRGVmaW5lZCgpO1xuICAgICAgZXhwZWN0KGxvZ2luRGF0YS5hZG1pbi5lbWFpbCkudG9CZShtb2NrQWRtaW4uZW1haWwpO1xuICAgICAgZXhwZWN0KGxvZ2luRGF0YS5hZG1pbi5uYW1lKS50b0JlKG1vY2tBZG1pbi5uYW1lKTtcbiAgICAgIGV4cGVjdChsb2dpbkRhdGEuYWRtaW4ucm9sZSkudG9CZShtb2NrQWRtaW4ucm9sZSk7XG4gICAgICBleHBlY3QobG9naW5EYXRhLmFkbWluLnRva2VuKS50b0JlRGVmaW5lZCgpO1xuICAgICAgZXhwZWN0KGxvZ2luRGF0YS5hZG1pbi5leHBpcmVzQXQpLnRvQmVEZWZpbmVkKCk7XG5cbiAgICAgIC8vIFZlcmlmeSB0b2tlbiBjYW4gYmUgdXNlZCBmb3Igc3Vic2VxdWVudCByZXF1ZXN0c1xuICAgICAgY29uc3QgdG9rZW4gPSBsb2dpbkRhdGEuYWRtaW4udG9rZW47XG4gICAgICBjb25zdCBkZWNvZGVkID0gand0LnZlcmlmeSh0b2tlbiwgcHJvY2Vzcy5lbnYuSldUX1NFQ1JFVCEpIGFzIHtcbiAgICAgICAgYWRtaW5JZDogc3RyaW5nO1xuICAgICAgICBlbWFpbDogc3RyaW5nO1xuICAgICAgICByb2xlOiBzdHJpbmc7XG4gICAgICAgIGV4cDogbnVtYmVyO1xuICAgICAgICBpYXQ6IG51bWJlcjtcbiAgICAgIH07XG5cbiAgICAgIGV4cGVjdChkZWNvZGVkLmFkbWluSWQpLnRvQmUobW9ja0FkbWluLmlkKTtcbiAgICAgIGV4cGVjdChkZWNvZGVkLmVtYWlsKS50b0JlKG1vY2tBZG1pbi5lbWFpbCk7XG4gICAgICBleHBlY3QoZGVjb2RlZC5yb2xlKS50b0JlKG1vY2tBZG1pbi5yb2xlKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgaGFuZGxlIGV4cGlyZWQgdG9rZW5zJywgYXN5bmMgKCkgPT4ge1xuICAgICAgLy8gQ3JlYXRlIGFuIGV4cGlyZWQgdG9rZW5cbiAgICAgIGNvbnN0IGV4cGlyZWRUb2tlbiA9IGp3dC5zaWduKFxuICAgICAgICB7XG4gICAgICAgICAgYWRtaW5JZDogJ2FkbWluX3Rlc3RAZXhhbXBsZS5jb20nLFxuICAgICAgICAgIGVtYWlsOiAndGVzdEBleGFtcGxlLmNvbScsXG4gICAgICAgICAgcm9sZTogJ3N1cGVyX2FkbWluJyxcbiAgICAgICAgICBpYXQ6IE1hdGguZmxvb3IoRGF0ZS5ub3coKSAvIDEwMDApIC0gODY0MDAsIC8vIDI0IGhvdXJzIGFnb1xuICAgICAgICAgIGV4cDogTWF0aC5mbG9vcihEYXRlLm5vdygpIC8gMTAwMCkgLSAzNjAwLCAvLyAxIGhvdXIgYWdvXG4gICAgICAgIH0sXG4gICAgICAgIHByb2Nlc3MuZW52LkpXVF9TRUNSRVQhXG4gICAgICApO1xuXG4gICAgICAvLyBBdHRlbXB0IHRvIHVzZSBleHBpcmVkIHRva2VuXG4gICAgICBleHBlY3QoKCkgPT4ge1xuICAgICAgICBqd3QudmVyaWZ5KGV4cGlyZWRUb2tlbiwgcHJvY2Vzcy5lbnYuSldUX1NFQ1JFVCEpO1xuICAgICAgfSkudG9UaHJvdygnand0IGV4cGlyZWQnKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgaGFuZGxlIGludmFsaWQgdG9rZW5zJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgaW52YWxpZFRva2VuID0gJ2ludmFsaWQuand0LnRva2VuJztcblxuICAgICAgZXhwZWN0KCgpID0+IHtcbiAgICAgICAgand0LnZlcmlmeShpbnZhbGlkVG9rZW4sIHByb2Nlc3MuZW52LkpXVF9TRUNSRVQhKTtcbiAgICAgIH0pLnRvVGhyb3coKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ0xvZ291dCBGbG93JywgKCkgPT4ge1xuICAgIGl0KCdzaG91bGQgY2xlYXIgc2Vzc2lvbiBvbiBsb2dvdXQnLCBhc3luYyAoKSA9PiB7XG4gICAgICAvLyBMb2dvdXQgZnVuY3Rpb25hbGl0eSB3b3VsZCBiZSB0ZXN0ZWQgd2l0aCB0aGUgYWN0dWFsIGxvZ291dCBlbmRwb2ludFxuICAgICAgLy8gRm9yIG5vdywgd2UnbGwgc2tpcCB0aGlzIHRlc3QgYXMgaXQgcmVxdWlyZXMgYSBkaWZmZXJlbnQgZW5kcG9pbnRcbiAgICAgIC8vIFRPRE86IEltcGxlbWVudCBsb2dvdXQgZW5kcG9pbnQgdGVzdCB3aGVuIGF2YWlsYWJsZVxuICAgICAgZXhwZWN0KHRydWUpLnRvQmUodHJ1ZSk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdSb3V0ZSBQcm90ZWN0aW9uJywgKCkgPT4ge1xuICAgIGl0KCdzaG91bGQgcHJvdGVjdCBhZG1pbiByb3V0ZXMgd2l0aG91dCB2YWxpZCB0b2tlbicsIGFzeW5jICgpID0+IHtcbiAgICAgIC8vIFRoaXMgd291bGQgdHlwaWNhbGx5IGJlIHRlc3RlZCB3aXRoIG1pZGRsZXdhcmUgb3Igcm91dGUgaGFuZGxlcnNcbiAgICAgIC8vIEZvciBub3csIHdlJ2xsIHRlc3QgdGhlIHRva2VuIHZhbGlkYXRpb24gbG9naWNcblxuICAgICAgY29uc3QgaW52YWxpZFRva2VuID0gJ2ludmFsaWQudG9rZW4nO1xuXG4gICAgICBleHBlY3QoKCkgPT4ge1xuICAgICAgICBqd3QudmVyaWZ5KGludmFsaWRUb2tlbiwgcHJvY2Vzcy5lbnYuSldUX1NFQ1JFVCEpO1xuICAgICAgfSkudG9UaHJvdygpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBhbGxvdyBhY2Nlc3Mgd2l0aCB2YWxpZCB0b2tlbicsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IHZhbGlkVG9rZW4gPSBqd3Quc2lnbihcbiAgICAgICAge1xuICAgICAgICAgIGFkbWluSWQ6ICdhZG1pbl8xMjMnLCAvLyBVc2UgSUQgZm9ybWF0IGNvbnNpc3RlbnQgd2l0aCByb3V0ZSBoYW5kbGVyXG4gICAgICAgICAgZW1haWw6ICd0ZXN0QGV4YW1wbGUuY29tJyxcbiAgICAgICAgICByb2xlOiAnc3VwZXJfYWRtaW4nLFxuICAgICAgICAgIGlhdDogTWF0aC5mbG9vcihEYXRlLm5vdygpIC8gMTAwMCksXG4gICAgICAgICAgZXhwOiBNYXRoLmZsb29yKERhdGUubm93KCkgLyAxMDAwKSArIDg2NDAwLCAvLyAyNCBob3VycyBmcm9tIG5vd1xuICAgICAgICB9LFxuICAgICAgICBwcm9jZXNzLmVudi5KV1RfU0VDUkVUIVxuICAgICAgKTtcblxuICAgICAgY29uc3QgZGVjb2RlZCA9IGp3dC52ZXJpZnkodmFsaWRUb2tlbiwgcHJvY2Vzcy5lbnYuSldUX1NFQ1JFVCEpIGFzIHtcbiAgICAgICAgYWRtaW5JZDogc3RyaW5nO1xuICAgICAgICBlbWFpbDogc3RyaW5nO1xuICAgICAgICByb2xlOiBzdHJpbmc7XG4gICAgICAgIGV4cDogbnVtYmVyO1xuICAgICAgICBpYXQ6IG51bWJlcjtcbiAgICAgIH07XG5cbiAgICAgIGV4cGVjdChkZWNvZGVkLmFkbWluSWQpLnRvQmUoJ2FkbWluXzEyMycpO1xuICAgICAgZXhwZWN0KGRlY29kZWQuZW1haWwpLnRvQmUoJ3Rlc3RAZXhhbXBsZS5jb20nKTtcbiAgICAgIGV4cGVjdChkZWNvZGVkLnJvbGUpLnRvQmUoJ3N1cGVyX2FkbWluJyk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdFcnJvciBIYW5kbGluZycsICgpID0+IHtcbiAgICBpdCgnc2hvdWxkIGhhbmRsZSBkYXRhYmFzZSBjb25uZWN0aW9uIGVycm9ycycsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IG1vY2tTaW5nbGUgPSBQcm9taXNlLnJlamVjdChcbiAgICAgICAgbmV3IEVycm9yKCdEYXRhYmFzZSBjb25uZWN0aW9uIGZhaWxlZCcpXG4gICAgICApO1xuXG4gICAgICBjb25zdCBtb2NrRXEgPSBqZXN0LmZuKCkubW9ja1JldHVyblZhbHVlKHtcbiAgICAgICAgc2luZ2xlOiAoKSA9PiBtb2NrU2luZ2xlLFxuICAgICAgfSk7XG5cbiAgICAgIGNvbnN0IG1vY2tTZWxlY3QgPSBqZXN0LmZuKCkubW9ja1JldHVyblZhbHVlKHtcbiAgICAgICAgZXE6IG1vY2tFcSxcbiAgICAgIH0pO1xuXG4gICAgICBtb2NrU3VwYWJhc2VDbGllbnQuZnJvbS5tb2NrUmV0dXJuVmFsdWUoe1xuICAgICAgICBzZWxlY3Q6IG1vY2tTZWxlY3QsXG4gICAgICB9KTtcblxuICAgICAgY29uc3QgbG9naW5SZXF1ZXN0ID0gbmV3IE5leHRSZXF1ZXN0KFxuICAgICAgICAnaHR0cDovL2xvY2FsaG9zdDozMDAwL2FwaS9hZG1pbi9hdXRoJyxcbiAgICAgICAge1xuICAgICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgICAgfSxcbiAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgICBlbWFpbDogJ3Rlc3RAZXhhbXBsZS5jb20nLFxuICAgICAgICAgICAgcGFzc3dvcmQ6ICd0ZXN0cGFzc3dvcmQxMjMnLFxuICAgICAgICAgIH0pLFxuICAgICAgICB9XG4gICAgICApO1xuXG4gICAgICBjb25zdCBsb2dpblJlc3BvbnNlID0gYXdhaXQgYXV0aFBPU1QobG9naW5SZXF1ZXN0KTtcbiAgICAgIGNvbnN0IGxvZ2luRGF0YSA9IGF3YWl0IGdldFJlc3BvbnNlRGF0YShsb2dpblJlc3BvbnNlKTtcblxuICAgICAgZXhwZWN0KGxvZ2luUmVzcG9uc2Uuc3RhdHVzKS50b0JlKDUwMCk7XG4gICAgICBleHBlY3QobG9naW5EYXRhLnN1Y2Nlc3MpLnRvQmUoZmFsc2UpO1xuICAgICAgZXhwZWN0KGxvZ2luRGF0YS5lcnJvcikudG9CZURlZmluZWQoKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgaGFuZGxlIG1hbGZvcm1lZCByZXF1ZXN0cycsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IGxvZ2luUmVxdWVzdCA9IG5ldyBOZXh0UmVxdWVzdChcbiAgICAgICAgJ2h0dHA6Ly9sb2NhbGhvc3Q6MzAwMC9hcGkvYWRtaW4vYXV0aCcsXG4gICAgICAgIHtcbiAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICAgIH0sXG4gICAgICAgICAgYm9keTogJ2ludmFsaWQganNvbicsXG4gICAgICAgIH1cbiAgICAgICk7XG5cbiAgICAgIGNvbnN0IGxvZ2luUmVzcG9uc2UgPSBhd2FpdCBhdXRoUE9TVChsb2dpblJlcXVlc3QpO1xuICAgICAgY29uc3QgbG9naW5EYXRhID0gYXdhaXQgZ2V0UmVzcG9uc2VEYXRhKGxvZ2luUmVzcG9uc2UpO1xuXG4gICAgICBleHBlY3QobG9naW5SZXNwb25zZS5zdGF0dXMpLnRvQmUoNDAwKTtcbiAgICAgIGV4cGVjdChsb2dpbkRhdGEuc3VjY2VzcykudG9CZShmYWxzZSk7XG4gICAgICBleHBlY3QobG9naW5EYXRhLmVycm9yKS50b0JlRGVmaW5lZCgpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBoYW5kbGUgbWlzc2luZyBlbnZpcm9ubWVudCB2YXJpYWJsZXMnLCBhc3luYyAoKSA9PiB7XG4gICAgICBkZWxldGUgcHJvY2Vzcy5lbnYuSldUX1NFQ1JFVDtcblxuICAgICAgY29uc3QgbW9ja0FkbWluID0ge1xuICAgICAgICBpZDogJ2FkbWluXzEyMycsXG4gICAgICAgIGVtYWlsOiAndGVzdEBleGFtcGxlLmNvbScsXG4gICAgICAgIG5hbWU6ICdUZXN0IEFkbWluJyxcbiAgICAgICAgcm9sZTogJ3N1cGVyX2FkbWluJyxcbiAgICAgICAgcGFzc3dvcmRfaGFzaDogJ2hhc2hlZF9wYXNzd29yZCcsXG4gICAgICAgIGlzX2FjdGl2ZTogdHJ1ZSxcbiAgICAgICAgY3JlYXRlZF9hdDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxuICAgICAgfTtcblxuICAgICAgY29uc3QgbW9ja1NpbmdsZSA9IFByb21pc2UucmVzb2x2ZSh7XG4gICAgICAgIGRhdGE6IG1vY2tBZG1pbixcbiAgICAgICAgZXJyb3I6IG51bGwsXG4gICAgICB9KTtcblxuICAgICAgY29uc3QgbW9ja0VxID0gamVzdC5mbigpLm1vY2tSZXR1cm5WYWx1ZSh7XG4gICAgICAgIHNpbmdsZTogKCkgPT4gbW9ja1NpbmdsZSxcbiAgICAgIH0pO1xuXG4gICAgICBjb25zdCBtb2NrU2VsZWN0ID0gamVzdC5mbigpLm1vY2tSZXR1cm5WYWx1ZSh7XG4gICAgICAgIGVxOiBtb2NrRXEsXG4gICAgICB9KTtcblxuICAgICAgbW9ja1N1cGFiYXNlQ2xpZW50LmZyb20ubW9ja1JldHVyblZhbHVlKHtcbiAgICAgICAgc2VsZWN0OiBtb2NrU2VsZWN0LFxuICAgICAgICB1cGRhdGU6IGplc3QuZm4oKS5tb2NrUmV0dXJuVmFsdWUoe1xuICAgICAgICAgIGVxOiBqZXN0LmZuKCkubW9ja1Jlc29sdmVkVmFsdWUoeyBlcnJvcjogbnVsbCB9KSxcbiAgICAgICAgfSksXG4gICAgICB9KTtcblxuICAgICAgYmNyeXB0LmNvbXBhcmUubW9ja1Jlc29sdmVkVmFsdWUodHJ1ZSk7XG5cbiAgICAgIGNvbnN0IGxvZ2luUmVxdWVzdCA9IG5ldyBOZXh0UmVxdWVzdChcbiAgICAgICAgJ2h0dHA6Ly9sb2NhbGhvc3Q6MzAwMC9hcGkvYWRtaW4vYXV0aCcsXG4gICAgICAgIHtcbiAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICAgIH0sXG4gICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICAgICAgZW1haWw6ICd0ZXN0QGV4YW1wbGUuY29tJyxcbiAgICAgICAgICAgIHBhc3N3b3JkOiAndGVzdHBhc3N3b3JkMTIzJyxcbiAgICAgICAgICB9KSxcbiAgICAgICAgfVxuICAgICAgKTtcblxuICAgICAgY29uc3QgbG9naW5SZXNwb25zZSA9IGF3YWl0IGF1dGhQT1NUKGxvZ2luUmVxdWVzdCk7XG4gICAgICBjb25zdCBsb2dpbkRhdGEgPSBhd2FpdCBnZXRSZXNwb25zZURhdGEobG9naW5SZXNwb25zZSk7XG5cbiAgICAgIGV4cGVjdChsb2dpblJlc3BvbnNlLnN0YXR1cykudG9CZSg1MDApO1xuICAgICAgZXhwZWN0KGxvZ2luRGF0YS5zdWNjZXNzKS50b0JlKGZhbHNlKTtcbiAgICAgIGV4cGVjdChsb2dpbkRhdGEuZXJyb3IpLnRvQmVEZWZpbmVkKCk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdTZWN1cml0eSBUZXN0cycsICgpID0+IHtcbiAgICBpdCgnc2hvdWxkIG5vdCBleHBvc2Ugc2Vuc2l0aXZlIGluZm9ybWF0aW9uIGluIGVycm9yIG1lc3NhZ2VzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgbW9ja1NpbmdsZSA9IFByb21pc2UucmVqZWN0KFxuICAgICAgICBuZXcgRXJyb3IoJ0RhdGFiYXNlIGNvbm5lY3Rpb24gZmFpbGVkOiBwYXNzd29yZD1zZWNyZXQxMjMnKVxuICAgICAgKTtcblxuICAgICAgY29uc3QgbW9ja0VxID0gamVzdC5mbigpLm1vY2tSZXR1cm5WYWx1ZSh7XG4gICAgICAgIHNpbmdsZTogKCkgPT4gbW9ja1NpbmdsZSxcbiAgICAgIH0pO1xuXG4gICAgICBjb25zdCBtb2NrU2VsZWN0ID0gamVzdC5mbigpLm1vY2tSZXR1cm5WYWx1ZSh7XG4gICAgICAgIGVxOiBtb2NrRXEsXG4gICAgICB9KTtcblxuICAgICAgbW9ja1N1cGFiYXNlQ2xpZW50LmZyb20ubW9ja1JldHVyblZhbHVlKHtcbiAgICAgICAgc2VsZWN0OiBtb2NrU2VsZWN0LFxuICAgICAgfSk7XG5cbiAgICAgIGNvbnN0IGxvZ2luUmVxdWVzdCA9IG5ldyBOZXh0UmVxdWVzdChcbiAgICAgICAgJ2h0dHA6Ly9sb2NhbGhvc3Q6MzAwMC9hcGkvYWRtaW4vYXV0aCcsXG4gICAgICAgIHtcbiAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICAgIH0sXG4gICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICAgICAgZW1haWw6ICd0ZXN0QGV4YW1wbGUuY29tJyxcbiAgICAgICAgICAgIHBhc3N3b3JkOiAndGVzdHBhc3N3b3JkMTIzJyxcbiAgICAgICAgICB9KSxcbiAgICAgICAgfVxuICAgICAgKTtcblxuICAgICAgY29uc3QgbG9naW5SZXNwb25zZSA9IGF3YWl0IGF1dGhQT1NUKGxvZ2luUmVxdWVzdCk7XG4gICAgICBjb25zdCBsb2dpbkRhdGEgPSBhd2FpdCBnZXRSZXNwb25zZURhdGEobG9naW5SZXNwb25zZSk7XG5cbiAgICAgIGV4cGVjdChsb2dpblJlc3BvbnNlLnN0YXR1cykudG9CZSg1MDApO1xuICAgICAgZXhwZWN0KGxvZ2luRGF0YS5zdWNjZXNzKS50b0JlKGZhbHNlKTtcbiAgICAgIGV4cGVjdChsb2dpbkRhdGEuZXJyb3IpLnRvQmVEZWZpbmVkKCk7XG4gICAgICBleHBlY3QobG9naW5EYXRhLmVycm9yKS5ub3QudG9Db250YWluKCdzZWNyZXQxMjMnKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgcmF0ZSBsaW1pdCBsb2dpbiBhdHRlbXB0cycsIGFzeW5jICgpID0+IHtcbiAgICAgIC8vIFRoaXMgdGVzdCB3b3VsZCBiZSBpbXBsZW1lbnRlZCBpZiByYXRlIGxpbWl0aW5nIGlzIGFkZGVkXG4gICAgICAvLyBTZXQgdXAgbW9jayBmb3IgZmFpbGVkIGF1dGhlbnRpY2F0aW9uICh3cm9uZyBwYXNzd29yZClcbiAgICAgIGNvbnN0IG1vY2tTaW5nbGUgPSBQcm9taXNlLnJlc29sdmUoe1xuICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgaWQ6ICdhZG1pbl8xMjMnLFxuICAgICAgICAgIGVtYWlsOiAndGVzdEBleGFtcGxlLmNvbScsXG4gICAgICAgICAgbmFtZTogJ1Rlc3QgQWRtaW4nLFxuICAgICAgICAgIHJvbGU6ICdzdXBlcl9hZG1pbicsXG4gICAgICAgICAgcGFzc3dvcmRfaGFzaDogJ2hhc2hlZF9wYXNzd29yZCcsXG4gICAgICAgICAgaXNfYWN0aXZlOiB0cnVlLFxuICAgICAgICAgIGNyZWF0ZWRfYXQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcbiAgICAgICAgfSxcbiAgICAgICAgZXJyb3I6IG51bGwsXG4gICAgICB9KTtcblxuICAgICAgY29uc3QgbW9ja0VxID0gamVzdC5mbigpLm1vY2tSZXR1cm5WYWx1ZSh7XG4gICAgICAgIHNpbmdsZTogKCkgPT4gbW9ja1NpbmdsZSxcbiAgICAgIH0pO1xuXG4gICAgICBjb25zdCBtb2NrU2VsZWN0ID0gamVzdC5mbigpLm1vY2tSZXR1cm5WYWx1ZSh7XG4gICAgICAgIGVxOiBtb2NrRXEsXG4gICAgICB9KTtcblxuICAgICAgbW9ja1N1cGFiYXNlQ2xpZW50LmZyb20ubW9ja1JldHVyblZhbHVlKHtcbiAgICAgICAgc2VsZWN0OiBtb2NrU2VsZWN0LFxuICAgICAgfSk7XG5cbiAgICAgIC8vIE1vY2sgYmNyeXB0IHRvIHJldHVybiBmYWxzZSAod3JvbmcgcGFzc3dvcmQpXG4gICAgICBiY3J5cHQuY29tcGFyZS5tb2NrUmVzb2x2ZWRWYWx1ZShmYWxzZSk7XG5cbiAgICAgIGNvbnN0IHJlcXVlc3RzID0gQXJyYXkoMTApXG4gICAgICAgIC5maWxsKG51bGwpXG4gICAgICAgIC5tYXAoXG4gICAgICAgICAgKCkgPT5cbiAgICAgICAgICAgIG5ldyBOZXh0UmVxdWVzdCgnaHR0cDovL2xvY2FsaG9zdDozMDAwL2FwaS9hZG1pbi9hdXRoJywge1xuICAgICAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICAgICAgICBlbWFpbDogJ3Rlc3RAZXhhbXBsZS5jb20nLFxuICAgICAgICAgICAgICAgIHBhc3N3b3JkOiAnd3JvbmdwYXNzd29yZCcsXG4gICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgfSlcbiAgICAgICAgKTtcblxuICAgICAgY29uc3QgcmVzcG9uc2VzID0gYXdhaXQgUHJvbWlzZS5hbGwocmVxdWVzdHMubWFwKHJlcSA9PiBhdXRoUE9TVChyZXEpKSk7XG5cbiAgICAgIC8vIEFsbCByZXF1ZXN0cyBzaG91bGQgYmUgaGFuZGxlZCAoZXZlbiBpZiB0aGV5IGZhaWwpXG4gICAgICByZXNwb25zZXMuZm9yRWFjaChyZXNwb25zZSA9PiB7XG4gICAgICAgIGV4cGVjdChbNDAwLCA0MDEsIDQyOV0pLnRvQ29udGFpbihyZXNwb25zZS5zdGF0dXMpO1xuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIHZhbGlkYXRlIHRva2VuIHNpZ25hdHVyZScsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IHRva2VuV2l0aFdyb25nU2VjcmV0ID0gand0LnNpZ24oXG4gICAgICAgIHtcbiAgICAgICAgICBhZG1pbklkOiAnYWRtaW5fdGVzdEBleGFtcGxlLmNvbScsXG4gICAgICAgICAgZW1haWw6ICd0ZXN0QGV4YW1wbGUuY29tJyxcbiAgICAgICAgICByb2xlOiAnc3VwZXJfYWRtaW4nLFxuICAgICAgICB9LFxuICAgICAgICAnd3Jvbmctc2VjcmV0J1xuICAgICAgKTtcblxuICAgICAgZXhwZWN0KCgpID0+IHtcbiAgICAgICAgand0LnZlcmlmeSh0b2tlbldpdGhXcm9uZ1NlY3JldCwgcHJvY2Vzcy5lbnYuSldUX1NFQ1JFVCEpO1xuICAgICAgfSkudG9UaHJvdygnaW52YWxpZCBzaWduYXR1cmUnKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ1BlcmZvcm1hbmNlIFRlc3RzJywgKCkgPT4ge1xuICAgIGl0KCdzaG91bGQgaGFuZGxlIGNvbmN1cnJlbnQgbG9naW4gcmVxdWVzdHMnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBtb2NrQWRtaW4gPSB7XG4gICAgICAgIGlkOiAnYWRtaW5fMTIzJyxcbiAgICAgICAgZW1haWw6ICd0ZXN0QGV4YW1wbGUuY29tJyxcbiAgICAgICAgbmFtZTogJ1Rlc3QgQWRtaW4nLFxuICAgICAgICByb2xlOiAnc3VwZXJfYWRtaW4nLFxuICAgICAgICBwYXNzd29yZF9oYXNoOiAnaGFzaGVkX3Bhc3N3b3JkJyxcbiAgICAgICAgaXNfYWN0aXZlOiB0cnVlLFxuICAgICAgICBjcmVhdGVkX2F0OiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXG4gICAgICB9O1xuXG4gICAgICBjb25zdCBtb2NrU2luZ2xlID0gUHJvbWlzZS5yZXNvbHZlKHtcbiAgICAgICAgZGF0YTogbW9ja0FkbWluLFxuICAgICAgICBlcnJvcjogbnVsbCxcbiAgICAgIH0pO1xuXG4gICAgICBjb25zdCBtb2NrRXEgPSBqZXN0LmZuKCkubW9ja1JldHVyblZhbHVlKHtcbiAgICAgICAgc2luZ2xlOiAoKSA9PiBtb2NrU2luZ2xlLFxuICAgICAgfSk7XG5cbiAgICAgIGNvbnN0IG1vY2tTZWxlY3QgPSBqZXN0LmZuKCkubW9ja1JldHVyblZhbHVlKHtcbiAgICAgICAgZXE6IG1vY2tFcSxcbiAgICAgIH0pO1xuXG4gICAgICBtb2NrU3VwYWJhc2VDbGllbnQuZnJvbS5tb2NrUmV0dXJuVmFsdWUoe1xuICAgICAgICBzZWxlY3Q6IG1vY2tTZWxlY3QsXG4gICAgICAgIHVwZGF0ZTogamVzdC5mbigpLm1vY2tSZXR1cm5WYWx1ZSh7XG4gICAgICAgICAgZXE6IGplc3QuZm4oKS5tb2NrUmVzb2x2ZWRWYWx1ZSh7IGVycm9yOiBudWxsIH0pLFxuICAgICAgICB9KSxcbiAgICAgIH0pO1xuXG4gICAgICBiY3J5cHQuY29tcGFyZS5tb2NrUmVzb2x2ZWRWYWx1ZSh0cnVlKTtcblxuICAgICAgY29uc3QgcmVxdWVzdHMgPSBBcnJheSg1KVxuICAgICAgICAuZmlsbChudWxsKVxuICAgICAgICAubWFwKFxuICAgICAgICAgICgpID0+XG4gICAgICAgICAgICBuZXcgTmV4dFJlcXVlc3QoJ2h0dHA6Ly9sb2NhbGhvc3Q6MzAwMC9hcGkvYWRtaW4vYXV0aCcsIHtcbiAgICAgICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgICAgICAgZW1haWw6ICd0ZXN0QGV4YW1wbGUuY29tJyxcbiAgICAgICAgICAgICAgICBwYXNzd29yZDogJ3Rlc3RwYXNzd29yZDEyMycsXG4gICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgfSlcbiAgICAgICAgKTtcblxuICAgICAgY29uc3Qgc3RhcnRUaW1lID0gRGF0ZS5ub3coKTtcbiAgICAgIGNvbnN0IHJlc3BvbnNlcyA9IGF3YWl0IFByb21pc2UuYWxsKHJlcXVlc3RzLm1hcChyZXEgPT4gYXV0aFBPU1QocmVxKSkpO1xuICAgICAgY29uc3QgZW5kVGltZSA9IERhdGUubm93KCk7XG5cbiAgICAgIC8vIEFsbCByZXF1ZXN0cyBzaG91bGQgYmUgaGFuZGxlZFxuICAgICAgcmVzcG9uc2VzLmZvckVhY2gocmVzcG9uc2UgPT4ge1xuICAgICAgICBleHBlY3QoWzIwMCwgNDAwLCA0MDFdKS50b0NvbnRhaW4ocmVzcG9uc2Uuc3RhdHVzKTtcbiAgICAgIH0pO1xuXG4gICAgICAvLyBTaG91bGQgY29tcGxldGUgd2l0aGluIHJlYXNvbmFibGUgdGltZSAoNSBzZWNvbmRzKVxuICAgICAgZXhwZWN0KGVuZFRpbWUgLSBzdGFydFRpbWUpLnRvQmVMZXNzVGhhbig1MDAwKTtcbiAgICB9KTtcbiAgfSk7XG59KTtcbiJdLCJuYW1lcyI6WyJqZXN0IiwibW9jayIsImFjdHVhbCIsInJlcXVpcmVBY3R1YWwiLCJOZXh0UmVzcG9uc2UiLCJqc29uIiwiYm9keSIsImluaXQiLCJyZXNwb25zZSIsIl9ib2R5IiwiSlNPTiIsInN0cmluZ2lmeSIsIm1vY2tTdXBhYmFzZUNsaWVudCIsImZyb20iLCJmbiIsImNyZWF0ZUNsaWVudCIsImNvbXBhcmUiLCJoYXNoIiwiYWRtaW5Db25maWciLCJzZWN1cml0eSIsInNhbHRSb3VuZHMiLCJzZXNzaW9uVGltZW91dCIsImp3dCIsInNlY3JldCIsImdldFJlc3BvbnNlRGF0YSIsInVuZGVmaW5lZCIsInBhcnNlIiwiZGF0YSIsIk9iamVjdCIsImtleXMiLCJsZW5ndGgiLCJ0ZXh0IiwiZGVzY3JpYmUiLCJiY3J5cHQiLCJyZXF1aXJlIiwiY29uc29sZUVycm9yU3B5IiwiYmVmb3JlRWFjaCIsImNsZWFyQWxsTW9ja3MiLCJtb2NrQ2xlYXIiLCJwcm9jZXNzIiwiZW52IiwiSldUX1NFQ1JFVCIsIk5FWFRfUFVCTElDX1NVUEFCQVNFX1VSTCIsIk5FWFRfUFVCTElDX1NVUEFCQVNFX0FOT05fS0VZIiwiU1VQQUJBU0VfU0VSVklDRV9ST0xFX0tFWSIsInNweU9uIiwiY29uc29sZSIsIm1vY2tJbXBsZW1lbnRhdGlvbiIsImFmdGVyRWFjaCIsIm1vY2tSZXN0b3JlIiwiaXQiLCJtb2NrQWRtaW4iLCJpZCIsImVtYWlsIiwibmFtZSIsInJvbGUiLCJwYXNzd29yZF9oYXNoIiwiaXNfYWN0aXZlIiwiY3JlYXRlZF9hdCIsIkRhdGUiLCJ0b0lTT1N0cmluZyIsIm1vY2tTaW5nbGUiLCJQcm9taXNlIiwicmVzb2x2ZSIsImVycm9yIiwibW9ja0VxIiwibW9ja1JldHVyblZhbHVlIiwic2luZ2xlIiwibW9ja1NlbGVjdCIsImVxIiwic2VsZWN0IiwidXBkYXRlIiwibW9ja1Jlc29sdmVkVmFsdWUiLCJsb2dpblJlcXVlc3QiLCJOZXh0UmVxdWVzdCIsIm1ldGhvZCIsImhlYWRlcnMiLCJwYXNzd29yZCIsImxvZ2luUmVzcG9uc2UiLCJhdXRoUE9TVCIsImxvZ2luRGF0YSIsImV4cGVjdCIsInN0YXR1cyIsInRvQmUiLCJzdWNjZXNzIiwiYWRtaW4iLCJ0b2tlbiIsInRvQmVEZWZpbmVkIiwiZXhwaXJlc0F0IiwiZGVjb2RlZCIsInZlcmlmeSIsImFkbWluSWQiLCJleHAiLCJleHBpcmF0aW9uVGltZSIsIm5vdyIsInR3ZW50eUZvdXJIb3VycyIsInRvQmVHcmVhdGVyVGhhbiIsInRvQmVMZXNzVGhhbiIsIm1lc3NhZ2UiLCJ0b0JlVW5kZWZpbmVkIiwiZXhwaXJlZFRva2VuIiwic2lnbiIsImlhdCIsIk1hdGgiLCJmbG9vciIsInRvVGhyb3ciLCJpbnZhbGlkVG9rZW4iLCJ2YWxpZFRva2VuIiwicmVqZWN0IiwiRXJyb3IiLCJub3QiLCJ0b0NvbnRhaW4iLCJyZXF1ZXN0cyIsIkFycmF5IiwiZmlsbCIsIm1hcCIsInJlc3BvbnNlcyIsImFsbCIsInJlcSIsImZvckVhY2giLCJ0b2tlbldpdGhXcm9uZ1NlY3JldCIsInN0YXJ0VGltZSIsImVuZFRpbWUiXSwibWFwcGluZ3MiOiJBQUFBLHFEQUFxRCxHQUNyRDs7Ozs7Ozs7O0NBU0M7QUFPRCw0REFBNEQ7QUFDNURBLEtBQUtDLElBQUksQ0FBQyxlQUFlO0lBQ3ZCLE1BQU1DLFNBQVNGLEtBQUtHLGFBQWEsQ0FBQztJQUNsQyxPQUFPO1FBQ0wsR0FBR0QsTUFBTTtRQUNURSxjQUFjO1lBQ1osR0FBR0YsT0FBT0UsWUFBWTtZQUN0QkMsTUFBTSxDQUFDQyxNQUFXQztnQkFDaEIsTUFBTUMsV0FBV04sT0FBT0UsWUFBWSxDQUFDQyxJQUFJLENBQUNDLE1BQU1DO2dCQUNoRCw2Q0FBNkM7Z0JB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