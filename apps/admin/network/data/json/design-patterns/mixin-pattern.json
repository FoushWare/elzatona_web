[
  {
    "id": "design-patterns-mixin-pattern-33",
    "title": "Definition of Mixin Pattern",
    "content": "What is the Mixin Pattern and why is it used?",
    "type": "open-ended",
    "category": "Design Patterns",
    "topic": "Mixin Pattern",
    "difficulty": "beginner",
    "learningCardId": "system-design",
    "isActive": true,
    "createdAt": "2025-10-15T00:47:17.206Z",
    "updatedAt": "2025-10-15T00:47:17.206Z",
    "createdBy": "admin",
    "updatedBy": "admin",
    "tags": ["design-patterns", "mixin-pattern", "beginner"],
    "explanation": "A mixin is an object containing reusable functionality that can be added to another object or class without inheritance. It allows sharing behavior across classes without forming rigid inheritance hierarchies.",
    "points": 10,
    "sampleAnswers": [
      "A mixin is an object containing reusable functionality that can be added to another object or class without inheritance.",
      "It allows sharing behavior across classes without forming rigid inheritance hierarchies."
    ],
    "hints": [],
    "metadata": {}
  },
  {
    "id": "design-patterns-mixin-pattern-34",
    "title": "Dog Example with Mixins",
    "content": "Given the following code:\n\n```js\nclass Dog {\n  constructor(name) {\n    this.name = name;\n  }\n}\n\nconst dogFunctionality = {\n  bark: () => console.log(\"Woof!\"),\n  wagTail: () => console.log(\"Wagging my tail!\"),\n};\n\nObject.assign(Dog.prototype, dogFunctionality);\n\nconst pet1 = new Dog(\"Daisy\");\npet1.bark();\n```\nWhat will be logged when `pet1.bark()` is executed?",
    "type": "multiple-choice",
    "category": "Design Patterns",
    "topic": "General Design Patterns",
    "difficulty": "beginner",
    "learningCardId": "system-design",
    "isActive": true,
    "createdAt": "2025-10-15T00:47:17.206Z",
    "updatedAt": "2025-10-15T00:47:17.206Z",
    "createdBy": "admin",
    "updatedBy": "admin",
    "tags": ["design-patterns", "general-design-patterns", "beginner"],
    "explanation": "The correct answer is: Woof!",
    "points": 10,
    "options": [
      {
        "id": "a",
        "text": "undefined",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "b",
        "text": "Woof!",
        "isCorrect": true,
        "explanation": ""
      },
      {
        "id": "c",
        "text": "Error: bark is not a function",
        "isCorrect": false,
        "explanation": ""
      }
    ],
    "hints": [],
    "metadata": {}
  },
  {
    "id": "design-patterns-mixin-pattern-35",
    "title": "Mixins vs Inheritance",
    "content": "How does the Mixin Pattern differ from classical inheritance?",
    "type": "open-ended",
    "category": "Design Patterns",
    "topic": "General Design Patterns",
    "difficulty": "intermediate",
    "learningCardId": "system-design",
    "isActive": true,
    "createdAt": "2025-10-15T00:47:17.206Z",
    "updatedAt": "2025-10-15T00:47:17.206Z",
    "createdBy": "admin",
    "updatedBy": "admin",
    "tags": ["design-patterns", "general-design-patterns", "intermediate"],
    "explanation": "Inheritance creates a parent-child relationship between classes, while mixins simply copy functionality into another class. Mixins allow horizontal code reuse across unrelated classes, inheritance enforces vertical hierarchy.",
    "points": 10,
    "sampleAnswers": [
      "Inheritance creates a parent-child relationship between classes, while mixins simply copy functionality into another class.",
      "Mixins allow horizontal code reuse across unrelated classes, inheritance enforces vertical hierarchy."
    ],
    "hints": [],
    "metadata": {}
  },
  {
    "id": "design-patterns-mixin-pattern-36",
    "title": "Chaining Mixins",
    "content": "In the example with `animalFunctionality` and `dogFunctionality`, why does Dog end up with both `bark()` and `walk()` methods?",
    "type": "open-ended",
    "category": "Design Patterns",
    "topic": "General Design Patterns",
    "difficulty": "intermediate",
    "learningCardId": "system-design",
    "isActive": true,
    "createdAt": "2025-10-15T00:47:17.206Z",
    "updatedAt": "2025-10-15T00:47:17.206Z",
    "createdBy": "admin",
    "updatedBy": "admin",
    "tags": ["design-patterns", "general-design-patterns", "intermediate"],
    "explanation": "Because `Object.assign(dogFunctionality, animalFunctionality)` merged animal methods into dogFunctionality, then `Object.assign(Dog.prototype, dogFunctionality)` added all methods to Dog’s prototype. This effectively chained multiple mixins together.",
    "points": 10,
    "sampleAnswers": [
      "Because `Object.assign(dogFunctionality, animalFunctionality)` merged animal methods into dogFunctionality, then `Object.assign(Dog.prototype, dogFunctionality)` added all methods to Dog’s prototype.",
      "This effectively chained multiple mixins together."
    ],
    "hints": [],
    "metadata": {}
  },
  {
    "id": "design-patterns-mixin-pattern-37",
    "title": "Real World Browser Example",
    "content": "Which of the following are examples of mixins in the browser Window object?",
    "type": "multiple-choice",
    "category": "Design Patterns",
    "topic": "General Design Patterns",
    "difficulty": "intermediate",
    "learningCardId": "system-design",
    "isActive": true,
    "createdAt": "2025-10-15T00:47:17.206Z",
    "updatedAt": "2025-10-15T00:47:17.206Z",
    "createdBy": "admin",
    "updatedBy": "admin",
    "tags": ["design-patterns", "general-design-patterns", "intermediate"],
    "explanation": "The correct answer is: setTimeout and setInterval (from WindowOrWorkerGlobalScope)",
    "points": 10,
    "options": [
      {
        "id": "a",
        "text": "setTimeout and setInterval (from WindowOrWorkerGlobalScope)",
        "isCorrect": true,
        "explanation": ""
      },
      {
        "id": "b",
        "text": "onbeforeunload (from WindowEventHandlers)",
        "isCorrect": true,
        "explanation": ""
      },
      {
        "id": "c",
        "text": "document.querySelector",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "d",
        "text": "console.log",
        "isCorrect": false,
        "explanation": ""
      }
    ],
    "hints": [],
    "metadata": {}
  },
  {
    "id": "design-patterns-mixin-pattern-38",
    "title": "Disadvantages of Mixins",
    "content": "What are potential disadvantages of using Mixins?",
    "type": "open-ended",
    "category": "Design Patterns",
    "topic": "General Design Patterns",
    "difficulty": "intermediate",
    "learningCardId": "system-design",
    "isActive": true,
    "createdAt": "2025-10-15T00:47:17.206Z",
    "updatedAt": "2025-10-15T00:47:17.206Z",
    "createdBy": "admin",
    "updatedBy": "admin",
    "tags": ["design-patterns", "general-design-patterns", "intermediate"],
    "explanation": "They can cause prototype pollution, making it unclear where a function originated. They can introduce naming conflicts if two mixins define the same property. In React, they added complexity, leading the team to recommend HOCs and Hooks instead.",
    "points": 10,
    "sampleAnswers": [
      "They can cause prototype pollution, making it unclear where a function originated.",
      "They can introduce naming conflicts if two mixins define the same property.",
      "In React, they added complexity, leading the team to recommend HOCs and Hooks instead."
    ],
    "hints": [],
    "metadata": {}
  },
  {
    "id": "design-patterns-mixin-pattern-39",
    "title": "Mixin vs Higher Order Components",
    "content": "Why did React discourage mixins in favor of Higher Order Components (HOCs) and later Hooks?",
    "type": "open-ended",
    "category": "Design Patterns",
    "topic": "General Design Patterns",
    "difficulty": "advanced",
    "learningCardId": "system-design",
    "isActive": true,
    "createdAt": "2025-10-15T00:47:17.206Z",
    "updatedAt": "2025-10-15T00:47:17.206Z",
    "createdBy": "admin",
    "updatedBy": "admin",
    "tags": ["design-patterns", "general-design-patterns", "advanced"],
    "explanation": "Mixins often lead to implicit dependencies and complexity, while HOCs and Hooks are more explicit, composable, and predictable. Hooks allow better reusability and cleaner separation of concerns than mixins.",
    "points": 10,
    "sampleAnswers": [
      "Mixins often lead to implicit dependencies and complexity, while HOCs and Hooks are more explicit, composable, and predictable.",
      "Hooks allow better reusability and cleaner separation of concerns than mixins."
    ],
    "hints": [],
    "metadata": {}
  },
  {
    "id": "design-patterns-mixin-pattern-40",
    "title": "Debugging Mixins",
    "content": "If you accidentally overwrite a method from another mixin when using `Object.assign`, what will happen?",
    "type": "multiple-choice",
    "category": "Design Patterns",
    "topic": "General Design Patterns",
    "difficulty": "beginner",
    "learningCardId": "system-design",
    "isActive": true,
    "createdAt": "2025-10-15T00:47:17.206Z",
    "updatedAt": "2025-10-15T00:47:17.206Z",
    "createdBy": "admin",
    "updatedBy": "admin",
    "tags": ["design-patterns", "general-design-patterns", "beginner"],
    "explanation": "The correct answer is: The last assigned method overwrites the previous one",
    "points": 10,
    "options": [
      {
        "id": "a",
        "text": "Both methods are preserved",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "b",
        "text": "The last assigned method overwrites the previous one",
        "isCorrect": true,
        "explanation": ""
      },
      {
        "id": "c",
        "text": "JavaScript throws an error",
        "isCorrect": false,
        "explanation": ""
      }
    ],
    "hints": [],
    "metadata": {}
  }
]
