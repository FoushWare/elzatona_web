{
  "category": "Testing Strategies",
  "totalQuestions": 8,
  "exportedAt": "2025-09-30T00:28:57.749Z",
  "questions": [
    {
      "id": "imported-testing-strategies-1759191713893-0",
      "createdAt": "2025-09-30T00:21:53.933Z",
      "topics": [
        "Unit Testing",
        "Integration Testing",
        "E2E Testing",
        "TDD"
      ],
      "category": "Testing Strategies",
      "options": [],
      "isActive": true,
      "type": "code",
      "content": "Explain the testing pyramid and different types of tests.",
      "correctAnswer": null,
      "explanation": "**1. Testing Pyramid Structure:**\n\n// Unit Tests (70%) - Fast, isolated, numerous\n// Integration Tests (20%) - Medium speed, test interactions\n// E2E Tests (10%) - Slow, full system, few\n\n// Unit Test Example\nfunction calculateTotal(items) {\nreturn items.reduce((total, item) => total + item.price, 0);\n}\n\ndescribe('calculateTotal', () => {\ntest('should calculate total for empty array', () => {\nexpect(calculateTotal([])).toBe(0);\n});\n\ntest('should calculate total for single item', () => {\nconst items = [{ price: 10 }];\nexpect(calculateTotal(items)).toBe(10);\n});\n\ntest('should calculate total for multiple items', () => {\nconst items = [{ price: 10 }, { price: 20 }, { price: 30 }];\nexpect(calculateTotal(items)).toBe(60);\n});\n});\n\n**2. Integration Tests:**\n\n// Integration test example\ndescribe('User Service Integration', () => {\nlet userService;\nlet database;\n\nbeforeEach(async () => {\ndatabase = await setupTestDatabase();\nuserService = new UserService(database);\n});\n\nafterEach(async () => {\nawait cleanupTestDatabase(database);\n});\n\ntest('should create and retrieve user', async () => {\nconst userData = {\nname: 'John Doe',\nemail: 'john@example.com',\n};\n\nconst user = await userService.createUser(userData);\nexpect(user.id).toBeDefined();\nexpect(user.name).toBe(userData.name);\n\nconst retrievedUser = await userService.getUser(user.id);\nexpect(retrievedUser).toEqual(user);\n});\n\ntest('should handle database errors gracefully', async () => {\nawait database.close();\n\nawait expect(userService.createUser({})).rejects.toThrow(\n'Database connection failed'\n);\n});\n});\n\n**3. End-to-End Tests:**\n\n// E2E test example with Playwright\nimport { test, expect } from '@playwright/test';\n\ntest.describe('User Registration Flow', () => {\ntest('should register new user successfully', async ({ page }) => {\nawait page.goto('/register');\n\nawait page.fill('[data-testid=\"name\"]', 'John Doe');\nawait page.fill('[data-testid=\"email\"]', 'john@example.com');\nawait page.fill('[data-testid=\"password\"]', 'password123');\n\nawait page.click('[data-testid=\"submit\"]');\n\nawait expect(page).toHaveURL('/dashboard');\nawait expect(page.locator('[data-testid=\"welcome-message\"]')).toContainText(\n'Welcome, John Doe'\n);\n});\n\ntest('should show validation errors for invalid input', async ({ page }) => {\nawait page.goto('/register');\n\nawait page.click('[data-testid=\"submit\"]');\n\nawait expect(page.locator('[data-testid=\"name-error\"]')).toBeVisible();\nawait expect(page.locator('[data-testid=\"email-error\"]')).toBeVisible();\nawait expect(page.locator('[data-testid=\"password-error\"]')).toBeVisible();\n});\n});",
      "source": "QuestionsBank",
      "codeBlock": "// Unit Tests (70%) - Fast, isolated, numerous\n// Integration Tests (20%) - Medium speed, test interactions\n// E2E Tests (10%) - Slow, full system, few\n\n// Unit Test Example\nfunction calculateTotal(items) {\n  return items.reduce((total, item) => total + item.price, 0);\n}\n\ndescribe('calculateTotal', () => {\n  test('should calculate total for empty array', () => {\n    expect(calculateTotal([])).toBe(0);\n  });\n\n  test('should calculate total for single item', () => {\n    const items = [{ price: 10 }];\n    expect(calculateTotal(items)).toBe(10);\n  });\n\n  test('should calculate total for multiple items', () => {\n    const items = [{ price: 10 }, { price: 20 }, { price: 30 }];\n    expect(calculateTotal(items)).toBe(60);\n  });\n});",
      "difficulty": "intermediate",
      "title": "Testing Pyramid",
      "updatedAt": "2025-09-30T00:21:53.933Z",
      "learningPaths": [
        "testing-strategies"
      ],
      "isComplete": false,
      "importedAt": "2025-09-30T00:21:53.893Z"
    },
    {
      "id": "imported-testing-strategies-1759191713896-7",
      "createdAt": "2025-09-30T00:21:53.933Z",
      "title": "Code Coverage",
      "isComplete": false,
      "source": "QuestionsBank",
      "topics": [
        "Unit Testing",
        "Integration Testing",
        "E2E Testing",
        "TDD"
      ],
      "options": [],
      "learningPaths": [
        "testing-strategies"
      ],
      "isActive": true,
      "correctAnswer": null,
      "updatedAt": "2025-09-30T00:21:53.933Z",
      "content": "What is code coverage, and what is a good target for a frontend application?",
      "explanation": "Code coverage is a metric that measures the percentage of your code that is executed when your test suite runs. It helps identify untested parts.\n\nA good target for frontend applications is around 60-70%. Aiming for 95%+ often leads to meaningless tests that provide little value and are expensive to maintain. Coverage is a useful guide, not a goal in itself.\n\n**Code Coverage Types:**\n\n// Statement Coverage - measures executed statements\nfunction calculateTotal(items) {\nlet total = 0; // ✓ Covered\nfor (let item of items) {\n// ✓ Covered\ntotal += item.price; // ✓ Covered\n}\nreturn total; // ✓ Covered\n}\n\n// Branch Coverage - measures executed branches\nfunction getDiscount(user) {\nif (user.isPremium) {\n// ✓ Covered (true)\nreturn 0.2; // ✓ Covered\n} else {\n// ✓ Covered (false)\nreturn 0.1; // ✓ Covered\n}\n}\n\n// Function Coverage - measures called functions\nfunction helper() {\n// ✓ Covered\nreturn 'helper';\n}\n\nfunction main() {\n// ✓ Covered\nreturn helper(); // ✓ Covered\n}\n\n// Line Coverage - measures executed lines\nfunction processData(data) {\nconst result = []; // ✓ Covered\ndata.forEach(item => {\n// ✓ Covered\nresult.push(item * 2); // ✓ Covered\n});\nreturn result; // ✓ Covered\n}\n\n**Jest Coverage Configuration:**\n\n// jest.config.js\nmodule.exports = {\ncollectCoverage: true,\ncoverageDirectory: 'coverage',\ncoverageReporters: ['text', 'lcov', 'html'],\ncollectCoverageFrom: [\n'src/**/*.{js,jsx}',\n'!src/**/*.test.{js,jsx}',\n'!src/**/*.spec.{js,jsx}',\n'!src/index.js',\n'!src/setupTests.js',\n],\ncoverageThreshold: {\nglobal: {\nbranches: 70,\nfunctions: 70,\nlines: 70,\nstatements: 70,\n},\n'./src/utils/': {\nbranches: 80,\nfunctions: 80,\nlines: 80,\nstatements: 80,\n},\n},\n};\n\n**Coverage Analysis:**\n\n// Good coverage - meaningful tests\ndescribe('calculateTotal', () => {\ntest('should return 0 for empty array', () => {\nexpect(calculateTotal([])).toBe(0);\n});\n\ntest('should calculate total for items', () => {\nconst items = [{ price: 10 }, { price: 20 }];\nexpect(calculateTotal(items)).toBe(30);\n});\n\ntest('should handle negative prices', () => {\nconst items = [{ price: -10 }, { price: 20 }];\nexpect(calculateTotal(items)).toBe(10);\n});\n});\n\n// Bad coverage - meaningless tests\ndescribe('Bad Coverage Example', () => {\ntest('should have a name property', () => {\nconst user = { name: 'John' };\nexpect(user.name).toBeDefined();\n});\n\ntest('should have an email property', () => {\nconst user = { email: 'john@example.com' };\nexpect(user.email).toBeDefined();\n});\n});\n\n**Coverage Reports:**\n\n// Generate coverage report\n// npm test -- --coverage\n\n// Coverage report structure\nconst coverageReport = {\ntotal: {\nlines: { total: 100, covered: 85, skipped: 0, pct: 85 },\nfunctions: { total: 20, covered: 18, skipped: 0, pct: 90 },\nbranches: { total: 30, covered: 25, skipped: 0, pct: 83.33 },\nstatements: { total: 100, covered: 85, skipped: 0, pct: 85 },\n},\nfiles: {\n'src/utils/helpers.js': {\nlines: { total: 50, covered: 45, skipped: 0, pct: 90 },\nfunctions: { total: 10, covered: 9, skipped: 0, pct: 90 },\nbranches: { total: 15, covered: 12, skipped: 0, pct: 80 },\nstatements: { total: 50, covered: 45, skipped: 0, pct: 90 },\n},\n},\n};\n\n**Coverage Best Practices:**\n\n// Focus on critical paths\ndescribe('User Authentication', () => {\ntest('should authenticate valid user', () => {\nconst user = { email: 'test@example.com', password: 'password123' };\nconst result = authenticateUser(user);\nexpect(result.success).toBe(true);\n});\n\ntest('should reject invalid credentials', () => {\nconst user = { email: 'test@example.com', password: 'wrong' };\nconst result = authenticateUser(user);\nexpect(result.success).toBe(false);\n});\n\ntest('should handle network errors', async () => {\n// Mock network failure\njest.spyOn(global, 'fetch').mockRejectedValue(new Error('Network error'));\n\nconst user = { email: 'test@example.com', password: 'password123' };\nconst result = await authenticateUser(user);\nexpect(result.error).toBe('Network error');\n});\n});\n\n// Test edge cases\ndescribe('Edge Cases', () => {\ntest('should handle empty input', () => {\nexpect(processData([])).toEqual([]);\n});\n\ntest('should handle null input', () => {\nexpect(processData(null)).toEqual([]);\n});\n\ntest('should handle undefined input', () => {\nexpect(processData(undefined)).toEqual([]);\n});\n});\n\n**Coverage Monitoring:**\n\n// CI/CD coverage check\n// .github/workflows/test.yml\nname: Tests\non: [push, pull_request]\njobs:\ntest:\nruns-on: ubuntu-latest\nsteps:\n- uses: actions/checkout@v2\n- name: Setup Node.js\nuses: actions/setup-node@v2\nwith:\nnode-version: '16'\n- name: Install dependencies\nrun: npm ci\n- name: Run tests with coverage\nrun: npm test -- --coverage\n- name: Upload coverage to Codecov\nuses: codecov/codecov-action@v2\nwith:\nfile: ./coverage/lcov.info\nflags: unittests\nname: codecov-umbrella\n\n**Coverage vs Quality:**\n\n// High coverage, low quality\ndescribe('Bad Tests', () => {\ntest('should exist', () => {\nexpect(calculateTotal).toBeDefined();\n});\n\ntest('should be a function', () => {\nexpect(typeof calculateTotal).toBe('function');\n});\n});\n\n// Lower coverage, high quality\ndescribe('Good Tests', () => {\ntest('should calculate total correctly', () => {\nconst items = [{ price: 10 }, { price: 20 }];\nexpect(calculateTotal(items)).toBe(30);\n});\n\ntest('should handle edge cases', () => {\nexpect(calculateTotal([])).toBe(0);\nexpect(calculateTotal([{ price: -10 }])).toBe(-10);\n});\n});",
      "codeBlock": "// Statement Coverage - measures executed statements\nfunction calculateTotal(items) {\n  let total = 0; // ✓ Covered\n  for (let item of items) {\n    // ✓ Covered\n    total += item.price; // ✓ Covered\n  }\n  return total; // ✓ Covered\n}\n\n// Branch Coverage - measures executed branches\nfunction getDiscount(user) {\n  if (user.isPremium) {\n    // ✓ Covered (true)\n    return 0.2; // ✓ Covered\n  } else {\n    // ✓ Covered (false)\n    return 0.1; // ✓ Covered\n  }\n}\n\n// Function Coverage - measures called functions\nfunction helper() {\n  // ✓ Covered\n  return 'helper';\n}\n\nfunction main() {\n  // ✓ Covered\n  return helper(); // ✓ Covered\n}\n\n// Line Coverage - measures executed lines\nfunction processData(data) {\n  const result = []; // ✓ Covered\n  data.forEach(item => {\n    // ✓ Covered\n    result.push(item * 2); // ✓ Covered\n  });\n  return result; // ✓ Covered\n}",
      "type": "code",
      "importedAt": "2025-09-30T00:21:53.896Z",
      "difficulty": "intermediate",
      "category": "Testing Strategies"
    },
    {
      "id": "imported-testing-strategies-1759191713893-2",
      "type": "code",
      "correctAnswer": null,
      "isComplete": false,
      "importedAt": "2025-09-30T00:21:53.893Z",
      "learningPaths": [
        "testing-strategies"
      ],
      "options": [],
      "isActive": true,
      "createdAt": "2025-09-30T00:21:53.933Z",
      "category": "Testing Strategies",
      "title": "Mocking and Stubbing",
      "codeBlock": "// Mock external dependencies\njest.mock('axios');\njest.mock('../services/emailService');\n\n// Mock functions\nconst mockFn = jest.fn();\nmockFn.mockReturnValue('mocked value');\nmockFn.mockResolvedValue('async mocked value');\nmockFn.mockRejectedValue(new Error('mocked error'));\n\n// Mock modules\njest.mock('../utils/logger', () => ({\n  info: jest.fn(),\n  error: jest.fn(),\n  warn: jest.fn(),\n}));\n\n// Mock class methods\nconst mockUserService = {\n  findById: jest.fn(),\n  create: jest.fn(),\n  update: jest.fn(),\n  delete: jest.fn(),\n};\n\n// Usage in tests\ndescribe('User Controller', () => {\n  beforeEach(() => {\n    jest.clearAllMocks();\n  });\n\n  test('should get user by id', async () => {\n    const mockUser = { id: 1, name: 'John Doe' };\n    mockUserService.findById.mockResolvedValue(mockUser);\n\n    const result = await userController.getUser(1);\n\n    expect(mockUserService.findById).toHaveBeenCalledWith(1);\n    expect(result).toEqual(mockUser);\n  });\n\n  test('should handle user not found', async () => {\n    mockUserService.findById.mockResolvedValue(null);\n\n    await expect(userController.getUser(999)).rejects.toThrow('User not found');\n  });\n});",
      "content": "Explain mocking and stubbing techniques in testing.",
      "explanation": "**1. Jest Mocking:**\n\n// Mock external dependencies\njest.mock('axios');\njest.mock('../services/emailService');\n\n// Mock functions\nconst mockFn = jest.fn();\nmockFn.mockReturnValue('mocked value');\nmockFn.mockResolvedValue('async mocked value');\nmockFn.mockRejectedValue(new Error('mocked error'));\n\n// Mock modules\njest.mock('../utils/logger', () => ({\ninfo: jest.fn(),\nerror: jest.fn(),\nwarn: jest.fn(),\n}));\n\n// Mock class methods\nconst mockUserService = {\nfindById: jest.fn(),\ncreate: jest.fn(),\nupdate: jest.fn(),\ndelete: jest.fn(),\n};\n\n// Usage in tests\ndescribe('User Controller', () => {\nbeforeEach(() => {\njest.clearAllMocks();\n});\n\ntest('should get user by id', async () => {\nconst mockUser = { id: 1, name: 'John Doe' };\nmockUserService.findById.mockResolvedValue(mockUser);\n\nconst result = await userController.getUser(1);\n\nexpect(mockUserService.findById).toHaveBeenCalledWith(1);\nexpect(result).toEqual(mockUser);\n});\n\ntest('should handle user not found', async () => {\nmockUserService.findById.mockResolvedValue(null);\n\nawait expect(userController.getUser(999)).rejects.toThrow('User not found');\n});\n});\n\n**2. Sinon Stubbing:**\n\nconst sinon = require('sinon');\n\ndescribe('Payment Service', () => {\nlet paymentService;\nlet stripeStub;\n\nbeforeEach(() => {\npaymentService = new PaymentService();\nstripeStub = sinon.stub(paymentService.stripe, 'charges');\n});\n\nafterEach(() => {\nsinon.restore();\n});\n\ntest('should process payment successfully', async () => {\nconst mockCharge = {\nid: 'ch_123',\namount: 2000,\nstatus: 'succeeded',\n};\n\nstripeStub.create.resolves(mockCharge);\n\nconst result = await paymentService.processPayment({\namount: 2000,\ncurrency: 'usd',\nsource: 'tok_visa',\n});\n\nexpect(result.success).toBe(true);\nexpect(result.chargeId).toBe('ch_123');\nexpect(stripeStub.create).toHaveBeenCalledWith({\namount: 2000,\ncurrency: 'usd',\nsource: 'tok_visa',\n});\n});\n\ntest('should handle payment failure', async () => {\nstripeStub.create.rejects(new Error('Card declined'));\n\nawait expect(\npaymentService.processPayment({\namount: 2000,\ncurrency: 'usd',\nsource: 'tok_visa',\n})\n).rejects.toThrow('Card declined');\n});\n});\n\n**3. Test Doubles:**\n\n// Dummy - placeholder object\nconst dummyUser = { id: 1, name: 'Test User' };\n\n// Stub - returns predefined responses\nconst stubUserService = {\nfindById: id => Promise.resolve({ id, name: 'Stubbed User' }),\n};\n\n// Spy - tracks method calls\nconst spyLogger = {\ninfo: jest.fn(),\nerror: jest.fn(),\n};\n\n// Mock - predefined behavior with verification\nconst mockEmailService = {\nsend: jest.fn().mockResolvedValue(true),\nsendWelcome: jest.fn().mockResolvedValue(true),\n};\n\n// Fake - working implementation with limitations\nclass FakeDatabase {\nconstructor() {\nthis.data = new Map();\n}\n\nasync save(key, value) {\nthis.data.set(key, value);\nreturn value;\n}\n\nasync find(key) {\nreturn this.data.get(key);\n}\n\nasync delete(key) {\nreturn this.data.delete(key);\n}\n}\n\n// Usage\ndescribe('User Registration', () => {\ntest('should register user and send welcome email', async () => {\nconst fakeDb = new FakeDatabase();\nconst userService = new UserService(fakeDb, mockEmailService);\n\nconst userData = { name: 'John Doe', email: 'john@example.com' };\nconst user = await userService.register(userData);\n\nexpect(user.id).toBeDefined();\nexpect(mockEmailService.sendWelcome).toHaveBeenCalledWith(user.email);\n});\n});",
      "topics": [
        "Unit Testing",
        "Integration Testing",
        "E2E Testing",
        "TDD"
      ],
      "difficulty": "intermediate",
      "source": "QuestionsBank",
      "updatedAt": "2025-09-30T00:21:53.933Z"
    },
    {
      "id": "imported-testing-strategies-1759191713893-3",
      "difficulty": "intermediate",
      "isComplete": false,
      "title": "Test Coverage and Quality",
      "type": "code",
      "createdAt": "2025-09-30T00:21:53.933Z",
      "isActive": true,
      "content": "Explain test coverage metrics and quality practices.",
      "learningPaths": [
        "testing-strategies"
      ],
      "category": "Testing Strategies",
      "codeBlock": "// Jest coverage configuration\n// jest.config.js\nmodule.exports = {\n  collectCoverage: true,\n  coverageDirectory: 'coverage',\n  coverageReporters: ['text', 'lcov', 'html'],\n  coverageThreshold: {\n    global: {\n      branches: 80,\n      functions: 80,\n      lines: 80,\n      statements: 80,\n    },\n  },\n  collectCoverageFrom: [\n    'src/**/*.{js,jsx}',\n    '!src/**/*.test.{js,jsx}',\n    '!src/**/*.spec.{js,jsx}',\n    '!src/index.js',\n  ],\n};\n\n// Coverage types\n// Line Coverage - percentage of lines executed\n// Branch Coverage - percentage of branches taken\n// Function Coverage - percentage of functions called\n// Statement Coverage - percentage of statements executed",
      "correctAnswer": null,
      "importedAt": "2025-09-30T00:21:53.893Z",
      "explanation": "**1. Coverage Metrics:**\n\n// Jest coverage configuration\n// jest.config.js\nmodule.exports = {\ncollectCoverage: true,\ncoverageDirectory: 'coverage',\ncoverageReporters: ['text', 'lcov', 'html'],\ncoverageThreshold: {\nglobal: {\nbranches: 80,\nfunctions: 80,\nlines: 80,\nstatements: 80,\n},\n},\ncollectCoverageFrom: [\n'src/**/*.{js,jsx}',\n'!src/**/*.test.{js,jsx}',\n'!src/**/*.spec.{js,jsx}',\n'!src/index.js',\n],\n};\n\n// Coverage types\n// Line Coverage - percentage of lines executed\n// Branch Coverage - percentage of branches taken\n// Function Coverage - percentage of functions called\n// Statement Coverage - percentage of statements executed\n\n**2. Test Quality Metrics:**\n\n// Test quality indicators\nclass TestQualityMetrics {\nconstructor() {\nthis.metrics = {\ntestCount: 0,\npassingTests: 0,\nfailingTests: 0,\nskippedTests: 0,\nexecutionTime: 0,\ncoverage: {\nlines: 0,\nbranches: 0,\nfunctions: 0,\nstatements: 0,\n},\n};\n}\n\ncalculateTestQuality() {\nconst passRate = this.metrics.passingTests / this.metrics.testCount;\nconst avgExecutionTime =\nthis.metrics.executionTime / this.metrics.testCount;\nconst coverageScore = this.calculateCoverageScore();\n\nreturn {\npassRate,\navgExecutionTime,\ncoverageScore,\nqualityScore: this.calculateOverallQuality(passRate, coverageScore),\n};\n}\n\ncalculateCoverageScore() {\nconst { lines, branches, functions, statements } = this.metrics.coverage;\nreturn (lines + branches + functions + statements) / 4;\n}\n\ncalculateOverallQuality(passRate, coverageScore) {\nreturn (passRate * 0.6 + coverageScore * 0.4) * 100;\n}\n}\n\n**3. Test Organization:**\n\n// Test structure\ndescribe('User Service', () => {\ndescribe('User Creation', () => {\ntest('should create user with valid data', () => {\n// Test implementation\n});\n\ntest('should validate required fields', () => {\n// Test implementation\n});\n\ntest('should handle duplicate email', () => {\n// Test implementation\n});\n});\n\ndescribe('User Authentication', () => {\ntest('should authenticate with valid credentials', () => {\n// Test implementation\n});\n\ntest('should reject invalid credentials', () => {\n// Test implementation\n});\n\ntest('should handle locked accounts', () => {\n// Test implementation\n});\n});\n});\n\n// Test data factories\nclass UserFactory {\nstatic create(overrides = {}) {\nreturn {\nid: 1,\nname: 'John Doe',\nemail: 'john@example.com',\npassword: 'password123',\n...overrides,\n};\n}\n\nstatic createMany(count, overrides = {}) {\nreturn Array.from({ length: count }, (_, index) =>\nthis.create({ id: index + 1, ...overrides })\n);\n}\n}\n\n// Test utilities\nclass TestUtils {\nstatic async waitFor(condition, timeout = 5000) {\nconst start = Date.now();\nwhile (Date.now() - start < timeout) {\nif (await condition()) {\nreturn true;\n}\nawait new Promise(resolve => setTimeout(resolve, 100));\n}\nthrow new Error('Condition not met within timeout');\n}\n\nstatic mockDate(date) {\nconst mockDate = new Date(date);\njest.spyOn(global, 'Date').mockImplementation(() => mockDate);\nreturn mockDate;\n}\n}",
      "updatedAt": "2025-09-30T00:21:53.933Z",
      "options": [],
      "topics": [
        "Unit Testing",
        "Integration Testing",
        "E2E Testing",
        "TDD"
      ],
      "source": "QuestionsBank"
    },
    {
      "id": "imported-testing-strategies-1759191713896-6",
      "codeBlock": "// Component to test\nfunction UserProfile({ user, onEdit }) {\n  const [isEditing, setIsEditing] = useState(false);\n\n  const handleSave = updatedUser => {\n    onEdit(updatedUser);\n    setIsEditing(false);\n  };\n\n  return (\n    <div data-testid=\"user-profile\">\n      {isEditing ? (\n        <UserEditForm\n          user={user}\n          onSave={handleSave}\n          onCancel={() => setIsEditing(false)}\n        />\n      ) : (\n        <div>\n          <h2>{user.name}</h2>\n          <p>{user.email}</p>\n          <button onClick={() => setIsEditing(true)}>Edit</button>\n        </div>\n      )}\n    </div>\n  );\n}\n\n// Unit test\nimport { render, screen, fireEvent } from '@testing-library/react';\nimport { UserProfile } from './UserProfile';\n\ndescribe('UserProfile', () => {\n  const mockUser = {\n    id: 1,\n    name: 'John Doe',\n    email: 'john@example.com',\n  };\n\n  const mockOnEdit = jest.fn();\n\n  beforeEach(() => {\n    mockOnEdit.mockClear();\n  });\n\n  test('renders user information', () => {\n    render(<UserProfile user={mockUser} onEdit={mockOnEdit} />);\n\n    expect(screen.getByText('John Doe')).toBeInTheDocument();\n    expect(screen.getByText('john@example.com')).toBeInTheDocument();\n  });\n\n  test('switches to edit mode when edit button is clicked', () => {\n    render(<UserProfile user={mockUser} onEdit={mockOnEdit} />);\n\n    fireEvent.click(screen.getByText('Edit'));\n\n    expect(screen.getByTestId('user-edit-form')).toBeInTheDocument();\n  });\n\n  test('calls onEdit when user is saved', () => {\n    render(<UserProfile user={mockUser} onEdit={mockOnEdit} />);\n\n    fireEvent.click(screen.getByText('Edit'));\n    fireEvent.click(screen.getByText('Save'));\n\n    expect(mockOnEdit).toHaveBeenCalledWith(mockUser);\n  });\n});",
      "topics": [
        "Unit Testing",
        "Integration Testing",
        "E2E Testing",
        "TDD"
      ],
      "content": "How would you approach testing a React application?",
      "explanation": "Follow the testing pyramid:\n\n**Unit Tests**: Test individual, reusable components or pure functions in isolation. Focus on components with complex logic. Use Jest and React Testing Library.\n\n**Integration Tests**: Test the interaction between several components or between components and hooks. This is where you get the most confidence for the effort.\n\n**End-to-End (E2E) Tests**: Test critical user flows (e.g., login, checkout) in a real browser environment. Use tools like Cypress or Playwright. They are slower but simulate real user behavior.\n\nAvoid the trap of unit testing everything; focus on value. Test reusable components and critical business logic.\n\n**Unit Testing React Components:**\n\n// Component to test\nfunction UserProfile({ user, onEdit }) {\nconst [isEditing, setIsEditing] = useState(false);\n\nconst handleSave = updatedUser => {\nonEdit(updatedUser);\nsetIsEditing(false);\n};\n\nreturn (\n<div data-testid=\"user-profile\">\n{isEditing ? (\n<UserEditForm\nuser={user}\nonSave={handleSave}\nonCancel={() => setIsEditing(false)}\n/>\n) : (\n<div>\n<h2>{user.name}</h2>\n<p>{user.email}</p>\n<button onClick={() => setIsEditing(true)}>Edit</button>\n</div>\n)}\n</div>\n);\n}\n\n// Unit test\nimport { render, screen, fireEvent } from '@testing-library/react';\nimport { UserProfile } from './UserProfile';\n\ndescribe('UserProfile', () => {\nconst mockUser = {\nid: 1,\nname: 'John Doe',\nemail: 'john@example.com',\n};\n\nconst mockOnEdit = jest.fn();\n\nbeforeEach(() => {\nmockOnEdit.mockClear();\n});\n\ntest('renders user information', () => {\nrender(<UserProfile user={mockUser} onEdit={mockOnEdit} />);\n\nexpect(screen.getByText('John Doe')).toBeInTheDocument();\nexpect(screen.getByText('john@example.com')).toBeInTheDocument();\n});\n\ntest('switches to edit mode when edit button is clicked', () => {\nrender(<UserProfile user={mockUser} onEdit={mockOnEdit} />);\n\nfireEvent.click(screen.getByText('Edit'));\n\nexpect(screen.getByTestId('user-edit-form')).toBeInTheDocument();\n});\n\ntest('calls onEdit when user is saved', () => {\nrender(<UserProfile user={mockUser} onEdit={mockOnEdit} />);\n\nfireEvent.click(screen.getByText('Edit'));\nfireEvent.click(screen.getByText('Save'));\n\nexpect(mockOnEdit).toHaveBeenCalledWith(mockUser);\n});\n});\n\n**Integration Testing:**\n\n// Integration test - testing component interactions\ndescribe('User Management Integration', () => {\ntest('should create and display new user', async () => {\nrender(\n<UserProvider>\n<UserList />\n<CreateUserForm />\n</UserProvider>\n);\n\n// Fill form\nfireEvent.change(screen.getByLabelText('Name'), {\ntarget: { value: 'Jane Doe' },\n});\nfireEvent.change(screen.getByLabelText('Email'), {\ntarget: { value: 'jane@example.com' },\n});\n\n// Submit form\nfireEvent.click(screen.getByText('Create User'));\n\n// Wait for user to appear in list\nawait waitFor(() => {\nexpect(screen.getByText('Jane Doe')).toBeInTheDocument();\n});\n});\n\ntest('should update user and reflect changes', async () => {\nconst { user } = renderWithProviders(<UserManagement />);\n\n// Edit existing user\nfireEvent.click(screen.getByTestId('edit-user-1'));\nfireEvent.change(screen.getByLabelText('Name'), {\ntarget: { value: 'Updated Name' },\n});\nfireEvent.click(screen.getByText('Save'));\n\n// Verify update\nawait waitFor(() => {\nexpect(screen.getByText('Updated Name')).toBeInTheDocument();\n});\n});\n});\n\n**Custom Hooks Testing:**\n\n// Custom hook to test\nfunction useCounter(initialValue = 0) {\nconst [count, setCount] = useState(initialValue);\n\nconst increment = useCallback(() => setCount(prev => prev + 1), []);\nconst decrement = useCallback(() => setCount(prev => prev - 1), []);\nconst reset = useCallback(() => setCount(initialValue), [initialValue]);\n\nreturn { count, increment, decrement, reset };\n}\n\n// Hook test\nimport { renderHook, act } from '@testing-library/react-hooks';\n\ndescribe('useCounter', () => {\ntest('should initialize with default value', () => {\nconst { result } = renderHook(() => useCounter());\n\nexpect(result.current.count).toBe(0);\n});\n\ntest('should initialize with custom value', () => {\nconst { result } = renderHook(() => useCounter(10));\n\nexpect(result.current.count).toBe(10);\n});\n\ntest('should increment count', () => {\nconst { result } = renderHook(() => useCounter());\n\nact(() => {\nresult.current.increment();\n});\n\nexpect(result.current.count).toBe(1);\n});\n\ntest('should decrement count', () => {\nconst { result } = renderHook(() => useCounter(5));\n\nact(() => {\nresult.current.decrement();\n});\n\nexpect(result.current.count).toBe(4);\n});\n\ntest('should reset count', () => {\nconst { result } = renderHook(() => useCounter(10));\n\nact(() => {\nresult.current.increment();\nresult.current.increment();\n});\n\nexpect(result.current.count).toBe(12);\n\nact(() => {\nresult.current.reset();\n});\n\nexpect(result.current.count).toBe(10);\n});\n});\n\n**E2E Testing with Cypress:**\n\n// cypress/integration/user-management.spec.js\ndescribe('User Management E2E', () => {\nbeforeEach(() => {\ncy.visit('/users');\n});\n\nit('should create a new user', () => {\n// Click create user button\ncy.get('[data-testid=\"create-user-button\"]').click();\n\n// Fill form\ncy.get('[data-testid=\"name-input\"]').type('John Doe');\ncy.get('[data-testid=\"email-input\"]').type('john@example.com');\n\n// Submit form\ncy.get('[data-testid=\"submit-button\"]').click();\n\n// Verify user appears in list\ncy.get('[data-testid=\"user-list\"]').should('contain', 'John Doe');\ncy.get('[data-testid=\"user-list\"]').should('contain', 'john@example.com');\n});\n\nit('should edit existing user', () => {\n// Click edit button for first user\ncy.get('[data-testid=\"user-list\"]')\n.first()\n.find('[data-testid=\"edit-button\"]')\n.click();\n\n// Update name\ncy.get('[data-testid=\"name-input\"]').clear().type('Updated Name');\n\n// Save changes\ncy.get('[data-testid=\"save-button\"]').click();\n\n// Verify update\ncy.get('[data-testid=\"user-list\"]').should('contain', 'Updated Name');\n});\n\nit('should delete user', () => {\n// Get initial count\ncy.get('[data-testid=\"user-list\"]')\n.children()\n.then($users => {\nconst initialCount = $users.length;\n\n// Delete first user\ncy.get('[data-testid=\"user-list\"]')\n.first()\n.find('[data-testid=\"delete-button\"]')\n.click();\ncy.get('[data-testid=\"confirm-delete\"]').click();\n\n// Verify count decreased\ncy.get('[data-testid=\"user-list\"]')\n.children()\n.should('have.length', initialCount - 1);\n});\n});\n});\n\n**Testing Best Practices:**\n\n// Test utilities\nexport function renderWithProviders(\nui,\n{ preloadedState = {}, ...renderOptions } = {}\n) {\nconst store = configureStore({\nreducer: { users: userReducer },\npreloadedState,\n});\n\nfunction Wrapper({ children }) {\nreturn (\n<Provider store={store}>\n<Router>{children}</Router>\n</Provider>\n);\n}\n\nreturn { store, ...render(ui, { wrapper: Wrapper, ...renderOptions }) };\n}\n\n// Mock API responses\nexport const mockApiResponses = {\nusers: [\n{ id: 1, name: 'John Doe', email: 'john@example.com' },\n{ id: 2, name: 'Jane Smith', email: 'jane@example.com' },\n],\n};\n\n// Test data factories\nexport function createUser(overrides = {}) {\nreturn {\nid: Math.random(),\nname: 'Test User',\nemail: 'test@example.com',\n...overrides,\n};\n}\n\n// Focus on behavior, not implementation\ndescribe('UserProfile', () => {\ntest('should allow user to edit their profile', () => {\nconst user = createUser({ name: 'John Doe' });\nrender(<UserProfile user={user} onEdit={jest.fn()} />);\n\n// Test behavior: user can edit profile\nfireEvent.click(screen.getByText('Edit'));\nexpect(screen.getByTestId('user-edit-form')).toBeInTheDocument();\n});\n});",
      "difficulty": "intermediate",
      "source": "QuestionsBank",
      "updatedAt": "2025-09-30T00:21:53.933Z",
      "type": "code",
      "importedAt": "2025-09-30T00:21:53.896Z",
      "correctAnswer": null,
      "isComplete": false,
      "learningPaths": [
        "testing-strategies"
      ],
      "isActive": true,
      "createdAt": "2025-09-30T00:21:53.933Z",
      "options": [],
      "category": "Testing Strategies",
      "title": "React Testing Approach"
    },
    {
      "id": "imported-testing-strategies-1759191713896-5",
      "explanation": "**1. GitHub Actions CI/CD:**\n\n# .github/workflows/ci.yml\nname: CI/CD Pipeline\n\non:\npush:\nbranches: [main, develop]\npull_request:\nbranches: [main]\n\njobs:\ntest:\nruns-on: ubuntu-latest\n\nstrategy:\nmatrix:\nnode-version: [16.x, 18.x, 20.x]\n\nsteps:\n- uses: actions/checkout@v3\n\n- name: Use Node.js ${{ matrix.node-version }}\nuses: actions/setup-node@v3\nwith:\nnode-version: ${{ matrix.node-version }}\ncache: 'npm'\n\n- name: Install dependencies\nrun: npm ci\n\n- name: Run linting\nrun: npm run lint\n\n- name: Run unit tests\nrun: npm run test:unit\n\n- name: Run integration tests\nrun: npm run test:integration\nenv:\nDATABASE_URL: ${{ secrets.TEST_DATABASE_URL }}\n\n- name: Generate coverage report\nrun: npm run test:coverage\n\n- name: Upload coverage to Codecov\nuses: codecov/codecov-action@v3\nwith:\nfile: ./coverage/lcov.info\n\n- name: Run E2E tests\nrun: npm run test:e2e\nenv:\nBASE_URL: http://localhost:3000\n\n- name: Build application\nrun: npm run build\n\n- name: Deploy to staging\nif: github.ref == 'refs/heads/develop'\nrun: npm run deploy:staging\nenv:\nDEPLOY_TOKEN: ${{ secrets.STAGING_DEPLOY_TOKEN }}\n\n- name: Deploy to production\nif: github.ref == 'refs/heads/main'\nrun: npm run deploy:production\nenv:\nDEPLOY_TOKEN: ${{ secrets.PRODUCTION_DEPLOY_TOKEN }}\n\n**2. Test Pipeline Configuration:**\n\n// package.json scripts\n{\n\"scripts\": {\n\"test\": \"jest\",\n\"test:unit\": \"jest --testPathPattern=unit\",\n\"test:integration\": \"jest --testPathPattern=integration\",\n\"test:e2e\": \"playwright test\",\n\"test:coverage\": \"jest --coverage\",\n\"test:watch\": \"jest --watch\",\n\"test:ci\": \"jest --ci --coverage --watchAll=false\",\n\"lint\": \"eslint src --ext .js,.jsx,.ts,.tsx\",\n\"lint:fix\": \"eslint src --ext .js,.jsx,.ts,.tsx --fix\",\n\"type-check\": \"tsc --noEmit\",\n\"build\": \"next build\",\n\"deploy:staging\": \"vercel --target staging\",\n\"deploy:production\": \"vercel --target production\"\n}\n}\n\n// Jest configuration\nmodule.exports = {\npreset: 'ts-jest',\ntestEnvironment: 'node',\nroots: ['<rootDir>/src'],\ntestMatch: [\n'**/__tests__/**/*.+(ts|tsx|js)',\n'**/*.(test|spec).+(ts|tsx|js)'\n],\ntransform: {\n'^.+\\\\.(ts|tsx)$': 'ts-jest'\n},\ncollectCoverageFrom: [\n'src/**/*.{ts,tsx}',\n'!src/**/*.d.ts',\n'!src/**/*.stories.{ts,tsx}'\n],\ncoverageThreshold: {\nglobal: {\nbranches: 80,\nfunctions: 80,\nlines: 80,\nstatements: 80\n}\n},\nsetupFilesAfterEnv: ['<rootDir>/src/setupTests.ts']\n};\n\n**3. Test Quality Gates:**\n\n// Quality gate configuration\nclass QualityGate {\nconstructor() {\nthis.thresholds = {\ncoverage: {\nlines: 80,\nbranches: 80,\nfunctions: 80,\nstatements: 80,\n},\nperformance: {\nmaxResponseTime: 500,\nmaxMemoryUsage: 100 * 1024 * 1024, // 100MB\nmaxCpuUsage: 80,\n},\nsecurity: {\nmaxVulnerabilities: 0,\nmaxHighSeverity: 0,\n},\n};\n}\n\nasync checkCoverage(coverageReport) {\nconst { lines, branches, functions, statements } = coverageReport;\n\nif (lines < this.thresholds.coverage.lines) {\nthrow new Error(\n`Line coverage ${lines}% is below threshold ${this.thresholds.coverage.lines}%`\n);\n}\n\nif (branches < this.thresholds.coverage.branches) {\nthrow new Error(\n`Branch coverage ${branches}% is below threshold ${this.thresholds.coverage.branches}%`\n);\n}\n\nif (functions < this.thresholds.coverage.functions) {\nthrow new Error(\n`Function coverage ${functions}% is below threshold ${this.thresholds.coverage.functions}%`\n);\n}\n\nif (statements < this.thresholds.coverage.statements) {\nthrow new Error(\n`Statement coverage ${statements}% is below threshold ${this.thresholds.coverage.statements}%`\n);\n}\n\nreturn true;\n}\n\nasync checkPerformance(performanceReport) {\nconst { responseTime, memoryUsage, cpuUsage } = performanceReport;\n\nif (responseTime > this.thresholds.performance.maxResponseTime) {\nthrow new Error(\n`Response time ${responseTime}ms exceeds threshold ${this.thresholds.performance.maxResponseTime}ms`\n);\n}\n\nif (memoryUsage > this.thresholds.performance.maxMemoryUsage) {\nthrow new Error(\n`Memory usage ${memoryUsage} bytes exceeds threshold ${this.thresholds.performance.maxMemoryUsage} bytes`\n);\n}\n\nif (cpuUsage > this.thresholds.performance.maxCpuUsage) {\nthrow new Error(\n`CPU usage ${cpuUsage}% exceeds threshold ${this.thresholds.performance.maxCpuUsage}%`\n);\n}\n\nreturn true;\n}\n\nasync checkSecurity(securityReport) {\nconst { vulnerabilities, highSeverity } = securityReport;\n\nif (vulnerabilities > this.thresholds.security.maxVulnerabilities) {\nthrow new Error(\n`Vulnerabilities ${vulnerabilities} exceed threshold ${this.thresholds.security.maxVulnerabilities}`\n);\n}\n\nif (highSeverity > this.thresholds.security.maxHighSeverity) {\nthrow new Error(\n`High severity vulnerabilities ${highSeverity} exceed threshold ${this.thresholds.security.maxHighSeverity}`\n);\n}\n\nreturn true;\n}\n}",
      "topics": [
        "Unit Testing",
        "Integration Testing",
        "E2E Testing",
        "TDD"
      ],
      "correctAnswer": null,
      "isActive": true,
      "source": "QuestionsBank",
      "createdAt": "2025-09-30T00:21:53.933Z",
      "learningPaths": [
        "testing-strategies"
      ],
      "title": "Test Automation and CI/CD",
      "updatedAt": "2025-09-30T00:21:53.933Z",
      "category": "Testing Strategies",
      "codeBlock": "# .github/workflows/ci.yml\nname: CI/CD Pipeline\n\non:\n  push:\n    branches: [main, develop]\n  pull_request:\n    branches: [main]\n\njobs:\n  test:\n    runs-on: ubuntu-latest\n\n    strategy:\n      matrix:\n        node-version: [16.x, 18.x, 20.x]\n\n    steps:\n      - uses: actions/checkout@v3\n\n      - name: Use Node.js ${{ matrix.node-version }}\n        uses: actions/setup-node@v3\n        with:\n          node-version: ${{ matrix.node-version }}\n          cache: 'npm'\n\n      - name: Install dependencies\n        run: npm ci\n\n      - name: Run linting\n        run: npm run lint\n\n      - name: Run unit tests\n        run: npm run test:unit\n\n      - name: Run integration tests\n        run: npm run test:integration\n        env:\n          DATABASE_URL: ${{ secrets.TEST_DATABASE_URL }}\n\n      - name: Generate coverage report\n        run: npm run test:coverage\n\n      - name: Upload coverage to Codecov\n        uses: codecov/codecov-action@v3\n        with:\n          file: ./coverage/lcov.info\n\n      - name: Run E2E tests\n        run: npm run test:e2e\n        env:\n          BASE_URL: http://localhost:3000\n\n      - name: Build application\n        run: npm run build\n\n      - name: Deploy to staging\n        if: github.ref == 'refs/heads/develop'\n        run: npm run deploy:staging\n        env:\n          DEPLOY_TOKEN: ${{ secrets.STAGING_DEPLOY_TOKEN }}\n\n      - name: Deploy to production\n        if: github.ref == 'refs/heads/main'\n        run: npm run deploy:production\n        env:\n          DEPLOY_TOKEN: ${{ secrets.PRODUCTION_DEPLOY_TOKEN }}",
      "options": [],
      "content": "Explain test automation in CI/CD pipelines.",
      "importedAt": "2025-09-30T00:21:53.896Z",
      "isComplete": false,
      "type": "code",
      "difficulty": "intermediate"
    },
    {
      "id": "imported-testing-strategies-1759191713893-4",
      "explanation": "**1. Load Testing:**\n\n// Using Artillery for load testing\n// artillery-config.yml\nconfig:\ntarget: 'http://localhost:3000'\nphases:\n- duration: 60\narrivalRate: 10\n- duration: 120\narrivalRate: 20\n- duration: 60\narrivalRate: 10\n\nscenarios:\n- name: \"User API Load Test\"\nweight: 100\nflow:\n- get:\nurl: \"/api/users\"\n- post:\nurl: \"/api/users\"\njson:\nname: \"Load Test User\"\nemail: \"loadtest@example.com\"\n\n// Using k6 for load testing\nimport http from 'k6/http';\nimport { check, sleep } from 'k6';\n\nexport let options = {\nstages: [\n{ duration: '2m', target: 100 },\n{ duration: '5m', target: 100 },\n{ duration: '2m', target: 200 },\n{ duration: '5m', target: 200 },\n{ duration: '2m', target: 0 },\n],\n};\n\nexport default function() {\nlet response = http.get('http://localhost:3000/api/users');\ncheck(response, {\n'status is 200': (r) => r.status === 200,\n'response time < 500ms': (r) => r.timings.duration < 500,\n});\nsleep(1);\n}\n\n**2. Stress Testing:**\n\n// Stress test configuration\nconst stressTestConfig = {\ntarget: 'http://localhost:3000',\nphases: [\n{ duration: '2m', arrivalRate: 1 },\n{ duration: '5m', arrivalRate: 5 },\n{ duration: '2m', arrivalRate: 10 },\n{ duration: '5m', arrivalRate: 15 },\n{ duration: '2m', arrivalRate: 20 },\n{ duration: '5m', arrivalRate: 25 },\n{ duration: '2m', arrivalRate: 30 },\n{ duration: '5m', arrivalRate: 35 },\n{ duration: '2m', arrivalRate: 40 },\n{ duration: '5m', arrivalRate: 45 },\n{ duration: '2m', arrivalRate: 50 },\n],\n};\n\n// Performance monitoring\nclass PerformanceMonitor {\nconstructor() {\nthis.metrics = {\nresponseTime: [],\nthroughput: [],\nerrorRate: [],\nmemoryUsage: [],\ncpuUsage: [],\n};\n}\n\nrecordResponseTime(time) {\nthis.metrics.responseTime.push(time);\n}\n\nrecordThroughput(requests) {\nthis.metrics.throughput.push(requests);\n}\n\nrecordErrorRate(errors, total) {\nthis.metrics.errorRate.push(errors / total);\n}\n\ngetStats() {\nreturn {\navgResponseTime: this.calculateAverage(this.metrics.responseTime),\nmaxResponseTime: Math.max(...this.metrics.responseTime),\nminResponseTime: Math.min(...this.metrics.responseTime),\navgThroughput: this.calculateAverage(this.metrics.throughput),\navgErrorRate: this.calculateAverage(this.metrics.errorRate),\n};\n}\n\ncalculateAverage(array) {\nreturn array.reduce((sum, value) => sum + value, 0) / array.length;\n}\n}\n\n**3. Benchmark Testing:**\n\n// Benchmark testing with benchmark.js\nconst Benchmark = require('benchmark');\n\nconst suite = new Benchmark.Suite();\n\n// Test different implementations\nsuite\n.add('Array.map', function () {\nconst arr = [1, 2, 3, 4, 5];\nreturn arr.map(x => x * 2);\n})\n.add('for loop', function () {\nconst arr = [1, 2, 3, 4, 5];\nconst result = [];\nfor (let i = 0; i < arr.length; i++) {\nresult.push(arr[i] * 2);\n}\nreturn result;\n})\n.add('for...of loop', function () {\nconst arr = [1, 2, 3, 4, 5];\nconst result = [];\nfor (const item of arr) {\nresult.push(item * 2);\n}\nreturn result;\n})\n.on('cycle', function (event) {\nconsole.log(String(event.target));\n})\n.on('complete', function () {\nconsole.log('Fastest is ' + this.filter('fastest').map('name'));\n})\n.run({ async: true });\n\n// Memory usage testing\nclass MemoryTest {\nstatic measureMemoryUsage(fn) {\nconst startMemory = process.memoryUsage();\nconst result = fn();\nconst endMemory = process.memoryUsage();\n\nreturn {\nresult,\nmemoryDelta: {\nrss: endMemory.rss - startMemory.rss,\nheapUsed: endMemory.heapUsed - startMemory.heapUsed,\nheapTotal: endMemory.heapTotal - startMemory.heapTotal,\nexternal: endMemory.external - startMemory.external,\n},\n};\n}\n\nstatic async measureAsyncMemoryUsage(asyncFn) {\nconst startMemory = process.memoryUsage();\nconst result = await asyncFn();\nconst endMemory = process.memoryUsage();\n\nreturn {\nresult,\nmemoryDelta: {\nrss: endMemory.rss - startMemory.rss,\nheapUsed: endMemory.heapUsed - startMemory.heapUsed,\nheapTotal: endMemory.heapTotal - startMemory.heapTotal,\nexternal: endMemory.external - startMemory.external,\n},\n};\n}\n}",
      "isActive": true,
      "updatedAt": "2025-09-30T00:21:53.933Z",
      "source": "QuestionsBank",
      "options": [],
      "title": "Performance Testing",
      "isComplete": false,
      "learningPaths": [
        "testing-strategies"
      ],
      "category": "Testing Strategies",
      "importedAt": "2025-09-30T00:21:53.893Z",
      "type": "code",
      "difficulty": "intermediate",
      "createdAt": "2025-09-30T00:21:53.933Z",
      "correctAnswer": null,
      "codeBlock": "// Using Artillery for load testing\n// artillery-config.yml\nconfig:\n  target: 'http://localhost:3000'\n  phases:\n    - duration: 60\n      arrivalRate: 10\n    - duration: 120\n      arrivalRate: 20\n    - duration: 60\n      arrivalRate: 10\n\nscenarios:\n  - name: \"User API Load Test\"\n    weight: 100\n    flow:\n      - get:\n          url: \"/api/users\"\n      - post:\n          url: \"/api/users\"\n          json:\n            name: \"Load Test User\"\n            email: \"loadtest@example.com\"\n\n// Using k6 for load testing\nimport http from 'k6/http';\nimport { check, sleep } from 'k6';\n\nexport let options = {\n  stages: [\n    { duration: '2m', target: 100 },\n    { duration: '5m', target: 100 },\n    { duration: '2m', target: 200 },\n    { duration: '5m', target: 200 },\n    { duration: '2m', target: 0 },\n  ],\n};\n\nexport default function() {\n  let response = http.get('http://localhost:3000/api/users');\n  check(response, {\n    'status is 200': (r) => r.status === 200,\n    'response time < 500ms': (r) => r.timings.duration < 500,\n  });\n  sleep(1);\n}",
      "content": "Explain performance testing strategies and tools.",
      "topics": [
        "Unit Testing",
        "Integration Testing",
        "E2E Testing",
        "TDD"
      ]
    },
    {
      "id": "imported-testing-strategies-1759191713893-1",
      "importedAt": "2025-09-30T00:21:53.893Z",
      "learningPaths": [
        "testing-strategies"
      ],
      "isActive": true,
      "title": "Test-Driven Development (TDD)",
      "content": "Explain TDD cycle and provide examples.",
      "difficulty": "intermediate",
      "source": "QuestionsBank",
      "codeBlock": "// RED: Write failing test\ndescribe('User Authentication', () => {\n  test('should authenticate user with valid credentials', () => {\n    const authService = new AuthService();\n    const result = authService.authenticate('user@example.com', 'password123');\n    expect(result.success).toBe(true);\n    expect(result.token).toBeDefined();\n  });\n});\n\n// GREEN: Write minimal code to pass\nclass AuthService {\n  authenticate(email, password) {\n    // Minimal implementation\n    return {\n      success: true,\n      token: 'fake-token',\n    };\n  }\n}\n\n// REFACTOR: Improve code while keeping tests green\nclass AuthService {\n  constructor(userRepository, tokenService) {\n    this.userRepository = userRepository;\n    this.tokenService = tokenService;\n  }\n\n  async authenticate(email, password) {\n    const user = await this.userRepository.findByEmail(email);\n\n    if (!user || !(await this.verifyPassword(password, user.passwordHash))) {\n      return { success: false, error: 'Invalid credentials' };\n    }\n\n    const token = this.tokenService.generateToken(user);\n    return { success: true, token };\n  }\n\n  async verifyPassword(password, hash) {\n    return await bcrypt.compare(password, hash);\n  }\n}",
      "options": [],
      "type": "code",
      "category": "Testing Strategies",
      "updatedAt": "2025-09-30T00:21:53.933Z",
      "explanation": "**1. TDD Cycle (Red-Green-Refactor):**\n\n// RED: Write failing test\ndescribe('User Authentication', () => {\ntest('should authenticate user with valid credentials', () => {\nconst authService = new AuthService();\nconst result = authService.authenticate('user@example.com', 'password123');\nexpect(result.success).toBe(true);\nexpect(result.token).toBeDefined();\n});\n});\n\n// GREEN: Write minimal code to pass\nclass AuthService {\nauthenticate(email, password) {\n// Minimal implementation\nreturn {\nsuccess: true,\ntoken: 'fake-token',\n};\n}\n}\n\n// REFACTOR: Improve code while keeping tests green\nclass AuthService {\nconstructor(userRepository, tokenService) {\nthis.userRepository = userRepository;\nthis.tokenService = tokenService;\n}\n\nasync authenticate(email, password) {\nconst user = await this.userRepository.findByEmail(email);\n\nif (!user || !(await this.verifyPassword(password, user.passwordHash))) {\nreturn { success: false, error: 'Invalid credentials' };\n}\n\nconst token = this.tokenService.generateToken(user);\nreturn { success: true, token };\n}\n\nasync verifyPassword(password, hash) {\nreturn await bcrypt.compare(password, hash);\n}\n}\n\n**2. TDD Example - Calculator:**\n\n// RED: Write failing test\ndescribe('Calculator', () => {\nlet calculator;\n\nbeforeEach(() => {\ncalculator = new Calculator();\n});\n\ntest('should add two numbers', () => {\nexpect(calculator.add(2, 3)).toBe(5);\n});\n\ntest('should subtract two numbers', () => {\nexpect(calculator.subtract(5, 3)).toBe(2);\n});\n\ntest('should multiply two numbers', () => {\nexpect(calculator.multiply(4, 3)).toBe(12);\n});\n\ntest('should divide two numbers', () => {\nexpect(calculator.divide(10, 2)).toBe(5);\n});\n\ntest('should throw error when dividing by zero', () => {\nexpect(() => calculator.divide(10, 0)).toThrow('Division by zero');\n});\n});\n\n// GREEN: Implement minimal code\nclass Calculator {\nadd(a, b) {\nreturn a + b;\n}\n\nsubtract(a, b) {\nreturn a - b;\n}\n\nmultiply(a, b) {\nreturn a * b;\n}\n\ndivide(a, b) {\nif (b === 0) {\nthrow new Error('Division by zero');\n}\nreturn a / b;\n}\n}",
      "isComplete": false,
      "createdAt": "2025-09-30T00:21:53.933Z",
      "correctAnswer": null,
      "topics": [
        "Unit Testing",
        "Integration Testing",
        "E2E Testing",
        "TDD"
      ]
    }
  ]
}