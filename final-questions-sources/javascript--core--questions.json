{
  "category": "JavaScript (Core)",
  "totalQuestions": 47,
  "exportedAt": "2025-09-30T00:28:57.751Z",
  "questions": [
    {
      "id": "imported-javascript-deep-dive-1759191663451-47",
      "options": [],
      "codeBlock": "sayHi();\n\nfunction sayHi() {\n  console.log('Hey!');\n}\n\nvar sayHi = function () {\n  console.log('Hi!');\n};",
      "isComplete": false,
      "updatedAt": "2025-09-30T00:21:03.475Z",
      "difficulty": "intermediate",
      "explanation": "Function declarations are hoisted, but function expressions are not. The function declaration `function sayHi()` is hoisted to the top of its scope, so when we call `sayHi()` before its declaration, it works and logs `\"Hey!\"`.\n\nThe function expression `var sayHi = function()` is not hoisted, so it doesn't affect the first call.",
      "title": "JavaScript Function Hoisting",
      "topics": [
        "Hoisting",
        "Closures",
        "Event Loop",
        "Promises",
        "Async/Await"
      ],
      "learningPaths": [
        "javascript-deep-dive"
      ],
      "source": "QuestionsBank",
      "correctAnswer": null,
      "isActive": true,
      "importedAt": "2025-09-30T00:21:03.451Z",
      "content": "What's the output of this code?\nsayHi();\nfunction sayHi() {\nconsole.log('Hey!');\n}\nvar sayHi = function () {\nconsole.log('Hi!');\n};",
      "category": "JavaScript (Core)",
      "createdAt": "2025-09-30T00:21:03.475Z",
      "type": "code"
    },
    {
      "id": "imported-javascript-deep-dive-1759191663451-28",
      "createdAt": "2025-09-30T00:21:03.475Z",
      "title": "JavaScript Arrow Functions and `this` Context",
      "type": "code",
      "options": [],
      "explanation": "Note that the value of `diameter` is a regular function, whereas the value of `perimeter` is an arrow function.\n\nWith arrow functions, the `this` keyword refers to its current surrounding scope, unlike regular functions! This means that when we call `perimeter`, it doesn't refer to the shape object, but to its surrounding scope (window for example).\n\nSince there is no value `radius` in the scope of the arrow function, `this.radius` returns `undefined` which, when multiplied by `2 * Math.PI`, results in `NaN`.",
      "correctAnswer": null,
      "topics": [
        "Hoisting",
        "Closures",
        "Event Loop",
        "Promises",
        "Async/Await"
      ],
      "updatedAt": "2025-09-30T00:21:03.475Z",
      "codeBlock": "const shape = {\n  radius: 10,\n  diameter() {\n    return this.radius * 2;\n  },\n  perimeter: () => 2 * Math.PI * this.radius,\n};\n\nconsole.log(shape.diameter());\nconsole.log(shape.perimeter());",
      "importedAt": "2025-09-30T00:21:03.451Z",
      "isActive": true,
      "difficulty": "intermediate",
      "content": "What's the output of this code?\nconst shape = {\nradius: 10,\ndiameter() {\nreturn this.radius * 2;\n},\nperimeter: () => 2 * Math.PI * this.radius,\n};\nconsole.log(shape.diameter());\nconsole.log(shape.perimeter());",
      "source": "QuestionsBank",
      "category": "JavaScript (Core)",
      "learningPaths": [
        "javascript-deep-dive"
      ],
      "isComplete": false
    },
    {
      "id": "imported-javascript-deep-dive-1759191663451-42",
      "topics": [
        "Hoisting",
        "Closures",
        "Event Loop",
        "Promises",
        "Async/Await"
      ],
      "title": "JavaScript Array Methods and Mutation",
      "options": [],
      "isComplete": false,
      "codeBlock": "const arr = [1, 2, 3];\narr[10] = 11;\nconsole.log(arr);",
      "learningPaths": [
        "javascript-deep-dive"
      ],
      "correctAnswer": null,
      "content": "What's the output of this code?\nconst arr = [1, 2, 3];\narr[10] = 11;\nconsole.log(arr);",
      "createdAt": "2025-09-30T00:21:03.475Z",
      "isActive": true,
      "difficulty": "intermediate",
      "source": "QuestionsBank",
      "updatedAt": "2025-09-30T00:21:03.475Z",
      "explanation": "When you set a value to an element in an array that exceeds the length of the array, JavaScript creates something called \"empty slots\". These actually have the value of `undefined`, but you'll see something like:\n\n`[1, 2, 3, empty × 7, 11]`\n\ndepending on where you run it (it's different for every browser, node, etc.)",
      "type": "code",
      "category": "JavaScript (Core)",
      "importedAt": "2025-09-30T00:21:03.451Z"
    },
    {
      "id": "imported-javascript-deep-dive-1759191663452-69",
      "explanation": "If you have two keys with the same name, the key will be replaced. It will still be in its first position, but with the last specified value.",
      "topics": [
        "Hoisting",
        "Closures",
        "Event Loop",
        "Promises",
        "Async/Await"
      ],
      "correctAnswer": null,
      "isActive": true,
      "options": [],
      "learningPaths": [
        "javascript-deep-dive"
      ],
      "createdAt": "2025-09-30T00:21:03.475Z",
      "category": "JavaScript (Core)",
      "title": "Array Methods and Return Values",
      "codeBlock": "function Person(firstName, lastName) {\n  this.firstName = firstName;\n  this.lastName = lastName;\n}\n\nconst lydia = new Person('Lydia', 'Hallie');\nconst sarah = Person('Sarah', 'Smith');\n\nconsole.log(lydia);\nconsole.log(sarah);",
      "source": "QuestionsBank",
      "updatedAt": "2025-09-30T00:21:03.475Z",
      "content": "What's the output of the following code?\n\\`\\`\\`javascript\nconst numbers = [1, 2, 3];\nnumbers[10] = 11;\nconsole.log(numbers);\n\\`\\`\\`",
      "isComplete": false,
      "type": "code",
      "importedAt": "2025-09-30T00:21:03.452Z",
      "difficulty": "intermediate"
    },
    {
      "id": "imported-javascript-deep-dive-1759191663452-64",
      "content": "What's the output of the following code?\n\\`\\`\\`javascript\nfunction getAge(...args) {\nconsole.log(typeof args);\n}\ngetAge(21);\n\\`\\`\\`",
      "options": [],
      "category": "JavaScript (Core)",
      "correctAnswer": null,
      "title": "Rest Parameters and typeof",
      "updatedAt": "2025-09-30T00:21:03.475Z",
      "importedAt": "2025-09-30T00:21:03.452Z",
      "source": "QuestionsBank",
      "isActive": true,
      "learningPaths": [
        "javascript-deep-dive"
      ],
      "explanation": "The rest parameter (\\`...args\\`) lets us \"collect\" all remaining arguments into an array. An array is an object, so \\`typeof args\\` returns \\`\"object\"\\`",
      "isComplete": false,
      "codeBlock": null,
      "topics": [
        "Hoisting",
        "Closures",
        "Event Loop",
        "Promises",
        "Async/Await"
      ],
      "createdAt": "2025-09-30T00:21:03.475Z",
      "difficulty": "intermediate",
      "type": "conceptual"
    },
    {
      "id": "imported-javascript-deep-dive-1759191663451-56",
      "isActive": true,
      "codeBlock": "function checkAge(data) {\n  if (data === { age: 18 }) {\n    console.log('You are an adult!');\n  } else if (data == { age: 18 }) {\n    console.log('You are still an adult.');\n  } else {\n    console.log(`Hmm.. You don't have an age I guess`);\n  }\n}\n\ncheckAge({ age: 18 });",
      "category": "JavaScript (Core)",
      "title": "JavaScript Object Comparison",
      "options": [],
      "content": "What's the output of this code?\nfunction checkAge(data) {\nif (data === { age: 18 }) {\nconsole.log('You are an adult!');\n} else if (data == { age: 18 }) {\nconsole.log('You are still an adult.');\n} else {\nconsole.log(`Hmm.. You don't have an age I guess`);\n}\n}\ncheckAge({ age: 18 });",
      "learningPaths": [
        "javascript-deep-dive"
      ],
      "explanation": "When testing equality, primitives are compared by their _value_, while objects are compared by their _reference_. JavaScript checks if the objects have a reference to the same location in memory.\n\nThe two objects that we are comparing don't have that: the object we passed as a parameter refers to a different location in memory than the object we used for checking equality.\n\nThis is why both `{ age: 18 } === { age: 18 }` and `{ age: 18 } == { age: 18 }` return `false`.",
      "createdAt": "2025-09-30T00:21:03.475Z",
      "source": "QuestionsBank",
      "correctAnswer": null,
      "importedAt": "2025-09-30T00:21:03.451Z",
      "topics": [
        "Hoisting",
        "Closures",
        "Event Loop",
        "Promises",
        "Async/Await"
      ],
      "type": "code",
      "isComplete": false,
      "updatedAt": "2025-09-30T00:21:03.475Z",
      "difficulty": "intermediate"
    },
    {
      "id": "imported-javascript-deep-dive-1759191663451-26",
      "isActive": true,
      "explanation": "Within the function, we first declare the `name` variable with the `var` keyword. This means that the variable gets hoisted (memory space is set up during the creation phase) with the default value of `undefined`, until we actually get to the line where we define the variable. We haven't defined the variable yet on the line where we try to log the `name` variable, so it still holds the value of `undefined`.\n\nVariables with the `let` keyword (and `const`) are hoisted, but unlike `var`, don't get initialized. They are not accessible before the line we declare (initialize) them. This is called the \"temporal dead zone\". When we try to access the variables before they are declared, JavaScript throws a `ReferenceError`.",
      "source": "QuestionsBank",
      "topics": [
        "Hoisting",
        "Closures",
        "Event Loop",
        "Promises",
        "Async/Await"
      ],
      "options": [],
      "category": "JavaScript (Core)",
      "importedAt": "2025-09-30T00:21:03.451Z",
      "createdAt": "2025-09-30T00:21:03.475Z",
      "content": "What's the output of this code?\nfunction sayHi() {\nconsole.log(name);\nconsole.log(age);\nvar name = 'Lydia';\nlet age = 21;\n}\nsayHi();",
      "isComplete": false,
      "learningPaths": [
        "javascript-deep-dive"
      ],
      "type": "code",
      "title": "JavaScript Hoisting and Variable Declarations",
      "correctAnswer": null,
      "updatedAt": "2025-09-30T00:21:03.475Z",
      "codeBlock": "function sayHi() {\n  console.log(name);\n  console.log(age);\n  var name = 'Lydia';\n  let age = 21;\n}\n\nsayHi();",
      "difficulty": "intermediate"
    },
    {
      "id": "imported-javascript-deep-dive-1759191663451-31",
      "category": "JavaScript (Core)",
      "source": "QuestionsBank",
      "correctAnswer": null,
      "isActive": true,
      "title": "JavaScript Array Methods and Mutation",
      "explanation": "In JavaScript, all objects interact by reference when setting them equal to each other.\n\nFirst, variable `c` holds a value to an object. Later, we assign `d` with the same reference that `c` has to the object.\n\nWhen you change one object, you change all of them.",
      "codeBlock": "let c = { greeting: 'Hey!' };\nlet d;\n\nd = c;\nc.greeting = 'Hello';\nconsole.log(d.greeting);",
      "createdAt": "2025-09-30T00:21:03.475Z",
      "learningPaths": [
        "javascript-deep-dive"
      ],
      "topics": [
        "Hoisting",
        "Closures",
        "Event Loop",
        "Promises",
        "Async/Await"
      ],
      "updatedAt": "2025-09-30T00:21:03.475Z",
      "content": "What's the output of this code?\nlet c = { greeting: 'Hey!' };\nlet d;\nd = c;\nc.greeting = 'Hello';\nconsole.log(d.greeting);",
      "importedAt": "2025-09-30T00:21:03.451Z",
      "difficulty": "intermediate",
      "isComplete": false,
      "type": "code",
      "options": []
    },
    {
      "id": "imported-javascript-deep-dive-1759191663449-1",
      "type": "code",
      "content": "What is closure in JavaScript and provide practical examples.",
      "options": [],
      "codeBlock": "function createCounter() {\n  let count = 0; // Private variable\n\n  return function () {\n    count++; // Access to outer scope variable\n    return count;\n  };\n}\n\nconst counter = createCounter();\nconsole.log(counter()); // 1\nconsole.log(counter()); // 2\nconsole.log(counter()); // 3",
      "isComplete": false,
      "learningPaths": [
        "javascript-deep-dive"
      ],
      "updatedAt": "2025-09-30T00:21:03.475Z",
      "explanation": "A closure is a function that has access to variables in its outer (enclosing) scope even after the outer function has returned.\n\n**Basic Example:**\n\nfunction createCounter() {\nlet count = 0; // Private variable\n\nreturn function () {\ncount++; // Access to outer scope variable\nreturn count;\n};\n}\n\nconst counter = createCounter();\nconsole.log(counter()); // 1\nconsole.log(counter()); // 2\nconsole.log(counter()); // 3\n\n**Practical Uses:**\n\n**1. Data Privacy:**\n\nfunction createBankAccount(initialBalance) {\nlet balance = initialBalance;\n\nreturn {\ndeposit: amount => {\nbalance += amount;\nreturn balance;\n},\nwithdraw: amount => {\nif (amount <= balance) {\nbalance -= amount;\nreturn balance;\n}\nreturn 'Insufficient funds';\n},\ngetBalance: () => balance,\n};\n}\n\nconst account = createBankAccount(1000);\nconsole.log(account.getBalance()); // 1000\naccount.deposit(500);\nconsole.log(account.getBalance()); // 1500\n\n**2. Function Factories:**\n\nfunction createMultiplier(multiplier) {\nreturn function (number) {\nreturn number * multiplier;\n};\n}\n\nconst double = createMultiplier(2);\nconst triple = createMultiplier(3);\n\nconsole.log(double(5)); // 10\nconsole.log(triple(5)); // 15\n\n**3. Event Handlers:**\n\nfunction setupButton(id) {\nconst button = document.getElementById(id);\nlet clickCount = 0;\n\nbutton.addEventListener('click', function () {\nclickCount++;\nconsole.log(`Button clicked ${clickCount} times`);\n});\n}",
      "difficulty": "intermediate",
      "topics": [
        "Hoisting",
        "Closures",
        "Event Loop",
        "Promises",
        "Async/Await"
      ],
      "title": "Closures in JavaScript",
      "category": "JavaScript (Core)",
      "source": "QuestionsBank",
      "createdAt": "2025-09-30T00:21:03.475Z",
      "correctAnswer": null,
      "isActive": true,
      "importedAt": "2025-09-30T00:21:03.449Z"
    },
    {
      "id": "imported-javascript-deep-dive-1759191663452-63",
      "updatedAt": "2025-09-30T00:21:03.475Z",
      "isComplete": false,
      "type": "conceptual",
      "correctAnswer": null,
      "explanation": "When testing equality, primitives are compared by their _value_, while objects are compared by their _reference_. JavaScript checks if the objects have a reference to the same location in memory.\n\nThe two objects that we are comparing don't have that: the object we passed as a parameter refers to a different location in memory than the object we used in order to check equality.\n\nThis is why both \\`{ age: 18 } === { age: 18 }\\` and \\`{ age: 18 } == { age: 18 }\\` return \\`false\\`.",
      "isActive": true,
      "source": "QuestionsBank",
      "difficulty": "intermediate",
      "options": [],
      "title": "Object Comparison by Reference",
      "topics": [
        "Hoisting",
        "Closures",
        "Event Loop",
        "Promises",
        "Async/Await"
      ],
      "codeBlock": null,
      "category": "JavaScript (Core)",
      "createdAt": "2025-09-30T00:21:03.475Z",
      "importedAt": "2025-09-30T00:21:03.452Z",
      "content": "What's the output of the following code?\n\\`\\`\\`javascript\nfunction checkAge(data) {\nif (data === { age: 18 }) {\nconsole.log('You are an adult!');\n} else if (data == { age: 18 }) {\nconsole.log('You are still an adult.');\n} else {\nconsole.log('Hmm.. You don\\'t have an age I guess');\n}\n}\ncheckAge({ age: 18 });\n\\`\\`\\`",
      "learningPaths": [
        "javascript-deep-dive"
      ]
    },
    {
      "id": "imported-javascript-deep-dive-1759191663450-8",
      "options": [],
      "correctAnswer": null,
      "updatedAt": "2025-09-30T00:21:03.475Z",
      "explanation": "**1. Avoid Global Variables:**\n\n// Bad - global variable lookup\nfunction calculate() {\nreturn globalValue * 2; // Slow\n}\n\n// Good - local variable\nfunction calculate(value) {\nreturn value * 2; // Fast\n}\n\n**2. Minimize DOM Access:**\n\n// Bad - multiple DOM queries\nfunction updateElements() {\ndocument.getElementById('item1').style.color = 'red';\ndocument.getElementById('item2').style.color = 'red';\ndocument.getElementById('item3').style.color = 'red';\n}\n\n// Good - cache DOM elements\nfunction updateElements() {\nconst elements = [\ndocument.getElementById('item1'),\ndocument.getElementById('item2'),\ndocument.getElementById('item3'),\n];\n\nelements.forEach(el => (el.style.color = 'red'));\n}\n\n**3. Use Efficient Loops:**\n\n// Bad - for-in loop\nfor (let key in object) {\nconsole.log(object[key]);\n}\n\n// Good - for-of loop\nfor (let value of Object.values(object)) {\nconsole.log(value);\n}\n\n// Best - for loop for arrays\nfor (let i = 0; i < array.length; i++) {\nconsole.log(array[i]);\n}\n\n**4. Debouncing and Throttling:**\n\n// Debouncing - delay execution until after events stop\nfunction debounce(func, wait) {\nlet timeout;\nreturn function executedFunction(...args) {\nconst later = () => {\nclearTimeout(timeout);\nfunc(...args);\n};\nclearTimeout(timeout);\ntimeout = setTimeout(later, wait);\n};\n}\n\n// Throttling - limit execution frequency\nfunction throttle(func, limit) {\nlet inThrottle;\nreturn function () {\nconst args = arguments;\nconst context = this;\nif (!inThrottle) {\nfunc.apply(context, args);\ninThrottle = true;\nsetTimeout(() => (inThrottle = false), limit);\n}\n};\n}\n\n// Usage\nconst debouncedSearch = debounce(searchFunction, 300);\nconst throttledScroll = throttle(scrollFunction, 100);\n\n**5. Lazy Loading:**\n\n// Lazy load images\nconst images = document.querySelectorAll('img[data-src]');\nconst imageObserver = new IntersectionObserver((entries, observer) => {\nentries.forEach(entry => {\nif (entry.isIntersecting) {\nconst img = entry.target;\nimg.src = img.dataset.src;\nimg.classList.remove('lazy');\nobserver.unobserve(img);\n}\n});\n});\n\nimages.forEach(img => imageObserver.observe(img));\n\n**6. Web Workers:**\n\n// main.js\nconst worker = new Worker('worker.js');\n\nworker.postMessage({ data: largeArray });\n\nworker.onmessage = function (e) {\nconsole.log('Result:', e.data);\n};\n\n// worker.js\nself.onmessage = function (e) {\nconst { data } = e.data;\nconst result = data.map(item => item * 2); // Heavy computation\nself.postMessage(result);\n};\n\n**7. Memory Optimization:**\n\n// Use WeakMap for metadata\nconst metadata = new WeakMap();\n\nfunction addMetadata(obj, data) {\nmetadata.set(obj, data);\n}\n\n// Use object pooling for frequently created objects\nclass ObjectPool {\nconstructor(createFn) {\nthis.createFn = createFn;\nthis.pool = [];\n}\n\nget() {\nreturn this.pool.pop() || this.createFn();\n}\n\nrelease(obj) {\nthis.pool.push(obj);\n}\n}",
      "difficulty": "intermediate",
      "learningPaths": [
        "javascript-deep-dive"
      ],
      "category": "JavaScript (Core)",
      "isActive": true,
      "codeBlock": "// Bad - global variable lookup\nfunction calculate() {\n  return globalValue * 2; // Slow\n}\n\n// Good - local variable\nfunction calculate(value) {\n  return value * 2; // Fast\n}",
      "topics": [
        "Hoisting",
        "Closures",
        "Event Loop",
        "Promises",
        "Async/Await"
      ],
      "importedAt": "2025-09-30T00:21:03.450Z",
      "type": "code",
      "isComplete": false,
      "title": "JavaScript Performance Optimization",
      "source": "QuestionsBank",
      "createdAt": "2025-09-30T00:21:03.475Z",
      "content": "How do you optimize JavaScript performance?"
    },
    {
      "id": "imported-javascript-deep-dive-1759191663449-5",
      "isComplete": false,
      "title": "JavaScript Generators and Iterators",
      "options": [],
      "learningPaths": [
        "javascript-deep-dive"
      ],
      "isActive": true,
      "topics": [
        "Hoisting",
        "Closures",
        "Event Loop",
        "Promises",
        "Async/Await"
      ],
      "codeBlock": "const iterable = {\n  [Symbol.iterator]() {\n    let count = 0;\n    return {\n      next() {\n        if (count < 3) {\n          return { value: count++, done: false };\n        }\n        return { done: true };\n      },\n    };\n  },\n};\n\nfor (const value of iterable) {\n  console.log(value); // 0, 1, 2\n}",
      "explanation": "**Iterators** are objects that implement the iterator protocol, allowing you to iterate over collections.\n\n**Iterator Protocol:**\n\nconst iterable = {\n[Symbol.iterator]() {\nlet count = 0;\nreturn {\nnext() {\nif (count < 3) {\nreturn { value: count++, done: false };\n}\nreturn { done: true };\n},\n};\n},\n};\n\nfor (const value of iterable) {\nconsole.log(value); // 0, 1, 2\n}\n\n**Generators** are functions that can be paused and resumed, returning an iterator.\n\n**Basic Generator:**\n\nfunction* numberGenerator() {\nyield 1;\nyield 2;\nyield 3;\n}\n\nconst gen = numberGenerator();\nconsole.log(gen.next()); // { value: 1, done: false }\nconsole.log(gen.next()); // { value: 2, done: false }\nconsole.log(gen.next()); // { value: 3, done: false }\nconsole.log(gen.next()); // { value: undefined, done: true }\n\n**Generator with Parameters:**\n\nfunction* fibonacci() {\nlet a = 0,\nb = 1;\nwhile (true) {\nyield a;\n[a, b] = [b, a + b];\n}\n}\n\nconst fib = fibonacci();\nconsole.log(fib.next().value); // 0\nconsole.log(fib.next().value); // 1\nconsole.log(fib.next().value); // 1\nconsole.log(fib.next().value); // 2\n\n**Generator with yield\\*:**\n\nfunction* generator1() {\nyield 1;\nyield 2;\n}\n\nfunction* generator2() {\nyield* generator1();\nyield 3;\nyield 4;\n}\n\nfor (const value of generator2()) {\nconsole.log(value); // 1, 2, 3, 4\n}\n\n**Practical Uses:**\n\n**1. Lazy Evaluation:**\n\nfunction* range(start, end) {\nfor (let i = start; i <= end; i++) {\nyield i;\n}\n}\n\n// Only generates values as needed\nconst numbers = range(1, 1000000);\nconsole.log(numbers.next().value); // 1\nconsole.log(numbers.next().value); // 2\n\n**2. Async Iteration:**\n\nasync function* asyncGenerator() {\nyield await fetch('/api/data1');\nyield await fetch('/api/data2');\nyield await fetch('/api/data3');\n}\n\nfor await (const response of asyncGenerator()) {\nconst data = await response.json();\nconsole.log(data);\n}",
      "importedAt": "2025-09-30T00:21:03.449Z",
      "content": "What are generators and iterators in JavaScript?",
      "category": "JavaScript (Core)",
      "correctAnswer": null,
      "difficulty": "intermediate",
      "type": "code",
      "updatedAt": "2025-09-30T00:21:03.475Z",
      "createdAt": "2025-09-30T00:21:03.475Z",
      "source": "QuestionsBank"
    },
    {
      "id": "imported-javascript-deep-dive-1759191663452-65",
      "createdAt": "2025-09-30T00:21:03.475Z",
      "options": [],
      "type": "conceptual",
      "source": "QuestionsBank",
      "codeBlock": null,
      "category": "JavaScript (Core)",
      "isComplete": false,
      "title": "Array Methods and Mutation",
      "importedAt": "2025-09-30T00:21:03.452Z",
      "difficulty": "intermediate",
      "updatedAt": "2025-09-30T00:21:03.475Z",
      "topics": [
        "Hoisting",
        "Closures",
        "Event Loop",
        "Promises",
        "Async/Await"
      ],
      "content": "What's the output of the following code?\n\\`\\`\\`javascript\nconst arr = [1, 2, 3];\narr[10] = 11;\nconsole.log(arr);\n\\`\\`\\`",
      "explanation": "When you set a value to an element in an array that exceeds the length of the array, JavaScript creates something called \"empty slots\". These actually have the value of \\`undefined\\`, but you will see something like:\n\n\\`\\`\\`javascript\n[1, 2, 3, 7 x empty, 11]\n\\`\\`\\`\n\ndepending on where you run it (it's different for every browser, node, etc.)",
      "learningPaths": [
        "javascript-deep-dive"
      ],
      "isActive": true,
      "correctAnswer": null
    },
    {
      "id": "imported-javascript-deep-dive-1759191663451-39",
      "importedAt": "2025-09-30T00:21:03.451Z",
      "topics": [
        "Hoisting",
        "Closures",
        "Event Loop",
        "Promises",
        "Async/Await"
      ],
      "createdAt": "2025-09-30T00:21:03.475Z",
      "learningPaths": [
        "javascript-deep-dive"
      ],
      "title": "JavaScript Functions as Objects",
      "source": "QuestionsBank",
      "correctAnswer": null,
      "isActive": true,
      "difficulty": "intermediate",
      "options": [],
      "explanation": "This is possible in JavaScript, because functions are objects! (Everything besides primitive types are objects)\n\nA function is a special type of object. The code you write yourself isn't the actual function. The function is an object with properties. This property is invocable.",
      "isComplete": false,
      "category": "JavaScript (Core)",
      "updatedAt": "2025-09-30T00:21:03.475Z",
      "codeBlock": "function bark() {\n  console.log('Woof!');\n}\n\nbark.animal = 'dog';",
      "content": "What happens when we do this?\nfunction bark() {\nconsole.log('Woof!');\n}\nbark.animal = 'dog';",
      "type": "code"
    },
    {
      "id": "imported-javascript-deep-dive-1759191663451-51",
      "correctAnswer": null,
      "type": "conceptual",
      "importedAt": "2025-09-30T00:21:03.451Z",
      "codeBlock": null,
      "content": "What are the three phases of event propagation?",
      "difficulty": "intermediate",
      "category": "JavaScript (Core)",
      "source": "QuestionsBank",
      "createdAt": "2025-09-30T00:21:03.475Z",
      "updatedAt": "2025-09-30T00:21:03.475Z",
      "options": [],
      "isComplete": false,
      "title": "JavaScript Event Propagation Phases",
      "topics": [
        "Hoisting",
        "Closures",
        "Event Loop",
        "Promises",
        "Async/Await"
      ],
      "learningPaths": [
        "javascript-deep-dive"
      ],
      "isActive": true,
      "explanation": "During the **capturing** phase, the event goes through the ancestor elements down to the target element. It then reaches the **target** element, and **bubbling** begins.\n\nThe event first travels down the DOM tree (capturing phase), reaches the target element (target phase), and then travels back up the DOM tree (bubbling phase)."
    },
    {
      "id": "imported-javascript-deep-dive-1759191663451-41",
      "updatedAt": "2025-09-30T00:21:03.475Z",
      "type": "code",
      "topics": [
        "Hoisting",
        "Closures",
        "Event Loop",
        "Promises",
        "Async/Await"
      ],
      "content": "What's the output of this code?\nconst person = {\nname: 'Lydia',\nage: 21,\n};\nfor (const item in person) {\nconsole.log(item);\n}",
      "source": "QuestionsBank",
      "createdAt": "2025-09-30T00:21:03.475Z",
      "isComplete": false,
      "options": [],
      "explanation": "With a `for-in` loop, we can iterate through object keys, in this case `name` and `age`. Under the hood, object keys are strings (or Symbols). On every loop, we set the value of `item` equal to the current key it's iterating over. First, `item` is equal to `\"name\"`, and gets logged. Then, `item` is equal to `\"age\"`, which gets logged.",
      "codeBlock": "const person = {\n  name: 'Lydia',\n  age: 21,\n};\n\nfor (const item in person) {\n  console.log(item);\n}",
      "difficulty": "intermediate",
      "category": "JavaScript (Core)",
      "learningPaths": [
        "javascript-deep-dive"
      ],
      "isActive": true,
      "title": "JavaScript `this` Context in Methods",
      "importedAt": "2025-09-30T00:21:03.451Z",
      "correctAnswer": null
    },
    {
      "id": "imported-javascript-deep-dive-1759191663451-45",
      "learningPaths": [
        "javascript-deep-dive"
      ],
      "isActive": true,
      "title": "JavaScript Array Methods",
      "importedAt": "2025-09-30T00:21:03.451Z",
      "correctAnswer": null,
      "topics": [
        "Hoisting",
        "Closures",
        "Event Loop",
        "Promises",
        "Async/Await"
      ],
      "updatedAt": "2025-09-30T00:21:03.475Z",
      "type": "code",
      "source": "QuestionsBank",
      "createdAt": "2025-09-30T00:21:03.475Z",
      "isComplete": false,
      "explanation": "When you set a value to an element in an array that exceeds the length of the array, JavaScript creates something called \"empty slots\". These actually have the value of `undefined`, but you'll see something like:\n\n`[1, 2, 3, empty × 7, 11]`\n\ndepending on where you run it (it's different for every browser, node, etc.)",
      "codeBlock": "const numbers = [1, 2, 3];\nnumbers[10] = 11;\nconsole.log(numbers);",
      "content": "What's the output of this code?\nconst numbers = [1, 2, 3];\nnumbers[10] = 11;\nconsole.log(numbers);",
      "options": [],
      "difficulty": "intermediate",
      "category": "JavaScript (Core)"
    },
    {
      "id": "imported-javascript-deep-dive-1759191663451-50",
      "content": "What's the output of this code?\nfunction Person(firstName, lastName) {\nthis.firstName = firstName;\nthis.lastName = lastName;\n}\nconst lydia = new Person('Lydia', 'Hallie');\nconst sarah = Person('Sarah', 'Smith');\nconsole.log(lydia);\nconsole.log(sarah);",
      "isComplete": false,
      "codeBlock": "function Person(firstName, lastName) {\n  this.firstName = firstName;\n  this.lastName = lastName;\n}\n\nconst lydia = new Person('Lydia', 'Hallie');\nconst sarah = Person('Sarah', 'Smith');\n\nconsole.log(lydia);\nconsole.log(sarah);",
      "updatedAt": "2025-09-30T00:21:03.475Z",
      "type": "code",
      "category": "JavaScript (Core)",
      "difficulty": "intermediate",
      "explanation": "For `sarah`, we didn't use the `new` keyword. When using `new`, `this` refers to the new empty object we create. However, if you don't add `new`, `this` refers to the global object!\n\nWe said that `this.firstName` equals `\"Sarah\"` and `this.lastName` equals `\"Smith\"`. What we actually did, is defining `global.firstName = 'Sarah'` and `global.lastName = 'Smith'`. `sarah` itself is left `undefined`, since we don't return a value from the `Person` function.",
      "title": "JavaScript Constructor Functions and `new` Keyword",
      "source": "QuestionsBank",
      "learningPaths": [
        "javascript-deep-dive"
      ],
      "createdAt": "2025-09-30T00:21:03.475Z",
      "isActive": true,
      "importedAt": "2025-09-30T00:21:03.451Z",
      "correctAnswer": null,
      "topics": [
        "Hoisting",
        "Closures",
        "Event Loop",
        "Promises",
        "Async/Await"
      ],
      "options": []
    },
    {
      "id": "imported-javascript-deep-dive-1759191663451-53",
      "source": "QuestionsBank",
      "createdAt": "2025-09-30T00:21:03.475Z",
      "explanation": "JavaScript is a **dynamically typed language**: we don't specify what types certain variables are. Values can automatically be converted into another type without you knowing, which is called _implicit type coercion_. **Coercion** is converting from one type into another.\n\nIn this example, JavaScript converts the number `1` into a string, in order for the function to make sense and return a value. During the addition of a numeric type (`1`) and a string type (`'2'`), the number is treated as a string. We can concatenate strings like `\"Hello\" + \"World\"`, so what's happening here is `\"1\" + \"2\"` which returns `\"12\"`.",
      "updatedAt": "2025-09-30T00:21:03.475Z",
      "isComplete": false,
      "content": "What's the output of this code?\nfunction sum(a, b) {\nreturn a + b;\n}\nsum(1, '2');",
      "codeBlock": "function sum(a, b) {\n  return a + b;\n}\n\nsum(1, '2');",
      "difficulty": "intermediate",
      "category": "JavaScript (Core)",
      "learningPaths": [
        "javascript-deep-dive"
      ],
      "isActive": true,
      "options": [],
      "title": "JavaScript Type Coercion",
      "correctAnswer": null,
      "type": "code",
      "importedAt": "2025-09-30T00:21:03.451Z",
      "topics": [
        "Hoisting",
        "Closures",
        "Event Loop",
        "Promises",
        "Async/Await"
      ]
    },
    {
      "id": "imported-javascript-deep-dive-1759191663451-30",
      "importedAt": "2025-09-30T00:21:03.451Z",
      "type": "code",
      "content": "Which one is true?\nconst bird = {\nsize: 'small',\n};\nconst mouse = {\nname: 'Mickey',\nsmall: true,\n};",
      "explanation": "In JavaScript, all object keys are strings (or Symbols). Even though we might not type them as strings, they are always converted into strings under the hood.\n\nJavaScript interprets (or unboxes) statements. When we use bracket notation, it sees the first opening bracket `[` and keeps going until it finds the closing bracket `]`. Only then, it will evaluate the statement.\n\n`mouse[bird.size]`: First it evaluates `bird.size`, which is `\"small\"`. `mouse[\"small\"]` returns `true`.\n\nHowever, with dot notation, this doesn't happen. `mouse` does not have a key called `bird`, which means `mouse.bird` is `undefined`. Then, we ask for the `size` using dot notation: `mouse.bird.size`. Since `mouse.bird` is `undefined`, we're actually asking `undefined.size`. This isn't valid, and will throw an error similar to `Cannot read property 'size' of undefined`.",
      "difficulty": "intermediate",
      "source": "QuestionsBank",
      "category": "JavaScript (Core)",
      "codeBlock": "const bird = {\n  size: 'small',\n};\n\nconst mouse = {\n  name: 'Mickey',\n  small: true,\n};",
      "options": [],
      "learningPaths": [
        "javascript-deep-dive"
      ],
      "createdAt": "2025-09-30T00:21:03.475Z",
      "topics": [
        "Hoisting",
        "Closures",
        "Event Loop",
        "Promises",
        "Async/Await"
      ],
      "correctAnswer": null,
      "updatedAt": "2025-09-30T00:21:03.475Z",
      "title": "JavaScript Object Property Access",
      "isActive": true,
      "isComplete": false
    },
    {
      "id": "imported-javascript-deep-dive-1759191663451-36",
      "correctAnswer": null,
      "options": [],
      "difficulty": "intermediate",
      "title": "JavaScript Number Constructor vs Primitive",
      "category": "JavaScript (Core)",
      "updatedAt": "2025-09-30T00:21:03.475Z",
      "source": "QuestionsBank",
      "importedAt": "2025-09-30T00:21:03.451Z",
      "isActive": true,
      "learningPaths": [
        "javascript-deep-dive"
      ],
      "isComplete": false,
      "codeBlock": "let a = 3;\nlet b = new Number(3);\nlet c = 3;\n\nconsole.log(a == b);\nconsole.log(a === b);\nconsole.log(b === c);",
      "explanation": "`new Number()` is a built-in function constructor. Although it looks like a number, it's not really a number: it has a bunch of extra features and is an object.\n\nWhen we use the `==` operator (Equality operator), it only checks whether it has the same value. They both have the value of `3`, so it returns `true`.\n\nHowever, when we use the `===` operator (Strict equality operator), both value and type should be the same. It's not: `new Number()` is not a number, it's an object. Both return `false`.",
      "topics": [
        "Hoisting",
        "Closures",
        "Event Loop",
        "Promises",
        "Async/Await"
      ],
      "type": "code",
      "content": "What's the output of this code?\nlet a = 3;\nlet b = new Number(3);\nlet c = 3;\nconsole.log(a == b);\nconsole.log(a === b);\nconsole.log(b === c);",
      "createdAt": "2025-09-30T00:21:03.475Z"
    },
    {
      "id": "imported-javascript-deep-dive-1759191663452-61",
      "createdAt": "2025-09-30T00:21:03.475Z",
      "codeBlock": null,
      "difficulty": "intermediate",
      "importedAt": "2025-09-30T00:21:03.452Z",
      "explanation": "JavaScript is a **dynamically typed language**: we don't specify what types certain variables are. Values can automatically be converted into another type without you knowing, which is called _implicit type coercion_. **Coercion** is converting from one type into another.\n\nIn this example, JavaScript converts the number \\`1\\` into a string, in order for the function to make sense and return a value. During the addition of a numeric type (\\`1\\`) and a string type (\\`'2'\\`), the number is treated as a string. We can concatenate strings like \\`\"Hello\" + \"World\"\\`, so what's happening here is \\`\"1\" + \"2\"\\` which returns \\`\"12\"\\`.",
      "topics": [
        "Hoisting",
        "Closures",
        "Event Loop",
        "Promises",
        "Async/Await"
      ],
      "isComplete": false,
      "learningPaths": [
        "javascript-deep-dive"
      ],
      "category": "JavaScript (Core)",
      "correctAnswer": null,
      "type": "conceptual",
      "updatedAt": "2025-09-30T00:21:03.475Z",
      "isActive": true,
      "source": "QuestionsBank",
      "content": "What's the output of the following code?\n\\`\\`\\`javascript\nfunction sum(a, b) {\nreturn a + b;\n}\nsum(1, '2');\n\\`\\`\\`",
      "title": "Implicit Type Coercion",
      "options": []
    },
    {
      "id": "imported-javascript-deep-dive-1759191663451-55",
      "explanation": "If you use tagged template literals, the value of the first argument is always an array of the string values. The remaining arguments get the values of the passed expressions!\n\nThe first argument is an array containing the string parts: `[\"\", \" is \", \" years old\"]`, the second argument is the first expression value `\"Lydia\"`, and the third argument is the second expression value `21`.",
      "isActive": true,
      "updatedAt": "2025-09-30T00:21:03.475Z",
      "options": [],
      "source": "QuestionsBank",
      "title": "JavaScript Tagged Template Literals",
      "isComplete": false,
      "learningPaths": [
        "javascript-deep-dive"
      ],
      "category": "JavaScript (Core)",
      "importedAt": "2025-09-30T00:21:03.451Z",
      "type": "code",
      "difficulty": "intermediate",
      "createdAt": "2025-09-30T00:21:03.475Z",
      "correctAnswer": null,
      "codeBlock": "function getPersonInfo(one, two, three) {\n  console.log(one);\n  console.log(two);\n  console.log(three);\n}\n\nconst person = 'Lydia';\nconst age = 21;\n\ngetPersonInfo`${person} is ${age} years old`;",
      "content": "What's the output of this code?\nfunction getPersonInfo(one, two, three) {\nconsole.log(one);\nconsole.log(two);\nconsole.log(three);\n}\nconst person = 'Lydia';\nconst age = 21;\ngetPersonInfo`${person} is ${age} years old`;",
      "topics": [
        "Hoisting",
        "Closures",
        "Event Loop",
        "Promises",
        "Async/Await"
      ]
    },
    {
      "id": "imported-javascript-deep-dive-1759191663451-44",
      "correctAnswer": null,
      "explanation": "When you assign `obj.b` to `c`, you're not calling the function, you're just assigning the function reference. When you call `c()`, it's called in the global context, so `this` refers to the global object (or `undefined` in strict mode). Since there's no `a` property on the global object, it returns `undefined`.",
      "updatedAt": "2025-09-30T00:21:03.475Z",
      "content": "What's the output of this code?\nconst obj = {\na: 'Hello',\nb: function () {\nconsole.log(this.a);\n},\n};\nconst c = obj.b;\nc();",
      "isComplete": false,
      "createdAt": "2025-09-30T00:21:03.475Z",
      "learningPaths": [
        "javascript-deep-dive"
      ],
      "source": "QuestionsBank",
      "options": [],
      "title": "JavaScript `this` Binding",
      "codeBlock": "const obj = {\n  a: 'Hello',\n  b: function () {\n    console.log(this.a);\n  },\n};\n\nconst c = obj.b;\nc();",
      "importedAt": "2025-09-30T00:21:03.451Z",
      "type": "code",
      "topics": [
        "Hoisting",
        "Closures",
        "Event Loop",
        "Promises",
        "Async/Await"
      ],
      "difficulty": "intermediate",
      "category": "JavaScript (Core)",
      "isActive": true
    },
    {
      "id": "imported-javascript-deep-dive-1759191663451-22",
      "createdAt": "2025-09-30T00:21:03.475Z",
      "options": [],
      "type": "code",
      "source": "QuestionsBank",
      "category": "JavaScript (Core)",
      "codeBlock": "// ❌ Callback Hell - Hard to read and maintain\ngetData(\n  function (a) {\n    getMoreData(\n      a,\n      function (b) {\n        getEvenMoreData(\n          b,\n          function (c) {\n            getFinalData(\n              c,\n              function (d) {\n                console.log('Got all data:', d);\n              },\n              function (error) {\n                console.error('Error in final step:', error);\n              }\n            );\n          },\n          function (error) {\n            console.error('Error in third step:', error);\n          }\n        );\n      },\n      function (error) {\n        console.error('Error in second step:', error);\n      }\n    );\n  },\n  function (error) {\n    console.error('Error in first step:', error);\n  }\n);",
      "isComplete": false,
      "title": "Promises vs Callbacks",
      "importedAt": "2025-09-30T00:21:03.451Z",
      "difficulty": "intermediate",
      "updatedAt": "2025-09-30T00:21:03.475Z",
      "topics": [
        "Hoisting",
        "Closures",
        "Event Loop",
        "Promises",
        "Async/Await"
      ],
      "content": "What problem do Promises solve, and how do they improve upon callback patterns?",
      "explanation": "Promises solve \"Callback Hell,\" the deeply nested, hard-to-read, and error-prone code structure that results from handling multiple asynchronous operations with callbacks. Promises provide a chainable `.then().catch()` syntax that flattens the code, making it more readable and easier to reason about. They also offer superior and centralized error handling with `.catch()`.\n\n**Callback Hell Problem:**\n\n// ❌ Callback Hell - Hard to read and maintain\ngetData(\nfunction (a) {\ngetMoreData(\na,\nfunction (b) {\ngetEvenMoreData(\nb,\nfunction (c) {\ngetFinalData(\nc,\nfunction (d) {\nconsole.log('Got all data:', d);\n},\nfunction (error) {\nconsole.error('Error in final step:', error);\n}\n);\n},\nfunction (error) {\nconsole.error('Error in third step:', error);\n}\n);\n},\nfunction (error) {\nconsole.error('Error in second step:', error);\n}\n);\n},\nfunction (error) {\nconsole.error('Error in first step:', error);\n}\n);\n\n**Promise Solution:**\n\n// ✅ Promise Chain - Clean and readable\ngetData()\n.then(a => getMoreData(a))\n.then(b => getEvenMoreData(b))\n.then(c => getFinalData(c))\n.then(d => console.log('Got all data:', d))\n.catch(error => console.error('Something went wrong:', error));\n\n**Key Improvements:**\n\n**1. Flattened Structure:**\n\n// Callbacks: Nested pyramid\nasyncOperation1(result1 => {\nasyncOperation2(result1, result2 => {\nasyncOperation3(result2, result3 => {\n// Deep nesting\n});\n});\n});\n\n// Promises: Flat chain\nasyncOperation1()\n.then(result1 => asyncOperation2(result1))\n.then(result2 => asyncOperation3(result2))\n.then(result3 => {\n// Clean structure\n});\n\n**2. Centralized Error Handling:**\n\n// Callbacks: Error handling scattered\nfunction callbackExample() {\ngetData((data, error) => {\nif (error) {\nconsole.error('Step 1 error:', error);\nreturn;\n}\n\nprocessData(data, (result, error) => {\nif (error) {\nconsole.error('Step 2 error:', error);\nreturn;\n}\n\nsaveData(result, (saved, error) => {\nif (error) {\nconsole.error('Step 3 error:', error);\nreturn;\n}\n\nconsole.log('Success:', saved);\n});\n});\n});\n}\n\n// Promises: Single error handler\nfunction promiseExample() {\ngetData()\n.then(data => processData(data))\n.then(result => saveData(result))\n.then(saved => console.log('Success:', saved))\n.catch(error => {\n// All errors caught here\nconsole.error('Error in any step:', error);\n});\n}\n\n**3. Better Composition:**\n\n// Parallel operations with callbacks\nlet results = [];\nlet completed = 0;\nconst total = 3;\n\nfunction checkComplete() {\ncompleted++;\nif (completed === total) {\nconsole.log('All done:', results);\n}\n}\n\ngetData1(result => {\nresults[0] = result;\ncheckComplete();\n});\n\ngetData2(result => {\nresults[1] = result;\ncheckComplete();\n});\n\ngetData3(result => {\nresults[2] = result;\ncheckComplete();\n});\n\n// Parallel operations with Promises\nPromise.all([getData1(), getData2(), getData3()])\n.then(results => {\nconsole.log('All done:', results);\n})\n.catch(error => {\nconsole.error('One or more failed:', error);\n});\n\n**4. Promise States and Methods:**\n\n// Promise states\nconst pendingPromise = new Promise((resolve, reject) => {\n// Pending state\n});\n\nconst resolvedPromise = Promise.resolve('resolved');\nconst rejectedPromise = Promise.reject('rejected');\n\n// Promise methods\nPromise.resolve('value')\n.then(value => {\nconsole.log(value); // 'value'\nreturn 'new value';\n})\n.then(value => {\nconsole.log(value); // 'new value'\nthrow new Error('Something went wrong');\n})\n.catch(error => {\nconsole.error(error.message); // 'Something went wrong'\nreturn 'recovery value';\n})\n.finally(() => {\nconsole.log('Always executed');\n});\n\n**5. Modern Async/Await:**\n\n// Even cleaner with async/await\nasync function modernExample() {\ntry {\nconst a = await getData();\nconst b = await getMoreData(a);\nconst c = await getEvenMoreData(b);\nconst d = await getFinalData(c);\n\nconsole.log('Got all data:', d);\n} catch (error) {\nconsole.error('Something went wrong:', error);\n}\n}\n\n// Parallel execution with async/await\nasync function parallelExample() {\ntry {\nconst [result1, result2, result3] = await Promise.all([\ngetData1(),\ngetData2(),\ngetData3(),\n]);\n\nconsole.log('All results:', { result1, result2, result3 });\n} catch (error) {\nconsole.error('One or more failed:', error);\n}\n}",
      "learningPaths": [
        "javascript-deep-dive"
      ],
      "isActive": true,
      "correctAnswer": null
    },
    {
      "id": "imported-javascript-deep-dive-1759191663452-68",
      "learningPaths": [
        "javascript-deep-dive"
      ],
      "createdAt": "2025-09-30T00:21:03.475Z",
      "explanation": "When you set a value to an element in an array that exceeds the length of the array, JavaScript creates something called \"empty slots\". These actually have the value of \\`undefined\\`, but you will see something like:\n\n\\`\\`\\`javascript\n[1, 2, 3, 7 x empty, 11]\n\\`\\`\\`\n\ndepending on where you run it (it's different for every browser, node, etc.)",
      "updatedAt": "2025-09-30T00:21:03.475Z",
      "type": "conceptual",
      "difficulty": "intermediate",
      "options": [],
      "correctAnswer": null,
      "isActive": true,
      "source": "QuestionsBank",
      "codeBlock": null,
      "importedAt": "2025-09-30T00:21:03.452Z",
      "category": "JavaScript (Core)",
      "topics": [
        "Hoisting",
        "Closures",
        "Event Loop",
        "Promises",
        "Async/Await"
      ],
      "isComplete": false,
      "title": "Array Methods and Return Values",
      "content": "What's the output of the following code?\n\\`\\`\\`javascript\nconst numbers = [1, 2, 3];\nnumbers[10] = 11;\nconsole.log(numbers);\n\\`\\`\\`"
    },
    {
      "id": "imported-javascript-deep-dive-1759191663451-33",
      "topics": [
        "Hoisting",
        "Closures",
        "Event Loop",
        "Promises",
        "Async/Await"
      ],
      "explanation": "You can't add properties to a constructor like you can with regular objects. If you want to add a feature to all objects at once, you have to use the prototype instead. So in this case:\n\nPerson.prototype.getFullName = function () {\nreturn `${this.firstName} ${this.lastName}`;\n};\n\nwould have made `member.getFullName()` work. In this case, we're trying to add a method as a property on the constructor function. `member` is an instance of `Person`, and doesn't have access to this method. Since `getFullName` is not defined on `member`, it throws a `TypeError`.",
      "updatedAt": "2025-09-30T00:21:03.475Z",
      "source": "QuestionsBank",
      "isComplete": false,
      "type": "code",
      "importedAt": "2025-09-30T00:21:03.451Z",
      "category": "JavaScript (Core)",
      "codeBlock": "function Person(firstName, lastName) {\n  this.firstName = firstName;\n  this.lastName = lastName;\n}\n\nconst member = new Person('Lydia', 'Hallie');\nPerson.getFullName = function () {\n  return `${this.firstName} ${this.lastName}`;\n};\n\nconsole.log(member.getFullName());",
      "createdAt": "2025-09-30T00:21:03.475Z",
      "options": [],
      "isActive": true,
      "title": "JavaScript Prototype Chain",
      "difficulty": "intermediate",
      "content": "What's the output of this code?\nfunction Person(firstName, lastName) {\nthis.firstName = firstName;\nthis.lastName = lastName;\n}\nconst member = new Person('Lydia', 'Hallie');\nPerson.getFullName = function () {\nreturn `${this.firstName} ${this.lastName}`;\n};\nconsole.log(member.getFullName());",
      "correctAnswer": null,
      "learningPaths": [
        "javascript-deep-dive"
      ]
    },
    {
      "id": "imported-javascript-deep-dive-1759191663451-37",
      "title": "JavaScript Static Methods",
      "isActive": true,
      "codeBlock": "class Chameleon {\n  static colorChange(newColor) {\n    this.newColor = newColor;\n    return this.newColor;\n  }\n\n  constructor({ newColor = 'green' } = {}) {\n    this.newColor = newColor;\n  }\n}\n\nconst freddie = new Chameleon({ newColor: 'purple' });\nconsole.log(freddie.colorChange('orange'));",
      "topics": [
        "Hoisting",
        "Closures",
        "Event Loop",
        "Promises",
        "Async/Await"
      ],
      "learningPaths": [
        "javascript-deep-dive"
      ],
      "explanation": "The `colorChange` function is static. Static methods are designed to live only on the constructor in which they are created, and cannot be passed down to any children or called upon class instances. Since `freddie` is an instance of class Chameleon, the function cannot be called upon it. A `TypeError` is thrown.",
      "importedAt": "2025-09-30T00:21:03.451Z",
      "correctAnswer": null,
      "type": "code",
      "createdAt": "2025-09-30T00:21:03.475Z",
      "category": "JavaScript (Core)",
      "isComplete": false,
      "options": [],
      "source": "QuestionsBank",
      "content": "What's the output of this code?\nclass Chameleon {\nstatic colorChange(newColor) {\nthis.newColor = newColor;\nreturn this.newColor;\n}\nconstructor({ newColor = 'green' } = {}) {\nthis.newColor = newColor;\n}\n}\nconst freddie = new Chameleon({ newColor: 'purple' });\nconsole.log(freddie.colorChange('orange'));",
      "updatedAt": "2025-09-30T00:21:03.475Z",
      "difficulty": "intermediate"
    },
    {
      "id": "imported-javascript-deep-dive-1759191663451-29",
      "options": [],
      "learningPaths": [
        "javascript-deep-dive"
      ],
      "topics": [
        "Hoisting",
        "Closures",
        "Event Loop",
        "Promises",
        "Async/Await"
      ],
      "isActive": true,
      "importedAt": "2025-09-30T00:21:03.451Z",
      "correctAnswer": null,
      "type": "code",
      "explanation": "The unary plus tries to convert an operand to a number. `true` is `1`, and `false` is `0`.\n\nThe string `'Lydia'` is a truthy value. What we're actually asking, is \"Is this truthy value falsy?\". This returns `false`.",
      "content": "What's the output of this code?\n+true;\n!'Lydia';",
      "isComplete": false,
      "codeBlock": "+true;\n!'Lydia';",
      "updatedAt": "2025-09-30T00:21:03.475Z",
      "category": "JavaScript (Core)",
      "difficulty": "intermediate",
      "source": "QuestionsBank",
      "createdAt": "2025-09-30T00:21:03.475Z",
      "title": "JavaScript Type Coercion"
    },
    {
      "id": "imported-javascript-deep-dive-1759191663451-46",
      "topics": [
        "Hoisting",
        "Closures",
        "Event Loop",
        "Promises",
        "Async/Await"
      ],
      "updatedAt": "2025-09-30T00:21:03.475Z",
      "isActive": true,
      "importedAt": "2025-09-30T00:21:03.451Z",
      "source": "QuestionsBank",
      "learningPaths": [
        "javascript-deep-dive"
      ],
      "difficulty": "intermediate",
      "isComplete": false,
      "content": "What's the output of this code?\nconst person = {\nname: 'Lydia',\nage: 21,\n};\nfor (const item in person) {\nconsole.log(item);\n}",
      "title": "JavaScript Object Property Access",
      "category": "JavaScript (Core)",
      "type": "code",
      "createdAt": "2025-09-30T00:21:03.475Z",
      "correctAnswer": null,
      "options": [],
      "explanation": "With a `for-in` loop, we can iterate through object keys, in this case `name` and `age`. Under the hood, object keys are strings (or Symbols). On every loop, we set the value of `item` equal to the current key it's iterating over. First, `item` is equal to `\"name\"`, and gets logged. Then, `item` is equal to `\"age\"`, which gets logged.",
      "codeBlock": "const person = {\n  name: 'Lydia',\n  age: 21,\n};\n\nfor (const item in person) {\n  console.log(item);\n}"
    },
    {
      "id": "imported-javascript-deep-dive-1759191663449-2",
      "category": "JavaScript (Core)",
      "importedAt": "2025-09-30T00:21:03.449Z",
      "isActive": true,
      "type": "code",
      "updatedAt": "2025-09-30T00:21:03.475Z",
      "isComplete": false,
      "learningPaths": [
        "javascript-deep-dive"
      ],
      "correctAnswer": null,
      "options": [],
      "topics": [
        "Hoisting",
        "Closures",
        "Event Loop",
        "Promises",
        "Async/Await"
      ],
      "difficulty": "intermediate",
      "title": "JavaScript Prototypes and Inheritance",
      "createdAt": "2025-09-30T00:21:03.475Z",
      "content": "Explain JavaScript prototypes and how inheritance works.",
      "codeBlock": "// Every object has a prototype\nconst obj = {};\nconsole.log(obj.__proto__ === Object.prototype); // true\n\n// Functions have prototypes\nfunction Person(name) {\n  this.name = name;\n}\n\nPerson.prototype.greet = function () {\n  return `Hello, I'm ${this.name}`;\n};\n\nconst john = new Person('John');\nconsole.log(john.greet()); // \"Hello, I'm John\"\n\n// Prototype chain lookup\nconsole.log(john.toString()); // Inherited from Object.prototype",
      "source": "QuestionsBank",
      "explanation": "JavaScript uses prototypal inheritance where objects inherit properties and methods from their prototype.\n\n**Prototype Chain:**\n\n// Every object has a prototype\nconst obj = {};\nconsole.log(obj.__proto__ === Object.prototype); // true\n\n// Functions have prototypes\nfunction Person(name) {\nthis.name = name;\n}\n\nPerson.prototype.greet = function () {\nreturn `Hello, I'm ${this.name}`;\n};\n\nconst john = new Person('John');\nconsole.log(john.greet()); // \"Hello, I'm John\"\n\n// Prototype chain lookup\nconsole.log(john.toString()); // Inherited from Object.prototype\n\n**ES6 Classes (Syntactic Sugar):**\n\nclass Person {\nconstructor(name) {\nthis.name = name;\n}\n\ngreet() {\nreturn `Hello, I'm ${this.name}`;\n}\n}\n\nclass Student extends Person {\nconstructor(name, grade) {\nsuper(name);\nthis.grade = grade;\n}\n\nstudy() {\nreturn `${this.name} is studying`;\n}\n}\n\nconst student = new Student('Alice', 'A');\nconsole.log(student.greet()); // \"Hello, I'm Alice\"\nconsole.log(student.study()); // \"Alice is studying\"\n\n**Prototype Methods:**\n\n// Adding methods to built-in prototypes\nArray.prototype.last = function () {\nreturn this[this.length - 1];\n};\n\nconst arr = [1, 2, 3, 4, 5];\nconsole.log(arr.last()); // 5\n\n// Object.create for prototypal inheritance\nconst animal = {\nspeak() {\nreturn `${this.name} makes a sound`;\n},\n};\n\nconst dog = Object.create(animal);\ndog.name = 'Buddy';\nconsole.log(dog.speak()); // \"Buddy makes a sound\""
    },
    {
      "id": "imported-javascript-deep-dive-1759191663452-66",
      "difficulty": "intermediate",
      "learningPaths": [
        "javascript-deep-dive"
      ],
      "codeBlock": null,
      "options": [],
      "importedAt": "2025-09-30T00:21:03.452Z",
      "title": "Array Methods and Return Values",
      "isComplete": false,
      "topics": [
        "Hoisting",
        "Closures",
        "Event Loop",
        "Promises",
        "Async/Await"
      ],
      "updatedAt": "2025-09-30T00:21:03.475Z",
      "createdAt": "2025-09-30T00:21:03.475Z",
      "source": "QuestionsBank",
      "explanation": "When you set a value to an element in an array that exceeds the length of the array, JavaScript creates something called \"empty slots\". These actually have the value of \\`undefined\\`, but you will see something like:\n\n\\`\\`\\`javascript\n[1, 2, 3, 7 x empty, 11]\n\\`\\`\\`\n\ndepending on where you run it (it's different for every browser, node, etc.)",
      "content": "What's the output of the following code?\n\\`\\`\\`javascript\nconst numbers = [1, 2, 3];\nnumbers[10] = 11;\nconsole.log(numbers);\n\\`\\`\\`",
      "correctAnswer": null,
      "type": "conceptual",
      "isActive": true,
      "category": "JavaScript (Core)"
    },
    {
      "id": "imported-javascript-deep-dive-1759191663451-57",
      "content": "What's the output of this code?\nconsole.log(typeof typeof 1);",
      "isComplete": false,
      "updatedAt": "2025-09-30T00:21:03.475Z",
      "codeBlock": "console.log(typeof typeof 1);",
      "type": "code",
      "category": "JavaScript (Core)",
      "difficulty": "intermediate",
      "explanation": "`typeof 1` returns `\"number\"`. `typeof \"number\"` returns `\"string\"`.\n\nThe `typeof` operator always returns a string, so `typeof typeof` will always return `\"string\"`.",
      "title": "JavaScript `typeof` Operator",
      "source": "QuestionsBank",
      "createdAt": "2025-09-30T00:21:03.475Z",
      "learningPaths": [
        "javascript-deep-dive"
      ],
      "isActive": true,
      "importedAt": "2025-09-30T00:21:03.451Z",
      "correctAnswer": null,
      "topics": [
        "Hoisting",
        "Closures",
        "Event Loop",
        "Promises",
        "Async/Await"
      ],
      "options": []
    },
    {
      "id": "imported-javascript-deep-dive-1759191663451-52",
      "importedAt": "2025-09-30T00:21:03.451Z",
      "createdAt": "2025-09-30T00:21:03.475Z",
      "learningPaths": [
        "javascript-deep-dive"
      ],
      "isActive": true,
      "difficulty": "intermediate",
      "content": "Do all objects have prototypes?",
      "topics": [
        "Hoisting",
        "Closures",
        "Event Loop",
        "Promises",
        "Async/Await"
      ],
      "isComplete": false,
      "codeBlock": null,
      "title": "JavaScript Object Prototypes",
      "options": [],
      "type": "conceptual",
      "explanation": "All objects have prototypes, except for the **base object**. The base object is the object created by the user, or an object that is created using the `new` keyword. The base object has access to some methods and properties, such as `.toString`. This is the reason why you can use built-in JavaScript methods! All of such methods are available on the prototype. Although JavaScript can't find it directly on your object, it goes down the prototype chain and finds it there, which makes it accessible for you.",
      "category": "JavaScript (Core)",
      "source": "QuestionsBank",
      "correctAnswer": null,
      "updatedAt": "2025-09-30T00:21:03.475Z"
    },
    {
      "id": "imported-javascript-deep-dive-1759191663451-19",
      "category": "JavaScript (Core)",
      "title": "JavaScript Scope Deep Understanding",
      "source": "QuestionsBank",
      "codeBlock": "// 1. Global Scope\nvar globalVar = 'I am global';\nlet globalLet = 'I am also global';\nconst globalConst = 'I am global too';\n\nfunction globalFunction() {\n  console.log(globalVar); // Accessible\n}\n\n// 2. Function Scope\nfunction functionScope() {\n  var functionVar = 'I am function scoped';\n  let functionLet = 'I am function scoped';\n  const functionConst = 'I am function scoped';\n\n  // All variables are accessible here\n  console.log(functionVar, functionLet, functionConst);\n}\n\n// console.log(functionVar); // ReferenceError: functionVar is not defined\n\n// 3. Block Scope (ES6+)\nif (true) {\n  var blockVar = 'I am function scoped (hoisted)';\n  let blockLet = 'I am block scoped';\n  const blockConst = 'I am block scoped';\n\n  console.log(blockVar, blockLet, blockConst); // All accessible\n}\n\nconsole.log(blockVar); // Accessible (hoisted)\n// console.log(blockLet); // ReferenceError: blockLet is not defined\n// console.log(blockConst); // ReferenceError: blockConst is not defined\n\n// 4. Module Scope\n// In ES6 modules, variables are module-scoped\nexport const moduleVar = 'I am module scoped';",
      "options": [],
      "isComplete": false,
      "createdAt": "2025-09-30T00:21:03.475Z",
      "importedAt": "2025-09-30T00:21:03.451Z",
      "correctAnswer": null,
      "explanation": "Scope defines the accessibility or visibility of variables and functions in your code. A senior developer must instantly recognize the scope of any variable (e.g., global, module, function, block) to predict code behavior, avoid bugs, and manage memory effectively. They understand that data lives in scopes, and misjudging scope leads to undefined errors, memory leaks, or unintended variable mutations.\n\n**Types of Scope:**\n\n// 1. Global Scope\nvar globalVar = 'I am global';\nlet globalLet = 'I am also global';\nconst globalConst = 'I am global too';\n\nfunction globalFunction() {\nconsole.log(globalVar); // Accessible\n}\n\n// 2. Function Scope\nfunction functionScope() {\nvar functionVar = 'I am function scoped';\nlet functionLet = 'I am function scoped';\nconst functionConst = 'I am function scoped';\n\n// All variables are accessible here\nconsole.log(functionVar, functionLet, functionConst);\n}\n\n// console.log(functionVar); // ReferenceError: functionVar is not defined\n\n// 3. Block Scope (ES6+)\nif (true) {\nvar blockVar = 'I am function scoped (hoisted)';\nlet blockLet = 'I am block scoped';\nconst blockConst = 'I am block scoped';\n\nconsole.log(blockVar, blockLet, blockConst); // All accessible\n}\n\nconsole.log(blockVar); // Accessible (hoisted)\n// console.log(blockLet); // ReferenceError: blockLet is not defined\n// console.log(blockConst); // ReferenceError: blockConst is not defined\n\n// 4. Module Scope\n// In ES6 modules, variables are module-scoped\nexport const moduleVar = 'I am module scoped';\n\n**Scope Chain and Lexical Scoping:**\n\n// Lexical scoping: inner functions have access to outer scope\nfunction outerFunction(x) {\n// Outer scope\nconst outerVar = 'outer';\n\nfunction innerFunction(y) {\n// Inner scope\nconst innerVar = 'inner';\n\n// Can access outer scope\nconsole.log(x, outerVar, y, innerVar);\n\nfunction deepestFunction(z) {\n// Deepest scope\nconsole.log(x, outerVar, y, innerVar, z);\n}\n\nreturn deepestFunction;\n}\n\nreturn innerFunction;\n}\n\nconst inner = outerFunction('parameter');\nconst deepest = inner('inner-param');\ndeepest('deepest-param');\n\n**Common Scope Pitfalls:**\n\n// 1. Variable Hoisting\nconsole.log(hoistedVar); // undefined (not ReferenceError)\nvar hoistedVar = 'I am hoisted';\n\n// 2. Temporal Dead Zone\n// console.log(temporalVar); // ReferenceError\nlet temporalVar = 'I am in TDZ';\n\n// 3. Loop Variable Capture\nconst functions = [];\nfor (var i = 0; i < 3; i++) {\nfunctions.push(() => console.log(i)); // All log 3\n}\nfunctions.forEach(fn => fn()); // 3, 3, 3\n\n// Fix with let\nconst functionsFixed = [];\nfor (let i = 0; i < 3; i++) {\nfunctionsFixed.push(() => console.log(i)); // Each logs its own value\n}\nfunctionsFixed.forEach(fn => fn()); // 0, 1, 2\n\n// 4. Global Pollution\nfunction badFunction() {\n// Accidentally creates global variable\nglobalPollution = 'I am global!';\n}\n\nbadFunction();\nconsole.log(window.globalPollution); // 'I am global!'\n\n**Memory Management and Scope:**\n\n// Memory leaks through closures\nfunction createLeak() {\nconst largeData = new Array(1000000).fill('data');\n\nreturn function () {\n// This closure keeps largeData in memory\nconsole.log('Closure executed');\n};\n}\n\nconst leakyFunction = createLeak();\n// largeData is still in memory even though createLeak finished\n\n// Proper cleanup\nfunction createCleanClosure() {\nconst largeData = new Array(1000000).fill('data');\n\nreturn function () {\nconsole.log('Clean closure');\n// Explicitly clear reference\nlargeData.length = 0;\n};\n}",
      "type": "code",
      "content": "What is scope in JavaScript, and why is it crucial for a senior developer to understand?",
      "updatedAt": "2025-09-30T00:21:03.475Z",
      "isActive": true,
      "learningPaths": [
        "javascript-deep-dive"
      ],
      "difficulty": "intermediate",
      "topics": [
        "Hoisting",
        "Closures",
        "Event Loop",
        "Promises",
        "Async/Await"
      ]
    },
    {
      "id": "imported-javascript-deep-dive-1759191663451-40",
      "content": "What's the output of this code?\nfunction Person(firstName, lastName) {\nthis.firstName = firstName;\nthis.lastName = lastName;\n}\nconst member = new Person('Lydia', 'Hallie');\nPerson.getFullName = function () {\nreturn `${this.firstName} ${this.lastName}`;\n};\nconsole.log(member.getFullName());",
      "title": "JavaScript Constructor Functions and Prototype",
      "source": "QuestionsBank",
      "category": "JavaScript (Core)",
      "options": [],
      "explanation": "You can't add properties to a constructor like you can with regular objects. If you want to add a feature to all objects at once, you have to use the prototype instead. So in this case:\n\nPerson.prototype.getFullName = function () {\nreturn `${this.firstName} ${this.lastName}`;\n};\n\nwould have made `member.getFullName()` work. In this case, we're trying to add a method as a property on the constructor function. `member` is an instance of `Person`, and doesn't have access to this method. Since `getFullName` is not defined on `member`, it throws a `TypeError`.",
      "learningPaths": [
        "javascript-deep-dive"
      ],
      "type": "code",
      "isComplete": false,
      "topics": [
        "Hoisting",
        "Closures",
        "Event Loop",
        "Promises",
        "Async/Await"
      ],
      "updatedAt": "2025-09-30T00:21:03.475Z",
      "correctAnswer": null,
      "importedAt": "2025-09-30T00:21:03.451Z",
      "createdAt": "2025-09-30T00:21:03.475Z",
      "codeBlock": "function Person(firstName, lastName) {\n  this.firstName = firstName;\n  this.lastName = lastName;\n}\n\nconst member = new Person('Lydia', 'Hallie');\nPerson.getFullName = function () {\n  return `${this.firstName} ${this.lastName}`;\n};\n\nconsole.log(member.getFullName());",
      "isActive": true,
      "difficulty": "intermediate"
    },
    {
      "id": "imported-javascript-deep-dive-1759191663451-32",
      "importedAt": "2025-09-30T00:21:03.451Z",
      "createdAt": "2025-09-30T00:21:03.475Z",
      "learningPaths": [
        "javascript-deep-dive"
      ],
      "isActive": true,
      "difficulty": "intermediate",
      "content": "What's the output of this code?\nfunction getAge(...args) {\nconsole.log(typeof args);\n}\ngetAge(21);",
      "topics": [
        "Hoisting",
        "Closures",
        "Event Loop",
        "Promises",
        "Async/Await"
      ],
      "isComplete": false,
      "codeBlock": "function getAge(...args) {\n  console.log(typeof args);\n}\n\ngetAge(21);",
      "title": "JavaScript Function Parameters and Arguments",
      "options": [],
      "type": "code",
      "category": "JavaScript (Core)",
      "explanation": "The rest parameter (`...args`) lets us \"collect\" all remaining arguments into an array. An array is an object, so `typeof args` returns `\"object\"`.",
      "correctAnswer": null,
      "source": "QuestionsBank",
      "updatedAt": "2025-09-30T00:21:03.475Z"
    },
    {
      "id": "imported-javascript-deep-dive-1759191663451-58",
      "source": "QuestionsBank",
      "difficulty": "intermediate",
      "createdAt": "2025-09-30T00:21:03.475Z",
      "options": [],
      "category": "JavaScript (Core)",
      "isComplete": false,
      "explanation": "When you set a value to an element in an array that exceeds the length of the array, JavaScript creates something called \"empty slots\". These actually have the value of `undefined`, but you'll see something like:\n\n`[1, 2, 3, empty × 6, 11]`\n\ndepending on where you run it (it's different for every browser, node, etc.)",
      "importedAt": "2025-09-30T00:21:03.451Z",
      "type": "code",
      "learningPaths": [
        "javascript-deep-dive"
      ],
      "topics": [
        "Hoisting",
        "Closures",
        "Event Loop",
        "Promises",
        "Async/Await"
      ],
      "content": "What's the output of this code?\nconst numbers = [1, 2, 3];\nnumbers[9] = 11;\nconsole.log(numbers);",
      "correctAnswer": null,
      "isActive": true,
      "updatedAt": "2025-09-30T00:21:03.475Z",
      "title": "JavaScript Array Methods and Mutation",
      "codeBlock": "const numbers = [1, 2, 3];\nnumbers[9] = 11;\nconsole.log(numbers);"
    },
    {
      "id": "imported-javascript-deep-dive-1759191663451-23",
      "difficulty": "intermediate",
      "isComplete": false,
      "createdAt": "2025-09-30T00:21:03.475Z",
      "category": "JavaScript (Core)",
      "explanation": "| Feature     | CommonJS                                 | ES6 Modules                              |\n| ----------- | ---------------------------------------- | ---------------------------------------- |\n| Syntax      | `require()`, `module.exports`            | `import`, `export`                       |\n| Loading     | Dynamic (runtime)                        | Static (parse-time)                      |\n| Analysis    | Hard to analyze (e.g., for tree-shaking) | Enables static analysis and tree-shaking |\n| Environment | Primarily Node.js                        | Universal (Node.js + Browsers)           |\n| Value       | Copies exported values                   | Live read-only view of exported values   |\n\n**CommonJS Examples:**\n\n// math.js\nconst add = (a, b) => a + b;\nconst subtract = (a, b) => a - b;\n\nmodule.exports = {\nadd,\nsubtract,\n};\n\n// Or individual exports\nexports.add = add;\nexports.subtract = subtract;\n\n// main.js\nconst math = require('./math');\nconst { add, subtract } = require('./math');\n\nconsole.log(math.add(2, 3)); // 5\nconsole.log(add(2, 3)); // 5\n\n// Dynamic require\nconst moduleName = 'math';\nconst mathModule = require(`./${moduleName}`);\n\n**ES6 Modules Examples:**\n\n// math.js\nexport const add = (a, b) => a + b;\nexport const subtract = (a, b) => a - b;\n\n// Default export\nexport default function multiply(a, b) {\nreturn a * b;\n}\n\n// main.js\nimport multiply, { add, subtract } from './math';\nimport * as math from './math';\n\nconsole.log(add(2, 3)); // 5\nconsole.log(multiply(2, 3)); // 6\nconsole.log(math.subtract(5, 2)); // 3\n\n// Dynamic import (async)\nconst moduleName = 'math';\nconst mathModule = await import(`./${moduleName}`);\n\n**Key Differences:**\n\n**1. Loading Time:**\n\n// CommonJS - Runtime loading\nif (condition) {\nconst module = require('./module'); // Loaded at runtime\n}\n\n// ES6 - Parse-time loading (static)\n// import module from './module'; // Must be at top level\n// Cannot be inside conditionals\n\n// ES6 Dynamic import (async)\nif (condition) {\nconst module = await import('./module'); // Async loading\n}\n\n**2. Value Binding:**\n\n// CommonJS - Value copying\n// counter.js\nlet count = 0;\nmodule.exports = {\ngetCount: () => count,\nincrement: () => ++count,\n};\n\n// main.js\nconst counter1 = require('./counter');\nconst counter2 = require('./counter');\n\ncounter1.increment();\nconsole.log(counter1.getCount()); // 1\nconsole.log(counter2.getCount()); // 1 (shared state)\n\n// ES6 - Live binding\n// counter.js\nlet count = 0;\nexport const getCount = () => count;\nexport const increment = () => ++count;\n\n// main.js\nimport { getCount, increment } from './counter';\n\nincrement();\nconsole.log(getCount()); // 1 (live binding)\n\n**3. Tree Shaking:**\n\n// CommonJS - No tree shaking\n// utils.js\nexports.add = (a, b) => a + b;\nexports.subtract = (a, b) => a - b;\nexports.multiply = (a, b) => a * b;\n\n// main.js\nconst { add } = require('./utils'); // All functions bundled\n\n// ES6 - Tree shaking possible\n// utils.js\nexport const add = (a, b) => a + b;\nexport const subtract = (a, b) => a - b;\nexport const multiply = (a, b) => a * b;\n\n// main.js\nimport { add } from './utils'; // Only 'add' function bundled\n\n**4. Hoisting Behavior:**\n\n// CommonJS\nconsole.log(typeof require); // 'function'\nconsole.log(typeof module); // 'object'\n\n// ES6\nconsole.log(typeof import); // 'undefined' (not hoisted)\nconsole.log(typeof export); // 'undefined' (not hoisted)\n\n// Import hoisting\nconsole.log(myFunction()); // Works! (imports are hoisted)\n\nimport { myFunction } from './module';\n\n**5. Circular Dependencies:**\n\n// CommonJS - Partial loading\n// a.js\nconsole.log('a starting');\nconst b = require('./b');\nconsole.log('in a, b.done =', b.done);\nmodule.exports = { done: true };\n\n// b.js\nconsole.log('b starting');\nconst a = require('./a');\nconsole.log('in b, a.done =', a.done);\nmodule.exports = { done: true };\n\n// Output: a starting, b starting, in b, a.done = undefined, in a, b.done = true\n\n// ES6 - Live binding\n// a.js\nconsole.log('a starting');\nimport { done as bDone } from './b.js';\nconsole.log('in a, b.done =', bDone);\nexport const done = true;\n\n// b.js\nconsole.log('b starting');\nimport { done as aDone } from './a.js';\nconsole.log('in b, a.done =', aDone);\nexport const done = true;\n\n// Output: a starting, b starting, in b, a.done = undefined, in a, b.done = true\n\n**Migration Example:**\n\n// Before (CommonJS)\nconst express = require('express');\nconst { Router } = require('express');\nconst path = require('path');\n\nconst app = express();\nconst router = Router();\n\nmodule.exports = { app, router };\n\n// After (ES6)\nimport express, { Router } from 'express';\nimport path from 'path';\n\nconst app = express();\nconst router = Router();\n\nexport { app, router };",
      "type": "code",
      "learningPaths": [
        "javascript-deep-dive"
      ],
      "source": "QuestionsBank",
      "options": [],
      "importedAt": "2025-09-30T00:21:03.451Z",
      "correctAnswer": null,
      "topics": [
        "Hoisting",
        "Closures",
        "Event Loop",
        "Promises",
        "Async/Await"
      ],
      "title": "CommonJS vs ES6 Modules",
      "content": "Compare and contrast CommonJS (require/module.exports) and ES6 Modules (import/export).",
      "updatedAt": "2025-09-30T00:21:03.475Z",
      "codeBlock": "// math.js\nconst add = (a, b) => a + b;\nconst subtract = (a, b) => a - b;\n\nmodule.exports = {\n  add,\n  subtract,\n};\n\n// Or individual exports\nexports.add = add;\nexports.subtract = subtract;\n\n// main.js\nconst math = require('./math');\nconst { add, subtract } = require('./math');\n\nconsole.log(math.add(2, 3)); // 5\nconsole.log(add(2, 3)); // 5\n\n// Dynamic require\nconst moduleName = 'math';\nconst mathModule = require(`./${moduleName}`);",
      "isActive": true
    },
    {
      "id": "imported-javascript-deep-dive-1759191663452-67",
      "content": "What's the output of the following code?\n\\`\\`\\`javascript\nconst numbers = [1, 2, 3];\nnumbers[10] = 11;\nconsole.log(numbers);\n\\`\\`\\`",
      "type": "conceptual",
      "isComplete": false,
      "source": "QuestionsBank",
      "codeBlock": null,
      "options": [],
      "title": "Array Methods and Return Values",
      "difficulty": "intermediate",
      "importedAt": "2025-09-30T00:21:03.452Z",
      "explanation": "When you set a value to an element in an array that exceeds the length of the array, JavaScript creates something called \"empty slots\". These actually have the value of \\`undefined\\`, but you will see something like:\n\n\\`\\`\\`javascript\n[1, 2, 3, 7 x empty, 11]\n\\`\\`\\`\n\ndepending on where you run it (it's different for every browser, node, etc.)",
      "category": "JavaScript (Core)",
      "correctAnswer": null,
      "updatedAt": "2025-09-30T00:21:03.475Z",
      "topics": [
        "Hoisting",
        "Closures",
        "Event Loop",
        "Promises",
        "Async/Await"
      ],
      "createdAt": "2025-09-30T00:21:03.475Z",
      "learningPaths": [
        "javascript-deep-dive"
      ],
      "isActive": true
    },
    {
      "id": "imported-javascript-deep-dive-1759191663452-60",
      "category": "JavaScript (Core)",
      "source": "QuestionsBank",
      "options": [],
      "isComplete": false,
      "updatedAt": "2025-09-30T00:21:03.475Z",
      "explanation": "With \\`\"use strict\"\\`, you can't reference undeclared variables. We never declared the variable \\`age\\`, and since we use \\`\"use strict\"\\`, it will throw a reference error. If we didn't use \\`\"use strict\"\\`, it would have worked, since the property \\`age\\` would have gotten added to the global object.",
      "correctAnswer": null,
      "type": "conceptual",
      "importedAt": "2025-09-30T00:21:03.452Z",
      "isActive": true,
      "codeBlock": null,
      "learningPaths": [
        "javascript-deep-dive"
      ],
      "content": "What's the output of the following code?\n\\`\\`\\`javascript\nfunction getAge() {\n'use strict';\nage = 21;\nconsole.log(age);\n}\ngetAge();\n\\`\\`\\`",
      "topics": [
        "Hoisting",
        "Closures",
        "Event Loop",
        "Promises",
        "Async/Await"
      ],
      "title": "Type Coercion in JavaScript",
      "difficulty": "intermediate",
      "createdAt": "2025-09-30T00:21:03.475Z"
    },
    {
      "id": "imported-javascript-deep-dive-1759191663451-49",
      "codeBlock": "const numbers = [1, 2, 3, 4, 5];\nconst result = numbers.map(num => num * 2).filter(num => num > 5);\nconsole.log(result);",
      "learningPaths": [
        "javascript-deep-dive"
      ],
      "type": "code",
      "source": "QuestionsBank",
      "options": [],
      "difficulty": "intermediate",
      "importedAt": "2025-09-30T00:21:03.451Z",
      "correctAnswer": null,
      "category": "JavaScript (Core)",
      "updatedAt": "2025-09-30T00:21:03.475Z",
      "explanation": "The `map` method creates a new array with each element multiplied by 2: `[2, 4, 6, 8, 10]`.\n\nThe `filter` method then filters out elements that are not greater than 5, leaving `[6, 8, 10]`.",
      "isActive": true,
      "content": "What's the output of this code?\nconst numbers = [1, 2, 3, 4, 5];\nconst result = numbers.map(num => num * 2).filter(num => num > 5);\nconsole.log(result);",
      "topics": [
        "Hoisting",
        "Closures",
        "Event Loop",
        "Promises",
        "Async/Await"
      ],
      "createdAt": "2025-09-30T00:21:03.475Z",
      "isComplete": false,
      "title": "JavaScript Array Methods and Return Values"
    },
    {
      "id": "imported-javascript-deep-dive-1759191663451-48",
      "codeBlock": "function createIncrement() {\n  let count = 0;\n  function increment() {\n    count++;\n  }\n  let message = `Count is ${count}`;\n  function log() {\n    console.log(message);\n  }\n  return [increment, log];\n}\n\nconst [increment, log] = createIncrement();\nincrement();\nincrement();\nincrement();\nlog();",
      "type": "code",
      "learningPaths": [
        "javascript-deep-dive"
      ],
      "source": "QuestionsBank",
      "options": [],
      "difficulty": "intermediate",
      "importedAt": "2025-09-30T00:21:03.451Z",
      "correctAnswer": null,
      "category": "JavaScript (Core)",
      "updatedAt": "2025-09-30T00:21:03.475Z",
      "explanation": "The `message` variable is created when the `createIncrement` function is called, and at that time, `count` is `0`. Even though `increment` is called multiple times, the `message` variable is not updated because it was captured at the time of creation.",
      "isActive": true,
      "content": "What's the output of this code?\nfunction createIncrement() {\nlet count = 0;\nfunction increment() {\ncount++;\n}\nlet message = `Count is ${count}`;\nfunction log() {\nconsole.log(message);\n}\nreturn [increment, log];\n}\nconst [increment, log] = createIncrement();\nincrement();\nincrement();\nincrement();\nlog();",
      "topics": [
        "Hoisting",
        "Closures",
        "Event Loop",
        "Promises",
        "Async/Await"
      ],
      "createdAt": "2025-09-30T00:21:03.475Z",
      "isComplete": false,
      "title": "JavaScript Closure and Scope"
    },
    {
      "id": "imported-javascript-deep-dive-1759191663451-35",
      "options": [],
      "importedAt": "2025-09-30T00:21:03.451Z",
      "isActive": true,
      "explanation": "In JavaScript, all objects interact by reference when setting them equal to each other.\n\nFirst, variable `c` holds a value to an object. Later, we assign `d` with the same reference that `c` has to the object.\n\nWhen you change one object, you change all of them.",
      "codeBlock": "let c = { greeting: 'Hey!' };\nlet d;\n\nd = c;\nc.greeting = 'Hello';\nconsole.log(d.greeting);",
      "isComplete": false,
      "title": "JavaScript Object Reference vs Value",
      "content": "What's the output of this code?\nlet c = { greeting: 'Hey!' };\nlet d;\nd = c;\nc.greeting = 'Hello';\nconsole.log(d.greeting);",
      "type": "code",
      "correctAnswer": null,
      "topics": [
        "Hoisting",
        "Closures",
        "Event Loop",
        "Promises",
        "Async/Await"
      ],
      "category": "JavaScript (Core)",
      "createdAt": "2025-09-30T00:21:03.475Z",
      "updatedAt": "2025-09-30T00:21:03.475Z",
      "source": "QuestionsBank",
      "learningPaths": [
        "javascript-deep-dive"
      ],
      "difficulty": "intermediate"
    },
    {
      "id": "imported-javascript-deep-dive-1759191663451-43",
      "codeBlock": "function getAge(...args) {\n  console.log(typeof args);\n}\n\ngetAge(21);",
      "isComplete": false,
      "topics": [
        "Hoisting",
        "Closures",
        "Event Loop",
        "Promises",
        "Async/Await"
      ],
      "isActive": true,
      "updatedAt": "2025-09-30T00:21:03.475Z",
      "type": "code",
      "source": "QuestionsBank",
      "createdAt": "2025-09-30T00:21:03.475Z",
      "content": "What's the output of this code?\nfunction getAge(...args) {\nconsole.log(typeof args);\n}\ngetAge(21);",
      "correctAnswer": null,
      "explanation": "The rest parameter (`...args`) lets us \"collect\" all remaining arguments into an array. An array is an object, so `typeof args` returns `\"object\"`.",
      "options": [],
      "importedAt": "2025-09-30T00:21:03.451Z",
      "difficulty": "intermediate",
      "title": "JavaScript Function Arguments",
      "learningPaths": [
        "javascript-deep-dive"
      ],
      "category": "JavaScript (Core)"
    },
    {
      "id": "imported-javascript-deep-dive-1759191663451-20",
      "category": "JavaScript (Core)",
      "content": "Explain closures and provide a practical example of their use.",
      "createdAt": "2025-09-30T00:21:03.475Z",
      "isActive": true,
      "updatedAt": "2025-09-30T00:21:03.475Z",
      "codeBlock": "function createCounter() {\n  let count = 0; // `count` is enclosed by the inner function\n\n  return function increment() {\n    count++;\n    return count;\n  };\n}\n\nconst counter = createCounter();\nconsole.log(counter()); // 1\nconsole.log(counter()); // 2\nconsole.log(counter()); // 3\n\n// Each counter maintains its own private state\nconst counter2 = createCounter();\nconsole.log(counter2()); // 1 (independent state)\nconsole.log(counter()); // 4 (original counter still works)",
      "type": "code",
      "difficulty": "intermediate",
      "isComplete": false,
      "importedAt": "2025-09-30T00:21:03.451Z",
      "options": [],
      "source": "QuestionsBank",
      "title": "Closures Practical Examples",
      "topics": [
        "Hoisting",
        "Closures",
        "Event Loop",
        "Promises",
        "Async/Await"
      ],
      "learningPaths": [
        "javascript-deep-dive"
      ],
      "correctAnswer": null,
      "explanation": "A closure is a function that \"encloses\" or remembers its lexical scope, even when that function is executed outside that scope. This means it has continuous access to variables from the place where it was created, not where it is called.\n\n**Basic Closure Example:**\n\nfunction createCounter() {\nlet count = 0; // `count` is enclosed by the inner function\n\nreturn function increment() {\ncount++;\nreturn count;\n};\n}\n\nconst counter = createCounter();\nconsole.log(counter()); // 1\nconsole.log(counter()); // 2\nconsole.log(counter()); // 3\n\n// Each counter maintains its own private state\nconst counter2 = createCounter();\nconsole.log(counter2()); // 1 (independent state)\nconsole.log(counter()); // 4 (original counter still works)\n\n**Practical Use Cases:**\n\n**1. Module Pattern:**\n\nconst userModule = (function () {\nlet users = [];\nlet currentUser = null;\n\nreturn {\naddUser: function (user) {\nusers.push(user);\n},\n\ngetUsers: function () {\nreturn [...users]; // Return copy to prevent external mutation\n},\n\nsetCurrentUser: function (user) {\ncurrentUser = user;\n},\n\ngetCurrentUser: function () {\nreturn currentUser;\n},\n\ngetUserCount: function () {\nreturn users.length;\n},\n};\n})();\n\n// Usage\nuserModule.addUser({ name: 'John', id: 1 });\nuserModule.addUser({ name: 'Jane', id: 2 });\nconsole.log(userModule.getUserCount()); // 2\nconsole.log(userModule.getUsers()); // [{ name: 'John', id: 1 }, { name: 'Jane', id: 2 }]\n\n// users and currentUser are private - cannot be accessed directly\n\n**2. Function Factories:**\n\nfunction createMultiplier(factor) {\nreturn function (number) {\nreturn number * factor;\n};\n}\n\nconst double = createMultiplier(2);\nconst triple = createMultiplier(3);\n\nconsole.log(double(5)); // 10\nconsole.log(triple(5)); // 15\n\n// More complex factory\nfunction createValidator(rules) {\nreturn function (data) {\nconst errors = [];\n\nfor (const [field, rule] of Object.entries(rules)) {\nif (rule.required && !data[field]) {\nerrors.push(`${field} is required`);\n}\n\nif (rule.minLength && data[field]?.length < rule.minLength) {\nerrors.push(`${field} must be at least ${rule.minLength} characters`);\n}\n}\n\nreturn {\nisValid: errors.length === 0,\nerrors,\n};\n};\n}\n\nconst userValidator = createValidator({\nname: { required: true, minLength: 2 },\nemail: { required: true, minLength: 5 },\n});\n\nconsole.log(userValidator({ name: 'J', email: 'test@example.com' }));\n// { isValid: false, errors: ['name must be at least 2 characters'] }\n\n**3. Event Handlers with State:**\n\nfunction createButtonHandler(buttonId) {\nlet clickCount = 0;\n\nreturn function (event) {\nclickCount++;\nconsole.log(`Button ${buttonId} clicked ${clickCount} times`);\n\nif (clickCount === 3) {\nevent.target.disabled = true;\nconsole.log(`Button ${buttonId} disabled after 3 clicks`);\n}\n};\n}\n\n// Each button gets its own click counter\nconst button1Handler = createButtonHandler('btn1');\nconst button2Handler = createButtonHandler('btn2');\n\n// In real DOM:\n// document.getElementById('btn1').addEventListener('click', button1Handler);\n// document.getElementById('btn2').addEventListener('click', button2Handler);\n\n**4. Memoization:**\n\nfunction createMemoizedFunction(fn) {\nconst cache = new Map();\n\nreturn function (...args) {\nconst key = JSON.stringify(args);\n\nif (cache.has(key)) {\nconsole.log('Cache hit!');\nreturn cache.get(key);\n}\n\nconsole.log('Computing...');\nconst result = fn.apply(this, args);\ncache.set(key, result);\nreturn result;\n};\n}\n\n// Expensive calculation\nfunction fibonacci(n) {\nif (n <= 1) return n;\nreturn fibonacci(n - 1) + fibonacci(n - 2);\n}\n\nconst memoizedFibonacci = createMemoizedFunction(fibonacci);\n\nconsole.log(memoizedFibonacci(10)); // Computing... 55\nconsole.log(memoizedFibonacci(10)); // Cache hit! 55\nconsole.log(memoizedFibonacci(11)); // Computing... 89\n\n**5. Partial Application:**\n\nfunction createPartialFunction(fn, ...presetArgs) {\nreturn function (...laterArgs) {\nreturn fn(...presetArgs, ...laterArgs);\n};\n}\n\nfunction add(a, b, c) {\nreturn a + b + c;\n}\n\nconst add5 = createPartialFunction(add, 5);\nconst add5And10 = createPartialFunction(add, 5, 10);\n\nconsole.log(add5(3, 2)); // 10 (5 + 3 + 2)\nconsole.log(add5And10(1)); // 16 (5 + 10 + 1)\n\n// Real-world example: API calls\nfunction apiCall(method, url, data) {\nreturn fetch(url, {\nmethod,\nheaders: { 'Content-Type': 'application/json' },\nbody: data ? JSON.stringify(data) : undefined,\n});\n}\n\nconst get = createPartialFunction(apiCall, 'GET');\nconst post = createPartialFunction(apiCall, 'POST');\n\n// Usage\n// get('/api/users')\n// post('/api/users', { name: 'John' })"
    },
    {
      "id": "imported-javascript-deep-dive-1759191663451-27",
      "isComplete": false,
      "learningPaths": [
        "javascript-deep-dive"
      ],
      "importedAt": "2025-09-30T00:21:03.451Z",
      "options": [],
      "difficulty": "intermediate",
      "isActive": true,
      "createdAt": "2025-09-30T00:21:03.475Z",
      "category": "JavaScript (Core)",
      "source": "QuestionsBank",
      "title": "JavaScript Event Loop and setTimeout",
      "updatedAt": "2025-09-30T00:21:03.475Z",
      "type": "code",
      "correctAnswer": null,
      "content": "What's the output of this code?\nfor (var i = 0; i < 3; i++) {\nsetTimeout(() => console.log(i), 1);\n}\nfor (let i = 0; i < 3; i++) {\nsetTimeout(() => console.log(i), 1);\n}",
      "codeBlock": "for (var i = 0; i < 3; i++) {\n  setTimeout(() => console.log(i), 1);\n}\n\nfor (let i = 0; i < 3; i++) {\n  setTimeout(() => console.log(i), 1);\n}",
      "explanation": "Because of the event queue in JavaScript, the `setTimeout` callback function is called after the loop has been executed. Since the variable `i` in the first loop was declared using the `var` keyword, this value was global. During the loop, we incremented the value of `i` by `1` each time, using the unary operator `++`. By the time the `setTimeout` callback function was invoked, `i` was equal to `3` in the first example.\n\nIn the second loop, the variable `i` was declared using the `let` keyword: variables declared with the `let` (and `const`) keyword are block-scoped (a block is anything between `{ }`). During each iteration, `i` will have a new value, and each value is scoped inside the loop.",
      "topics": [
        "Hoisting",
        "Closures",
        "Event Loop",
        "Promises",
        "Async/Await"
      ]
    }
  ]
}