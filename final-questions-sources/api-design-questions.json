{
  "category": "API Design",
  "totalQuestions": 9,
  "exportedAt": "2025-09-30T00:28:57.755Z",
  "questions": [
    {
      "id": "imported-api-design-1759191587277-2",
      "topics": [
        "REST APIs",
        "GraphQL",
        "Authentication",
        "Rate Limiting"
      ],
      "updatedAt": "2025-09-30T00:19:47.305Z",
      "type": "code",
      "isActive": true,
      "codeBlock": "const jwt = require('jsonwebtoken');\n\nclass JWTAuth {\n  constructor(secret) {\n    this.secret = secret;\n  }\n\n  generateToken(payload, options = {}) {\n    return jwt.sign(payload, this.secret, {\n      expiresIn: options.expiresIn || '1h',\n      issuer: options.issuer || 'your-app',\n      audience: options.audience || 'your-app-users',\n    });\n  }\n\n  verifyToken(token) {\n    try {\n      return jwt.verify(token, this.secret);\n    } catch (error) {\n      throw new Error('Invalid token');\n    }\n  }\n\n  // Middleware\n  authenticate() {\n    return (req, res, next) => {\n      const authHeader = req.get('Authorization');\n      if (!authHeader || !authHeader.startsWith('Bearer ')) {\n        return res.status(401).json({ error: 'No token provided' });\n      }\n\n      const token = authHeader.substring(7);\n      try {\n        const decoded = this.verifyToken(token);\n        req.user = decoded;\n        next();\n      } catch (error) {\n        res.status(401).json({ error: 'Invalid token' });\n      }\n    };\n  }\n}\n\n// Usage\nconst auth = new JWTAuth(process.env.JWT_SECRET);\napp.use('/api/protected', auth.authenticate());",
      "options": [],
      "isComplete": false,
      "source": "QuestionsBank",
      "title": "API Authentication and Authorization",
      "category": "API Design",
      "correctAnswer": null,
      "difficulty": "intermediate",
      "explanation": "**1. JWT Authentication:**\n\nconst jwt = require('jsonwebtoken');\n\nclass JWTAuth {\nconstructor(secret) {\nthis.secret = secret;\n}\n\ngenerateToken(payload, options = {}) {\nreturn jwt.sign(payload, this.secret, {\nexpiresIn: options.expiresIn || '1h',\nissuer: options.issuer || 'your-app',\naudience: options.audience || 'your-app-users',\n});\n}\n\nverifyToken(token) {\ntry {\nreturn jwt.verify(token, this.secret);\n} catch (error) {\nthrow new Error('Invalid token');\n}\n}\n\n// Middleware\nauthenticate() {\nreturn (req, res, next) => {\nconst authHeader = req.get('Authorization');\nif (!authHeader || !authHeader.startsWith('Bearer ')) {\nreturn res.status(401).json({ error: 'No token provided' });\n}\n\nconst token = authHeader.substring(7);\ntry {\nconst decoded = this.verifyToken(token);\nreq.user = decoded;\nnext();\n} catch (error) {\nres.status(401).json({ error: 'Invalid token' });\n}\n};\n}\n}\n\n// Usage\nconst auth = new JWTAuth(process.env.JWT_SECRET);\napp.use('/api/protected', auth.authenticate());\n\n**2. API Key Authentication:**\n\nclass APIKeyAuth {\nconstructor() {\nthis.apiKeys = new Map();\n}\n\ngenerateAPIKey(userId, permissions = []) {\nconst key = crypto.randomBytes(32).toString('hex');\nthis.apiKeys.set(key, {\nuserId,\npermissions,\ncreatedAt: Date.now(),\nlastUsed: null,\n});\nreturn key;\n}\n\nvalidateAPIKey(key) {\nconst keyData = this.apiKeys.get(key);\nif (!keyData) {\nreturn null;\n}\n\n// Update last used\nkeyData.lastUsed = Date.now();\nreturn keyData;\n}\n\n// Middleware\nauthenticate() {\nreturn (req, res, next) => {\nconst apiKey = req.get('X-API-Key');\nif (!apiKey) {\nreturn res.status(401).json({ error: 'API key required' });\n}\n\nconst keyData = this.validateAPIKey(apiKey);\nif (!keyData) {\nreturn res.status(401).json({ error: 'Invalid API key' });\n}\n\nreq.user = { id: keyData.userId };\nreq.permissions = keyData.permissions;\nnext();\n};\n}\n}\n\n**3. OAuth 2.0:**\n\nclass OAuth2Provider {\nconstructor() {\nthis.clients = new Map();\nthis.authorizationCodes = new Map();\nthis.accessTokens = new Map();\n}\n\nregisterClient(clientId, clientSecret, redirectUri) {\nthis.clients.set(clientId, {\nclientSecret,\nredirectUri,\ncreatedAt: Date.now(),\n});\n}\n\n// Authorization Code Flow\ngenerateAuthorizationCode(clientId, userId, scope) {\nconst code = crypto.randomBytes(32).toString('hex');\nthis.authorizationCodes.set(code, {\nclientId,\nuserId,\nscope,\nexpiresAt: Date.now() + 600000, // 10 minutes\n});\nreturn code;\n}\n\nexchangeCodeForToken(code, clientId, clientSecret) {\nconst codeData = this.authorizationCodes.get(code);\nif (!codeData || codeData.clientId !== clientId) {\nthrow new Error('Invalid authorization code');\n}\n\nif (Date.now() > codeData.expiresAt) {\nthrow new Error('Authorization code expired');\n}\n\nconst client = this.clients.get(clientId);\nif (!client || client.clientSecret !== clientSecret) {\nthrow new Error('Invalid client credentials');\n}\n\n// Generate access token\nconst accessToken = crypto.randomBytes(32).toString('hex');\nthis.accessTokens.set(accessToken, {\nuserId: codeData.userId,\nscope: codeData.scope,\nexpiresAt: Date.now() + 3600000, // 1 hour\n});\n\n// Clean up authorization code\nthis.authorizationCodes.delete(code);\n\nreturn {\naccess_token: accessToken,\ntoken_type: 'Bearer',\nexpires_in: 3600,\nscope: codeData.scope,\n};\n}\n\nvalidateAccessToken(token) {\nconst tokenData = this.accessTokens.get(token);\nif (!tokenData || Date.now() > tokenData.expiresAt) {\nreturn null;\n}\nreturn tokenData;\n}\n}\n\n**4. Role-Based Access Control:**\n\nclass RBAC {\nconstructor() {\nthis.roles = new Map();\nthis.permissions = new Map();\n}\n\ndefineRole(roleName, permissions) {\nthis.roles.set(roleName, permissions);\n}\n\ndefinePermission(permission, resource, action) {\nthis.permissions.set(permission, { resource, action });\n}\n\nhasPermission(userRole, permission) {\nconst rolePermissions = this.roles.get(userRole);\nreturn rolePermissions && rolePermissions.includes(permission);\n}\n\n// Middleware\nrequirePermission(permission) {\nreturn (req, res, next) => {\nconst userRole = req.user.role;\nif (!this.hasPermission(userRole, permission)) {\nreturn res.status(403).json({ error: 'Insufficient permissions' });\n}\nnext();\n};\n}\n\n// Resource-based authorization\nrequireOwnership(resourceIdParam = 'id') {\nreturn (req, res, next) => {\nconst resourceId = req.params[resourceIdParam];\nconst userId = req.user.id;\n\n// Check if user owns the resource\nif (resourceId !== userId) {\nreturn res.status(403).json({ error: 'Access denied' });\n}\nnext();\n};\n}\n}\n\n// Usage\nconst rbac = new RBAC();\nrbac.defineRole('admin', ['read', 'write', 'delete']);\nrbac.defineRole('user', ['read', 'write']);\nrbac.defineRole('guest', ['read']);\n\napp.get(\n'/api/users/:id',\nauth.authenticate(),\nrbac.requirePermission('read'),\ngetUser\n);",
      "content": "Explain different API authentication and authorization methods.",
      "learningPaths": [
        "api-design"
      ],
      "createdAt": "2025-09-30T00:19:47.305Z",
      "importedAt": "2025-09-30T00:19:47.277Z"
    },
    {
      "id": "imported-api-design-1759191587277-0",
      "createdAt": "2025-09-30T00:19:47.305Z",
      "updatedAt": "2025-09-30T00:19:47.305Z",
      "category": "API Design",
      "content": "Explain RESTful API design principles and best practices.",
      "type": "code",
      "explanation": "**1. REST Principles:**\n\n// Resource-based URLs\nGET    /api/users           // Get all users\nGET    /api/users/123       // Get user by ID\nPOST   /api/users           // Create new user\nPUT    /api/users/123       // Update entire user\nPATCH  /api/users/123       // Partial update\nDELETE /api/users/123       // Delete user\n\n// Nested resources\nGET    /api/users/123/orders        // Get user's orders\nPOST   /api/users/123/orders        // Create order for user\nGET    /api/users/123/orders/456    // Get specific order\n\n// Query parameters for filtering\nGET    /api/users?page=1&limit=10&sort=name&order=asc\nGET    /api/users?status=active&role=admin\nGET    /api/users?search=john&fields=name,email\n\n**2. HTTP Status Codes:**\n\n// Success responses\n200 OK          // Successful GET, PUT, PATCH\n201 Created     // Successful POST\n204 No Content  // Successful DELETE\n\n// Client errors\n400 Bad Request     // Invalid request data\n401 Unauthorized    // Authentication required\n403 Forbidden       // Access denied\n404 Not Found       // Resource not found\n409 Conflict        // Resource conflict\n422 Unprocessable Entity // Validation errors\n\n// Server errors\n500 Internal Server Error // Server error\n502 Bad Gateway          // Upstream server error\n503 Service Unavailable  // Service temporarily unavailable\n\n// Example implementation\napp.get('/api/users/:id', async (req, res) => {\ntry {\nconst user = await User.findById(req.params.id);\nif (!user) {\nreturn res.status(404).json({ error: 'User not found' });\n}\nres.json(user);\n} catch (error) {\nres.status(500).json({ error: 'Internal server error' });\n}\n});\n\n**3. Request/Response Format:**\n\n// Request format\n{\n\"data\": {\n\"type\": \"users\",\n\"attributes\": {\n\"name\": \"John Doe\",\n\"email\": \"john@example.com\",\n\"age\": 30\n}\n}\n}\n\n// Response format\n{\n\"data\": {\n\"id\": \"123\",\n\"type\": \"users\",\n\"attributes\": {\n\"name\": \"John Doe\",\n\"email\": \"john@example.com\",\n\"age\": 30,\n\"created_at\": \"2023-01-01T00:00:00Z\",\n\"updated_at\": \"2023-01-01T00:00:00Z\"\n},\n\"links\": {\n\"self\": \"/api/users/123\"\n}\n}\n}\n\n// Error response format\n{\n\"errors\": [\n{\n\"id\": \"validation-error\",\n\"status\": \"422\",\n\"code\": \"validation_failed\",\n\"title\": \"Validation Error\",\n\"detail\": \"Email is required\",\n\"source\": {\n\"pointer\": \"/data/attributes/email\"\n}\n}\n]\n}",
      "isComplete": false,
      "isActive": true,
      "options": [],
      "title": "RESTful API Design",
      "correctAnswer": null,
      "topics": [
        "REST APIs",
        "GraphQL",
        "Authentication",
        "Rate Limiting"
      ],
      "codeBlock": "// Resource-based URLs\nGET    /api/users           // Get all users\nGET    /api/users/123       // Get user by ID\nPOST   /api/users           // Create new user\nPUT    /api/users/123       // Update entire user\nPATCH  /api/users/123       // Partial update\nDELETE /api/users/123       // Delete user\n\n// Nested resources\nGET    /api/users/123/orders        // Get user's orders\nPOST   /api/users/123/orders        // Create order for user\nGET    /api/users/123/orders/456    // Get specific order\n\n// Query parameters for filtering\nGET    /api/users?page=1&limit=10&sort=name&order=asc\nGET    /api/users?status=active&role=admin\nGET    /api/users?search=john&fields=name,email",
      "difficulty": "intermediate",
      "source": "QuestionsBank",
      "learningPaths": [
        "api-design"
      ],
      "importedAt": "2025-09-30T00:19:47.277Z"
    },
    {
      "id": "imported-api-design-1759191587278-7",
      "updatedAt": "2025-09-30T00:19:47.305Z",
      "category": "API Design",
      "type": "code",
      "title": "Streaming Data Handling",
      "isActive": true,
      "codeBlock": "// ❌ Inefficient polling approach\nconst pollForUpdates = async conversationId => {\n  const pollInterval = setInterval(async () => {\n    try {\n      const response = await fetch(\n        `/api/conversations/${conversationId}/status`\n      );\n      const data = await response.json();\n\n      if (data.hasNewData) {\n        const newData = await fetch(\n          `/api/conversations/${conversationId}/latest`\n        );\n        updateUI(await newData.json());\n      }\n    } catch (error) {\n      console.error('Polling error:', error);\n    }\n  }, 1000); // Poll every second\n\n  return () => clearInterval(pollInterval);\n};\n\n// Problems with polling:\nconst pollingProblems = {\n  inefficiency: 'Unnecessary requests when no updates',\n  latency: 'Up to 1 second delay for updates',\n  serverLoad: 'High number of requests',\n  batteryDrain: 'Continuous network activity on mobile',\n};",
      "options": [],
      "correctAnswer": null,
      "learningPaths": [
        "api-design"
      ],
      "createdAt": "2025-09-30T00:19:47.305Z",
      "source": "QuestionsBank",
      "importedAt": "2025-09-30T00:19:47.278Z",
      "explanation": "There are three common approaches:\n\n**Polling**: The client repeatedly asks the server for updates (e.g., every second). This is inefficient and doesn't scale well due to the high number of unnecessary requests, especially with billions of users.\n\n**WebSockets**: Provides a full-duplex (two-way) communication channel. While powerful, it has more overhead and complexity than needed for a one-way stream from server to client.\n\n**Server-Sent Events (SSE)**: A native browser API that allows the server to push text-based events to the client over a single, long-lived HTTP connection. This is the most scalable and efficient choice for this use case, as it's lightweight, simple to implement, and designed specifically for one-way streaming from server to client.\n\n**Comparison of Approaches:**\n\n**1. Polling:**\n\n// ❌ Inefficient polling approach\nconst pollForUpdates = async conversationId => {\nconst pollInterval = setInterval(async () => {\ntry {\nconst response = await fetch(\n`/api/conversations/${conversationId}/status`\n);\nconst data = await response.json();\n\nif (data.hasNewData) {\nconst newData = await fetch(\n`/api/conversations/${conversationId}/latest`\n);\nupdateUI(await newData.json());\n}\n} catch (error) {\nconsole.error('Polling error:', error);\n}\n}, 1000); // Poll every second\n\nreturn () => clearInterval(pollInterval);\n};\n\n// Problems with polling:\nconst pollingProblems = {\ninefficiency: 'Unnecessary requests when no updates',\nlatency: 'Up to 1 second delay for updates',\nserverLoad: 'High number of requests',\nbatteryDrain: 'Continuous network activity on mobile',\n};\n\n**2. WebSockets:**\n\n// WebSocket implementation\nconst useWebSocket = url => {\nconst [socket, setSocket] = useState(null);\nconst [isConnected, setIsConnected] = useState(false);\n\nuseEffect(() => {\nconst ws = new WebSocket(url);\n\nws.onopen = () => {\nsetIsConnected(true);\nsetSocket(ws);\n};\n\nws.onmessage = event => {\nconst data = JSON.parse(event.data);\nhandleStreamData(data);\n};\n\nws.onclose = () => {\nsetIsConnected(false);\nsetSocket(null);\n};\n\nws.onerror = error => {\nconsole.error('WebSocket error:', error);\n};\n\nreturn () => {\nws.close();\n};\n}, [url]);\n\nreturn { socket, isConnected };\n};\n\n// WebSocket pros and cons\nconst webSocketAnalysis = {\npros: [\n'Full-duplex communication',\n'Low latency',\n'Efficient for real-time apps',\n],\ncons: [\n'Complex connection management',\n'Firewall/proxy issues',\n'Overkill for one-way streaming',\n'Higher resource usage',\n],\n};\n\n**3. Server-Sent Events (SSE) - Recommended:**\n\n// ✅ Optimal SSE implementation\nconst useServerSentEvents = url => {\nconst [eventSource, setEventSource] = useState(null);\nconst [isConnected, setIsConnected] = useState(false);\n\nuseEffect(() => {\nconst es = new EventSource(url);\n\nes.onopen = () => {\nsetIsConnected(true);\nsetEventSource(es);\n};\n\nes.onmessage = event => {\ntry {\nconst data = JSON.parse(event.data);\nhandleStreamChunk(data);\n} catch (error) {\nconsole.error('Error parsing SSE data:', error);\n}\n};\n\nes.onerror = error => {\nconsole.error('SSE error:', error);\nsetIsConnected(false);\n};\n\nreturn () => {\nes.close();\n};\n}, [url]);\n\nreturn { eventSource, isConnected };\n};\n\n// SSE benefits\nconst sseBenefits = {\nefficiency: 'Single HTTP connection',\nsimplicity: 'Native browser API',\nreliability: 'Automatic reconnection',\nscalability: 'Low server overhead',\ncompatibility: 'Works through firewalls/proxies',\n};\n\n**Complete Chat Implementation:**\n\n// Chat component with SSE\nconst ChatComponent = ({ conversationId }) => {\nconst [messages, setMessages] = useState([]);\nconst [currentMessage, setCurrentMessage] = useState('');\nconst [isStreaming, setIsStreaming] = useState(false);\n\n// SSE for receiving AI responses\nuseEffect(() => {\nconst eventSource = new EventSource(\n`/api/conversations/${conversationId}/stream`\n);\n\neventSource.onmessage = event => {\nconst data = JSON.parse(event.data);\n\nif (data.type === 'chunk') {\nsetMessages(prev => appendChunkToLastMessage(prev, data.content));\n} else if (data.type === 'complete') {\nsetIsStreaming(false);\n}\n};\n\nreturn () => eventSource.close();\n}, [conversationId]);\n\nconst sendMessage = async () => {\nif (!currentMessage.trim()) return;\n\n// Add user message\nconst userMessage = {\nid: Date.now(),\ntype: 'user',\ncontent: currentMessage,\ntimestamp: new Date(),\n};\n\nsetMessages(prev => [...prev, userMessage]);\nsetCurrentMessage('');\nsetIsStreaming(true);\n\n// Send to server\ntry {\nawait fetch(`/api/conversations/${conversationId}/messages`, {\nmethod: 'POST',\nheaders: { 'Content-Type': 'application/json' },\nbody: JSON.stringify({ content: userMessage.content }),\n});\n} catch (error) {\nconsole.error('Failed to send message:', error);\nsetIsStreaming(false);\n}\n};\n\nreturn (\n<div className=\"chat-container\">\n<div className=\"messages\">\n{messages.map(message => (\n<MessageComponent key={message.id} message={message} />\n))}\n{isStreaming && <TypingIndicator />}\n</div>\n<div className=\"input-area\">\n<input\nvalue={currentMessage}\nonChange={e => setCurrentMessage(e.target.value)}\nonKeyPress={e => e.key === 'Enter' && sendMessage()}\ndisabled={isStreaming}\n/>\n<button onClick={sendMessage} disabled={isStreaming}>\nSend\n</button>\n</div>\n</div>\n);\n};",
      "isComplete": false,
      "topics": [
        "REST APIs",
        "GraphQL",
        "Authentication",
        "Rate Limiting"
      ],
      "content": "The answer from the LLM is streamed. What are the different ways to handle this on the frontend, and which one is most scalable?",
      "difficulty": "intermediate"
    },
    {
      "id": "imported-api-design-1759191587278-4",
      "source": "QuestionsBank",
      "correctAnswer": null,
      "type": "code",
      "content": "Explain API documentation best practices and tools.",
      "difficulty": "intermediate",
      "topics": [
        "REST APIs",
        "GraphQL",
        "Authentication",
        "Rate Limiting"
      ],
      "updatedAt": "2025-09-30T00:19:47.305Z",
      "importedAt": "2025-09-30T00:19:47.278Z",
      "explanation": "**1. OpenAPI/Swagger Specification:**\n\n# openapi.yaml\nopenapi: 3.0.0\ninfo:\ntitle: User API\nversion: 1.0.0\ndescription: API for managing users\nservers:\n- url: https://api.example.com/v1\ndescription: Production server\n- url: https://staging-api.example.com/v1\ndescription: Staging server\n\npaths:\n/users:\nget:\nsummary: Get all users\nparameters:\n- name: page\nin: query\nschema:\ntype: integer\ndefault: 1\n- name: limit\nin: query\nschema:\ntype: integer\ndefault: 10\nresponses:\n'200':\ndescription: List of users\ncontent:\napplication/json:\nschema:\ntype: object\nproperties:\ndata:\ntype: array\nitems:\n$ref: '#/components/schemas/User'\nmeta:\n$ref: '#/components/schemas/PaginationMeta'\npost:\nsummary: Create a new user\nrequestBody:\nrequired: true\ncontent:\napplication/json:\nschema:\n$ref: '#/components/schemas/CreateUserRequest'\nresponses:\n'201':\ndescription: User created\ncontent:\napplication/json:\nschema:\n$ref: '#/components/schemas/User'\n'400':\ndescription: Bad request\ncontent:\napplication/json:\nschema:\n$ref: '#/components/schemas/Error'\n\n/users/{id}:\nget:\nsummary: Get user by ID\nparameters:\n- name: id\nin: path\nrequired: true\nschema:\ntype: string\nresponses:\n'200':\ndescription: User found\ncontent:\napplication/json:\nschema:\n$ref: '#/components/schemas/User'\n'404':\ndescription: User not found\n\ncomponents:\nschemas:\nUser:\ntype: object\nproperties:\nid:\ntype: string\nname:\ntype: string\nemail:\ntype: string\nformat: email\ncreated_at:\ntype: string\nformat: date-time\nCreateUserRequest:\ntype: object\nrequired:\n- name\n- email\nproperties:\nname:\ntype: string\nemail:\ntype: string\nformat: email\nError:\ntype: object\nproperties:\nerror:\ntype: string\nmessage:\ntype: string\nPaginationMeta:\ntype: object\nproperties:\npage:\ntype: integer\nlimit:\ntype: integer\ntotal:\ntype: integer\npages:\ntype: integer\n\nsecuritySchemes:\nbearerAuth:\ntype: http\nscheme: bearer\nbearerFormat: JWT\n\n**2. API Documentation Generation:**\n\n// Using swagger-jsdoc\nconst swaggerJSDoc = require('swagger-jsdoc');\n\nconst options = {\ndefinition: {\nopenapi: '3.0.0',\ninfo: {\ntitle: 'User API',\nversion: '1.0.0',\ndescription: 'API for managing users',\n},\n},\napis: ['./routes/*.js'], // Path to the API docs\n};\n\nconst specs = swaggerJSDoc(options);\n\n// Using swagger-ui-express\nconst swaggerUi = require('swagger-ui-express');\napp.use('/api-docs', swaggerUi.serve, swaggerUi.setup(specs));\n\n// JSDoc comments for API documentation\n/**\n* @swagger\n* /users:\n*   get:\n*     summary: Get all users\n*     tags: [Users]\n*     parameters:\n*       - in: query\n*         name: page\n*         schema:\n*           type: integer\n*           default: 1\n*         description: Page number\n*     responses:\n*       200:\n*         description: List of users\n*         content:\n*           application/json:\n*             schema:\n*               type: array\n*               items:\n*                 $ref: '#/components/schemas/User'\n*/\napp.get('/users', async (req, res) => {\n// Implementation\n});\n\n**3. API Testing Documentation:**\n\n// Using supertest for API testing\nconst request = require('supertest');\nconst app = require('../app');\n\ndescribe('User API', () => {\ndescribe('GET /api/users', () => {\nit('should return list of users', async () => {\nconst response = await request(app).get('/api/users').expect(200);\n\nexpect(response.body).toHaveProperty('data');\nexpect(Array.isArray(response.body.data)).toBe(true);\n});\n\nit('should support pagination', async () => {\nconst response = await request(app)\n.get('/api/users?page=1&limit=5')\n.expect(200);\n\nexpect(response.body.data.length).toBeLessThanOrEqual(5);\nexpect(response.body).toHaveProperty('meta');\n});\n});\n\ndescribe('POST /api/users', () => {\nit('should create a new user', async () => {\nconst userData = {\nname: 'John Doe',\nemail: 'john@example.com',\n};\n\nconst response = await request(app)\n.post('/api/users')\n.send(userData)\n.expect(201);\n\nexpect(response.body).toHaveProperty('id');\nexpect(response.body.name).toBe(userData.name);\nexpect(response.body.email).toBe(userData.email);\n});\n\nit('should validate required fields', async () => {\nconst response = await request(app)\n.post('/api/users')\n.send({})\n.expect(400);\n\nexpect(response.body).toHaveProperty('error');\n});\n});\n});",
      "category": "API Design",
      "isComplete": false,
      "createdAt": "2025-09-30T00:19:47.305Z",
      "learningPaths": [
        "api-design"
      ],
      "options": [],
      "title": "API Documentation",
      "isActive": true,
      "codeBlock": "# openapi.yaml\nopenapi: 3.0.0\ninfo:\n  title: User API\n  version: 1.0.0\n  description: API for managing users\nservers:\n  - url: https://api.example.com/v1\n    description: Production server\n  - url: https://staging-api.example.com/v1\n    description: Staging server\n\npaths:\n  /users:\n    get:\n      summary: Get all users\n      parameters:\n        - name: page\n          in: query\n          schema:\n            type: integer\n            default: 1\n        - name: limit\n          in: query\n          schema:\n            type: integer\n            default: 10\n      responses:\n        '200':\n          description: List of users\n          content:\n            application/json:\n              schema:\n                type: object\n                properties:\n                  data:\n                    type: array\n                    items:\n                      $ref: '#/components/schemas/User'\n                  meta:\n                    $ref: '#/components/schemas/PaginationMeta'\n    post:\n      summary: Create a new user\n      requestBody:\n        required: true\n        content:\n          application/json:\n            schema:\n              $ref: '#/components/schemas/CreateUserRequest'\n      responses:\n        '201':\n          description: User created\n          content:\n            application/json:\n              schema:\n                $ref: '#/components/schemas/User'\n        '400':\n          description: Bad request\n          content:\n            application/json:\n              schema:\n                $ref: '#/components/schemas/Error'\n\n  /users/{id}:\n    get:\n      summary: Get user by ID\n      parameters:\n        - name: id\n          in: path\n          required: true\n          schema:\n            type: string\n      responses:\n        '200':\n          description: User found\n          content:\n            application/json:\n              schema:\n                $ref: '#/components/schemas/User'\n        '404':\n          description: User not found\n\ncomponents:\n  schemas:\n    User:\n      type: object\n      properties:\n        id:\n          type: string\n        name:\n          type: string\n        email:\n          type: string\n          format: email\n        created_at:\n          type: string\n          format: date-time\n    CreateUserRequest:\n      type: object\n      required:\n        - name\n        - email\n      properties:\n        name:\n          type: string\n        email:\n          type: string\n          format: email\n    Error:\n      type: object\n      properties:\n        error:\n          type: string\n        message:\n          type: string\n    PaginationMeta:\n      type: object\n      properties:\n        page:\n          type: integer\n        limit:\n          type: integer\n        total:\n          type: integer\n        pages:\n          type: integer\n\n  securitySchemes:\n    bearerAuth:\n      type: http\n      scheme: bearer\n      bearerFormat: JWT"
    },
    {
      "id": "imported-api-design-1759191587278-5",
      "createdAt": "2025-09-30T00:19:47.305Z",
      "title": "API Error Handling",
      "isComplete": false,
      "category": "API Design",
      "importedAt": "2025-09-30T00:19:47.278Z",
      "type": "code",
      "correctAnswer": null,
      "difficulty": "intermediate",
      "codeBlock": "class APIError extends Error {\n  constructor(message, statusCode, code, details = null) {\n    super(message);\n    this.statusCode = statusCode;\n    this.code = code;\n    this.details = details;\n    this.timestamp = new Date().toISOString();\n  }\n\n  toJSON() {\n    return {\n      error: {\n        message: this.message,\n        code: this.code,\n        status: this.statusCode,\n        timestamp: this.timestamp,\n        details: this.details,\n      },\n    };\n  }\n}\n\n// Specific error types\nclass ValidationError extends APIError {\n  constructor(message, details) {\n    super(message, 400, 'VALIDATION_ERROR', details);\n  }\n}\n\nclass NotFoundError extends APIError {\n  constructor(resource, id) {\n    super(`${resource} with id ${id} not found`, 404, 'NOT_FOUND');\n  }\n}\n\nclass UnauthorizedError extends APIError {\n  constructor(message = 'Unauthorized') {\n    super(message, 401, 'UNAUTHORIZED');\n  }\n}\n\nclass ForbiddenError extends APIError {\n  constructor(message = 'Forbidden') {\n    super(message, 403, 'FORBIDDEN');\n  }\n}",
      "explanation": "**1. Error Response Format:**\n\nclass APIError extends Error {\nconstructor(message, statusCode, code, details = null) {\nsuper(message);\nthis.statusCode = statusCode;\nthis.code = code;\nthis.details = details;\nthis.timestamp = new Date().toISOString();\n}\n\ntoJSON() {\nreturn {\nerror: {\nmessage: this.message,\ncode: this.code,\nstatus: this.statusCode,\ntimestamp: this.timestamp,\ndetails: this.details,\n},\n};\n}\n}\n\n// Specific error types\nclass ValidationError extends APIError {\nconstructor(message, details) {\nsuper(message, 400, 'VALIDATION_ERROR', details);\n}\n}\n\nclass NotFoundError extends APIError {\nconstructor(resource, id) {\nsuper(`${resource} with id ${id} not found`, 404, 'NOT_FOUND');\n}\n}\n\nclass UnauthorizedError extends APIError {\nconstructor(message = 'Unauthorized') {\nsuper(message, 401, 'UNAUTHORIZED');\n}\n}\n\nclass ForbiddenError extends APIError {\nconstructor(message = 'Forbidden') {\nsuper(message, 403, 'FORBIDDEN');\n}\n}\n\n**2. Error Handling Middleware:**\n\nclass ErrorHandler {\nstatic handle(err, req, res, next) {\n// Log error\nconsole.error('API Error:', {\nmessage: err.message,\nstack: err.stack,\nurl: req.url,\nmethod: req.method,\nip: req.ip,\nuserAgent: req.get('User-Agent'),\n});\n\n// Handle different error types\nif (err instanceof APIError) {\nreturn res.status(err.statusCode).json(err.toJSON());\n}\n\nif (err.name === 'ValidationError') {\nreturn res.status(400).json({\nerror: {\nmessage: 'Validation failed',\ncode: 'VALIDATION_ERROR',\nstatus: 400,\ndetails: err.details,\n},\n});\n}\n\nif (err.name === 'CastError') {\nreturn res.status(400).json({\nerror: {\nmessage: 'Invalid ID format',\ncode: 'INVALID_ID',\nstatus: 400,\n},\n});\n}\n\nif (err.name === 'MongoError' && err.code === 11000) {\nreturn res.status(409).json({\nerror: {\nmessage: 'Duplicate entry',\ncode: 'DUPLICATE_ENTRY',\nstatus: 409,\n},\n});\n}\n\n// Default error\nres.status(500).json({\nerror: {\nmessage: 'Internal server error',\ncode: 'INTERNAL_ERROR',\nstatus: 500,\n},\n});\n}\n\nstatic notFound(req, res, next) {\nconst error = new APIError(\n`Route ${req.originalUrl} not found`,\n404,\n'ROUTE_NOT_FOUND'\n);\nnext(error);\n}\n\nstatic asyncHandler(fn) {\nreturn (req, res, next) => {\nPromise.resolve(fn(req, res, next)).catch(next);\n};\n}\n}\n\n// Usage\napp.use(ErrorHandler.notFound);\napp.use(ErrorHandler.handle);\n\n**3. Validation Error Handling:**\n\nconst Joi = require('joi');\n\nclass ValidationMiddleware {\nstatic validate(schema) {\nreturn (req, res, next) => {\nconst { error, value } = schema.validate(req.body, {\nabortEarly: false,\nstripUnknown: true,\n});\n\nif (error) {\nconst details = error.details.map(detail => ({\nfield: detail.path.join('.'),\nmessage: detail.message,\nvalue: detail.context.value,\n}));\n\nconst validationError = new ValidationError(\n'Validation failed',\ndetails\n);\nreturn next(validationError);\n}\n\nreq.validatedData = value;\nnext();\n};\n}\n}\n\n// Usage\nconst userSchema = Joi.object({\nname: Joi.string().min(2).max(50).required(),\nemail: Joi.string().email().required(),\nage: Joi.number().integer().min(0).max(120).optional(),\n});\n\napp.post(\n'/api/users',\nValidationMiddleware.validate(userSchema),\nasync (req, res, next) => {\ntry {\nconst user = await User.create(req.validatedData);\nres.status(201).json(user);\n} catch (error) {\nnext(error);\n}\n}\n);\n\n**4. Error Monitoring:**\n\nclass ErrorMonitor {\nconstructor() {\nthis.errors = [];\nthis.maxErrors = 1000;\n}\n\nlogError(error, context = {}) {\nconst errorLog = {\nid: crypto.randomUUID(),\nmessage: error.message,\nstack: error.stack,\ntimestamp: new Date().toISOString(),\ncontext,\n};\n\nthis.errors.push(errorLog);\n\n// Keep only recent errors\nif (this.errors.length > this.maxErrors) {\nthis.errors = this.errors.slice(-this.maxErrors);\n}\n\n// Send to external monitoring service\nthis.sendToMonitoringService(errorLog);\n}\n\nasync sendToMonitoringService(errorLog) {\ntry {\nawait fetch('https://monitoring-service.com/api/errors', {\nmethod: 'POST',\nheaders: {\n'Content-Type': 'application/json',\nAuthorization: `Bearer ${process.env.MONITORING_API_KEY}`,\n},\nbody: JSON.stringify(errorLog),\n});\n} catch (error) {\nconsole.error('Failed to send error to monitoring service:', error);\n}\n}\n\ngetErrors(limit = 100) {\nreturn this.errors.slice(-limit);\n}\n\ngetErrorStats() {\nconst now = Date.now();\nconst oneHour = 60 * 60 * 1000;\nconst oneDay = 24 * oneHour;\n\nconst lastHour = this.errors.filter(\ne => new Date(e.timestamp).getTime() > now - oneHour\n);\n\nconst lastDay = this.errors.filter(\ne => new Date(e.timestamp).getTime() > now - oneDay\n);\n\nreturn {\ntotal: this.errors.length,\nlastHour: lastHour.length,\nlastDay: lastDay.length,\nbyType: this.getErrorsByType(),\n};\n}\n\ngetErrorsByType() {\nconst types = {};\nthis.errors.forEach(error => {\nconst type = error.message.split(':')[0];\ntypes[type] = (types[type] || 0) + 1;\n});\nreturn types;\n}\n}\n\n// Usage\nconst errorMonitor = new ErrorMonitor();\n\napp.use((err, req, res, next) => {\nerrorMonitor.logError(err, {\nurl: req.url,\nmethod: req.method,\nip: req.ip,\nuserAgent: req.get('User-Agent'),\n});\n\nnext(err);\n});",
      "options": [],
      "updatedAt": "2025-09-30T00:19:47.305Z",
      "learningPaths": [
        "api-design"
      ],
      "source": "QuestionsBank",
      "content": "Explain API error handling strategies and best practices.",
      "topics": [
        "REST APIs",
        "GraphQL",
        "Authentication",
        "Rate Limiting"
      ],
      "isActive": true
    },
    {
      "id": "imported-api-design-1759191587278-3",
      "source": "QuestionsBank",
      "options": [],
      "isActive": true,
      "difficulty": "intermediate",
      "topics": [
        "REST APIs",
        "GraphQL",
        "Authentication",
        "Rate Limiting"
      ],
      "explanation": "**1. Token Bucket Algorithm:**\n\nclass TokenBucket {\nconstructor(capacity, refillRate) {\nthis.capacity = capacity;\nthis.refillRate = refillRate;\nthis.tokens = capacity;\nthis.lastRefill = Date.now();\n}\n\nrefill() {\nconst now = Date.now();\nconst timePassed = now - this.lastRefill;\nconst tokensToAdd = (timePassed / 1000) * this.refillRate;\n\nthis.tokens = Math.min(this.capacity, this.tokens + tokensToAdd);\nthis.lastRefill = now;\n}\n\nconsume(tokens = 1) {\nthis.refill();\n\nif (this.tokens >= tokens) {\nthis.tokens -= tokens;\nreturn true;\n}\n\nreturn false;\n}\n\ngetTokensRemaining() {\nthis.refill();\nreturn this.tokens;\n}\n}\n\nclass RateLimiter {\nconstructor() {\nthis.buckets = new Map();\n}\n\ngetBucket(key, capacity, refillRate) {\nif (!this.buckets.has(key)) {\nthis.buckets.set(key, new TokenBucket(capacity, refillRate));\n}\nreturn this.buckets.get(key);\n}\n\nisAllowed(key, capacity, refillRate, tokens = 1) {\nconst bucket = this.getBucket(key, capacity, refillRate);\nreturn bucket.consume(tokens);\n}\n}\n\n**2. Sliding Window Rate Limiting:**\n\nclass SlidingWindowRateLimiter {\nconstructor() {\nthis.windows = new Map();\n}\n\nisAllowed(key, limit, windowSize) {\nconst now = Date.now();\nconst windowStart = now - windowSize;\n\nif (!this.windows.has(key)) {\nthis.windows.set(key, []);\n}\n\nconst requests = this.windows.get(key);\n\n// Remove old requests\nconst validRequests = requests.filter(timestamp => timestamp > windowStart);\n\nif (validRequests.length >= limit) {\nreturn false;\n}\n\n// Add current request\nvalidRequests.push(now);\nthis.windows.set(key, validRequests);\n\nreturn true;\n}\n\ngetRemainingRequests(key, limit, windowSize) {\nconst now = Date.now();\nconst windowStart = now - windowSize;\n\nif (!this.windows.has(key)) {\nreturn limit;\n}\n\nconst requests = this.windows.get(key);\nconst validRequests = requests.filter(timestamp => timestamp > windowStart);\n\nreturn Math.max(0, limit - validRequests.length);\n}\n}\n\n**3. Rate Limiting Middleware:**\n\nclass RateLimitMiddleware {\nconstructor() {\nthis.limiters = new Map();\n}\n\n// Global rate limiting\nglobal(limit, windowSize) {\nreturn (req, res, next) => {\nconst key = 'global';\nconst limiter = this.getLimiter(key, limit, windowSize);\n\nif (!limiter.isAllowed(key, limit, windowSize)) {\nreturn res.status(429).json({\nerror: 'Rate limit exceeded',\nretryAfter: windowSize / 1000,\n});\n}\n\nnext();\n};\n}\n\n// Per-IP rate limiting\nperIP(limit, windowSize) {\nreturn (req, res, next) => {\nconst key = `ip:${req.ip}`;\nconst limiter = this.getLimiter(key, limit, windowSize);\n\nif (!limiter.isAllowed(key, limit, windowSize)) {\nreturn res.status(429).json({\nerror: 'Rate limit exceeded',\nretryAfter: windowSize / 1000,\n});\n}\n\nnext();\n};\n}\n\n// Per-user rate limiting\nperUser(limit, windowSize) {\nreturn (req, res, next) => {\nif (!req.user) {\nreturn next();\n}\n\nconst key = `user:${req.user.id}`;\nconst limiter = this.getLimiter(key, limit, windowSize);\n\nif (!limiter.isAllowed(key, limit, windowSize)) {\nreturn res.status(429).json({\nerror: 'Rate limit exceeded',\nretryAfter: windowSize / 1000,\n});\n}\n\nnext();\n};\n}\n\ngetLimiter(key, limit, windowSize) {\nif (!this.limiters.has(key)) {\nthis.limiters.set(key, new SlidingWindowRateLimiter());\n}\nreturn this.limiters.get(key);\n}\n}\n\n// Usage\nconst rateLimit = new RateLimitMiddleware();\n\n// Global rate limiting: 100 requests per minute\napp.use(rateLimit.global(100, 60000));\n\n// Per-IP rate limiting: 10 requests per minute\napp.use('/api/auth', rateLimit.perIP(10, 60000));\n\n// Per-user rate limiting: 1000 requests per hour\napp.use('/api/users', rateLimit.perUser(1000, 3600000));",
      "content": "Explain API rate limiting strategies and implementation.",
      "updatedAt": "2025-09-30T00:19:47.305Z",
      "learningPaths": [
        "api-design"
      ],
      "createdAt": "2025-09-30T00:19:47.305Z",
      "correctAnswer": null,
      "codeBlock": "class TokenBucket {\n  constructor(capacity, refillRate) {\n    this.capacity = capacity;\n    this.refillRate = refillRate;\n    this.tokens = capacity;\n    this.lastRefill = Date.now();\n  }\n\n  refill() {\n    const now = Date.now();\n    const timePassed = now - this.lastRefill;\n    const tokensToAdd = (timePassed / 1000) * this.refillRate;\n\n    this.tokens = Math.min(this.capacity, this.tokens + tokensToAdd);\n    this.lastRefill = now;\n  }\n\n  consume(tokens = 1) {\n    this.refill();\n\n    if (this.tokens >= tokens) {\n      this.tokens -= tokens;\n      return true;\n    }\n\n    return false;\n  }\n\n  getTokensRemaining() {\n    this.refill();\n    return this.tokens;\n  }\n}\n\nclass RateLimiter {\n  constructor() {\n    this.buckets = new Map();\n  }\n\n  getBucket(key, capacity, refillRate) {\n    if (!this.buckets.has(key)) {\n      this.buckets.set(key, new TokenBucket(capacity, refillRate));\n    }\n    return this.buckets.get(key);\n  }\n\n  isAllowed(key, capacity, refillRate, tokens = 1) {\n    const bucket = this.getBucket(key, capacity, refillRate);\n    return bucket.consume(tokens);\n  }\n}",
      "type": "code",
      "category": "API Design",
      "title": "API Rate Limiting",
      "importedAt": "2025-09-30T00:19:47.278Z",
      "isComplete": false
    },
    {
      "id": "imported-api-design-1759191587278-6",
      "source": "QuestionsBank",
      "difficulty": "intermediate",
      "explanation": "In RESTful design, HTTP verbs define the action. A GET request is for retrieving (reading) data, while a POST request is for creating a new resource. Sending a user's message is a \"create\" action, as it creates a new entry in the conversation on the server, making POST the semantically correct choice.\n\n**HTTP Method Semantics:**\n\n// ❌ Wrong - GET for sending data\nGET /api/chat?message=hello&conversationId=123\n// Problems:\n// - Message appears in URL (security risk)\n// - URL length limitations\n// - Cached by browsers/proxies\n// - Not semantically correct\n\n// ✅ Correct - POST for creating resources\nPOST /api/chat\nContent-Type: application/json\n\n{\n\"message\": \"Hello, how are you?\",\n\"conversationId\": \"123\",\n\"userId\": \"user-456\"\n}\n\n**RESTful Design Principles:**\n\n// Resource-based design\nconst chatAPI = {\n// Create new message\nsendMessage: {\nmethod: 'POST',\nurl: '/api/conversations/:id/messages',\nbody: { content: 'Hello' },\n},\n\n// Retrieve conversation history\ngetMessages: {\nmethod: 'GET',\nurl: '/api/conversations/:id/messages?page=1&limit=50',\n},\n\n// Update message (edit)\nupdateMessage: {\nmethod: 'PUT',\nurl: '/api/conversations/:id/messages/:messageId',\nbody: { content: 'Updated message' },\n},\n\n// Delete message\ndeleteMessage: {\nmethod: 'DELETE',\nurl: '/api/conversations/:id/messages/:messageId',\n},\n};\n\n**Security Considerations:**\n\n// GET request issues\nconst getRequestIssues = {\nurlExposure: 'Sensitive data in URL logs',\nbrowserHistory: 'Messages stored in browser history',\nreferrerLeakage: 'URLs sent to external sites',\ncaching: 'Messages cached by proxies/CDNs',\n};\n\n// POST request benefits\nconst postRequestBenefits = {\nbodyEncryption: 'Data encrypted in request body',\nnoLogging: 'Sensitive data not in access logs',\nsizeLimit: 'No URL length restrictions',\nsemanticCorrectness: 'Proper HTTP method usage',\n};\n\n**Implementation Example:**\n\n// Frontend implementation\nconst sendMessage = async (message, conversationId) => {\ntry {\nconst response = await fetch(\n`/api/conversations/${conversationId}/messages`,\n{\nmethod: 'POST',\nheaders: {\n'Content-Type': 'application/json',\nAuthorization: `Bearer ${token}`,\n},\nbody: JSON.stringify({\ncontent: message,\ntimestamp: new Date().toISOString(),\n}),\n}\n);\n\nif (!response.ok) {\nthrow new Error(`HTTP error! status: ${response.status}`);\n}\n\nreturn await response.json();\n} catch (error) {\nconsole.error('Failed to send message:', error);\nthrow error;\n}\n};\n\n// Backend implementation\napp.post(\n'/api/conversations/:id/messages',\nauthenticateUser,\nasync (req, res) => {\ntry {\nconst { content } = req.body;\nconst { id: conversationId } = req.params;\nconst userId = req.user.id;\n\n// Validate input\nif (!content || content.trim().length === 0) {\nreturn res.status(400).json({\nerror: 'Message content is required',\n});\n}\n\n// Create message\nconst message = await Message.create({\ncontent: content.trim(),\nconversationId,\nuserId,\ntimestamp: new Date(),\n});\n\nres.status(201).json(message);\n} catch (error) {\nconsole.error('Error creating message:', error);\nres.status(500).json({\nerror: 'Internal server error',\n});\n}\n}\n);",
      "options": [],
      "createdAt": "2025-09-30T00:19:47.305Z",
      "title": "HTTP Methods for Chat Applications",
      "isActive": true,
      "correctAnswer": null,
      "topics": [
        "REST APIs",
        "GraphQL",
        "Authentication",
        "Rate Limiting"
      ],
      "learningPaths": [
        "api-design"
      ],
      "isComplete": false,
      "category": "API Design",
      "importedAt": "2025-09-30T00:19:47.278Z",
      "codeBlock": "// ❌ Wrong - GET for sending data\nGET /api/chat?message=hello&conversationId=123\n// Problems:\n// - Message appears in URL (security risk)\n// - URL length limitations\n// - Cached by browsers/proxies\n// - Not semantically correct\n\n// ✅ Correct - POST for creating resources\nPOST /api/chat\nContent-Type: application/json\n\n{\n  \"message\": \"Hello, how are you?\",\n  \"conversationId\": \"123\",\n  \"userId\": \"user-456\"\n}",
      "updatedAt": "2025-09-30T00:19:47.305Z",
      "type": "code",
      "content": "Why would you use a POST request instead of a GET when sending the user's query?"
    },
    {
      "id": "imported-api-design-1759191587280-8",
      "topics": [
        "REST APIs",
        "GraphQL",
        "Authentication",
        "Rate Limiting"
      ],
      "type": "code",
      "category": "API Design",
      "title": "Frontend SSE Data Handling",
      "updatedAt": "2025-09-30T00:19:47.305Z",
      "difficulty": "intermediate",
      "source": "QuestionsBank",
      "isActive": true,
      "importedAt": "2025-09-30T00:19:47.280Z",
      "createdAt": "2025-09-30T00:19:47.305Z",
      "correctAnswer": null,
      "isComplete": false,
      "options": [],
      "learningPaths": [
        "api-design"
      ],
      "explanation": "You create a new EventSource object pointing to the server's endpoint. You then attach an event listener (e.g., onmessage). Every time the server sends a new chunk of data, this callback is fired. The frontend then takes that data payload and updates its state (e.g., appends the new chunk to the current AI reply in the conversation array), triggering a re-render of the UI.\n\n**SSE Connection Setup:**\n\n// Basic SSE connection\nconst setupSSEConnection = conversationId => {\nconst eventSource = new EventSource(\n`/api/conversations/${conversationId}/stream`\n);\n\n// Handle incoming messages\neventSource.onmessage = event => {\nconst data = JSON.parse(event.data);\nhandleStreamData(data);\n};\n\n// Handle connection events\neventSource.onopen = () => {\nconsole.log('SSE connection opened');\n};\n\neventSource.onerror = error => {\nconsole.error('SSE connection error:', error);\n};\n\nreturn eventSource;\n};\n\n**Data Processing and State Updates:**\n\n// Handle different types of stream data\nconst handleStreamData = data => {\nswitch (data.type) {\ncase 'chunk':\n// Append chunk to current AI message\nappendChunkToMessage(data.content, data.messageId);\nbreak;\n\ncase 'message_start':\n// Start new AI message\ncreateNewAIMessage(data.messageId);\nbreak;\n\ncase 'message_complete':\n// Mark message as complete\ncompleteAIMessage(data.messageId);\nbreak;\n\ncase 'error':\n// Handle streaming error\nhandleStreamingError(data.error);\nbreak;\n}\n};\n\n// State update functions\nconst appendChunkToMessage = (chunk, messageId) => {\nsetMessages(prevMessages =>\nprevMessages.map(message =>\nmessage.id === messageId\n? { ...message, content: message.content + chunk }\n: message\n)\n);\n};\n\nconst createNewAIMessage = messageId => {\nconst newMessage = {\nid: messageId,\ntype: 'assistant',\ncontent: '',\ntimestamp: new Date(),\nstatus: 'streaming',\n};\n\nsetMessages(prevMessages => [...prevMessages, newMessage]);\n};\n\nconst completeAIMessage = messageId => {\nsetMessages(prevMessages =>\nprevMessages.map(message =>\nmessage.id === messageId ? { ...message, status: 'completed' } : message\n)\n);\n};\n\n**React Hook Implementation:**\n\n// Custom hook for SSE\nconst useSSE = (url, options = {}) => {\nconst [data, setData] = useState(null);\nconst [isConnected, setIsConnected] = useState(false);\nconst [error, setError] = useState(null);\n\nuseEffect(() => {\nif (!url) return;\n\nconst eventSource = new EventSource(url);\n\neventSource.onopen = () => {\nsetIsConnected(true);\nsetError(null);\n};\n\neventSource.onmessage = event => {\ntry {\nconst parsedData = JSON.parse(event.data);\nsetData(parsedData);\n\n// Call custom handler if provided\nif (options.onMessage) {\noptions.onMessage(parsedData);\n}\n} catch (err) {\nconsole.error('Error parsing SSE data:', err);\nsetError(err);\n}\n};\n\neventSource.onerror = err => {\nconsole.error('SSE error:', err);\nsetError(err);\nsetIsConnected(false);\n};\n\nreturn () => {\neventSource.close();\n};\n}, [url, options.onMessage]);\n\nreturn { data, isConnected, error };\n};\n\n// Usage in component\nconst ChatComponent = ({ conversationId }) => {\nconst [messages, setMessages] = useState([]);\n\nconst { isConnected, error } = useSSE(\n`/api/conversations/${conversationId}/stream`,\n{\nonMessage: data => {\nif (data.type === 'chunk') {\nsetMessages(prev =>\nprev.map(msg =>\nmsg.id === data.messageId\n? { ...msg, content: msg.content + data.content }\n: msg\n)\n);\n}\n},\n}\n);\n\nreturn (\n<div>\n<div>Connection: {isConnected ? 'Connected' : 'Disconnected'}</div>\n{error && <div>Error: {error.message}</div>}\n{/* Render messages */}\n</div>\n);\n};\n\n**Error Handling and Reconnection:**\n\n// Robust SSE implementation with reconnection\nconst useRobustSSE = url => {\nconst [eventSource, setEventSource] = useState(null);\nconst [isConnected, setIsConnected] = useState(false);\nconst [reconnectAttempts, setReconnectAttempts] = useState(0);\n\nconst maxReconnectAttempts = 5;\nconst reconnectDelay = 1000; // 1 second\n\nconst connect = useCallback(() => {\nconst es = new EventSource(url);\n\nes.onopen = () => {\nsetIsConnected(true);\nsetReconnectAttempts(0);\n};\n\nes.onmessage = event => {\nconst data = JSON.parse(event.data);\nhandleStreamData(data);\n};\n\nes.onerror = () => {\nsetIsConnected(false);\nes.close();\n\nif (reconnectAttempts < maxReconnectAttempts) {\nsetTimeout(\n() => {\nsetReconnectAttempts(prev => prev + 1);\nconnect();\n},\nreconnectDelay * Math.pow(2, reconnectAttempts)\n); // Exponential backoff\n}\n};\n\nsetEventSource(es);\n}, [url, reconnectAttempts]);\n\nuseEffect(() => {\nconnect();\n\nreturn () => {\nif (eventSource) {\neventSource.close();\n}\n};\n}, [connect]);\n\nreturn { isConnected, reconnectAttempts };\n};\n\n**Performance Optimization:**\n\n// Optimized message updates\nconst useOptimizedMessages = () => {\nconst [messages, setMessages] = useState([]);\n\n// Use useCallback to prevent unnecessary re-renders\nconst appendChunk = useCallback((messageId, chunk) => {\nsetMessages(prev =>\nprev.map(msg =>\nmsg.id === messageId ? { ...msg, content: msg.content + chunk } : msg\n)\n);\n}, []);\n\n// Batch updates for better performance\nconst batchUpdate = useCallback(updates => {\nsetMessages(prev => {\nlet newMessages = [...prev];\n\nupdates.forEach(update => {\nconst index = newMessages.findIndex(msg => msg.id === update.messageId);\nif (index !== -1) {\nnewMessages[index] = {\n...newMessages[index],\n...update.changes,\n};\n}\n});\n\nreturn newMessages;\n});\n}, []);\n\nreturn { messages, appendChunk, batchUpdate };\n};",
      "content": "How does the frontend handle incoming data from an SSE connection?",
      "codeBlock": "// Basic SSE connection\nconst setupSSEConnection = conversationId => {\n  const eventSource = new EventSource(\n    `/api/conversations/${conversationId}/stream`\n  );\n\n  // Handle incoming messages\n  eventSource.onmessage = event => {\n    const data = JSON.parse(event.data);\n    handleStreamData(data);\n  };\n\n  // Handle connection events\n  eventSource.onopen = () => {\n    console.log('SSE connection opened');\n  };\n\n  eventSource.onerror = error => {\n    console.error('SSE connection error:', error);\n  };\n\n  return eventSource;\n};"
    },
    {
      "id": "imported-api-design-1759191587277-1",
      "difficulty": "intermediate",
      "importedAt": "2025-09-30T00:19:47.277Z",
      "explanation": "**1. URL Versioning:**\n\n// URL path versioning\napp.use('/api/v1/users', v1UserRoutes);\napp.use('/api/v2/users', v2UserRoutes);\n\n// Example routes\nGET / api / v1 / users / 123;\nGET / api / v2 / users / 123;\n\n// Pros: Clear, explicit, easy to understand\n// Cons: URL pollution, harder to maintain\n\n**2. Header Versioning:**\n\n// Accept header versioning\napp.use('/api/users', (req, res, next) => {\nconst acceptHeader = req.get('Accept');\nif (acceptHeader.includes('application/vnd.api.v2+json')) {\nreq.apiVersion = 'v2';\n} else if (acceptHeader.includes('application/vnd.api.v1+json')) {\nreq.apiVersion = 'v1';\n} else {\nreq.apiVersion = 'v1'; // default\n}\nnext();\n});\n\n// Example requests\nGET / api / users / 123;\nAccept: application / vnd.api.v2 + json;\n\n// Pros: Clean URLs, flexible\n// Cons: Less discoverable, requires client changes\n\n**3. Query Parameter Versioning:**\n\n// Query parameter versioning\napp.use('/api/users', (req, res, next) => {\nreq.apiVersion = req.query.version || 'v1';\nnext();\n});\n\n// Example requests\nGET /api/users/123?version=v2\nGET /api/users/123?v=2\n\n// Pros: Simple, backward compatible\n// Cons: URL pollution, caching issues\n\n**4. Versioning Implementation:**\n\nclass APIVersionManager {\nconstructor() {\nthis.versions = new Map();\n}\n\nregisterVersion(version, routes) {\nthis.versions.set(version, routes);\n}\n\ngetVersion(version) {\nreturn this.versions.get(version);\n}\n\ngetLatestVersion() {\nconst versions = Array.from(this.versions.keys()).sort();\nreturn versions[versions.length - 1];\n}\n\n// Version compatibility check\nisCompatible(clientVersion, serverVersion) {\nconst client = this.parseVersion(clientVersion);\nconst server = this.parseVersion(serverVersion);\n\n// Major version must match\nreturn client.major === server.major;\n}\n\nparseVersion(version) {\nconst [major, minor, patch] = version\n.replace('v', '')\n.split('.')\n.map(Number);\nreturn { major, minor, patch };\n}\n}\n\n// Usage\nconst versionManager = new APIVersionManager();\nversionManager.registerVersion('v1', v1Routes);\nversionManager.registerVersion('v2', v2Routes);",
      "category": "API Design",
      "isActive": true,
      "isComplete": false,
      "options": [],
      "learningPaths": [
        "api-design"
      ],
      "source": "QuestionsBank",
      "codeBlock": "// URL path versioning\napp.use('/api/v1/users', v1UserRoutes);\napp.use('/api/v2/users', v2UserRoutes);\n\n// Example routes\nGET / api / v1 / users / 123;\nGET / api / v2 / users / 123;\n\n// Pros: Clear, explicit, easy to understand\n// Cons: URL pollution, harder to maintain",
      "title": "API Versioning",
      "type": "code",
      "topics": [
        "REST APIs",
        "GraphQL",
        "Authentication",
        "Rate Limiting"
      ],
      "updatedAt": "2025-09-30T00:19:47.305Z",
      "content": "Explain different API versioning strategies and their trade-offs.",
      "correctAnswer": null,
      "createdAt": "2025-09-30T00:19:47.305Z"
    }
  ]
}