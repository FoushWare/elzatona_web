{
  "category": "React.js (Core)",
  "totalQuestions": 12,
  "exportedAt": "2025-09-30T00:28:57.750Z",
  "questions": [
    {
      "id": "imported-react-mastery-1759191695558-3",
      "difficulty": "intermediate",
      "learningPaths": [
        "react-mastery"
      ],
      "isActive": true,
      "correctAnswer": null,
      "title": "React Performance Optimization",
      "createdAt": "2025-09-30T00:21:35.602Z",
      "source": "QuestionsBank",
      "category": "React.js (Core)",
      "isComplete": false,
      "content": "How do you optimize React application performance?",
      "importedAt": "2025-09-30T00:21:35.558Z",
      "type": "code",
      "explanation": "**1. React.memo - Prevent Unnecessary Re-renders:**\n\nconst ExpensiveComponent = React.memo(({ data, onUpdate }) => {\nconsole.log('ExpensiveComponent rendered');\nreturn (\n<div>\n{data.map(item => (\n<div key={item.id}>{item.name}</div>\n))}\n<button onClick={onUpdate}>Update</button>\n</div>\n);\n});\n\n// Custom comparison function\nconst ExpensiveComponent = React.memo(\n({ data, onUpdate }) => {\n// component logic\n},\n(prevProps, nextProps) => {\n// Return true if props are equal (don't re-render)\nreturn prevProps.data.length === nextProps.data.length;\n}\n);\n\n**2. useMemo - Memoize Expensive Calculations:**\n\nfunction ProductList({ products, filter }) {\nconst filteredProducts = useMemo(() => {\nconsole.log('Filtering products...');\nreturn products.filter(product =>\nproduct.name.toLowerCase().includes(filter.toLowerCase())\n);\n}, [products, filter]);\n\nconst totalPrice = useMemo(() => {\nconsole.log('Calculating total...');\nreturn filteredProducts.reduce((sum, product) => sum + product.price, 0);\n}, [filteredProducts]);\n\nreturn (\n<div>\n<p>Total: ${totalPrice}</p>\n{filteredProducts.map(product => (\n<div key={product.id}>{product.name}</div>\n))}\n</div>\n);\n}\n\n**3. useCallback - Memoize Functions:**\n\nfunction Parent() {\nconst [count, setCount] = useState(0);\nconst [items, setItems] = useState([]);\n\n// Without useCallback - creates new function on every render\nconst handleAddItem = useCallback(item => {\nsetItems(prev => [...prev, item]);\n}, []);\n\n// With useCallback - same function reference\nconst handleRemoveItem = useCallback(id => {\nsetItems(prev => prev.filter(item => item.id !== id));\n}, []);\n\nreturn (\n<div>\n<button onClick={() => setCount(c => c + 1)}>Count: {count}</button>\n<ItemList\nitems={items}\nonAdd={handleAddItem}\nonRemove={handleRemoveItem}\n/>\n</div>\n);\n}\n\nconst ItemList = React.memo(({ items, onAdd, onRemove }) => {\nconsole.log('ItemList rendered');\nreturn (\n<div>\n{items.map(item => (\n<div key={item.id}>\n{item.name}\n<button onClick={() => onRemove(item.id)}>Remove</button>\n</div>\n))}\n</div>\n);\n});\n\n**4. Code Splitting with React.lazy:**\n\nimport React, { Suspense } from 'react';\n\n// Lazy load components\nconst LazyComponent = React.lazy(() => import('./LazyComponent'));\nconst AnotherLazyComponent = React.lazy(() => import('./AnotherLazyComponent'));\n\nfunction App() {\nconst [showLazy, setShowLazy] = useState(false);\n\nreturn (\n<div>\n<button onClick={() => setShowLazy(true)}>Load Lazy Component</button>\n\n{showLazy && (\n<Suspense fallback={<div>Loading...</div>}>\n<LazyComponent />\n</Suspense>\n)}\n</div>\n);\n}\n\n// Route-based code splitting\nconst Home = React.lazy(() => import('./pages/Home'));\nconst About = React.lazy(() => import('./pages/About'));\nconst Contact = React.lazy(() => import('./pages/Contact'));\n\nfunction App() {\nreturn (\n<Router>\n<Suspense fallback={<div>Loading page...</div>}>\n<Routes>\n<Route path=\"/\" element={<Home />} />\n<Route path=\"/about\" element={<About />} />\n<Route path=\"/contact\" element={<Contact />} />\n</Routes>\n</Suspense>\n</Router>\n);\n}\n\n**5. Virtual Scrolling for Large Lists:**\n\nimport { FixedSizeList as List } from 'react-window';\n\nfunction VirtualizedList({ items }) {\nconst Row = ({ index, style }) => (\n<div style={style}>{items[index].name}</div>\n);\n\nreturn (\n<List height={600} itemCount={items.length} itemSize={50}>\n{Row}\n</List>\n);\n}\n\n**6. Debouncing and Throttling:**\n\nfunction SearchInput({ onSearch }) {\nconst [query, setQuery] = useState('');\n\n// Debounced search\nconst debouncedSearch = useMemo(\n() =>\ndebounce(searchQuery => {\nonSearch(searchQuery);\n}, 300),\n[onSearch]\n);\n\nuseEffect(() => {\nif (query) {\ndebouncedSearch(query);\n}\n}, [query, debouncedSearch]);\n\nreturn (\n<input\ntype=\"text\"\nvalue={query}\nonChange={e => setQuery(e.target.value)}\nplaceholder=\"Search...\"\n/>\n);\n}\n\n**7. Bundle Analysis and Optimization:**\n\n// webpack-bundle-analyzer\nnpm install --save-dev webpack-bundle-analyzer\n\n// In webpack.config.js\nconst BundleAnalyzerPlugin = require('webpack-bundle-analyzer').BundleAnalyzerPlugin;\n\nmodule.exports = {\nplugins: [\nnew BundleAnalyzerPlugin()\n]\n};\n\n// Dynamic imports for large libraries\nconst loadChart = () => import('chart.js').then(module => module.default);\n\nfunction ChartComponent() {\nconst [Chart, setChart] = useState(null);\n\nuseEffect(() => {\nloadChart().then(setChart);\n}, []);\n\nif (!Chart) return <div>Loading chart...</div>;\n\nreturn <Chart data={chartData} />;\n}",
      "topics": [
        "React Hooks",
        "State Management",
        "Component Lifecycle",
        "JSX"
      ],
      "codeBlock": "const ExpensiveComponent = React.memo(({ data, onUpdate }) => {\n  console.log('ExpensiveComponent rendered');\n  return (\n    <div>\n      {data.map(item => (\n        <div key={item.id}>{item.name}</div>\n      ))}\n      <button onClick={onUpdate}>Update</button>\n    </div>\n  );\n});\n\n// Custom comparison function\nconst ExpensiveComponent = React.memo(\n  ({ data, onUpdate }) => {\n    // component logic\n  },\n  (prevProps, nextProps) => {\n    // Return true if props are equal (don't re-render)\n    return prevProps.data.length === nextProps.data.length;\n  }\n);",
      "updatedAt": "2025-09-30T00:21:35.602Z",
      "options": []
    },
    {
      "id": "imported-react-mastery-1759191695562-20",
      "type": "code",
      "isComplete": false,
      "createdAt": "2025-09-30T00:21:35.602Z",
      "learningPaths": [
        "react-mastery"
      ],
      "title": "Key Prop Necessity",
      "source": "QuestionsBank",
      "updatedAt": "2025-09-30T00:21:35.602Z",
      "difficulty": "intermediate",
      "explanation": "The key prop helps React identify which items have changed, been added, or been removed. It provides a stable identity for each element, allowing React to efficiently update and re-order the DOM instead of re-rendering the entire list, which is a costly operation. Never use array indexes as keys if the list can be reordered, as this defeats the purpose and can lead to bugs and performance issues.\n\n**Why Keys Are Essential:**\n\n// Without keys - React can't efficiently update\nfunction BadTodoList({ todos }) {\nreturn (\n<ul>\n{todos.map(todo => (\n<TodoItem todo={todo} /> // No key - React treats all as new\n))}\n</ul>\n);\n}\n\n// With keys - React can efficiently update\nfunction GoodTodoList({ todos }) {\nreturn (\n<ul>\n{todos.map(todo => (\n<TodoItem key={todo.id} todo={todo} /> // Stable key\n))}\n</ul>\n);\n}\n\n**Performance Impact:**\n\n// Without proper keys - expensive re-renders\nfunction ExpensiveList({ items }) {\nreturn (\n<div>\n{items.map((item, index) => (\n<ExpensiveComponent\nkey={index} // ❌ Bad: causes unnecessary re-renders\ndata={item}\n/>\n))}\n</div>\n);\n}\n\n// With proper keys - efficient updates\nfunction OptimizedList({ items }) {\nreturn (\n<div>\n{items.map(item => (\n<ExpensiveComponent\nkey={item.id} // ✅ Good: efficient updates\ndata={item}\n/>\n))}\n</div>\n);\n}\n\n**State Preservation:**\n\nfunction TodoItem({ todo }) {\nconst [isEditing, setIsEditing] = useState(false);\n\nreturn (\n<div>\n{isEditing ? (\n<input defaultValue={todo.text} />\n) : (\n<span>{todo.text}</span>\n)}\n<button onClick={() => setIsEditing(!isEditing)}>\n{isEditing ? 'Save' : 'Edit'}\n</button>\n</div>\n);\n}\n\n// With proper keys, editing state is preserved when list reorders\n// With index keys, editing state is lost",
      "content": "Why is the key prop necessary when rendering lists in React?",
      "options": [],
      "correctAnswer": null,
      "isActive": true,
      "codeBlock": "// Without keys - React can't efficiently update\nfunction BadTodoList({ todos }) {\n  return (\n    <ul>\n      {todos.map(todo => (\n        <TodoItem todo={todo} /> // No key - React treats all as new\n      ))}\n    </ul>\n  );\n}\n\n// With keys - React can efficiently update\nfunction GoodTodoList({ todos }) {\n  return (\n    <ul>\n      {todos.map(todo => (\n        <TodoItem key={todo.id} todo={todo} /> // Stable key\n      ))}\n    </ul>\n  );\n}",
      "topics": [
        "React Hooks",
        "State Management",
        "Component Lifecycle",
        "JSX"
      ],
      "category": "React.js (Core)",
      "importedAt": "2025-09-30T00:21:35.562Z"
    },
    {
      "id": "imported-react-mastery-1759191695561-15",
      "importedAt": "2025-09-30T00:21:35.561Z",
      "codeBlock": "// 1. Element type comparison\nfunction reconcileChildren(returnFiber, currentFirstChild, newChildren) {\n  // If element type is the same, update props\n  if (currentFiber.type === newElement.type) {\n    // Reuse existing fiber, just update props\n    return updateElement(currentFiber, newElement);\n  }\n\n  // If element type is different, create new fiber\n  return createFiberFromElement(newElement);\n}\n\n// 2. Key-based reconciliation for lists\nfunction reconcileChildrenArray(returnFiber, currentFirstChild, newChildren) {\n  const resultingFirstChild = null;\n  let previousNewFiber = null;\n\n  // First pass: find matching fibers by key\n  for (let i = 0; i < newChildren.length; i++) {\n    const newChild = newChildren[i];\n    const key = newChild.key;\n\n    // Look for existing fiber with same key\n    const existingFiber = findExistingFiber(currentFirstChild, key);\n\n    if (existingFiber) {\n      // Reuse existing fiber\n      const newFiber = updateElement(existingFiber, newChild);\n      // ... link fibers\n    } else {\n      // Create new fiber\n      const newFiber = createFiberFromElement(newChild);\n      // ... link fibers\n    }\n  }\n\n  return resultingFirstChild;\n}",
      "updatedAt": "2025-09-30T00:21:35.602Z",
      "difficulty": "intermediate",
      "content": "Explain the Reconciliation process and the role of the \"key\" prop.",
      "type": "code",
      "options": [],
      "isComplete": false,
      "source": "QuestionsBank",
      "explanation": "Reconciliation is React's algorithm for diffing one virtual DOM tree against another to determine which parts of the real DOM need to be updated.\n\nThe key prop is crucial for performance and correctness when rendering lists. It helps React identify which items have changed, been added, or been removed.\n\n**Stable Keys**: If keys are stable and unique, React can efficiently re-order elements instead of re-rendering them, minimizing DOM operations.\n\n**Unstable Keys (e.g., array index)**: If an item is removed from the list, the indexes of all following items change. React sees them as new elements, causing unnecessary re-renders and potential state bugs. Never use array indexes as keys if the list can change.\n\n**Reconciliation Process:**\n\n// 1. Element type comparison\nfunction reconcileChildren(returnFiber, currentFirstChild, newChildren) {\n// If element type is the same, update props\nif (currentFiber.type === newElement.type) {\n// Reuse existing fiber, just update props\nreturn updateElement(currentFiber, newElement);\n}\n\n// If element type is different, create new fiber\nreturn createFiberFromElement(newElement);\n}\n\n// 2. Key-based reconciliation for lists\nfunction reconcileChildrenArray(returnFiber, currentFirstChild, newChildren) {\nconst resultingFirstChild = null;\nlet previousNewFiber = null;\n\n// First pass: find matching fibers by key\nfor (let i = 0; i < newChildren.length; i++) {\nconst newChild = newChildren[i];\nconst key = newChild.key;\n\n// Look for existing fiber with same key\nconst existingFiber = findExistingFiber(currentFirstChild, key);\n\nif (existingFiber) {\n// Reuse existing fiber\nconst newFiber = updateElement(existingFiber, newChild);\n// ... link fibers\n} else {\n// Create new fiber\nconst newFiber = createFiberFromElement(newChild);\n// ... link fibers\n}\n}\n\nreturn resultingFirstChild;\n}\n\n**Key Prop Examples:**\n\n**❌ Bad - Using Array Index:**\n\nfunction TodoList({ todos }) {\nreturn (\n<ul>\n{todos.map((todo, index) => (\n<TodoItem\nkey={index} // ❌ Bad: index changes when items are removed\ntodo={todo}\n/>\n))}\n</ul>\n);\n}\n\n// Problem: When first item is removed\n// Before: [0: \"Buy milk\", 1: \"Walk dog\", 2: \"Clean house\"]\n// After:  [0: \"Walk dog\", 1: \"Clean house\"]\n// React thinks \"Walk dog\" is a new item and \"Clean house\" is new too\n\n**✅ Good - Using Stable IDs:**\n\nfunction TodoList({ todos }) {\nreturn (\n<ul>\n{todos.map(todo => (\n<TodoItem\nkey={todo.id} // ✅ Good: stable, unique identifier\ntodo={todo}\n/>\n))}\n</ul>\n);\n}\n\n// When first item is removed, React knows exactly which items to keep\n// and which to remove, minimizing DOM operations\n\n**Key Prop Best Practices:**\n\n// 1. Use unique, stable identifiers\nconst users = [\n{ id: 'user-1', name: 'John' },\n{ id: 'user-2', name: 'Jane' },\n{ id: 'user-3', name: 'Bob' },\n];\n\n// ✅ Good\n{\nusers.map(user => <UserCard key={user.id} user={user} />);\n}\n\n// 2. For items without IDs, create stable keys\nconst items = ['apple', 'banana', 'orange'];\n\n// ✅ Good - use the value itself if it's unique\n{\nitems.map(item => <Item key={item} item={item} />);\n}\n\n// 3. For complex objects, combine multiple fields\nconst products = [\n{ category: 'electronics', name: 'laptop', price: 999 },\n{ category: 'electronics', name: 'phone', price: 699 },\n];\n\n// ✅ Good - combine fields for uniqueness\n{\nproducts.map(product => (\n<Product key={`${product.category}-${product.name}`} product={product} />\n));\n}\n\n// 4. Avoid random keys\n// ❌ Bad - creates new key on every render\n{\nitems.map(item => <Item key={Math.random()} item={item} />);\n}\n\n**Performance Impact:**\n\n// Without proper keys - expensive re-renders\nfunction ExpensiveList({ items }) {\nreturn (\n<div>\n{items.map((item, index) => (\n<ExpensiveComponent\nkey={index} // Causes unnecessary re-renders\ndata={item}\n/>\n))}\n</div>\n);\n}\n\n// With proper keys - efficient updates\nfunction OptimizedList({ items }) {\nreturn (\n<div>\n{items.map(item => (\n<ExpensiveComponent\nkey={item.id} // Efficient updates\ndata={item}\n/>\n))}\n</div>\n);\n}\n\n// State preservation with keys\nfunction TodoItem({ todo }) {\nconst [isEditing, setIsEditing] = useState(false);\n\nreturn (\n<div>\n{isEditing ? (\n<input defaultValue={todo.text} />\n) : (\n<span>{todo.text}</span>\n)}\n<button onClick={() => setIsEditing(!isEditing)}>\n{isEditing ? 'Save' : 'Edit'}\n</button>\n</div>\n);\n}\n\n// With proper keys, editing state is preserved when list reorders\n// With index keys, editing state is lost\n\n**Reconciliation Optimization:**\n\n// React.memo for preventing unnecessary re-renders\nconst TodoItem = React.memo(({ todo }) => {\nreturn (\n<div>\n<span>{todo.text}</span>\n<span>{todo.completed ? '✓' : '○'}</span>\n</div>\n);\n});\n\n// useMemo for expensive calculations\nfunction TodoList({ todos, filter }) {\nconst filteredTodos = useMemo(() => {\nreturn todos.filter(todo =>\ntodo.text.toLowerCase().includes(filter.toLowerCase())\n);\n}, [todos, filter]);\n\nreturn (\n<div>\n{filteredTodos.map(todo => (\n<TodoItem key={todo.id} todo={todo} />\n))}\n</div>\n);\n}",
      "correctAnswer": null,
      "learningPaths": [
        "react-mastery"
      ],
      "isActive": true,
      "createdAt": "2025-09-30T00:21:35.602Z",
      "category": "React.js (Core)",
      "topics": [
        "React Hooks",
        "State Management",
        "Component Lifecycle",
        "JSX"
      ],
      "title": "Reconciliation and Key Prop"
    },
    {
      "id": "imported-react-mastery-1759191695562-22",
      "explanation": "An Error Boundary is a React component that uses the `componentDidCatch` or `getDerivedStateFromError` lifecycle methods to catch JavaScript errors anywhere in their child component tree, log those errors, and display a fallback UI instead of crashing the whole app. It cannot be a functional component because Hooks do not have an equivalent to these lifecycle methods yet. Error Boundaries must be class components.\n\n**Basic Error Boundary:**\n\nclass ErrorBoundary extends React.Component {\nconstructor(props) {\nsuper(props);\nthis.state = { hasError: false, error: null, errorInfo: null };\n}\n\nstatic getDerivedStateFromError(error) {\n// Update state so the next render will show the fallback UI\nreturn { hasError: true };\n}\n\ncomponentDidCatch(error, errorInfo) {\n// Log the error to an error reporting service\nconsole.error('Error caught by boundary:', error, errorInfo);\n\nthis.setState({\nerror: error,\nerrorInfo: errorInfo,\n});\n\n// Send to error reporting service\nlogErrorToService(error, errorInfo);\n}\n\nrender() {\nif (this.state.hasError) {\n// Fallback UI\nreturn (\n<div className=\"error-boundary\">\n<h2>Something went wrong.</h2>\n<details style={{ whiteSpace: 'pre-wrap' }}>\n{this.state.error && this.state.error.toString()}\n<br />\n{this.state.errorInfo.componentStack}\n</details>\n</div>\n);\n}\n\nreturn this.props.children;\n}\n}\n\n// Usage\nfunction App() {\nreturn (\n<ErrorBoundary>\n<Header />\n<MainContent />\n<Footer />\n</ErrorBoundary>\n);\n}\n\n**Advanced Error Boundary:**\n\nclass AdvancedErrorBoundary extends React.Component {\nconstructor(props) {\nsuper(props);\nthis.state = {\nhasError: false,\nerror: null,\nerrorInfo: null,\nretryCount: 0,\n};\n}\n\nstatic getDerivedStateFromError(error) {\nreturn { hasError: true };\n}\n\ncomponentDidCatch(error, errorInfo) {\nthis.setState({\nerror: error,\nerrorInfo: errorInfo,\n});\n\n// Different handling based on error type\nif (error.name === 'ChunkLoadError') {\n// Handle code splitting errors\nthis.handleChunkError();\n} else if (error.name === 'TypeError') {\n// Handle type errors\nthis.handleTypeError(error);\n} else {\n// Generic error handling\nthis.handleGenericError(error, errorInfo);\n}\n}\n\nhandleChunkError = () => {\n// Reload the page for chunk errors\nwindow.location.reload();\n};\n\nhandleTypeError = error => {\n// Log type errors for debugging\nconsole.error('Type error detected:', error);\n};\n\nhandleGenericError = (error, errorInfo) => {\n// Send to error reporting service\nerrorReportingService.captureException(error, {\nextra: errorInfo,\ntags: {\ncomponent: 'ErrorBoundary',\n},\n});\n};\n\nhandleRetry = () => {\nthis.setState(prevState => ({\nhasError: false,\nerror: null,\nerrorInfo: null,\nretryCount: prevState.retryCount + 1,\n}));\n};\n\nrender() {\nif (this.state.hasError) {\nif (this.state.retryCount >= 3) {\nreturn (\n<div className=\"error-boundary\">\n<h2>Something went wrong and we couldn't recover.</h2>\n<p>Please refresh the page or contact support.</p>\n<button onClick={() => window.location.reload()}>\nRefresh Page\n</button>\n</div>\n);\n}\n\nreturn (\n<div className=\"error-boundary\">\n<h2>Oops! Something went wrong.</h2>\n<p>We're sorry for the inconvenience.</p>\n<button onClick={this.handleRetry}>\nTry Again ({this.state.retryCount}/3)\n</button>\n{process.env.NODE_ENV === 'development' && (\n<details>\n<summary>Error Details</summary>\n<pre>{this.state.error && this.state.error.toString()}</pre>\n<pre>{this.state.errorInfo.componentStack}</pre>\n</details>\n)}\n</div>\n);\n}\n\nreturn this.props.children;\n}\n}\n\n**Multiple Error Boundaries:**\n\nfunction App() {\nreturn (\n<ErrorBoundary>\n<Header />\n\n<ErrorBoundary>\n<Sidebar />\n</ErrorBoundary>\n\n<main>\n<ErrorBoundary>\n<MainContent />\n</ErrorBoundary>\n</main>\n\n<ErrorBoundary>\n<Footer />\n</ErrorBoundary>\n</ErrorBoundary>\n);\n}\n\n// Each boundary can catch errors independently\n// If Sidebar crashes, Header and MainContent still work\n\n**Error Boundary with Hooks (Workaround):**\n\n// Since Error Boundaries must be class components,\n// you can create a wrapper that provides error state to hooks\nclass ErrorBoundaryWithHooks extends React.Component {\nconstructor(props) {\nsuper(props);\nthis.state = { hasError: false, error: null };\n}\n\nstatic getDerivedStateFromError(error) {\nreturn { hasError: true, error };\n}\n\ncomponentDidCatch(error, errorInfo) {\nconsole.error('Error caught:', error, errorInfo);\n}\n\nrender() {\nif (this.state.hasError) {\nreturn this.props.fallback(this.state.error);\n}\n\nreturn this.props.children;\n}\n}\n\n// Usage with hooks\nfunction ComponentWithErrorHandling() {\nreturn (\n<ErrorBoundaryWithHooks\nfallback={error => (\n<div>\n<h2>Error occurred</h2>\n<p>{error.message}</p>\n</div>\n)}\n>\n<RiskyComponent />\n</ErrorBoundaryWithHooks>\n);\n}",
      "title": "Error Boundaries",
      "topics": [
        "React Hooks",
        "State Management",
        "Component Lifecycle",
        "JSX"
      ],
      "category": "React.js (Core)",
      "updatedAt": "2025-09-30T00:21:35.602Z",
      "learningPaths": [
        "react-mastery"
      ],
      "options": [],
      "isActive": true,
      "importedAt": "2025-09-30T00:21:35.562Z",
      "content": "What is an Error Boundary, and why can't it be implemented with a functional component?",
      "source": "QuestionsBank",
      "createdAt": "2025-09-30T00:21:35.602Z",
      "correctAnswer": null,
      "codeBlock": "class ErrorBoundary extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = { hasError: false, error: null, errorInfo: null };\n  }\n\n  static getDerivedStateFromError(error) {\n    // Update state so the next render will show the fallback UI\n    return { hasError: true };\n  }\n\n  componentDidCatch(error, errorInfo) {\n    // Log the error to an error reporting service\n    console.error('Error caught by boundary:', error, errorInfo);\n\n    this.setState({\n      error: error,\n      errorInfo: errorInfo,\n    });\n\n    // Send to error reporting service\n    logErrorToService(error, errorInfo);\n  }\n\n  render() {\n    if (this.state.hasError) {\n      // Fallback UI\n      return (\n        <div className=\"error-boundary\">\n          <h2>Something went wrong.</h2>\n          <details style={{ whiteSpace: 'pre-wrap' }}>\n            {this.state.error && this.state.error.toString()}\n            <br />\n            {this.state.errorInfo.componentStack}\n          </details>\n        </div>\n      );\n    }\n\n    return this.props.children;\n  }\n}\n\n// Usage\nfunction App() {\n  return (\n    <ErrorBoundary>\n      <Header />\n      <MainContent />\n      <Footer />\n    </ErrorBoundary>\n  );\n}",
      "isComplete": false,
      "type": "code",
      "difficulty": "intermediate"
    },
    {
      "id": "imported-react-mastery-1759191695559-5",
      "explanation": "**1. Only Call Hooks at the Top Level:**\nDon't call Hooks inside loops, conditions, or nested functions. This ensures Hooks are called in the same order every time a component renders, which is how React preserves state between calls.\n\n**2. Only Call Hooks from React Functions:**\nCall them from within React functional components or from custom Hooks.\n\n**Examples:**\n\n**❌ Wrong - Conditional Hook:**\n\nfunction MyComponent({ shouldUseEffect }) {\nif (shouldUseEffect) {\nuseEffect(() => {\n// This violates the rules of hooks\n}, []);\n}\n\nreturn <div>Hello</div>;\n}\n\n**✅ Correct - Always Call Hooks:**\n\nfunction MyComponent({ shouldUseEffect }) {\nuseEffect(() => {\nif (shouldUseEffect) {\n// Logic inside the hook\n}\n}, [shouldUseEffect]);\n\nreturn <div>Hello</div>;\n}\n\n**❌ Wrong - Hook in Loop:**\n\nfunction MyComponent({ items }) {\nitems.forEach(item => {\nuseState(item); // This violates the rules of hooks\n});\n\nreturn <div>Hello</div>;\n}\n\n**✅ Correct - Use Array:**\n\nfunction MyComponent({ items }) {\nconst [selectedItems, setSelectedItems] = useState([]);\n\nreturn <div>Hello</div>;\n}",
      "difficulty": "intermediate",
      "title": "React Hooks Rules",
      "topics": [
        "React Hooks",
        "State Management",
        "Component Lifecycle",
        "JSX"
      ],
      "correctAnswer": null,
      "isActive": true,
      "type": "code",
      "content": "What are the two main rules of Hooks?",
      "category": "React.js (Core)",
      "options": [],
      "createdAt": "2025-09-30T00:21:35.602Z",
      "importedAt": "2025-09-30T00:21:35.559Z",
      "source": "QuestionsBank",
      "isComplete": false,
      "codeBlock": "function MyComponent({ shouldUseEffect }) {\n  if (shouldUseEffect) {\n    useEffect(() => {\n      // This violates the rules of hooks\n    }, []);\n  }\n\n  return <div>Hello</div>;\n}",
      "learningPaths": [
        "react-mastery"
      ],
      "updatedAt": "2025-09-30T00:21:35.602Z"
    },
    {
      "id": "imported-react-mastery-1759191695562-23",
      "correctAnswer": null,
      "isActive": true,
      "difficulty": "intermediate",
      "explanation": "**Pitfalls**: Overusing useEffect can lead to a messy \"effect soup\" that is hard to reason about and can cause unnecessary re-renders or infinite loops.\n\n**Async Callback**: The useEffect callback cannot be async because an async function implicitly returns a Promise. useEffect expects its return value to be either nothing or a cleanup function (a regular function). A Promise is not a function, so React doesn't know how to use it for cleanup. The solution is to define an async function inside the useEffect and call it.\n\n**Common Pitfalls:**\n\n// ❌ Pitfall 1: Missing dependencies\nfunction BadComponent({ userId }) {\nconst [user, setUser] = useState(null);\n\nuseEffect(() => {\nfetchUser(userId).then(setUser); // Missing userId in deps\n}, []); // Empty dependency array\n\nreturn <div>{user?.name}</div>;\n}\n\n// ✅ Correct\nfunction GoodComponent({ userId }) {\nconst [user, setUser] = useState(null);\n\nuseEffect(() => {\nfetchUser(userId).then(setUser);\n}, [userId]); // Include all dependencies\n\nreturn <div>{user?.name}</div>;\n}\n\n**Infinite Loops:**\n\n// ❌ Pitfall 2: Infinite loop with object dependencies\nfunction BadComponent({ user }) {\nconst [data, setData] = useState(null);\n\nuseEffect(() => {\nfetchData(user).then(setData);\n}, [user]); // user object recreated on every render\n\nreturn <div>{data}</div>;\n}\n\n// ✅ Solutions\nfunction GoodComponent({ user }) {\nconst [data, setData] = useState(null);\n\n// Solution 1: Use specific properties\nuseEffect(() => {\nfetchData(user.id).then(setData);\n}, [user.id]);\n\n// Solution 2: Memoize the object\nconst memoizedUser = useMemo(() => user, [user.id, user.name]);\n\nuseEffect(() => {\nfetchData(memoizedUser).then(setData);\n}, [memoizedUser]);\n\nreturn <div>{data}</div>;\n}\n\n**Async Function Handling:**\n\n// ❌ Wrong - async callback\nfunction BadComponent() {\nuseEffect(async () => {\nconst data = await fetchData();\nsetData(data);\n}, []);\n\nreturn <div>Bad example</div>;\n}\n\n// ✅ Correct - async function inside useEffect\nfunction GoodComponent() {\nuseEffect(() => {\nasync function fetchData() {\ntry {\nconst data = await fetchData();\nsetData(data);\n} catch (error) {\nsetError(error);\n}\n}\n\nfetchData();\n}, []);\n\nreturn <div>Good example</div>;\n}\n\n// ✅ Alternative - using .then()\nfunction AlternativeComponent() {\nuseEffect(() => {\nfetchData().then(setData).catch(setError);\n}, []);\n\nreturn <div>Alternative example</div>;\n}\n\n**Cleanup Functions:**\n\n// ✅ Proper cleanup\nfunction ComponentWithCleanup() {\nuseEffect(() => {\nconst subscription = subscribeToUpdates();\nconst timer = setInterval(updateData, 1000);\n\n// Cleanup function\nreturn () => {\nsubscription.unsubscribe();\nclearInterval(timer);\n};\n}, []);\n\nreturn <div>Component with cleanup</div>;\n}\n\n// ✅ Cleanup with async operations\nfunction ComponentWithAsyncCleanup() {\nuseEffect(() => {\nlet isCancelled = false;\n\nasync function fetchData() {\ntry {\nconst data = await fetchData();\nif (!isCancelled) {\nsetData(data);\n}\n} catch (error) {\nif (!isCancelled) {\nsetError(error);\n}\n}\n}\n\nfetchData();\n\nreturn () => {\nisCancelled = true;\n};\n}, []);\n\nreturn <div>Component with async cleanup</div>;\n}\n\n**Effect Soup Prevention:**\n\n// ❌ Effect soup - multiple effects doing related things\nfunction BadComponent({ userId }) {\nconst [user, setUser] = useState(null);\nconst [posts, setPosts] = useState([]);\nconst [loading, setLoading] = useState(false);\n\nuseEffect(() => {\nsetLoading(true);\nfetchUser(userId).then(user => {\nsetUser(user);\nsetLoading(false);\n});\n}, [userId]);\n\nuseEffect(() => {\nif (user) {\nfetchUserPosts(user.id).then(setPosts);\n}\n}, [user]);\n\nuseEffect(() => {\nif (user && posts.length > 0) {\nupdateUserActivity(user.id, posts.length);\n}\n}, [user, posts]);\n\nreturn <div>Bad example</div>;\n}\n\n// ✅ Better - combine related effects\nfunction GoodComponent({ userId }) {\nconst [user, setUser] = useState(null);\nconst [posts, setPosts] = useState([]);\nconst [loading, setLoading] = useState(false);\n\nuseEffect(() => {\nasync function loadUserData() {\nsetLoading(true);\ntry {\nconst userData = await fetchUser(userId);\nsetUser(userData);\n\nconst userPosts = await fetchUserPosts(userData.id);\nsetPosts(userPosts);\n\nupdateUserActivity(userData.id, userPosts.length);\n} catch (error) {\nconsole.error('Failed to load user data:', error);\n} finally {\nsetLoading(false);\n}\n}\n\nloadUserData();\n}, [userId]);\n\nreturn <div>Good example</div>;\n}\n\n**Custom Hook for Async Effects:**\n\n// Custom hook to handle async effects properly\nfunction useAsyncEffect(asyncFn, deps) {\nuseEffect(() => {\nlet isCancelled = false;\n\nasync function runAsync() {\ntry {\nconst result = await asyncFn();\nif (!isCancelled) {\nreturn result;\n}\n} catch (error) {\nif (!isCancelled) {\nthrow error;\n}\n}\n}\n\nrunAsync();\n\nreturn () => {\nisCancelled = true;\n};\n}, deps);\n}\n\n// Usage\nfunction ComponentUsingCustomHook({ userId }) {\nconst [user, setUser] = useState(null);\n\nuseAsyncEffect(async () => {\nconst userData = await fetchUser(userId);\nsetUser(userData);\n}, [userId]);\n\nreturn <div>{user?.name}</div>;\n}\n\n\n// 3. Use Suspense boundaries strategically\nfunction Dashboard() {\nreturn (\n<div>\n<Suspense fallback={<QuickStatsSkeleton />}>\n<QuickStats />\n</Suspense>\n<Suspense fallback={<DetailedChartSkeleton />}>\n<DetailedChart />\n</Suspense>\n</div>\n);\n}",
      "createdAt": "2025-09-30T00:21:35.602Z",
      "options": [],
      "type": "code",
      "importedAt": "2025-09-30T00:21:35.562Z",
      "title": "useEffect Pitfalls",
      "topics": [
        "React Hooks",
        "State Management",
        "Component Lifecycle",
        "JSX"
      ],
      "source": "QuestionsBank",
      "category": "React.js (Core)",
      "learningPaths": [
        "react-mastery"
      ],
      "isComplete": false,
      "updatedAt": "2025-09-30T00:21:35.602Z",
      "content": "Explain the common pitfalls of the useEffect Hook. Why can't its callback be async?",
      "codeBlock": "// ❌ Pitfall 1: Missing dependencies\nfunction BadComponent({ userId }) {\n  const [user, setUser] = useState(null);\n\n  useEffect(() => {\n    fetchUser(userId).then(setUser); // Missing userId in deps\n  }, []); // Empty dependency array\n\n  return <div>{user?.name}</div>;\n}\n\n// ✅ Correct\nfunction GoodComponent({ userId }) {\n  const [user, setUser] = useState(null);\n\n  useEffect(() => {\n    fetchUser(userId).then(setUser);\n  }, [userId]); // Include all dependencies\n\n  return <div>{user?.name}</div>;\n}"
    },
    {
      "id": "imported-react-mastery-1759191695562-19",
      "topics": [
        "React Hooks",
        "State Management",
        "Component Lifecycle",
        "JSX"
      ],
      "updatedAt": "2025-09-30T00:21:35.602Z",
      "content": "Compare and contrast useMemo and useCallback. When would you use them?",
      "category": "React.js (Core)",
      "codeBlock": "function ExpensiveComponent({ items, filter }) {\n  // Expensive calculation - only runs when items or filter changes\n  const filteredItems = useMemo(() => {\n    console.log('Filtering items...'); // Only logs when dependencies change\n    return items.filter(item =>\n      item.name.toLowerCase().includes(filter.toLowerCase())\n    );\n  }, [items, filter]);\n\n  // Expensive sorting - only runs when filteredItems changes\n  const sortedItems = useMemo(() => {\n    console.log('Sorting items...'); // Only logs when filteredItems changes\n    return filteredItems.sort((a, b) => a.name.localeCompare(b.name));\n  }, [filteredItems]);\n\n  return (\n    <div>\n      {sortedItems.map(item => (\n        <Item key={item.id} item={item} />\n      ))}\n    </div>\n  );\n}\n\n// Complex calculations\nfunction DataVisualization({ data }) {\n  const chartData = useMemo(() => {\n    // Expensive data transformation\n    return data.map(item => ({\n      x: item.timestamp,\n      y: calculateComplexMetric(item),\n      color: getColorByCategory(item.category),\n    }));\n  }, [data]);\n\n  const statistics = useMemo(() => {\n    return {\n      mean: calculateMean(chartData.map(d => d.y)),\n      median: calculateMedian(chartData.map(d => d.y)),\n      standardDeviation: calculateStdDev(chartData.map(d => d.y)),\n    };\n  }, [chartData]);\n\n  return (\n    <div>\n      <Chart data={chartData} />\n      <Statistics stats={statistics} />\n    </div>\n  );\n}",
      "learningPaths": [
        "react-mastery"
      ],
      "isActive": true,
      "difficulty": "intermediate",
      "source": "QuestionsBank",
      "title": "useMemo and useCallback Comparison",
      "correctAnswer": null,
      "importedAt": "2025-09-30T00:21:35.562Z",
      "options": [],
      "explanation": "Both are performance optimization Hooks that memoize values based on a dependency array.\n\n**useMemo**: Memoizes the result of a computation. Use it when you have an expensive calculation that you don't want to re-run on every render (e.g., sorting a large array, complex math).\n\n**useCallback**: Memoizes the function instance itself. Use it when you need to pass a stable function reference to a child component that is optimized with React.memo to prevent unnecessary re-renders.\n\n**Caution**: Use them pragmatically; most apps don't need them everywhere. Profile performance first.\n\n**useMemo Examples:**\n\nfunction ExpensiveComponent({ items, filter }) {\n// Expensive calculation - only runs when items or filter changes\nconst filteredItems = useMemo(() => {\nconsole.log('Filtering items...'); // Only logs when dependencies change\nreturn items.filter(item =>\nitem.name.toLowerCase().includes(filter.toLowerCase())\n);\n}, [items, filter]);\n\n// Expensive sorting - only runs when filteredItems changes\nconst sortedItems = useMemo(() => {\nconsole.log('Sorting items...'); // Only logs when filteredItems changes\nreturn filteredItems.sort((a, b) => a.name.localeCompare(b.name));\n}, [filteredItems]);\n\nreturn (\n<div>\n{sortedItems.map(item => (\n<Item key={item.id} item={item} />\n))}\n</div>\n);\n}\n\n// Complex calculations\nfunction DataVisualization({ data }) {\nconst chartData = useMemo(() => {\n// Expensive data transformation\nreturn data.map(item => ({\nx: item.timestamp,\ny: calculateComplexMetric(item),\ncolor: getColorByCategory(item.category),\n}));\n}, [data]);\n\nconst statistics = useMemo(() => {\nreturn {\nmean: calculateMean(chartData.map(d => d.y)),\nmedian: calculateMedian(chartData.map(d => d.y)),\nstandardDeviation: calculateStdDev(chartData.map(d => d.y)),\n};\n}, [chartData]);\n\nreturn (\n<div>\n<Chart data={chartData} />\n<Statistics stats={statistics} />\n</div>\n);\n}\n\n**useCallback Examples:**\n\n// Preventing unnecessary re-renders\nconst ExpensiveChild = React.memo(({ onClick, data }) => {\nconsole.log('ExpensiveChild rendered'); // Only logs when props actually change\nreturn <button onClick={onClick}>{data.name}</button>;\n});\n\nfunction ParentComponent({ items }) {\nconst [count, setCount] = useState(0);\n\n// Without useCallback - function recreated on every render\nconst handleClick = useCallback(item => {\nconsole.log('Clicked:', item.name);\n// Handle click logic\n}, []); // Empty dependency array - function never changes\n\n// With dependencies\nconst handleItemUpdate = useCallback((itemId, updates) => {\nsetItems(prev =>\nprev.map(item => (item.id === itemId ? { ...item, ...updates } : item))\n);\n}, []); // setItems is stable from useState\n\nreturn (\n<div>\n<button onClick={() => setCount(c => c + 1)}>Count: {count}</button>\n\n{items.map(item => (\n<ExpensiveChild\nkey={item.id}\nonClick={() => handleClick(item)}\ndata={item}\n/>\n))}\n</div>\n);\n}\n\n**When NOT to Use Them:**\n\n// ❌ Don't use useMemo for simple calculations\nfunction BadExample({ a, b }) {\nconst sum = useMemo(() => a + b, [a, b]); // Overkill!\nreturn <div>{sum}</div>;\n}\n\n// ✅ Simple calculations are fine without memoization\nfunction GoodExample({ a, b }) {\nconst sum = a + b; // This is fast enough\nreturn <div>{sum}</div>;\n}\n\n// ❌ Don't use useCallback for functions that don't need stability\nfunction BadExample({ items }) {\nconst handleClick = useCallback(item => {\nconsole.log(item.name);\n}, []); // If this function isn't passed to memoized children, it's unnecessary\n\nreturn (\n<div>\n{items.map(item => (\n<div key={item.id} onClick={() => handleClick(item)}>\n{item.name}\n</div>\n))}\n</div>\n);\n}\n\n**Performance Profiling:**\n\n// Use React DevTools Profiler to identify actual performance issues\nfunction ProfiledComponent({ data }) {\n// Only add memoization after profiling shows it's needed\nconst expensiveValue = useMemo(() => {\nreturn data.reduce((acc, item) => {\n// Expensive operation\nreturn acc + complexCalculation(item);\n}, 0);\n}, [data]);\n\nreturn <div>{expensiveValue}</div>;\n}\n\n// Custom hook for performance monitoring\nfunction usePerformanceMonitor(name) {\nconst renderCount = useRef(0);\nrenderCount.current++;\n\nuseEffect(() => {\nconsole.log(`${name} rendered ${renderCount.current} times`);\n});\n}\n\n**Advanced Patterns:**\n\n// Combining useMemo and useCallback\nfunction AdvancedComponent({ items, onItemSelect }) {\n// Memoize the filtered items\nconst filteredItems = useMemo(() => {\nreturn items.filter(item => item.active);\n}, [items]);\n\n// Memoize the selection handler\nconst handleSelect = useCallback((item) => {\nonItemSelect(item);\n}, [onItemSelect]);\n\n// Memoize the rendered list\nconst itemList = useMemo(() => {\nreturn filteredItems.map(item => (\n<Item\nkey={item.id}\nitem={item}\nonSelect={handleSelect}\n/>\n));\n}, [filteredItems, handleSelect]);\n\nreturn <div>{itemList}</div>;\n}\n\n// Custom hook for expensive operations\nfunction useExpensiveCalculation(data, options) {\nreturn useMemo(() => {\nreturn performExpensiveCalculation(data, options);\n}, [data, options]);\n}",
      "isComplete": false,
      "createdAt": "2025-09-30T00:21:35.602Z",
      "type": "code"
    },
    {
      "id": "imported-react-mastery-1759191695559-12",
      "source": "QuestionsBank",
      "category": "React.js (Core)",
      "explanation": "**1. Lifting State Up:**\nMove the shared state to the closest common parent component and pass it down via props.\n\nfunction Parent() {\nconst [sharedState, setSharedState] = useState('');\n\nreturn (\n<div>\n<SiblingA value={sharedState} onChange={setSharedState} />\n<SiblingB value={sharedState} onChange={setSharedState} />\n</div>\n);\n}\n\nfunction SiblingA({ value, onChange }) {\nreturn <input value={value} onChange={e => onChange(e.target.value)} />;\n}\n\nfunction SiblingB({ value, onChange }) {\nreturn <div>Current value: {value}</div>;\n}\n\n**2. Context API:**\nCreate a context to hold the state and use `useContext` to consume it in the siblings.\n\nconst SharedStateContext = createContext();\n\nfunction Parent() {\nconst [sharedState, setSharedState] = useState('');\n\nreturn (\n<SharedStateContext.Provider value={{ sharedState, setSharedState }}>\n<SiblingA />\n<SiblingB />\n</SharedStateContext.Provider>\n);\n}\n\nfunction SiblingA() {\nconst { sharedState, setSharedState } = useContext(SharedStateContext);\n\nreturn (\n<input value={sharedState} onChange={e => setSharedState(e.target.value)} />\n);\n}\n\nfunction SiblingB() {\nconst { sharedState } = useContext(SharedStateContext);\n\nreturn <div>Current value: {sharedState}</div>;\n}\n\n**3. State Management Library:**\nUse a global state library like Redux, Zustand, or Recoil.\n\n// With Zustand\nimport { create } from 'zustand';\n\nconst useStore = create(set => ({\nsharedState: '',\nsetSharedState: value => set({ sharedState: value }),\n}));\n\nfunction SiblingA() {\nconst { sharedState, setSharedState } = useStore();\n\nreturn (\n<input value={sharedState} onChange={e => setSharedState(e.target.value)} />\n);\n}\n\nfunction SiblingB() {\nconst { sharedState } = useStore();\n\nreturn <div>Current value: {sharedState}</div>;\n}\n\n**4. Custom Hook:**\nCreate a custom hook that manages the shared state.\n\nfunction useSharedState(initialValue) {\nconst [state, setState] = useState(initialValue);\n\nreturn [state, setState];\n}\n\nfunction Parent() {\nconst [sharedState, setSharedState] = useSharedState('');\n\nreturn (\n<div>\n<SiblingA value={sharedState} onChange={setSharedState} />\n<SiblingB value={sharedState} />\n</div>\n);\n}",
      "importedAt": "2025-09-30T00:21:35.559Z",
      "type": "code",
      "topics": [
        "React Hooks",
        "State Management",
        "Component Lifecycle",
        "JSX"
      ],
      "title": "Sibling Component Communication",
      "options": [],
      "updatedAt": "2025-09-30T00:21:35.602Z",
      "isComplete": false,
      "codeBlock": "function Parent() {\n  const [sharedState, setSharedState] = useState('');\n\n  return (\n    <div>\n      <SiblingA value={sharedState} onChange={setSharedState} />\n      <SiblingB value={sharedState} onChange={setSharedState} />\n    </div>\n  );\n}\n\nfunction SiblingA({ value, onChange }) {\n  return <input value={value} onChange={e => onChange(e.target.value)} />;\n}\n\nfunction SiblingB({ value, onChange }) {\n  return <div>Current value: {value}</div>;\n}",
      "difficulty": "intermediate",
      "isActive": true,
      "learningPaths": [
        "react-mastery"
      ],
      "content": "How can sibling components share state?",
      "correctAnswer": null,
      "createdAt": "2025-09-30T00:21:35.602Z"
    },
    {
      "id": "imported-react-mastery-1759191695562-21",
      "source": "QuestionsBank",
      "category": "React.js (Core)",
      "title": "React Context Performance Pitfalls",
      "type": "code",
      "codeBlock": "// ❌ Bad - Single context with multiple concerns\nconst AppContext = createContext();\n\nfunction AppProvider({ children }) {\n  const [user, setUser] = useState(null);\n  const [theme, setTheme] = useState('light');\n  const [notifications, setNotifications] = useState([]);\n  const [settings, setSettings] = useState({});\n\n  const value = {\n    user,\n    setUser,\n    theme,\n    setTheme,\n    notifications,\n    setNotifications,\n    settings,\n    setSettings,\n  };\n\n  return <AppContext.Provider value={value}>{children}</AppContext.Provider>;\n}\n\n// Any component using this context re-renders when ANY value changes\nfunction Header() {\n  const { theme } = useContext(AppContext); // Re-renders when user changes!\n  return <header className={theme}>Header</header>;\n}",
      "isComplete": false,
      "topics": [
        "React Hooks",
        "State Management",
        "Component Lifecycle",
        "JSX"
      ],
      "correctAnswer": null,
      "content": "What are the potential performance pitfalls of using React Context, and how can you mitigate them?",
      "explanation": "**Pitfall**: Any component consuming a Context will re-render whenever any value in that Context's state changes, even if it only cares about a specific part of the state.\n\n**Mitigation**: Split your state into multiple, logically separate Contexts (e.g., AuthContext, SettingsContext). This way, a component subscribing to SettingsContext won't re-render when the authentication state changes.\n\n**The Problem:**\n\n// ❌ Bad - Single context with multiple concerns\nconst AppContext = createContext();\n\nfunction AppProvider({ children }) {\nconst [user, setUser] = useState(null);\nconst [theme, setTheme] = useState('light');\nconst [notifications, setNotifications] = useState([]);\nconst [settings, setSettings] = useState({});\n\nconst value = {\nuser,\nsetUser,\ntheme,\nsetTheme,\nnotifications,\nsetNotifications,\nsettings,\nsetSettings,\n};\n\nreturn <AppContext.Provider value={value}>{children}</AppContext.Provider>;\n}\n\n// Any component using this context re-renders when ANY value changes\nfunction Header() {\nconst { theme } = useContext(AppContext); // Re-renders when user changes!\nreturn <header className={theme}>Header</header>;\n}\n\n**The Solution:**\n\n// ✅ Good - Split contexts by domain\nconst AuthContext = createContext();\nconst ThemeContext = createContext();\nconst NotificationContext = createContext();\nconst SettingsContext = createContext();\n\n// Auth Context\nfunction AuthProvider({ children }) {\nconst [user, setUser] = useState(null);\nconst [isLoading, setIsLoading] = useState(false);\n\nconst value = useMemo(\n() => ({\nuser,\nsetUser,\nisLoading,\nsetIsLoading,\n}),\n[user, isLoading]\n);\n\nreturn <AuthContext.Provider value={value}>{children}</AuthContext.Provider>;\n}\n\n// Theme Context\nfunction ThemeProvider({ children }) {\nconst [theme, setTheme] = useState('light');\n\nconst value = useMemo(\n() => ({\ntheme,\nsetTheme,\n}),\n[theme]\n);\n\nreturn (\n<ThemeContext.Provider value={value}>{children}</ThemeContext.Provider>\n);\n}\n\n// Now components only re-render when their specific context changes\nfunction Header() {\nconst { theme } = useContext(ThemeContext); // Only re-renders when theme changes\nreturn <header className={theme}>Header</header>;\n}\n\nfunction UserProfile() {\nconst { user } = useContext(AuthContext); // Only re-renders when user changes\nreturn <div>Welcome, {user?.name}</div>;\n}\n\n**Advanced Optimization:**\n\n// Custom hook for selective context consumption\nfunction useAuth() {\nconst context = useContext(AuthContext);\nif (!context) {\nthrow new Error('useAuth must be used within AuthProvider');\n}\nreturn context;\n}\n\n// Memoized context values\nfunction AuthProvider({ children }) {\nconst [user, setUser] = useState(null);\nconst [isLoading, setIsLoading] = useState(false);\n\n// Memoize the context value to prevent unnecessary re-renders\nconst value = useMemo(\n() => ({\nuser,\nsetUser,\nisLoading,\nsetIsLoading,\n}),\n[user, isLoading]\n);\n\nreturn <AuthContext.Provider value={value}>{children}</AuthContext.Provider>;\n}\n\n// Context selector pattern\nfunction useAuthSelector(selector) {\nconst context = useContext(AuthContext);\nreturn useMemo(() => selector(context), [context, selector]);\n}\n\n// Usage - only re-renders when user.name changes\nfunction UserName() {\nconst userName = useAuthSelector(state => state.user?.name);\nreturn <span>{userName}</span>;\n}",
      "difficulty": "intermediate",
      "importedAt": "2025-09-30T00:21:35.562Z",
      "options": [],
      "createdAt": "2025-09-30T00:21:35.602Z",
      "updatedAt": "2025-09-30T00:21:35.602Z",
      "isActive": true,
      "learningPaths": [
        "react-mastery"
      ]
    },
    {
      "id": "imported-react-mastery-1759191695561-16",
      "options": [],
      "difficulty": "intermediate",
      "content": "How does React's use of requestIdleCallback and priorities make the UI feel more responsive?",
      "importedAt": "2025-09-30T00:21:35.561Z",
      "category": "React.js (Core)",
      "type": "code",
      "updatedAt": "2025-09-30T00:21:35.602Z",
      "isComplete": false,
      "learningPaths": [
        "react-mastery"
      ],
      "isActive": true,
      "source": "QuestionsBank",
      "explanation": "React's Fiber architecture uses a scheduler that simulates the behavior of requestIdleCallback. It breaks rendering work into small units. After completing a unit, it yields to the browser, allowing it to paint the screen, handle user events, or perform other critical tasks. This prevents long, uninterrupted rendering work from \"janking\" or freezing the UI. High-priority updates (like typing in an input) can interrupt low-priority work (like rendering a large fetched list), ensuring the user interactions feel immediate and fluid.\n\n**Scheduler Implementation:**\n\n// React's internal scheduler (simplified)\nfunction workLoop(deadline) {\nwhile (nextUnitOfWork && deadline.timeRemaining() > 1) {\nnextUnitOfWork = performUnitOfWork(nextUnitOfWork);\n}\n\nif (nextUnitOfWork) {\n// More work to do, schedule it for later\nrequestIdleCallback(workLoop);\n} else {\n// All work complete, commit changes\ncommitRoot();\n}\n}\n\n// Priority-based scheduling\nconst priorities = {\nImmediate: 1, // User input, clicks\nUserBlocking: 2, // Hover effects, animations\nNormal: 3, // Data fetching, updates\nLow: 4, // Analytics, logging\nIdle: 5, // Background tasks\n};\n\nfunction scheduleUpdate(fiber, expirationTime) {\nconst priorityLevel = getCurrentPriorityLevel();\n\nif (priorityLevel === ImmediatePriority) {\n// Execute immediately\nperformSyncWorkOnRoot(root);\n} else {\n// Schedule for later\nscheduleCallback(\npriorityLevel,\nperformConcurrentWorkOnRoot.bind(null, root)\n);\n}\n}\n\n**Responsive UI Examples:**\n\n**1. Interruptible Rendering:**\n\n// Before - Blocking rendering\nfunction HeavyList({ items }) {\nconst [filteredItems, setFilteredItems] = useState([]);\n\nuseEffect(() => {\n// This blocks the UI until complete\nconst filtered = items.filter(item => item.visible);\nsetFilteredItems(filtered);\n}, [items]);\n\nreturn (\n<div>\n{filteredItems.map(item => (\n<HeavyComponent key={item.id} data={item} />\n))}\n</div>\n);\n}\n\n// After - Interruptible rendering\nfunction ResponsiveList({ items }) {\nconst [filteredItems, setFilteredItems] = useState([]);\nconst [isPending, startTransition] = useTransition();\n\nuseEffect(() => {\nstartTransition(() => {\n// This can be interrupted for user interactions\nconst filtered = items.filter(item => item.visible);\nsetFilteredItems(filtered);\n});\n}, [items]);\n\nreturn (\n<div>\n{isPending && <Spinner />}\n{filteredItems.map(item => (\n<HeavyComponent key={item.id} data={item} />\n))}\n</div>\n);\n}\n\n**2. Priority-based Updates:**\n\nfunction SearchApp() {\nconst [query, setQuery] = useState('');\nconst [results, setResults] = useState([]);\nconst [isPending, startTransition] = useTransition();\n\nconst handleInputChange = e => {\nconst value = e.target.value;\n\n// High priority - immediate UI update\nsetQuery(value);\n\n// Low priority - can be interrupted\nstartTransition(() => {\nconst newResults = searchItems(value);\nsetResults(newResults);\n});\n};\n\nreturn (\n<div>\n<input\nvalue={query}\nonChange={handleInputChange}\nplaceholder=\"Search...\"\n/>\n{isPending && <div>Searching...</div>}\n<ResultsList results={results} />\n</div>\n);\n}\n\n**3. Deferred Values:**\n\nfunction ProductList({ products, filter }) {\nconst [inputValue, setInputValue] = useState(filter);\nconst deferredFilter = useDeferredValue(inputValue);\n\nconst filteredProducts = useMemo(() => {\n// This expensive calculation can be deferred\nreturn products.filter(product =>\nproduct.name.toLowerCase().includes(deferredFilter.toLowerCase())\n);\n}, [products, deferredFilter]);\n\nreturn (\n<div>\n<input\nvalue={inputValue}\nonChange={e => setInputValue(e.target.value)}\nplaceholder=\"Filter products...\"\n/>\n<ProductGrid products={filteredProducts} />\n</div>\n);\n}\n\n**4. Suspense for Better UX:**\n\nfunction App() {\nreturn (\n<div>\n<Header />\n<Suspense fallback={<PageSkeleton />}>\n<MainContent />\n</Suspense>\n<Footer />\n</div>\n);\n}\n\nfunction MainContent() {\nreturn (\n<div>\n<Suspense fallback={<UserProfileSkeleton />}>\n<UserProfile />\n</Suspense>\n<Suspense fallback={<PostsSkeleton />}>\n<UserPosts />\n</Suspense>\n</div>\n);\n}\n\n// Each Suspense boundary can load independently\n// User sees content as it becomes available\n\n**Performance Monitoring:**\n\n// Measuring responsiveness\nfunction usePerformanceMonitor() {\nuseEffect(() => {\nconst observer = new PerformanceObserver(list => {\nfor (const entry of list.getEntries()) {\nif (entry.entryType === 'measure') {\nconsole.log(`${entry.name}: ${entry.duration}ms`);\n}\n}\n});\n\nobserver.observe({ entryTypes: ['measure'] });\n\nreturn () => observer.disconnect();\n}, []);\n}\n\n// Measuring frame drops\nfunction useFrameRateMonitor() {\nuseEffect(() => {\nlet frameCount = 0;\nlet lastTime = performance.now();\n\nfunction measureFrameRate() {\nframeCount++;\nconst currentTime = performance.now();\n\nif (currentTime - lastTime >= 1000) {\nconst fps = Math.round((frameCount * 1000) / (currentTime - lastTime));\nconsole.log(`FPS: ${fps}`);\n\nif (fps < 30) {\nconsole.warn('Low frame rate detected!');\n}\n\nframeCount = 0;\nlastTime = currentTime;\n}\n\nrequestAnimationFrame(measureFrameRate);\n}\n\nrequestAnimationFrame(measureFrameRate);\n}, []);\n}\n\n**Best Practices for Responsive UI:**\n\n// 1. Use transitions for non-urgent updates\nfunction DataTable({ data }) {\nconst [isPending, startTransition] = useTransition();\nconst [filteredData, setFilteredData] = useState(data);\n\nconst handleFilter = filter => {\nstartTransition(() => {\n// This won't block user interactions\nsetFilteredData(data.filter(item => item.matches(filter)));\n});\n};\n\nreturn (\n<div>\n<FilterInput onFilter={handleFilter} />\n{isPending && <LoadingIndicator />}\n<Table data={filteredData} />\n</div>\n);\n}\n\n// 2. Defer expensive calculations\nfunction Chart({ data }) {\nconst [inputData, setInputData] = useState(data);\nconst deferredData = useDeferredValue(inputData);\n\nconst chartData = useMemo(() => {\n// Expensive data transformation\nreturn processChartData(deferredData);\n}, [deferredData]);\n\nreturn <ChartComponent data={chartData} />;\n}",
      "title": "React Scheduler and Responsiveness",
      "createdAt": "2025-09-30T00:21:35.602Z",
      "correctAnswer": null,
      "topics": [
        "React Hooks",
        "State Management",
        "Component Lifecycle",
        "JSX"
      ],
      "codeBlock": "// React's internal scheduler (simplified)\nfunction workLoop(deadline) {\n  while (nextUnitOfWork && deadline.timeRemaining() > 1) {\n    nextUnitOfWork = performUnitOfWork(nextUnitOfWork);\n  }\n\n  if (nextUnitOfWork) {\n    // More work to do, schedule it for later\n    requestIdleCallback(workLoop);\n  } else {\n    // All work complete, commit changes\n    commitRoot();\n  }\n}\n\n// Priority-based scheduling\nconst priorities = {\n  Immediate: 1, // User input, clicks\n  UserBlocking: 2, // Hover effects, animations\n  Normal: 3, // Data fetching, updates\n  Low: 4, // Analytics, logging\n  Idle: 5, // Background tasks\n};\n\nfunction scheduleUpdate(fiber, expirationTime) {\n  const priorityLevel = getCurrentPriorityLevel();\n\n  if (priorityLevel === ImmediatePriority) {\n    // Execute immediately\n    performSyncWorkOnRoot(root);\n  } else {\n    // Schedule for later\n    scheduleCallback(\n      priorityLevel,\n      performConcurrentWorkOnRoot.bind(null, root)\n    );\n  }\n}"
    },
    {
      "id": "imported-react-mastery-1759191695559-7",
      "type": "code",
      "difficulty": "intermediate",
      "topics": [
        "React Hooks",
        "State Management",
        "Component Lifecycle",
        "JSX"
      ],
      "isComplete": false,
      "correctAnswer": null,
      "options": [],
      "codeBlock": "useEffect(async () => {\n  const data = await fetchData();\n  setData(data);\n}, []);",
      "source": "QuestionsBank",
      "category": "React.js (Core)",
      "updatedAt": "2025-09-30T00:21:35.602Z",
      "explanation": "The function passed to `useEffect` can optionally return a cleanup function. If you mark it as `async`, it implicitly returns a Promise, and React cannot use a Promise as a cleanup function.\n\n**❌ Wrong:**\n\nuseEffect(async () => {\nconst data = await fetchData();\nsetData(data);\n}, []);\n\n**✅ Correct Pattern:**\n\nuseEffect(() => {\nconst fetchData = async () => {\nconst result = await myApi.get(data);\nsetData(result);\n};\n\nfetchData();\n}, [data]);\n\n**Alternative with IIFE (Immediately Invoked Function Expression):**\n\nuseEffect(() => {\n(async () => {\nconst data = await fetchData();\nsetData(data);\n})();\n}, []);\n\n**With Cleanup:**\n\nuseEffect(() => {\nlet cancelled = false;\n\nconst fetchData = async () => {\nconst result = await myApi.get(data);\nif (!cancelled) {\nsetData(result);\n}\n};\n\nfetchData();\n\nreturn () => {\ncancelled = true;\n};\n}, [data]);\n\n**With AbortController:**\n\nuseEffect(() => {\nconst controller = new AbortController();\n\nconst fetchData = async () => {\ntry {\nconst response = await fetch('/api/data', {\nsignal: controller.signal,\n});\nconst data = await response.json();\nsetData(data);\n} catch (error) {\nif (error.name !== 'AbortError') {\nconsole.error('Fetch error:', error);\n}\n}\n};\n\nfetchData();\n\nreturn () => {\ncontroller.abort();\n};\n}, []);",
      "title": "useEffect with async functions",
      "learningPaths": [
        "react-mastery"
      ],
      "createdAt": "2025-09-30T00:21:35.602Z",
      "content": "Why can't we use an async function directly as the input to useEffect?",
      "isActive": true,
      "importedAt": "2025-09-30T00:21:35.559Z"
    },
    {
      "id": "imported-react-mastery-1759191695561-18",
      "correctAnswer": null,
      "content": "Explain the purpose and trade-offs of React.lazy and Suspense.",
      "explanation": "**Purpose**: React.lazy enables code-splitting by dynamically importing a component, telling Webpack to create a separate bundle. Suspense provides a fallback UI (like a loading spinner) to display while the lazy-loaded component is being fetched.\n\n**Trade-offs:**\n\n**Pros**: Reduces initial bundle size, improving load time.\n\n**Cons**: Can be an anti-pattern if overused on critical components, as it adds HTTP requests to the critical rendering path. It can also complicate Server-Side Rendering (SSR) setups.\n\n**Basic Implementation:**\n\nimport React, { Suspense, lazy } from 'react';\n\n// Lazy load a component\nconst LazyComponent = lazy(() => import('./LazyComponent'));\n\nfunction App() {\nreturn (\n<div>\n<h1>My App</h1>\n<Suspense fallback={<div>Loading...</div>}>\n<LazyComponent />\n</Suspense>\n</div>\n);\n}\n\n**Route-based Code Splitting:**\n\nimport React, { Suspense, lazy } from 'react';\nimport { BrowserRouter, Routes, Route } from 'react-router-dom';\n\n// Lazy load route components\nconst Home = lazy(() => import('./pages/Home'));\nconst About = lazy(() => import('./pages/About'));\nconst Contact = lazy(() => import('./pages/Contact'));\nconst Dashboard = lazy(() => import('./pages/Dashboard'));\n\nfunction App() {\nreturn (\n<BrowserRouter>\n<div className=\"app\">\n<nav>{/* Navigation */}</nav>\n\n<main>\n<Suspense fallback={<PageLoader />}>\n<Routes>\n<Route path=\"/\" element={<Home />} />\n<Route path=\"/about\" element={<About />} />\n<Route path=\"/contact\" element={<Contact />} />\n<Route path=\"/dashboard\" element={<Dashboard />} />\n</Routes>\n</Suspense>\n</main>\n</div>\n</BrowserRouter>\n);\n}\n\n// Loading component\nfunction PageLoader() {\nreturn (\n<div className=\"page-loader\">\n<div className=\"spinner\" />\n<p>Loading page...</p>\n</div>\n);\n}\n\n**Multiple Suspense Boundaries:**\n\nfunction App() {\nreturn (\n<div>\n<Header />\n\n<Suspense fallback={<SidebarSkeleton />}>\n<Sidebar />\n</Suspense>\n\n<main>\n<Suspense fallback={<ContentSkeleton />}>\n<MainContent />\n</Suspense>\n</main>\n\n<Suspense fallback={<FooterSkeleton />}>\n<Footer />\n</Suspense>\n</div>\n);\n}\n\n// Each boundary can load independently\n// User sees content as it becomes available\n\n**Error Boundaries with Lazy Loading:**\n\nclass ErrorBoundary extends React.Component {\nconstructor(props) {\nsuper(props);\nthis.state = { hasError: false };\n}\n\nstatic getDerivedStateFromError(error) {\nreturn { hasError: true };\n}\n\ncomponentDidCatch(error, errorInfo) {\nconsole.error('Error loading component:', error, errorInfo);\n}\n\nrender() {\nif (this.state.hasError) {\nreturn (\n<div className=\"error-fallback\">\n<h2>Something went wrong loading this component.</h2>\n<button onClick={() => this.setState({ hasError: false })}>\nTry again\n</button>\n</div>\n);\n}\n\nreturn this.props.children;\n}\n}\n\nfunction App() {\nreturn (\n<ErrorBoundary>\n<Suspense fallback={<div>Loading...</div>}>\n<LazyComponent />\n</Suspense>\n</ErrorBoundary>\n);\n}\n\n**Preloading Strategies:**\n\n// Preload component on hover\nfunction NavigationLink({ to, children }) {\nconst handleMouseEnter = () => {\n// Preload the component\nimport(`./pages/${to}`);\n};\n\nreturn (\n<Link to={to} onMouseEnter={handleMouseEnter}>\n{children}\n</Link>\n);\n}\n\n// Preload after initial render\nfunction App() {\nuseEffect(() => {\n// Preload non-critical components after app loads\nconst timer = setTimeout(() => {\nimport('./pages/About');\nimport('./pages/Contact');\n}, 2000);\n\nreturn () => clearTimeout(timer);\n}, []);\n\nreturn (\n<div>\n<Suspense fallback={<div>Loading...</div>}>\n<Home />\n</Suspense>\n</div>\n);\n}\n\n**SSR Considerations:**\n\n// For SSR, you might need to handle hydration differently\nfunction SSRApp() {\nconst [isClient, setIsClient] = useState(false);\n\nuseEffect(() => {\nsetIsClient(true);\n}, []);\n\nif (!isClient) {\n// Server-side: render fallback or placeholder\nreturn <div>Loading...</div>;\n}\n\n// Client-side: render with Suspense\nreturn (\n<Suspense fallback={<div>Loading...</div>}>\n<LazyComponent />\n</Suspense>\n);\n}\n\n**Performance Monitoring:**\n\n// Monitor lazy loading performance\nfunction withLoadingMetrics(Component) {\nreturn function WrappedComponent(props) {\nconst startTime = performance.now();\n\nuseEffect(() => {\nconst endTime = performance.now();\nconst loadTime = endTime - startTime;\n\n// Send metrics to analytics\nanalytics.track('component_load_time', {\ncomponent: Component.name,\nloadTime: loadTime,\n});\n}, [startTime]);\n\nreturn <Component {...props} />;\n};\n}\n\n// Usage\nconst LazyComponent = lazy(() =>\nimport('./LazyComponent').then(module => ({\ndefault: withLoadingMetrics(module.default),\n}))\n);",
      "options": [],
      "difficulty": "intermediate",
      "category": "React.js (Core)",
      "isActive": true,
      "importedAt": "2025-09-30T00:21:35.561Z",
      "updatedAt": "2025-09-30T00:21:35.602Z",
      "codeBlock": "import React, { Suspense, lazy } from 'react';\n\n// Lazy load a component\nconst LazyComponent = lazy(() => import('./LazyComponent'));\n\nfunction App() {\n  return (\n    <div>\n      <h1>My App</h1>\n      <Suspense fallback={<div>Loading...</div>}>\n        <LazyComponent />\n      </Suspense>\n    </div>\n  );\n}",
      "topics": [
        "React Hooks",
        "State Management",
        "Component Lifecycle",
        "JSX"
      ],
      "type": "code",
      "isComplete": false,
      "createdAt": "2025-09-30T00:21:35.602Z",
      "learningPaths": [
        "react-mastery"
      ],
      "title": "React.lazy and Suspense",
      "source": "QuestionsBank"
    }
  ]
}