{
  "category": "System Design",
  "totalQuestions": 8,
  "exportedAt": "2025-09-30T00:28:57.750Z",
  "questions": [
    {
      "id": "imported-system-design-1759191708256-8",
      "category": "System Design",
      "explanation": "I would model it with two primary state variables:\n\n**userQuery (string)**: A controlled input for the user's current message.\n\n**conversation (Array of objects)**: An array containing the history of the chat. Each item in the array would be a \"reply\" object with properties like id (string), type (e.g., 'user' or 'chat'), timestamp, and content (string).\n\n**Detailed State Structure:**\n\n// TypeScript interfaces\ninterface Message {\nid: string;\nconversationId: string;\ntimestamp: Date;\ntype: 'user' | 'assistant';\ncontent: string;\nstatus?: 'sending' | 'sent' | 'error';\n}\n\ninterface ChatState {\nuserQuery: string;\nconversation: Message[];\nisConnected: boolean;\nisTyping: boolean;\ncurrentConversationId: string | null;\n}\n\n// React state implementation\nconst [chatState, setChatState] = useState<ChatState>({\nuserQuery: '',\nconversation: [],\nisConnected: false,\nisTyping: false,\ncurrentConversationId: null\n});\n\n**State Management Functions:**\n\n// Add user message\nconst addUserMessage = (content: string) => {\nconst newMessage: Message = {\nid: generateId(),\nconversationId: chatState.currentConversationId,\ntimestamp: new Date(),\ntype: 'user',\ncontent,\nstatus: 'sending'\n};\n\nsetChatState(prev => ({\n...prev,\nconversation: [...prev.conversation, newMessage],\nuserQuery: ''\n}));\n};\n\n// Add AI response chunk\nconst addAIResponseChunk = (chunk: string, messageId?: string) => {\nsetChatState(prev => {\nconst lastMessage = prev.conversation[prev.conversation.length - 1];\n\nif (lastMessage?.type === 'assistant' && lastMessage.status === 'streaming') {\n// Append to existing AI message\nreturn {\n...prev,\nconversation: prev.conversation.map((msg, index) =>\nindex === prev.conversation.length - 1\n? { ...msg, content: msg.content + chunk }\n: msg\n)\n};\n} else {\n// Create new AI message\nconst newMessage: Message = {\nid: messageId || generateId(),\nconversationId: prev.currentConversationId,\ntimestamp: new Date(),\ntype: 'assistant',\ncontent: chunk,\nstatus: 'streaming'\n};\n\nreturn {\n...prev,\nconversation: [...prev.conversation, newMessage]\n};\n}\n});\n};",
      "updatedAt": "2025-09-30T00:21:48.281Z",
      "correctAnswer": null,
      "isActive": true,
      "options": [],
      "topics": [
        "Scalability",
        "Load Balancing",
        "Database Design",
        "Microservices"
      ],
      "createdAt": "2025-09-30T00:21:48.281Z",
      "isComplete": false,
      "content": "How would you model the state for the chat conversation?",
      "codeBlock": "// TypeScript interfaces\ninterface Message {\n  id: string;\n  conversationId: string;\n  timestamp: Date;\n  type: 'user' | 'assistant';\n  content: string;\n  status?: 'sending' | 'sent' | 'error';\n}\n\ninterface ChatState {\n  userQuery: string;\n  conversation: Message[];\n  isConnected: boolean;\n  isTyping: boolean;\n  currentConversationId: string | null;\n}\n\n// React state implementation\nconst [chatState, setChatState] = useState<ChatState>({\n  userQuery: '',\n  conversation: [],\n  isConnected: false,\n  isTyping: false,\n  currentConversationId: null\n});",
      "title": "Chat Application State Modeling",
      "type": "code",
      "learningPaths": [
        "system-design"
      ],
      "importedAt": "2025-09-30T00:21:48.256Z",
      "source": "QuestionsBank",
      "difficulty": "intermediate"
    },
    {
      "id": "imported-system-design-1759191708255-4",
      "learningPaths": [
        "system-design"
      ],
      "content": "Explain different caching strategies and their implementation.",
      "isActive": true,
      "createdAt": "2025-09-30T00:21:48.281Z",
      "codeBlock": "class CacheAside {\n  constructor(cache, database) {\n    this.cache = cache;\n    this.db = database;\n  }\n\n  async get(key) {\n    // Try cache first\n    let value = await this.cache.get(key);\n    if (value) {\n      console.log('Cache hit for key:', key);\n      return value;\n    }\n\n    console.log('Cache miss for key:', key);\n    // Cache miss - get from database\n    value = await this.db.get(key);\n    if (value) {\n      // Update cache\n      await this.cache.set(key, value, 3600); // 1 hour TTL\n    }\n    return value;\n  }\n\n  async set(key, value) {\n    // Write to database\n    await this.db.set(key, value);\n    // Update cache\n    await this.cache.set(key, value, 3600);\n  }\n\n  async delete(key) {\n    // Delete from database\n    await this.db.delete(key);\n    // Delete from cache\n    await this.cache.delete(key);\n  }\n}",
      "topics": [
        "Scalability",
        "Load Balancing",
        "Database Design",
        "Microservices"
      ],
      "updatedAt": "2025-09-30T00:21:48.281Z",
      "correctAnswer": null,
      "title": "Caching Strategies",
      "isComplete": false,
      "explanation": "**1. Cache-Aside Pattern:**\n\nclass CacheAside {\nconstructor(cache, database) {\nthis.cache = cache;\nthis.db = database;\n}\n\nasync get(key) {\n// Try cache first\nlet value = await this.cache.get(key);\nif (value) {\nconsole.log('Cache hit for key:', key);\nreturn value;\n}\n\nconsole.log('Cache miss for key:', key);\n// Cache miss - get from database\nvalue = await this.db.get(key);\nif (value) {\n// Update cache\nawait this.cache.set(key, value, 3600); // 1 hour TTL\n}\nreturn value;\n}\n\nasync set(key, value) {\n// Write to database\nawait this.db.set(key, value);\n// Update cache\nawait this.cache.set(key, value, 3600);\n}\n\nasync delete(key) {\n// Delete from database\nawait this.db.delete(key);\n// Delete from cache\nawait this.cache.delete(key);\n}\n}\n\n**2. Write-Through Cache:**\n\nclass WriteThroughCache {\nconstructor(cache, database) {\nthis.cache = cache;\nthis.db = database;\n}\n\nasync set(key, value) {\n// Write to both cache and database\nawait Promise.all([\nthis.cache.set(key, value, 3600),\nthis.db.set(key, value),\n]);\n}\n\nasync get(key) {\n// Try cache first\nlet value = await this.cache.get(key);\nif (value) {\nreturn value;\n}\n\n// Cache miss - get from database\nvalue = await this.db.get(key);\nif (value) {\n// Update cache\nawait this.cache.set(key, value, 3600);\n}\nreturn value;\n}\n}\n\n**3. Write-Behind Cache:**\n\nclass WriteBehindCache {\nconstructor(cache, database) {\nthis.cache = cache;\nthis.db = database;\nthis.writeQueue = [];\nthis.batchSize = 100;\nthis.flushInterval = 5000; // 5 seconds\nthis.startBatchProcessor();\n}\n\nasync set(key, value) {\n// Write to cache immediately\nawait this.cache.set(key, value, 3600);\n\n// Queue for database write\nthis.writeQueue.push({ key, value, timestamp: Date.now() });\n\n// Flush if queue is full\nif (this.writeQueue.length >= this.batchSize) {\nawait this.flush();\n}\n}\n\nasync get(key) {\nreturn await this.cache.get(key);\n}\n\nstartBatchProcessor() {\nsetInterval(async () => {\nif (this.writeQueue.length > 0) {\nawait this.flush();\n}\n}, this.flushInterval);\n}\n\nasync flush() {\nif (this.writeQueue.length === 0) return;\n\nconst batch = this.writeQueue.splice(0, this.batchSize);\n\ntry {\n// Batch write to database\nawait this.db.batchWrite(batch);\nconsole.log(`Flushed ${batch.length} items to database`);\n} catch (error) {\nconsole.error('Batch write failed:', error);\n// Re-queue failed items\nthis.writeQueue.unshift(...batch);\n}\n}\n}\n\n**4. Cache Invalidation:**\n\nclass CacheInvalidation {\nconstructor(cache, database) {\nthis.cache = cache;\nthis.db = database;\nthis.invalidationPatterns = new Map();\n}\n\n// TTL-based invalidation\nasync setWithTTL(key, value, ttl) {\nawait this.cache.set(key, value, ttl);\n}\n\n// Event-based invalidation\nasync invalidateOnEvent(event, pattern) {\nthis.invalidationPatterns.set(event, pattern);\n}\n\nasync handleEvent(event, data) {\nconst pattern = this.invalidationPatterns.get(event);\nif (pattern) {\nawait this.invalidateByPattern(pattern, data);\n}\n}\n\nasync invalidateByPattern(pattern, data) {\nconst keys = await this.cache.keys(pattern);\nif (keys.length > 0) {\nawait this.cache.delete(...keys);\nconsole.log(\n`Invalidated ${keys.length} cache keys matching pattern: ${pattern}`\n);\n}\n}\n\n// Version-based invalidation\nasync setWithVersion(key, value, version) {\nconst versionedKey = `${key}:v${version}`;\nawait this.cache.set(versionedKey, value, 3600);\n\n// Store current version\nawait this.cache.set(`${key}:current`, version, 3600);\n}\n\nasync getWithVersion(key) {\nconst currentVersion = await this.cache.get(`${key}:current`);\nif (currentVersion) {\nconst versionedKey = `${key}:v${currentVersion}`;\nreturn await this.cache.get(versionedKey);\n}\nreturn null;\n}\n}",
      "difficulty": "intermediate",
      "type": "code",
      "importedAt": "2025-09-30T00:21:48.255Z",
      "options": [],
      "category": "System Design",
      "source": "QuestionsBank"
    },
    {
      "id": "imported-system-design-1759191708255-3",
      "content": "Explain microservices architecture and communication patterns.",
      "createdAt": "2025-09-30T00:21:48.281Z",
      "type": "code",
      "isComplete": false,
      "options": [],
      "category": "System Design",
      "importedAt": "2025-09-30T00:21:48.255Z",
      "codeBlock": "// Synchronous Communication (HTTP/REST)\nclass UserService {\n  constructor() {\n    this.baseURL = 'http://user-service:3001';\n  }\n\n  async getUser(userId) {\n    try {\n      const response = await fetch(`${this.baseURL}/users/${userId}`);\n      if (!response.ok) {\n        throw new Error(`HTTP error! status: ${response.status}`);\n      }\n      return await response.json();\n    } catch (error) {\n      console.error('Error fetching user:', error);\n      throw error;\n    }\n  }\n\n  async createUser(userData) {\n    const response = await fetch(`${this.baseURL}/users`, {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json',\n      },\n      body: JSON.stringify(userData),\n    });\n    return await response.json();\n  }\n}\n\n// Asynchronous Communication (Message Queue)\nclass OrderService {\n  constructor(messageQueue) {\n    this.messageQueue = messageQueue;\n    this.setupEventHandlers();\n  }\n\n  setupEventHandlers() {\n    // Listen for user events\n    this.messageQueue.subscribe(\n      'user.created',\n      this.handleUserCreated.bind(this)\n    );\n    this.messageQueue.subscribe(\n      'user.updated',\n      this.handleUserUpdated.bind(this)\n    );\n  }\n\n  async handleUserCreated(event) {\n    const { userId, userData } = event.payload;\n    // Create user profile in order service\n    await this.createUserProfile(userId, userData);\n  }\n\n  async handleUserUpdated(event) {\n    const { userId, userData } = event.payload;\n    // Update user profile in order service\n    await this.updateUserProfile(userId, userData);\n  }\n\n  async createOrder(orderData) {\n    // Create order\n    const order = await this.saveOrder(orderData);\n\n    // Publish event\n    await this.messageQueue.publish('order.created', {\n      orderId: order.id,\n      userId: order.userId,\n      amount: order.total,\n    });\n\n    return order;\n  }\n}",
      "explanation": "**1. Service Communication:**\n\n// Synchronous Communication (HTTP/REST)\nclass UserService {\nconstructor() {\nthis.baseURL = 'http://user-service:3001';\n}\n\nasync getUser(userId) {\ntry {\nconst response = await fetch(`${this.baseURL}/users/${userId}`);\nif (!response.ok) {\nthrow new Error(`HTTP error! status: ${response.status}`);\n}\nreturn await response.json();\n} catch (error) {\nconsole.error('Error fetching user:', error);\nthrow error;\n}\n}\n\nasync createUser(userData) {\nconst response = await fetch(`${this.baseURL}/users`, {\nmethod: 'POST',\nheaders: {\n'Content-Type': 'application/json',\n},\nbody: JSON.stringify(userData),\n});\nreturn await response.json();\n}\n}\n\n// Asynchronous Communication (Message Queue)\nclass OrderService {\nconstructor(messageQueue) {\nthis.messageQueue = messageQueue;\nthis.setupEventHandlers();\n}\n\nsetupEventHandlers() {\n// Listen for user events\nthis.messageQueue.subscribe(\n'user.created',\nthis.handleUserCreated.bind(this)\n);\nthis.messageQueue.subscribe(\n'user.updated',\nthis.handleUserUpdated.bind(this)\n);\n}\n\nasync handleUserCreated(event) {\nconst { userId, userData } = event.payload;\n// Create user profile in order service\nawait this.createUserProfile(userId, userData);\n}\n\nasync handleUserUpdated(event) {\nconst { userId, userData } = event.payload;\n// Update user profile in order service\nawait this.updateUserProfile(userId, userData);\n}\n\nasync createOrder(orderData) {\n// Create order\nconst order = await this.saveOrder(orderData);\n\n// Publish event\nawait this.messageQueue.publish('order.created', {\norderId: order.id,\nuserId: order.userId,\namount: order.total,\n});\n\nreturn order;\n}\n}\n\n**2. API Gateway:**\n\nclass APIGateway {\nconstructor(services) {\nthis.services = services;\nthis.routes = new Map();\nthis.setupRoutes();\n}\n\nsetupRoutes() {\n// User service routes\nthis.routes.set('/api/users', this.services.userService);\nthis.routes.set('/api/users/*', this.services.userService);\n\n// Order service routes\nthis.routes.set('/api/orders', this.services.orderService);\nthis.routes.set('/api/orders/*', this.services.orderService);\n\n// Product service routes\nthis.routes.set('/api/products', this.services.productService);\nthis.routes.set('/api/products/*', this.services.productService);\n}\n\nasync handleRequest(req, res) {\ntry {\n// Authentication\nconst user = await this.authenticate(req);\nif (!user) {\nreturn res.status(401).json({ error: 'Unauthorized' });\n}\n\n// Rate limiting\nif (!(await this.checkRateLimit(user.id))) {\nreturn res.status(429).json({ error: 'Rate limit exceeded' });\n}\n\n// Route to appropriate service\nconst service = this.findService(req.url);\nif (!service) {\nreturn res.status(404).json({ error: 'Service not found' });\n}\n\n// Forward request\nconst response = await service.handleRequest(req, user);\nres.json(response);\n} catch (error) {\nconsole.error('API Gateway error:', error);\nres.status(500).json({ error: 'Internal server error' });\n}\n}\n\nfindService(url) {\nfor (const [pattern, service] of this.routes) {\nif (url.startsWith(pattern.replace('*', ''))) {\nreturn service;\n}\n}\nreturn null;\n}\n}\n\n**3. Service Discovery:**\n\nclass ServiceRegistry {\nconstructor() {\nthis.services = new Map();\n}\n\nregister(serviceName, serviceInfo) {\nthis.services.set(serviceName, {\n...serviceInfo,\nregisteredAt: Date.now(),\nhealthCheck: serviceInfo.healthCheck || '/health',\n});\n}\n\ndiscover(serviceName) {\nconst service = this.services.get(serviceName);\nif (!service) {\nthrow new Error(`Service ${serviceName} not found`);\n}\nreturn service;\n}\n\nasync getHealthyInstance(serviceName) {\nconst service = this.discover(serviceName);\nconst instances = service.instances || [];\n\nfor (const instance of instances) {\ntry {\nconst response = await fetch(`${instance.url}${service.healthCheck}`);\nif (response.ok) {\nreturn instance;\n}\n} catch (error) {\nconsole.error(`Health check failed for ${instance.url}:`, error);\n}\n}\n\nthrow new Error(`No healthy instances found for ${serviceName}`);\n}\n}",
      "source": "QuestionsBank",
      "updatedAt": "2025-09-30T00:21:48.281Z",
      "topics": [
        "Scalability",
        "Load Balancing",
        "Database Design",
        "Microservices"
      ],
      "learningPaths": [
        "system-design"
      ],
      "difficulty": "intermediate",
      "correctAnswer": null,
      "isActive": true,
      "title": "Microservices Architecture"
    },
    {
      "id": "imported-system-design-1759191708255-2",
      "topics": [
        "Scalability",
        "Load Balancing",
        "Database Design",
        "Microservices"
      ],
      "options": [],
      "isComplete": false,
      "difficulty": "intermediate",
      "isActive": true,
      "source": "QuestionsBank",
      "explanation": "**1. Database Sharding:**\n\n// Horizontal Sharding\nclass ShardedDatabase {\nconstructor(shards) {\nthis.shards = shards;\n}\n\ngetShard(key) {\n// Simple hash-based sharding\nconst hash = this.hash(key);\nconst shardIndex = hash % this.shards.length;\nreturn this.shards[shardIndex];\n}\n\nhash(key) {\nlet hash = 0;\nfor (let i = 0; i < key.length; i++) {\nconst char = key.charCodeAt(i);\nhash = (hash << 5) - hash + char;\nhash = hash & hash; // Convert to 32-bit integer\n}\nreturn Math.abs(hash);\n}\n\nasync get(key) {\nconst shard = this.getShard(key);\nreturn await shard.get(key);\n}\n\nasync set(key, value) {\nconst shard = this.getShard(key);\nreturn await shard.set(key, value);\n}\n}\n\n// Range-based Sharding\nclass RangeShardedDatabase {\nconstructor(shards) {\nthis.shards = shards.sort((a, b) => a.range.start - b.range.start);\n}\n\ngetShard(key) {\nconst keyValue = parseInt(key);\nfor (const shard of this.shards) {\nif (keyValue >= shard.range.start && keyValue < shard.range.end) {\nreturn shard;\n}\n}\nthrow new Error(`No shard found for key: ${key}`);\n}\n}\n\n**2. Database Indexing:**\n\n-- Single column index\nCREATE INDEX idx_user_email ON users(email);\n\n-- Composite index\nCREATE INDEX idx_user_name_email ON users(last_name, first_name, email);\n\n-- Partial index\nCREATE INDEX idx_active_users ON users(email) WHERE status = 'active';\n\n-- Covering index\nCREATE INDEX idx_user_cover ON users(id, email, first_name, last_name);\n\n-- Query optimization\nEXPLAIN SELECT * FROM users WHERE email = 'user@example.com';\n\n**3. Database Normalization:**\n\n-- First Normal Form (1NF)\n-- Each column contains atomic values\nCREATE TABLE users (\nid INT PRIMARY KEY,\nname VARCHAR(100),\nemail VARCHAR(100)\n);\n\n-- Second Normal Form (2NF)\n-- Remove partial dependencies\nCREATE TABLE orders (\nid INT PRIMARY KEY,\nuser_id INT,\norder_date DATE,\nFOREIGN KEY (user_id) REFERENCES users(id)\n);\n\nCREATE TABLE order_items (\nid INT PRIMARY KEY,\norder_id INT,\nproduct_id INT,\nquantity INT,\nFOREIGN KEY (order_id) REFERENCES orders(id),\nFOREIGN KEY (product_id) REFERENCES products(id)\n);\n\n-- Third Normal Form (3NF)\n-- Remove transitive dependencies\nCREATE TABLE products (\nid INT PRIMARY KEY,\nname VARCHAR(100),\ncategory_id INT,\nFOREIGN KEY (category_id) REFERENCES categories(id)\n);\n\nCREATE TABLE categories (\nid INT PRIMARY KEY,\nname VARCHAR(100)\n);",
      "correctAnswer": null,
      "learningPaths": [
        "system-design"
      ],
      "title": "Database Design",
      "content": "Explain database design patterns and optimization strategies.",
      "category": "System Design",
      "codeBlock": "// Horizontal Sharding\nclass ShardedDatabase {\n  constructor(shards) {\n    this.shards = shards;\n  }\n\n  getShard(key) {\n    // Simple hash-based sharding\n    const hash = this.hash(key);\n    const shardIndex = hash % this.shards.length;\n    return this.shards[shardIndex];\n  }\n\n  hash(key) {\n    let hash = 0;\n    for (let i = 0; i < key.length; i++) {\n      const char = key.charCodeAt(i);\n      hash = (hash << 5) - hash + char;\n      hash = hash & hash; // Convert to 32-bit integer\n    }\n    return Math.abs(hash);\n  }\n\n  async get(key) {\n    const shard = this.getShard(key);\n    return await shard.get(key);\n  }\n\n  async set(key, value) {\n    const shard = this.getShard(key);\n    return await shard.set(key, value);\n  }\n}\n\n// Range-based Sharding\nclass RangeShardedDatabase {\n  constructor(shards) {\n    this.shards = shards.sort((a, b) => a.range.start - b.range.start);\n  }\n\n  getShard(key) {\n    const keyValue = parseInt(key);\n    for (const shard of this.shards) {\n      if (keyValue >= shard.range.start && keyValue < shard.range.end) {\n        return shard;\n      }\n    }\n    throw new Error(`No shard found for key: ${key}`);\n  }\n}",
      "importedAt": "2025-09-30T00:21:48.255Z",
      "updatedAt": "2025-09-30T00:21:48.281Z",
      "type": "code",
      "createdAt": "2025-09-30T00:21:48.281Z"
    },
    {
      "id": "imported-system-design-1759191708255-1",
      "topics": [
        "Scalability",
        "Load Balancing",
        "Database Design",
        "Microservices"
      ],
      "explanation": "**1. Load Balancing Algorithms:**\n\n// Round Robin\nclass RoundRobinLoadBalancer {\nconstructor(servers) {\nthis.servers = servers;\nthis.currentIndex = 0;\n}\n\ngetNextServer() {\nconst server = this.servers[this.currentIndex];\nthis.currentIndex = (this.currentIndex + 1) % this.servers.length;\nreturn server;\n}\n}\n\n// Weighted Round Robin\nclass WeightedRoundRobinLoadBalancer {\nconstructor(servers) {\nthis.servers = servers;\nthis.currentWeight = 0;\nthis.currentIndex = -1;\n}\n\ngetNextServer() {\nwhile (true) {\nthis.currentIndex = (this.currentIndex + 1) % this.servers.length;\nif (this.currentIndex === 0) {\nthis.currentWeight -= this.gcd();\nif (this.currentWeight <= 0) {\nthis.currentWeight = Math.max(...this.servers.map(s => s.weight));\n}\n}\n\nif (this.servers[this.currentIndex].weight >= this.currentWeight) {\nreturn this.servers[this.currentIndex];\n}\n}\n}\n\ngcd() {\nreturn this.servers.reduce((a, b) => this.gcdTwo(a, b.weight), 0);\n}\n\ngcdTwo(a, b) {\nreturn b === 0 ? a : this.gcdTwo(b, a % b);\n}\n}\n\n// Least Connections\nclass LeastConnectionsLoadBalancer {\nconstructor(servers) {\nthis.servers = servers.map(server => ({\n...server,\nconnections: 0,\n}));\n}\n\ngetNextServer() {\nconst server = this.servers.reduce((min, current) =>\ncurrent.connections < min.connections ? current : min\n);\nserver.connections++;\nreturn server;\n}\n\nreleaseConnection(server) {\nconst s = this.servers.find(s => s.id === server.id);\nif (s) s.connections--;\n}\n}\n\n**2. Health Checks:**\n\nclass HealthChecker {\nconstructor(servers, options = {}) {\nthis.servers = servers;\nthis.interval = options.interval || 30000; // 30 seconds\nthis.timeout = options.timeout || 5000; // 5 seconds\nthis.healthyServers = new Set();\nthis.startHealthChecks();\n}\n\nstartHealthChecks() {\nsetInterval(() => {\nthis.checkAllServers();\n}, this.interval);\n}\n\nasync checkAllServers() {\nconst promises = this.servers.map(server => this.checkServer(server));\nawait Promise.allSettled(promises);\n}\n\nasync checkServer(server) {\ntry {\nconst controller = new AbortController();\nconst timeoutId = setTimeout(() => controller.abort(), this.timeout);\n\nconst response = await fetch(`${server.url}/health`, {\nsignal: controller.signal,\nmethod: 'GET',\n});\n\nclearTimeout(timeoutId);\n\nif (response.ok) {\nthis.healthyServers.add(server.id);\n} else {\nthis.healthyServers.delete(server.id);\n}\n} catch (error) {\nthis.healthyServers.delete(server.id);\n}\n}\n\nisHealthy(server) {\nreturn this.healthyServers.has(server.id);\n}\n\ngetHealthyServers() {\nreturn this.servers.filter(server => this.isHealthy(server));\n}\n}",
      "correctAnswer": null,
      "isActive": true,
      "options": [],
      "learningPaths": [
        "system-design"
      ],
      "createdAt": "2025-09-30T00:21:48.281Z",
      "category": "System Design",
      "title": "Load Balancing",
      "source": "QuestionsBank",
      "codeBlock": "// Round Robin\nclass RoundRobinLoadBalancer {\n  constructor(servers) {\n    this.servers = servers;\n    this.currentIndex = 0;\n  }\n\n  getNextServer() {\n    const server = this.servers[this.currentIndex];\n    this.currentIndex = (this.currentIndex + 1) % this.servers.length;\n    return server;\n  }\n}\n\n// Weighted Round Robin\nclass WeightedRoundRobinLoadBalancer {\n  constructor(servers) {\n    this.servers = servers;\n    this.currentWeight = 0;\n    this.currentIndex = -1;\n  }\n\n  getNextServer() {\n    while (true) {\n      this.currentIndex = (this.currentIndex + 1) % this.servers.length;\n      if (this.currentIndex === 0) {\n        this.currentWeight -= this.gcd();\n        if (this.currentWeight <= 0) {\n          this.currentWeight = Math.max(...this.servers.map(s => s.weight));\n        }\n      }\n\n      if (this.servers[this.currentIndex].weight >= this.currentWeight) {\n        return this.servers[this.currentIndex];\n      }\n    }\n  }\n\n  gcd() {\n    return this.servers.reduce((a, b) => this.gcdTwo(a, b.weight), 0);\n  }\n\n  gcdTwo(a, b) {\n    return b === 0 ? a : this.gcdTwo(b, a % b);\n  }\n}\n\n// Least Connections\nclass LeastConnectionsLoadBalancer {\n  constructor(servers) {\n    this.servers = servers.map(server => ({\n      ...server,\n      connections: 0,\n    }));\n  }\n\n  getNextServer() {\n    const server = this.servers.reduce((min, current) =>\n      current.connections < min.connections ? current : min\n    );\n    server.connections++;\n    return server;\n  }\n\n  releaseConnection(server) {\n    const s = this.servers.find(s => s.id === server.id);\n    if (s) s.connections--;\n  }\n}",
      "updatedAt": "2025-09-30T00:21:48.281Z",
      "content": "Explain different load balancing algorithms and strategies.",
      "isComplete": false,
      "type": "code",
      "importedAt": "2025-09-30T00:21:48.255Z",
      "difficulty": "intermediate"
    },
    {
      "id": "imported-system-design-1759191708256-9",
      "isComplete": false,
      "topics": [
        "Scalability",
        "Load Balancing",
        "Database Design",
        "Microservices"
      ],
      "isActive": true,
      "createdAt": "2025-09-30T00:21:48.281Z",
      "difficulty": "intermediate",
      "source": "QuestionsBank",
      "correctAnswer": null,
      "content": "What are the primary state transitions in this chat application?",
      "category": "System Design",
      "type": "code",
      "explanation": "State transitions come from two sources:\n\n**User Interactions**: Typing in the input field (updates userQuery) and clicking the \"send\" button (clears userQuery and initiates an API call).\n\n**Backend Synchronization**: Listening for new data chunks from the server via Server-Sent Events and appending them to the conversation array.\n\n**State Transition Diagram:**\n\n// State transition mapping\nconst stateTransitions = {\n// User Interactions\nuserTyping: {\nfrom: { userQuery: 'any string' },\nto: { userQuery: 'new string' },\ntrigger: 'onChange event',\n},\n\nsendMessage: {\nfrom: { userQuery: 'non-empty string', conversation: 'any' },\nto: { userQuery: '', conversation: 'adds user message' },\ntrigger: 'onSubmit event',\nsideEffect: 'API call to /api/chat',\n},\n\n// Backend Synchronization\nreceiveChunk: {\nfrom: { conversation: 'any', isTyping: 'any' },\nto: { conversation: 'appends chunk', isTyping: true },\ntrigger: 'SSE message event',\n},\n\nstreamComplete: {\nfrom: { isTyping: true },\nto: { isTyping: false },\ntrigger: 'SSE close event',\n},\n\nconnectionLost: {\nfrom: { isConnected: true },\nto: { isConnected: false },\ntrigger: 'SSE error event',\n},\n\nconnectionRestored: {\nfrom: { isConnected: false },\nto: { isConnected: true },\ntrigger: 'SSE open event',\n},\n};\n\n**Implementation with React:**\n\n// User interaction handlers\nconst handleInputChange = (e: React.ChangeEvent<HTMLInputElement>) => {\nsetChatState(prev => ({\n...prev,\nuserQuery: e.target.value\n}));\n};\n\nconst handleSendMessage = async () => {\nif (!chatState.userQuery.trim()) return;\n\n// Add user message to conversation\nconst userMessage: Message = {\nid: generateId(),\nconversationId: chatState.currentConversationId,\ntimestamp: new Date(),\ntype: 'user',\ncontent: chatState.userQuery,\nstatus: 'sending'\n};\n\nsetChatState(prev => ({\n...prev,\nuserQuery: '',\nconversation: [...prev.conversation, userMessage]\n}));\n\n// Initiate API call\nawait sendMessageToAPI(userMessage);\n};\n\n// Backend synchronization\nuseEffect(() => {\nconst eventSource = new EventSource('/api/chat/stream');\n\neventSource.onmessage = (event) => {\nconst data = JSON.parse(event.data);\n\nif (data.type === 'chunk') {\nsetChatState(prev => ({\n...prev,\nisTyping: true,\nconversation: appendChunkToLastMessage(prev.conversation, data.content)\n}));\n} else if (data.type === 'complete') {\nsetChatState(prev => ({\n...prev,\nisTyping: false\n}));\n}\n};\n\neventSource.onopen = () => {\nsetChatState(prev => ({ ...prev, isConnected: true }));\n};\n\neventSource.onerror = () => {\nsetChatState(prev => ({ ...prev, isConnected: false }));\n};\n\nreturn () => {\neventSource.close();\n};\n}, []);",
      "learningPaths": [
        "system-design"
      ],
      "importedAt": "2025-09-30T00:21:48.256Z",
      "title": "State Transitions in Chat Application",
      "codeBlock": "// State transition mapping\nconst stateTransitions = {\n  // User Interactions\n  userTyping: {\n    from: { userQuery: 'any string' },\n    to: { userQuery: 'new string' },\n    trigger: 'onChange event',\n  },\n\n  sendMessage: {\n    from: { userQuery: 'non-empty string', conversation: 'any' },\n    to: { userQuery: '', conversation: 'adds user message' },\n    trigger: 'onSubmit event',\n    sideEffect: 'API call to /api/chat',\n  },\n\n  // Backend Synchronization\n  receiveChunk: {\n    from: { conversation: 'any', isTyping: 'any' },\n    to: { conversation: 'appends chunk', isTyping: true },\n    trigger: 'SSE message event',\n  },\n\n  streamComplete: {\n    from: { isTyping: true },\n    to: { isTyping: false },\n    trigger: 'SSE close event',\n  },\n\n  connectionLost: {\n    from: { isConnected: true },\n    to: { isConnected: false },\n    trigger: 'SSE error event',\n  },\n\n  connectionRestored: {\n    from: { isConnected: false },\n    to: { isConnected: true },\n    trigger: 'SSE open event',\n  },\n};",
      "options": [],
      "updatedAt": "2025-09-30T00:21:48.281Z"
    },
    {
      "id": "imported-system-design-1759191708256-5",
      "createdAt": "2025-09-30T00:21:48.281Z",
      "codeBlock": "-- Index optimization\nCREATE INDEX idx_user_email ON users(email);\nCREATE INDEX idx_order_user_date ON orders(user_id, order_date);\n\n-- Query optimization\n-- Bad: SELECT * FROM users WHERE email LIKE '%@gmail.com';\n-- Good: SELECT id, name, email FROM users WHERE email LIKE '%@gmail.com';\n\n-- Use EXPLAIN to analyze queries\nEXPLAIN SELECT * FROM users u\nJOIN orders o ON u.id = o.user_id\nWHERE u.email = 'user@example.com';\n\n-- Pagination\nSELECT * FROM users\nORDER BY created_at DESC\nLIMIT 20 OFFSET 0;\n\n-- Use cursor-based pagination for large datasets\nSELECT * FROM users\nWHERE created_at < '2023-01-01'\nORDER BY created_at DESC\nLIMIT 20;",
      "isActive": true,
      "category": "System Design",
      "updatedAt": "2025-09-30T00:21:48.281Z",
      "content": "Explain system performance optimization techniques.",
      "learningPaths": [
        "system-design"
      ],
      "topics": [
        "Scalability",
        "Load Balancing",
        "Database Design",
        "Microservices"
      ],
      "explanation": "**1. Database Query Optimization:**\n\n-- Index optimization\nCREATE INDEX idx_user_email ON users(email);\nCREATE INDEX idx_order_user_date ON orders(user_id, order_date);\n\n-- Query optimization\n-- Bad: SELECT * FROM users WHERE email LIKE '%@gmail.com';\n-- Good: SELECT id, name, email FROM users WHERE email LIKE '%@gmail.com';\n\n-- Use EXPLAIN to analyze queries\nEXPLAIN SELECT * FROM users u\nJOIN orders o ON u.id = o.user_id\nWHERE u.email = 'user@example.com';\n\n-- Pagination\nSELECT * FROM users\nORDER BY created_at DESC\nLIMIT 20 OFFSET 0;\n\n-- Use cursor-based pagination for large datasets\nSELECT * FROM users\nWHERE created_at < '2023-01-01'\nORDER BY created_at DESC\nLIMIT 20;\n\n**2. Connection Pooling:**\n\nclass ConnectionPool {\nconstructor(config) {\nthis.config = config;\nthis.pool = [];\nthis.maxConnections = config.maxConnections || 10;\nthis.minConnections = config.minConnections || 2;\nthis.initializePool();\n}\n\nasync initializePool() {\nfor (let i = 0; i < this.minConnections; i++) {\nconst connection = await this.createConnection();\nthis.pool.push(connection);\n}\n}\n\nasync getConnection() {\n// Try to get existing connection\nif (this.pool.length > 0) {\nreturn this.pool.pop();\n}\n\n// Create new connection if under limit\nif (this.pool.length < this.maxConnections) {\nreturn await this.createConnection();\n}\n\n// Wait for connection to become available\nreturn await this.waitForConnection();\n}\n\nreleaseConnection(connection) {\nif (this.pool.length < this.maxConnections) {\nthis.pool.push(connection);\n} else {\nconnection.close();\n}\n}\n\nasync waitForConnection() {\nreturn new Promise(resolve => {\nconst checkPool = () => {\nif (this.pool.length > 0) {\nresolve(this.pool.pop());\n} else {\nsetTimeout(checkPool, 100);\n}\n};\ncheckPool();\n});\n}\n}\n\n**3. Asynchronous Processing:**\n\nclass AsyncProcessor {\nconstructor(options = {}) {\nthis.concurrency = options.concurrency || 5;\nthis.queue = [];\nthis.processing = new Set();\n}\n\nasync addTask(task) {\nreturn new Promise((resolve, reject) => {\nthis.queue.push({\ntask,\nresolve,\nreject,\n});\nthis.processNext();\n});\n}\n\nasync processNext() {\nif (this.processing.size >= this.concurrency || this.queue.length === 0) {\nreturn;\n}\n\nconst { task, resolve, reject } = this.queue.shift();\nconst taskId = Date.now() + Math.random();\n\nthis.processing.add(taskId);\n\ntry {\nconst result = await task();\nresolve(result);\n} catch (error) {\nreject(error);\n} finally {\nthis.processing.delete(taskId);\nthis.processNext();\n}\n}\n}\n\n// Usage\nconst processor = new AsyncProcessor({ concurrency: 3 });\n\n// Add tasks\nprocessor.addTask(async () => {\nawait processUserData();\nreturn 'User data processed';\n});\n\nprocessor.addTask(async () => {\nawait sendEmail();\nreturn 'Email sent';\n});\n\n**4. Monitoring and Metrics:**\n\nclass PerformanceMonitor {\nconstructor() {\nthis.metrics = new Map();\nthis.startTime = Date.now();\n}\n\nstartTimer(name) {\nthis.metrics.set(name, { start: Date.now() });\n}\n\nendTimer(name) {\nconst metric = this.metrics.get(name);\nif (metric) {\nmetric.duration = Date.now() - metric.start;\nmetric.end = Date.now();\n}\n}\n\nrecordMetric(name, value) {\nif (!this.metrics.has(name)) {\nthis.metrics.set(name, []);\n}\nthis.metrics.get(name).push({\nvalue,\ntimestamp: Date.now(),\n});\n}\n\ngetMetrics() {\nconst result = {};\nfor (const [name, data] of this.metrics) {\nif (Array.isArray(data)) {\nresult[name] = {\ncount: data.length,\naverage:\ndata.reduce((sum, item) => sum + item.value, 0) / data.length,\nlatest: data[data.length - 1]?.value,\n};\n} else {\nresult[name] = data;\n}\n}\nreturn result;\n}\n\n// Middleware for Express\nmiddleware() {\nreturn (req, res, next) => {\nconst start = Date.now();\n\nres.on('finish', () => {\nconst duration = Date.now() - start;\nthis.recordMetric('response_time', duration);\nthis.recordMetric(\n`response_time_${req.method}_${req.route?.path || req.path}`,\nduration\n);\n});\n\nnext();\n};\n}\n}",
      "difficulty": "intermediate",
      "source": "QuestionsBank",
      "type": "code",
      "isComplete": false,
      "correctAnswer": null,
      "options": [],
      "importedAt": "2025-09-30T00:21:48.256Z",
      "title": "Performance Optimization"
    },
    {
      "id": "imported-system-design-1759191708255-0",
      "title": "Scalability Patterns",
      "options": [],
      "content": "Explain different scalability patterns and when to use them.",
      "learningPaths": [
        "system-design"
      ],
      "correctAnswer": null,
      "category": "System Design",
      "codeBlock": "// Vertical Scaling (Scale Up)\n// Add more resources to existing server\nconst server = {\n  cpu: '8 cores',\n  ram: '32GB',\n  storage: '1TB SSD',\n};\n\n// Horizontal Scaling (Scale Out)\n// Add more servers\nconst servers = [\n  { id: 1, cpu: '4 cores', ram: '16GB' },\n  { id: 2, cpu: '4 cores', ram: '16GB' },\n  { id: 3, cpu: '4 cores', ram: '16GB' },\n];\n\n// Load balancer configuration\nconst loadBalancer = {\n  algorithm: 'round-robin',\n  healthCheck: '/health',\n  servers: servers,\n};",
      "topics": [
        "Scalability",
        "Load Balancing",
        "Database Design",
        "Microservices"
      ],
      "explanation": "**1. Horizontal vs Vertical Scaling:**\n\n// Vertical Scaling (Scale Up)\n// Add more resources to existing server\nconst server = {\ncpu: '8 cores',\nram: '32GB',\nstorage: '1TB SSD',\n};\n\n// Horizontal Scaling (Scale Out)\n// Add more servers\nconst servers = [\n{ id: 1, cpu: '4 cores', ram: '16GB' },\n{ id: 2, cpu: '4 cores', ram: '16GB' },\n{ id: 3, cpu: '4 cores', ram: '16GB' },\n];\n\n// Load balancer configuration\nconst loadBalancer = {\nalgorithm: 'round-robin',\nhealthCheck: '/health',\nservers: servers,\n};\n\n**2. Database Scaling:**\n\n// Read Replicas\nconst masterDB = {\nhost: 'master-db.example.com',\nrole: 'write',\n};\n\nconst readReplicas = [\n{ host: 'replica-1.example.com', role: 'read' },\n{ host: 'replica-2.example.com', role: 'read' },\n{ host: 'replica-3.example.com', role: 'read' },\n];\n\n// Database connection strategy\nclass DatabaseConnection {\nconstructor() {\nthis.master = masterDB;\nthis.replicas = readReplicas;\nthis.currentReplica = 0;\n}\n\ngetWriteConnection() {\nreturn this.master;\n}\n\ngetReadConnection() {\nconst replica = this.replicas[this.currentReplica];\nthis.currentReplica = (this.currentReplica + 1) % this.replicas.length;\nreturn replica;\n}\n}\n\n**3. Caching Strategies:**\n\n// Cache-Aside Pattern\nclass CacheAside {\nconstructor(cache, database) {\nthis.cache = cache;\nthis.db = database;\n}\n\nasync get(key) {\n// Try cache first\nlet value = await this.cache.get(key);\nif (value) {\nreturn value;\n}\n\n// Cache miss - get from database\nvalue = await this.db.get(key);\nif (value) {\nawait this.cache.set(key, value, 3600); // 1 hour TTL\n}\nreturn value;\n}\n\nasync set(key, value) {\n// Write to database\nawait this.db.set(key, value);\n// Update cache\nawait this.cache.set(key, value, 3600);\n}\n}\n\n// Write-Through Cache\nclass WriteThroughCache {\nconstructor(cache, database) {\nthis.cache = cache;\nthis.db = database;\n}\n\nasync set(key, value) {\n// Write to both cache and database\nawait Promise.all([\nthis.cache.set(key, value, 3600),\nthis.db.set(key, value),\n]);\n}\n}",
      "isActive": true,
      "source": "QuestionsBank",
      "updatedAt": "2025-09-30T00:21:48.281Z",
      "type": "code",
      "createdAt": "2025-09-30T00:21:48.281Z",
      "isComplete": false,
      "importedAt": "2025-09-30T00:21:48.255Z",
      "difficulty": "intermediate"
    }
  ]
}