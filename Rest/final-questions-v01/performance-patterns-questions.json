[
  {
    "id": "performance-patterns-import-on-visibility-10",
    "title": "Which browser API can be used to detect when an element enters the viewport?",
    "content": "The IntersectionObserver API lets developers detect when elements intersect with the viewport and trigger actions like lazy loading.",
    "type": "multiple-choice",
    "category": "Performance Patterns",
    "topic": "Browser APIs",
    "difficulty": "intermediate",
    "learningCardId": "system-design",
    "isActive": true,
    "createdAt": "2025-10-10",
    "updatedAt": "2025-11-11T18:50:32.209Z",
    "createdBy": "admin",
    "updatedBy": "admin",
    "tags": [
      "performance-patterns",
      "browser-apis",
      "intermediate"
    ],
    "explanation": "IntersectionObserver efficiently tracks element visibility changes without heavy scroll listeners.",
    "points": 10,
    "options": [
      {
        "id": "o1",
        "text": "ResizeObserver",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "o2",
        "text": "IntersectionObserver",
        "isCorrect": true,
        "explanation": ""
      },
      {
        "id": "o3",
        "text": "MutationObserver",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "o4",
        "text": "EventTarget",
        "isCorrect": false,
        "explanation": ""
      }
    ],
    "sampleAnswers": [
      "IntersectionObserver"
    ],
    "hints": [],
    "metadata": {}
  },
  {
    "id": "performance-patterns-loading-sequence-10",
    "title": "Avoiding Preload Overuse",
    "content": "Why should developers avoid overusing the preload directive?",
    "type": "multiple-choice",
    "category": "Performance Patterns",
    "topic": "Browser Optimization",
    "difficulty": "intermediate",
    "learningCardId": "system-design",
    "isActive": true,
    "createdAt": "2025-10-10T00:00:00Z",
    "updatedAt": "2025-11-11T18:50:32.218Z",
    "createdBy": "admin",
    "updatedBy": "admin",
    "tags": [
      "performance-patterns",
      "browser-optimization",
      "intermediate"
    ],
    "explanation": "Overusing preload can cause browsers to fetch unnecessary resources too early, increasing network congestion and reducing performance.",
    "points": 10,
    "options": [
      {
        "id": "o1",
        "text": "It can cause the browser to download unnecessary resources early",
        "isCorrect": true,
        "explanation": ""
      },
      {
        "id": "o2",
        "text": "It improves caching too much",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "o3",
        "text": "It automatically prioritizes resources correctly",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "o4",
        "text": "It blocks all async scripts",
        "isCorrect": false,
        "explanation": ""
      }
    ],
    "sampleAnswers": [
      "It can cause the browser to download unnecessary resources early"
    ],
    "hints": [],
    "metadata": {}
  },
  {
    "id": "performance-patterns-pre-load-7",
    "title": "Preload in Chrome 95+",
    "content": "How did Chrome 95+ improve the safety of using preload?",
    "type": "multiple-choice",
    "category": "Performance Patterns",
    "topic": "Browser Optimization",
    "difficulty": "intermediate",
    "learningCardId": "system-design",
    "isActive": true,
    "createdAt": "2025-10-10T00:00:00Z",
    "updatedAt": "2025-11-11T18:50:32.240Z",
    "createdBy": "admin",
    "updatedBy": "admin",
    "tags": [
      "performance-patterns",
      "browser-optimization",
      "intermediate"
    ],
    "explanation": "Chrome 95+ fixed queue-jumping behavior, making preload order more predictable relative to other resources.",
    "points": 10,
    "options": [
      {
        "id": "o1",
        "text": "It made preload ordering more consistent and less likely to block critical resources.",
        "isCorrect": true,
        "explanation": "Chrome 95+ fixed queue-jumping behavior, making preload order more predictable relative to other resources."
      },
      {
        "id": "o2",
        "text": "This is not correct. Please refer to the explanation.",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "o3",
        "text": "Incorrect. Review performance optimization concepts.",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "o4",
        "text": "This is a common misconception. The correct answer is different.",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "o5",
        "text": "Not quite. Consider web performance best practices.",
        "isCorrect": false,
        "explanation": ""
      }
    ],
    "sampleAnswers": [
      "It made preload ordering more consistent and less likely to block critical resources."
    ],
    "hints": [],
    "metadata": {}
  },
  {
    "id": "performance-patterns-dynamic-import-14",
    "title": "How much was the bundle size reduced by using dynamic import for EmojiPicker?",
    "content": "By dynamically importing EmojiPicker, the initial bundle size was reduced from 1.5 MiB to 1.33 MiB.",
    "type": "multiple-choice",
    "category": "Performance Patterns",
    "topic": "Bundle Optimization",
    "difficulty": "intermediate",
    "learningCardId": "system-design",
    "isActive": true,
    "createdAt": "2025-10-10T00:00:00Z",
    "updatedAt": "2025-11-11T18:50:32.188Z",
    "createdBy": "admin",
    "updatedBy": "admin",
    "tags": [
      "performance-patterns",
      "bundle-optimization",
      "intermediate"
    ],
    "explanation": "The example reduced the main bundle from 1.5 MiB to 1.33 MiB by deferring the loading of EmojiPicker.",
    "points": 10,
    "options": [
      {
        "id": "o1",
        "text": "From 1.5 MiB to 1.2 MiB",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "o2",
        "text": "From 1.5 MiB to 1.33 MiB",
        "isCorrect": true,
        "explanation": ""
      },
      {
        "id": "o3",
        "text": "From 1.3 MiB to 1.1 MiB",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "o4",
        "text": "From 2 MiB to 1.5 MiB",
        "isCorrect": false,
        "explanation": ""
      }
    ],
    "sampleAnswers": [
      "From 1.5 MiB to 1.33 MiB"
    ],
    "hints": [],
    "metadata": {}
  },
  {
    "id": "performance-patterns-performance-1-pp11",
    "title": "Which tools or techniques can help automate Bundle Splitting in modern web projects?",
    "content": "Select the correct tools or features that support automatic bundle splitting.",
    "type": "multiple-choice",
    "category": "Performance Patterns",
    "topic": "Bundle Splitting Tools",
    "difficulty": "advanced",
    "learningCardId": "system-design",
    "isActive": true,
    "createdAt": "2025-10-10T00:00:00.000Z",
    "updatedAt": "2025-11-11T18:50:32.225Z",
    "createdBy": "admin",
    "updatedBy": "admin",
    "tags": [
      "performance-patterns",
      "bundle-splitting-tools",
      "advanced"
    ],
    "explanation": "Tools like Webpack’s SplitChunksPlugin, Rollup, and modern bundlers like Vite handle automatic code-splitting and lazy loading integration.",
    "points": 10,
    "options": [
      {
        "id": "o1",
        "text": "Webpack's `SplitChunksPlugin`",
        "isCorrect": true,
        "explanation": ""
      },
      {
        "id": "o2",
        "text": "Vite’s pre-bundling mechanism (esbuild)",
        "isCorrect": true,
        "explanation": ""
      },
      {
        "id": "o3",
        "text": "React.lazy() + Suspense",
        "isCorrect": true,
        "explanation": ""
      },
      {
        "id": "o4",
        "text": "HTML inline scripts",
        "isCorrect": false,
        "explanation": ""
      }
    ],
    "hints": [],
    "metadata": {}
  },
  {
    "id": "performance-patterns-tree-shaking-ts1",
    "title": "What is tree shaking in JavaScript?",
    "content": "Define tree shaking and its main purpose.",
    "type": "multiple-choice",
    "category": "Performance Patterns",
    "topic": "Code Optimization",
    "difficulty": "intermediate",
    "learningCardId": "system-design",
    "isActive": true,
    "createdAt": "2025-10-11T00:00:00.000Z",
    "updatedAt": "2025-11-11T18:50:32.264Z",
    "createdBy": "admin",
    "updatedBy": "admin",
    "tags": [
      "performance-patterns",
      "tree-shaking",
      "beginner",
      "intermediate"
    ],
    "explanation": "Tree shaking is the process of eliminating unused code from the final JavaScript bundle to reduce size, download, parse, and execution time.",
    "points": 10,
    "sampleAnswers": [
      "Tree shaking is the process of eliminating unused code from the final JavaScript bundle to reduce size, download, parse, and execution time."
    ],
    "hints": [],
    "metadata": {},
    "options": [
      {
        "id": "o1",
        "text": "Tree shaking is the process of eliminating unused code from the final JavaScript bundle to reduce size, download, parse, and execution time.",
        "isCorrect": true,
        "explanation": "Tree shaking is the process of eliminating unused code from the final JavaScript bundle to reduce size, download, parse, and execution time."
      },
      {
        "id": "o2",
        "text": "This is not correct. Please refer to the explanation.",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "o3",
        "text": "Incorrect. Review performance optimization concepts.",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "o4",
        "text": "This is a common misconception. The correct answer is different.",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "o5",
        "text": "Not quite. Consider web performance best practices.",
        "isCorrect": false,
        "explanation": ""
      }
    ]
  },
  {
    "id": "performance-patterns-tree-shaking-ts2",
    "title": "True or False: Tree shaking works with CommonJS modules.",
    "content": "Evaluate whether tree shaking can remove dead code from CommonJS modules.",
    "type": "multiple-choice",
    "category": "Performance Patterns",
    "topic": "Code Optimization",
    "difficulty": "intermediate",
    "learningCardId": "system-design",
    "isActive": true,
    "createdAt": "2025-10-11T00:00:00.000Z",
    "updatedAt": "2025-11-11T18:50:32.264Z",
    "createdBy": "admin",
    "updatedBy": "admin",
    "tags": [
      "performance-patterns",
      "tree-shaking-modules",
      "beginner",
      "intermediate"
    ],
    "explanation": "The correct answer is: False",
    "points": 10,
    "options": [
      {
        "id": "o1",
        "text": "True",
        "isCorrect": false,
        "explanation": "Tree shaking only works reliably with ES2015 (ES6) modules using import/export syntax."
      },
      {
        "id": "o2",
        "text": "False",
        "isCorrect": false,
        "explanation": "Tree shaking only works reliably with ES2015 (ES6) modules using import/export syntax."
      },
      {
        "id": "o3",
        "text": "Partially true - depends on the context",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "o4",
        "text": "Not applicable",
        "isCorrect": false,
        "explanation": ""
      }
    ],
    "hints": [],
    "metadata": {}
  },
  {
    "id": "performance-patterns-dynamic-import-11",
    "title": "What problem does dynamic import solve in the chat application example?",
    "content": "Dynamic import prevents loading unnecessary modules like EmojiPicker on the initial render, reducing bundle size and improving load performance.",
    "type": "multiple-choice",
    "category": "Performance Patterns",
    "topic": "Code Splitting and Lazy Loading",
    "difficulty": "intermediate",
    "learningCardId": "system-design",
    "isActive": true,
    "createdAt": "2025-10-10T00:00:00Z",
    "updatedAt": "2025-11-11T18:50:32.187Z",
    "createdBy": "admin",
    "updatedBy": "admin",
    "tags": [
      "performance-patterns",
      "code-splitting-and-lazy-loading",
      "beginner",
      "intermediate"
    ],
    "explanation": "Dynamic imports allow you to load components only when needed, reducing initial bundle size and improving first render speed.",
    "points": 10,
    "options": [
      {
        "id": "o1",
        "text": "It makes all modules load immediately",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "o2",
        "text": "It avoids unnecessary loading of non-critical modules",
        "isCorrect": true,
        "explanation": ""
      },
      {
        "id": "o3",
        "text": "It disables code splitting",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "o4",
        "text": "It improves SEO",
        "isCorrect": false,
        "explanation": ""
      }
    ],
    "sampleAnswers": [
      "It avoids unnecessary loading of non-critical modules"
    ],
    "hints": [],
    "metadata": {}
  },
  {
    "id": "performance-patterns-bundle-splitting-pp1",
    "title": "What is Bundle Splitting?",
    "content": "### Bundle Splitting\nBundle Splitting is a performance optimization technique that divides a large JavaScript bundle into smaller chunks. Instead of loading one huge file containing all code (even unused code), the application loads only what’s required for the current view.\n\n**Example:**\nSplitting <code>main.bundle.js</code> into <code>main.bundle.js</code> and <code>emoji-picker.bundle.js</code> reduces initial load time by fetching less data.\n\n**Why it matters:**\n- Reduces time to First Contentful Paint (FCP) and Largest Contentful Paint (LCP)\n- Decreases loading and execution time\n- Improves Time To Interactive (TTI)\n\n**Goal:** Deliver visible and interactive content to the user faster by minimizing unnecessary code loading.",
    "type": "multiple-choice",
    "category": "Performance Patterns",
    "topic": "Code Splitting",
    "difficulty": "intermediate",
    "learningCardId": "system-design",
    "isActive": true,
    "createdAt": "2025-10-10T00:00:00.000Z",
    "updatedAt": "2025-11-11T18:50:32.133Z",
    "createdBy": "admin",
    "updatedBy": "admin",
    "tags": [
      "performance-patterns",
      "bundle-splitting",
      "intermediate"
    ],
    "explanation": "Bundle Splitting divides a large JavaScript file into smaller bundles so the browser loads only necessary code for the current route or view, improving load performance.",
    "points": 10,
    "sampleAnswers": [
      "Bundle Splitting divides a large JavaScript file into smaller bundles so the browser loads only necessary code for the current route or view, improving load performance."
    ],
    "hints": [],
    "metadata": {},
    "options": [
      {
        "id": "o1",
        "text": "Bundle Splitting divides a large JavaScript file into smaller bundles so the browser loads only necessary code for the current route or view, improving load performance.",
        "isCorrect": true,
        "explanation": "Bundle Splitting divides a large JavaScript file into smaller bundles so the browser loads only necessary code for the current route or view, improving load performance."
      },
      {
        "id": "o2",
        "text": "This is not correct. Please refer to the explanation.",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "o3",
        "text": "Incorrect. Review performance optimization concepts.",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "o4",
        "text": "This is a common misconception. The correct answer is different.",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "o5",
        "text": "Not quite. Consider web performance best practices.",
        "isCorrect": false,
        "explanation": ""
      }
    ]
  },
  {
    "id": "performance-patterns-bundle-splitting-pp2",
    "title": "What are the main benefits of Bundle Splitting?",
    "content": "Select all benefits that result from splitting your bundle into smaller chunks.",
    "type": "multiple-choice",
    "category": "Performance Patterns",
    "topic": "Code Splitting",
    "difficulty": "intermediate",
    "learningCardId": "system-design",
    "isActive": true,
    "createdAt": "2025-10-10T00:00:00.000Z",
    "updatedAt": "2025-11-11T18:50:32.157Z",
    "createdBy": "admin",
    "updatedBy": "admin",
    "tags": [
      "performance-patterns",
      "bundle-splitting",
      "beginner",
      "intermediate"
    ],
    "explanation": "Splitting bundles reduces loading and execution times, improving FCP, LCP, and TTI metrics—especially for low-end devices or slow networks.",
    "points": 10,
    "options": [
      {
        "id": "o1",
        "text": "Reduced time to First Contentful Paint (FCP)",
        "isCorrect": true,
        "explanation": ""
      },
      {
        "id": "o2",
        "text": "Reduced Time To Interactive (TTI)",
        "isCorrect": true,
        "explanation": ""
      },
      {
        "id": "o3",
        "text": "Larger initial download size",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "o4",
        "text": "Improved perceived performance on slower networks",
        "isCorrect": true,
        "explanation": ""
      }
    ],
    "hints": [],
    "metadata": {}
  },
  {
    "id": "performance-patterns-bundle-splitting-pp3",
    "title": "True or False: Bundle Splitting reduces the total amount of JavaScript your app needs to execute.",
    "content": "Evaluate this statement based on the performance pattern.",
    "type": "multiple-choice",
    "category": "Performance Patterns",
    "topic": "Code Splitting",
    "difficulty": "intermediate",
    "learningCardId": "system-design",
    "isActive": true,
    "createdAt": "2025-10-10T00:00:00.000Z",
    "updatedAt": "2025-11-11T18:50:32.164Z",
    "createdBy": "admin",
    "updatedBy": "admin",
    "tags": [
      "performance-patterns",
      "bundle-splitting",
      "beginner",
      "intermediate"
    ],
    "explanation": "The correct answer is: False",
    "points": 10,
    "options": [
      {
        "id": "o1",
        "text": "True",
        "isCorrect": false,
        "explanation": "The total code size remains the same; bundle splitting optimizes loading sequence, not total size."
      },
      {
        "id": "o2",
        "text": "False",
        "isCorrect": false,
        "explanation": "The total code size remains the same; bundle splitting optimizes loading sequence, not total size."
      },
      {
        "id": "o3",
        "text": "Partially true - depends on the context",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "o4",
        "text": "Not applicable",
        "isCorrect": false,
        "explanation": ""
      }
    ],
    "hints": [],
    "metadata": {}
  },
  {
    "id": "performance-patterns-bundle-splitting-pp4",
    "title": "Which performance metrics are most directly improved by Bundle Splitting?",
    "content": "Identify which performance metrics benefit most from applying bundle splitting.",
    "type": "multiple-choice",
    "category": "Performance Patterns",
    "topic": "Code Splitting",
    "difficulty": "intermediate",
    "learningCardId": "system-design",
    "isActive": true,
    "createdAt": "2025-10-10T00:00:00.000Z",
    "updatedAt": "2025-11-11T18:50:32.164Z",
    "createdBy": "admin",
    "updatedBy": "admin",
    "tags": [
      "performance-patterns",
      "bundle-splitting",
      "intermediate"
    ],
    "explanation": "FCP, LCP, and TTI improve as less code needs to be parsed and executed before meaningful content appears.",
    "points": 10,
    "options": [
      {
        "id": "m1",
        "text": "First Contentful Paint (FCP)",
        "isCorrect": true,
        "explanation": ""
      },
      {
        "id": "m2",
        "text": "Largest Contentful Paint (LCP)",
        "isCorrect": true,
        "explanation": ""
      },
      {
        "id": "m3",
        "text": "Cumulative Layout Shift (CLS)",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "m4",
        "text": "Time To Interactive (TTI)",
        "isCorrect": true,
        "explanation": ""
      }
    ],
    "hints": [],
    "metadata": {}
  },
  {
    "id": "performance-patterns-bundle-splitting-pp5",
    "title": "What problem does Bundle Splitting aim to solve?",
    "content": "### Problem Description\nLarge bundles can delay the time it takes before the browser paints the first visible content and becomes interactive. Even unused code has to be downloaded and parsed before rendering.\n\n**Question:**\nWhat core issue does bundle splitting address in modern web applications?",
    "type": "multiple-choice",
    "category": "Performance Patterns",
    "topic": "Code Splitting",
    "difficulty": "intermediate",
    "learningCardId": "system-design",
    "isActive": true,
    "createdAt": "2025-10-10T00:00:00.000Z",
    "updatedAt": "2025-11-11T18:50:32.164Z",
    "createdBy": "admin",
    "updatedBy": "admin",
    "tags": [
      "performance-patterns",
      "bundle-splitting",
      "intermediate"
    ],
    "explanation": "Bundle splitting addresses slow load times caused by downloading and parsing large monolithic bundles that contain code not needed on initial render.",
    "points": 10,
    "sampleAnswers": [
      "Bundle splitting addresses slow load times caused by downloading and parsing large monolithic bundles that contain code not needed on initial render."
    ],
    "hints": [],
    "metadata": {},
    "options": [
      {
        "id": "o1",
        "text": "Bundle splitting addresses slow load times caused by downloading and parsing large monolithic bundles that contain code not needed on initial render.",
        "isCorrect": true,
        "explanation": "Bundle splitting addresses slow load times caused by downloading and parsing large monolithic bundles that contain code not needed on initial render."
      },
      {
        "id": "o2",
        "text": "This is not correct. Please refer to the explanation.",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "o3",
        "text": "Incorrect. Review performance optimization concepts.",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "o4",
        "text": "This is a common misconception. The correct answer is different.",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "o5",
        "text": "Not quite. Consider web performance best practices.",
        "isCorrect": false,
        "explanation": ""
      }
    ]
  },
  {
    "id": "performance-patterns-performance-1-pp7",
    "title": "How does Dynamic Import relate to Bundle Splitting?",
    "content": "### Dynamic Import\nDynamic imports allow us to load JavaScript modules only when needed rather than at initial load. This enables bundle splitting by creating separate chunks for on-demand code.\n\n**Example:**\n<pre><code>import('./EmojiPicker').then(module =&gt; {\n  const EmojiPicker = module.default;\n  render(&lt;EmojiPicker /&gt;);\n});</code></pre>\n\n**Question:**\nExplain how dynamic import statements contribute to bundle splitting and performance optimization.",
    "type": "multiple-choice",
    "category": "Performance Patterns",
    "topic": "Code Splitting",
    "difficulty": "advanced",
    "learningCardId": "system-design",
    "isActive": true,
    "createdAt": "2025-10-10T00:00:00.000Z",
    "updatedAt": "2025-11-11T18:50:32.225Z",
    "createdBy": "admin",
    "updatedBy": "admin",
    "tags": [
      "performance-patterns",
      "dynamic-import",
      "advanced"
    ],
    "explanation": "Dynamic imports allow JavaScript modules to be fetched on demand, automatically creating separate bundles for lazy-loaded components and reducing initial load size.",
    "points": 10,
    "sampleAnswers": [
      "Dynamic imports allow JavaScript modules to be fetched on demand, automatically creating separate bundles for lazy-loaded components and reducing initial load size."
    ],
    "hints": [],
    "metadata": {},
    "options": [
      {
        "id": "o1",
        "text": "Dynamic imports allow JavaScript modules to be fetched on demand, automatically creating separate bundles for lazy-loaded components and reducing initial load size.",
        "isCorrect": true,
        "explanation": "Dynamic imports allow JavaScript modules to be fetched on demand, automatically creating separate bundles for lazy-loaded components and reducing initial load size."
      },
      {
        "id": "o2",
        "text": "This is not correct. Please refer to the explanation.",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "o3",
        "text": "Incorrect. Review performance optimization concepts.",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "o4",
        "text": "This is a common misconception. The correct answer is different.",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "o5",
        "text": "Not quite. Consider web performance best practices.",
        "isCorrect": false,
        "explanation": ""
      }
    ]
  },
  {
    "id": "performance-patterns-performance-1-pp8",
    "title": "Which of the following statements about Dynamic Import are true?",
    "content": "Select all correct statements related to dynamic imports and bundle splitting.",
    "type": "multiple-choice",
    "category": "Performance Patterns",
    "topic": "Code Splitting",
    "difficulty": "intermediate",
    "learningCardId": "system-design",
    "isActive": true,
    "createdAt": "2025-10-10T00:00:00.000Z",
    "updatedAt": "2025-11-11T18:50:32.225Z",
    "createdBy": "admin",
    "updatedBy": "admin",
    "tags": [
      "performance-patterns",
      "dynamic-import",
      "intermediate"
    ],
    "explanation": "Dynamic imports are asynchronous and allow bundlers like Webpack to split code into separate chunks that load only when needed, improving perceived performance.",
    "points": 10,
    "options": [
      {
        "id": "o1",
        "text": "Dynamic imports return a Promise that resolves to the requested module.",
        "isCorrect": true,
        "explanation": ""
      },
      {
        "id": "o2",
        "text": "Dynamic imports always block the initial page render.",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "o3",
        "text": "Webpack automatically creates separate chunks for dynamically imported modules.",
        "isCorrect": true,
        "explanation": ""
      },
      {
        "id": "o4",
        "text": "Dynamic imports are part of the ES2020 specification.",
        "isCorrect": true,
        "explanation": ""
      }
    ],
    "hints": [],
    "metadata": {}
  },
  {
    "id": "performance-patterns-performance-1-pp12",
    "title": "What are potential drawbacks of overusing Bundle Splitting?",
    "content": "### Trade-offs\nWhile bundle splitting improves load times, over-splitting can lead to performance issues.\n\n**Possible issues include:**\n- Too many network requests\n- Increased HTTP overhead\n- Caching complexity\n\n**Question:** What are the main drawbacks developers should consider before aggressively splitting bundles?",
    "type": "multiple-choice",
    "category": "Performance Patterns",
    "topic": "Code Splitting",
    "difficulty": "advanced",
    "learningCardId": "system-design",
    "isActive": true,
    "createdAt": "2025-10-10T00:00:00.000Z",
    "updatedAt": "2025-11-11T18:50:32.225Z",
    "createdBy": "admin",
    "updatedBy": "admin",
    "tags": [
      "performance-patterns",
      "bundle-splitting",
      "advanced"
    ],
    "explanation": "Excessive splitting can cause too many small network requests, increase latency, and make caching more complex.",
    "points": 10,
    "sampleAnswers": [
      "Excessive splitting can cause too many small network requests, increase latency, and make caching more complex."
    ],
    "hints": [],
    "metadata": {},
    "options": [
      {
        "id": "o1",
        "text": "Excessive splitting can cause too many small network requests, increase latency, and make caching more complex.",
        "isCorrect": true,
        "explanation": "Excessive splitting can cause too many small network requests, increase latency, and make caching more complex."
      },
      {
        "id": "o2",
        "text": "This is not correct. Please refer to the explanation.",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "o3",
        "text": "Incorrect. Review performance optimization concepts.",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "o4",
        "text": "This is a common misconception. The correct answer is different.",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "o5",
        "text": "Not quite. Consider web performance best practices.",
        "isCorrect": false,
        "explanation": ""
      }
    ]
  },
  {
    "id": "performance-patterns-compression-2",
    "title": "Which compression algorithms are most commonly used for JavaScript?",
    "content": "The two most common compression algorithms used for HTTP and JavaScript data are Gzip and Brotli.",
    "type": "multiple-choice",
    "category": "Performance Patterns",
    "topic": "Compression Algorithms",
    "difficulty": "intermediate",
    "learningCardId": "system-design",
    "isActive": true,
    "createdAt": "2025-10-10T00:00:00Z",
    "updatedAt": "2025-11-11T18:50:32.172Z",
    "createdBy": "admin",
    "updatedBy": "admin",
    "tags": [
      "performance-patterns",
      "compression-algorithms",
      "beginner",
      "intermediate"
    ],
    "explanation": "Modern browsers widely support Gzip and Brotli for compressing text-based assets like JavaScript, HTML, and CSS.",
    "points": 10,
    "options": [
      {
        "id": "o1",
        "text": "JPEG and PNG",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "o2",
        "text": "Gzip and Brotli",
        "isCorrect": true,
        "explanation": ""
      },
      {
        "id": "o3",
        "text": "Zlib and Snappy",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "o4",
        "text": "WebP and AVIF",
        "isCorrect": false,
        "explanation": ""
      }
    ],
    "sampleAnswers": [
      "Gzip and Brotli"
    ],
    "hints": [],
    "metadata": {}
  },
  {
    "id": "performance-patterns-compression-5",
    "title": "Which compression type should be used for JavaScript files?",
    "content": "JavaScript should always use lossless compression to ensure code runs correctly after decompression.",
    "type": "multiple-choice",
    "category": "Performance Patterns",
    "topic": "Compression Best Practices",
    "difficulty": "intermediate",
    "learningCardId": "system-design",
    "isActive": true,
    "createdAt": "2025-10-10T00:00:00Z",
    "updatedAt": "2025-11-11T18:50:32.172Z",
    "createdBy": "admin",
    "updatedBy": "admin",
    "tags": [
      "performance-patterns",
      "compression-best-practices",
      "beginner",
      "intermediate"
    ],
    "explanation": "Since JavaScript must remain valid after compression, only lossless algorithms like Brotli or Gzip should be used.",
    "points": 10,
    "options": [
      {
        "id": "o1",
        "text": "Lossy compression",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "o2",
        "text": "Lossless compression",
        "isCorrect": true,
        "explanation": ""
      },
      {
        "id": "o3",
        "text": "Dynamic compression only",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "o4",
        "text": "No compression",
        "isCorrect": false,
        "explanation": ""
      }
    ],
    "sampleAnswers": [
      "Lossless compression"
    ],
    "hints": [],
    "metadata": {}
  },
  {
    "id": "performance-patterns-compression-3",
    "title": "Which compression algorithm provides better compression ratios?",
    "content": "Brotli typically provides smaller file sizes compared to Gzip at similar compression levels.",
    "type": "multiple-choice",
    "category": "Performance Patterns",
    "topic": "Compression Comparison",
    "difficulty": "intermediate",
    "learningCardId": "system-design",
    "isActive": true,
    "createdAt": "2025-10-10T00:00:00Z",
    "updatedAt": "2025-11-11T18:50:32.172Z",
    "createdBy": "admin",
    "updatedBy": "admin",
    "tags": [
      "performance-patterns",
      "compression-comparison",
      "intermediate"
    ],
    "explanation": "Brotli achieves denser compression through context modeling and larger dictionary windows, reducing file size effectively.",
    "points": 10,
    "options": [
      {
        "id": "o1",
        "text": "Gzip has a higher compression ratio than Brotli",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "o2",
        "text": "Brotli has a better compression ratio at similar levels",
        "isCorrect": true,
        "explanation": ""
      },
      {
        "id": "o3",
        "text": "Both perform the same at all levels",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "o4",
        "text": "Brotli compresses slower with worse ratios",
        "isCorrect": false,
        "explanation": ""
      }
    ],
    "sampleAnswers": [
      "Brotli has a better compression ratio at similar levels"
    ],
    "hints": [],
    "metadata": {}
  },
  {
    "id": "performance-patterns-compression-4",
    "title": "What is the difference between lossy and lossless compression?",
    "content": "Lossy compression slightly alters files while maintaining usability, while lossless compression preserves data exactly.",
    "type": "multiple-choice",
    "category": "Performance Patterns",
    "topic": "Compression Types",
    "difficulty": "intermediate",
    "learningCardId": "system-design",
    "isActive": true,
    "createdAt": "2025-10-10T00:00:00Z",
    "updatedAt": "2025-11-11T18:50:32.172Z",
    "createdBy": "admin",
    "updatedBy": "admin",
    "tags": [
      "performance-patterns",
      "compression-types",
      "intermediate"
    ],
    "explanation": "JavaScript requires lossless compression to preserve code integrity during compression and decompression.",
    "points": 10,
    "options": [
      {
        "id": "o1",
        "text": "Lossy retains exact data; lossless removes data",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "o2",
        "text": "Lossy slightly changes files; lossless preserves them exactly",
        "isCorrect": true,
        "explanation": ""
      },
      {
        "id": "o3",
        "text": "Both compress with some data loss",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "o4",
        "text": "Lossless only applies to images",
        "isCorrect": false,
        "explanation": ""
      }
    ],
    "sampleAnswers": [
      "Lossy slightly changes files; lossless preserves them exactly"
    ],
    "hints": [],
    "metadata": {}
  },
  {
    "id": "performance-patterns-compression-7",
    "title": "What is static compression?",
    "content": "Static compression pre-compresses resources at build time for better download performance of infrequently changing files.",
    "type": "multiple-choice",
    "category": "Performance Patterns",
    "topic": "Compression Types",
    "difficulty": "intermediate",
    "learningCardId": "system-design",
    "isActive": true,
    "createdAt": "2025-10-10T00:00:00Z",
    "updatedAt": "2025-11-11T18:50:32.172Z",
    "createdBy": "admin",
    "updatedBy": "admin",
    "tags": [
      "performance-patterns",
      "compression-types",
      "intermediate"
    ],
    "explanation": "Static compression is ideal for files that rarely change, improving transfer speeds without runtime cost.",
    "points": 10,
    "options": [
      {
        "id": "o1",
        "text": "Compression applied at runtime",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "o2",
        "text": "Pre-compressing files during build time",
        "isCorrect": true,
        "explanation": ""
      },
      {
        "id": "o3",
        "text": "Client-side compression of resources",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "o4",
        "text": "Compressing files multiple times after deployment",
        "isCorrect": false,
        "explanation": ""
      }
    ],
    "sampleAnswers": [
      "Pre-compressing files during build time"
    ],
    "hints": [],
    "metadata": {}
  },
  {
    "id": "performance-patterns-loading-sequence-5",
    "title": "Critical CSS Best Practice",
    "content": "What is the best way to handle critical CSS for optimal performance?",
    "type": "multiple-choice",
    "category": "Performance Patterns",
    "topic": "CSS Optimization",
    "difficulty": "intermediate",
    "learningCardId": "system-design",
    "isActive": true,
    "createdAt": "2025-10-10T00:00:00Z",
    "updatedAt": "2025-11-11T18:50:32.218Z",
    "createdBy": "admin",
    "updatedBy": "admin",
    "tags": [
      "performance-patterns",
      "css-optimization",
      "beginner",
      "intermediate"
    ],
    "explanation": "Inlining critical CSS ensures faster rendering of above-the-fold content, directly improving FCP and LCP.",
    "points": 10,
    "options": [
      {
        "id": "o1",
        "text": "Load all CSS files asynchronously",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "o2",
        "text": "Inline critical CSS and preload if external",
        "isCorrect": true,
        "explanation": ""
      },
      {
        "id": "o3",
        "text": "Serve all CSS from third-party CDNs",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "o4",
        "text": "Load CSS after all JavaScript",
        "isCorrect": false,
        "explanation": ""
      }
    ],
    "sampleAnswers": [
      "Inline critical CSS and preload if external"
    ],
    "hints": [],
    "metadata": {}
  },
  {
    "id": "performance-patterns-import-on-interaction-6",
    "title": "Which JavaScript feature enables dynamic Import On Interaction?",
    "content": "The dynamic <code>import()</code> function allows modules to be loaded only when needed.",
    "type": "multiple-choice",
    "category": "Performance Patterns",
    "topic": "Dynamic Imports",
    "difficulty": "intermediate",
    "learningCardId": "system-design",
    "isActive": true,
    "createdAt": "2025-10-10T00:00:00Z",
    "updatedAt": "2025-11-11T18:50:32.201Z",
    "createdBy": "admin",
    "updatedBy": "admin",
    "tags": [
      "performance-patterns",
      "dynamic-imports",
      "beginner",
      "intermediate"
    ],
    "explanation": "Dynamic <code>import()</code> returns a promise and can load modules lazily, which is ideal for import-on-interaction use cases.",
    "points": 10,
    "options": [
      {
        "id": "o1",
        "text": "require()",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "o2",
        "text": "import * from 'module'",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "o3",
        "text": "dynamic import()",
        "isCorrect": true,
        "explanation": ""
      },
      {
        "id": "o4",
        "text": "async await",
        "isCorrect": false,
        "explanation": ""
      }
    ],
    "sampleAnswers": [
      "dynamic import()"
    ],
    "hints": [],
    "metadata": {}
  },
  {
    "id": "performance-patterns-import-on-visibility-15",
    "title": "What happens when the EmojiPicker becomes visible in the viewport using react-loadable-visibility?",
    "content": "The library detects visibility and begins importing the EmojiPicker module, showing a loading indicator until it’s ready.",
    "type": "scenario",
    "category": "Performance Patterns",
    "topic": "EmojiPicker Example",
    "difficulty": "intermediate",
    "learningCardId": "system-design",
    "isActive": true,
    "createdAt": "2025-10-10",
    "updatedAt": "2025-11-11T18:50:32.209Z",
    "createdBy": "admin",
    "updatedBy": "admin",
    "tags": [
      "performance-patterns",
      "emojipicker-example",
      "beginner",
      "intermediate"
    ],
    "explanation": "The module import only begins when the element is visible.",
    "points": 10,
    "options": [
      {
        "id": "o1",
        "text": "It loads immediately",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "o2",
        "text": "It loads when visible",
        "isCorrect": true,
        "explanation": ""
      },
      {
        "id": "o3",
        "text": "It preloads on hover",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "o4",
        "text": "It loads on build time",
        "isCorrect": false,
        "explanation": ""
      }
    ],
    "sampleAnswers": [
      "It loads when visible."
    ],
    "hints": [],
    "metadata": {}
  },
  {
    "id": "performance-patterns-import-on-interaction-3",
    "title": "What is a facade in Import On Interaction?",
    "content": "A facade is a lightweight placeholder or preview that mimics a heavy component until the user interacts with it.",
    "type": "multiple-choice",
    "category": "Performance Patterns",
    "topic": "Facades and Placeholders",
    "difficulty": "intermediate",
    "learningCardId": "system-design",
    "isActive": true,
    "createdAt": "2025-10-10T00:00:00Z",
    "updatedAt": "2025-11-11T18:50:32.201Z",
    "createdBy": "admin",
    "updatedBy": "admin",
    "tags": [
      "performance-patterns",
      "facades-and-placeholders",
      "intermediate"
    ],
    "explanation": "A facade prevents heavy resources from loading immediately by displaying a placeholder (like a thumbnail or fake button) until the user interacts.",
    "points": 10,
    "options": [
      {
        "id": "o1",
        "text": "A placeholder element shown before real content loads",
        "isCorrect": true,
        "explanation": ""
      },
      {
        "id": "o2",
        "text": "A type of React component",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "o3",
        "text": "A third-party API optimization tool",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "o4",
        "text": "A performance monitoring technique",
        "isCorrect": false,
        "explanation": ""
      }
    ],
    "sampleAnswers": [
      "A placeholder element shown before real content loads"
    ],
    "hints": [],
    "metadata": {}
  },
  {
    "id": "performance-patterns-loading-sequence-6",
    "title": "Font Loading Strategy",
    "content": "How can developers reduce the delay caused by fetching external fonts?",
    "type": "multiple-choice",
    "category": "Performance Patterns",
    "topic": "Fonts and Preconnect",
    "difficulty": "intermediate",
    "learningCardId": "system-design",
    "isActive": true,
    "createdAt": "2025-10-10T00:00:00Z",
    "updatedAt": "2025-11-11T18:50:32.218Z",
    "createdBy": "admin",
    "updatedBy": "admin",
    "tags": [
      "performance-patterns",
      "fonts-and-preconnect",
      "intermediate"
    ],
    "explanation": "Using preconnect allows browsers to establish connections early, reducing delay in fetching critical font resources.",
    "points": 10,
    "options": [
      {
        "id": "o1",
        "text": "Use font preconnect for external domains",
        "isCorrect": true,
        "explanation": ""
      },
      {
        "id": "o2",
        "text": "Load all fonts after interactivity starts",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "o3",
        "text": "Inline all font files directly into HTML",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "o4",
        "text": "Avoid using font fallbacks",
        "isCorrect": false,
        "explanation": ""
      }
    ],
    "sampleAnswers": [
      "Use font preconnect for external domains"
    ],
    "hints": [],
    "metadata": {}
  },
  {
    "id": "performance-patterns-compression-10",
    "title": "What trade-off does bundle granularity create in compression?",
    "content": "Smaller chunks improve caching but reduce compression efficiency, while larger chunks compress better but cache less effectively.",
    "type": "multiple-choice",
    "category": "Performance Patterns",
    "topic": "Granularity Trade-off",
    "difficulty": "intermediate",
    "learningCardId": "system-design",
    "isActive": true,
    "createdAt": "2025-10-10T00:00:00Z",
    "updatedAt": "2025-11-11T18:50:32.172Z",
    "createdBy": "admin",
    "updatedBy": "admin",
    "tags": [
      "performance-patterns",
      "granularity-trade-off",
      "intermediate"
    ],
    "explanation": "This is the granularity trade-off: compression efficiency and caching benefits often compete in bundle optimization.",
    "points": 10,
    "options": [
      {
        "id": "o1",
        "text": "Larger chunks are always better",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "o2",
        "text": "Smaller chunks are always faster",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "o3",
        "text": "Smaller chunks cache better, larger compress better",
        "isCorrect": true,
        "explanation": ""
      },
      {
        "id": "o4",
        "text": "Chunk size has no impact on performance",
        "isCorrect": false,
        "explanation": ""
      }
    ],
    "sampleAnswers": [
      "Smaller chunks cache better, larger compress better"
    ],
    "hints": [],
    "metadata": {}
  },
  {
    "id": "performance-patterns-compression-8",
    "title": "What is dynamic compression?",
    "content": "Dynamic compression happens at runtime when the browser requests a resource, compressing it on the fly.",
    "type": "multiple-choice",
    "category": "Performance Patterns",
    "topic": "HTTP Compression",
    "difficulty": "intermediate",
    "learningCardId": "system-design",
    "isActive": true,
    "createdAt": "2025-10-10T00:00:00Z",
    "updatedAt": "2025-11-11T18:50:32.172Z",
    "createdBy": "admin",
    "updatedBy": "admin",
    "tags": [
      "performance-patterns",
      "http-compression",
      "intermediate"
    ],
    "explanation": "Dynamic compression is used for frequently changing content, balancing CPU time with real-time optimization.",
    "points": 10,
    "options": [
      {
        "id": "o1",
        "text": "Compression done before build",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "o2",
        "text": "Compression applied during runtime on request",
        "isCorrect": true,
        "explanation": ""
      },
      {
        "id": "o3",
        "text": "Compression handled by the browser only",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "o4",
        "text": "Compression used only for media files",
        "isCorrect": false,
        "explanation": ""
      }
    ],
    "sampleAnswers": [
      "Compression applied during runtime on request"
    ],
    "hints": [],
    "metadata": {}
  },
  {
    "id": "performance-patterns-loading-sequence-7",
    "title": "Image Loading Prioritization",
    "content": "Which images should be prioritized during the initial page load?",
    "type": "multiple-choice",
    "category": "Performance Patterns",
    "topic": "Images and LCP",
    "difficulty": "intermediate",
    "learningCardId": "system-design",
    "isActive": true,
    "createdAt": "2025-10-10T00:00:00Z",
    "updatedAt": "2025-11-11T18:50:32.218Z",
    "createdBy": "admin",
    "updatedBy": "admin",
    "tags": [
      "performance-patterns",
      "images-and-lcp",
      "beginner",
      "intermediate"
    ],
    "explanation": "Above-the-fold (ATF) and hero images directly affect LCP and should be prioritized during initial loading.",
    "points": 10,
    "options": [
      {
        "id": "o1",
        "text": "Below the fold images",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "o2",
        "text": "Above the fold images including the hero image",
        "isCorrect": true,
        "explanation": ""
      },
      {
        "id": "o3",
        "text": "All images equally",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "o4",
        "text": "Lazy-load all images",
        "isCorrect": false,
        "explanation": ""
      }
    ],
    "sampleAnswers": [
      "Above the fold images including the hero image"
    ],
    "hints": [],
    "metadata": {}
  },
  {
    "id": "performance-patterns-import-on-visibility-13",
    "title": "How does import-on-visibility differ from basic dynamic import?",
    "content": "Dynamic import loads modules when triggered by user action, while import-on-visibility loads them automatically when they become visible on screen.",
    "type": "open-ended",
    "category": "Performance Patterns",
    "topic": "Import Strategies",
    "difficulty": "intermediate",
    "learningCardId": "system-design",
    "isActive": true,
    "createdAt": "2025-10-10",
    "updatedAt": "2025-11-11T18:50:32.209Z",
    "createdBy": "admin",
    "updatedBy": "admin",
    "tags": [
      "performance-patterns",
      "import-strategies",
      "intermediate"
    ],
    "explanation": "Import-on-visibility uses viewport detection rather than explicit user events to trigger the import.",
    "points": 10,
    "options": [],
    "sampleAnswers": [
      "It loads on visibility, not just user click."
    ],
    "hints": [],
    "metadata": {}
  },
  {
    "id": "performance-patterns-import-on-interaction-1",
    "title": "What is the main goal of the Import On Interaction pattern?",
    "content": "Import On Interaction delays the loading of non-critical resources until the user interacts with the UI element that requires them, improving page load performance.",
    "type": "multiple-choice",
    "category": "Performance Patterns",
    "topic": "Lazy Loading",
    "difficulty": "intermediate",
    "learningCardId": "system-design",
    "isActive": true,
    "createdAt": "2025-10-10T00:00:00Z",
    "updatedAt": "2025-11-11T18:50:32.201Z",
    "createdBy": "admin",
    "updatedBy": "admin",
    "tags": [
      "performance-patterns",
      "lazy-loading",
      "beginner",
      "intermediate"
    ],
    "explanation": "The Import On Interaction pattern improves load performance by deferring loading of non-critical JavaScript until a user interacts with a relevant element.",
    "points": 10,
    "options": [
      {
        "id": "o1",
        "text": "To load all scripts eagerly on page load",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "o2",
        "text": "To lazy-load non-critical resources when needed",
        "isCorrect": true,
        "explanation": ""
      },
      {
        "id": "o3",
        "text": "To compile code during build time",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "o4",
        "text": "To improve SEO ranking",
        "isCorrect": false,
        "explanation": ""
      }
    ],
    "sampleAnswers": [
      "To lazy-load non-critical resources when needed"
    ],
    "hints": [],
    "metadata": {}
  },
  {
    "id": "performance-patterns-performance-1-pp10",
    "title": "What is Lazy Loading, and how is it connected to Bundle Splitting?",
    "content": "### Lazy Loading\nLazy loading is a strategy where certain resources or components are loaded only when they’re actually needed. When used with bundle splitting, lazy loading ensures that non-critical chunks are loaded later.\n\n**Example:** React’s <code>lazy()</code> and <code>Suspense</code> help load components on demand.\n\n**Question:**\nDescribe how lazy loading works in combination with bundle splitting to improve user experience.",
    "type": "multiple-choice",
    "category": "Performance Patterns",
    "topic": "Lazy Loading",
    "difficulty": "intermediate",
    "learningCardId": "system-design",
    "isActive": true,
    "createdAt": "2025-10-10T00:00:00.000Z",
    "updatedAt": "2025-11-11T18:50:32.225Z",
    "createdBy": "admin",
    "updatedBy": "admin",
    "tags": [
      "performance-patterns",
      "lazy-loading",
      "intermediate"
    ],
    "explanation": "Lazy loading delays loading of non-critical components. Combined with bundle splitting, it ensures smaller initial bundles and faster interactive experiences.",
    "points": 10,
    "sampleAnswers": [
      "Lazy loading delays loading of non-critical components. Combined with bundle splitting, it ensures smaller initial bundles and faster interactive experiences."
    ],
    "hints": [],
    "metadata": {},
    "options": [
      {
        "id": "o1",
        "text": "Lazy loading delays loading of non-critical components. Combined with bundle splitting, it ensures smaller initial bundles and faster interactive experiences.",
        "isCorrect": true,
        "explanation": "Lazy loading delays loading of non-critical components. Combined with bundle splitting, it ensures smaller initial bundles and faster interactive experiences."
      },
      {
        "id": "o2",
        "text": "This is not correct. Please refer to the explanation.",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "o3",
        "text": "Incorrect. Review performance optimization concepts.",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "o4",
        "text": "This is a common misconception. The correct answer is different.",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "o5",
        "text": "Not quite. Consider web performance best practices.",
        "isCorrect": false,
        "explanation": ""
      }
    ]
  },
  {
    "id": "performance-patterns-dynamic-import-15",
    "title": "When is the EmojiPicker component actually loaded in the dynamic import example?",
    "content": "EmojiPicker is loaded only when the user clicks on the emoji icon, triggering the lazy import.",
    "type": "multiple-choice",
    "category": "Performance Patterns",
    "topic": "Lazy Loading Behavior",
    "difficulty": "intermediate",
    "learningCardId": "system-design",
    "isActive": true,
    "createdAt": "2025-10-10T00:00:00Z",
    "updatedAt": "2025-11-11T18:50:32.188Z",
    "createdBy": "admin",
    "updatedBy": "admin",
    "tags": [
      "performance-patterns",
      "lazy-loading-behavior",
      "intermediate"
    ],
    "explanation": "The lazy import ensures that the module is fetched and executed only upon user interaction with the emoji button.",
    "points": 10,
    "options": [
      {
        "id": "o1",
        "text": "When the app starts",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "o2",
        "text": "When the page is reloaded",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "o3",
        "text": "Only when the emoji button is clicked",
        "isCorrect": true,
        "explanation": ""
      },
      {
        "id": "o4",
        "text": "Immediately after rendering ChatInput",
        "isCorrect": false,
        "explanation": ""
      }
    ],
    "sampleAnswers": [
      "Only when the emoji button is clicked"
    ],
    "hints": [],
    "metadata": {}
  },
  {
    "id": "performance-patterns-import-on-visibility-9",
    "title": "What is the purpose of the “import on visibility” pattern?",
    "content": "“Import on visibility” defers loading of components until they are actually visible in the viewport, reducing the initial load time and improving performance.",
    "type": "open-ended",
    "category": "Performance Patterns",
    "topic": "Lazy Loading Components",
    "difficulty": "intermediate",
    "learningCardId": "system-design",
    "isActive": true,
    "createdAt": "2025-10-10",
    "updatedAt": "2025-11-11T18:50:32.209Z",
    "createdBy": "admin",
    "updatedBy": "admin",
    "tags": [
      "performance-patterns",
      "lazy-loading-components",
      "beginner",
      "intermediate"
    ],
    "explanation": "By only importing components when they come into view, the application avoids loading unnecessary code at startup.",
    "points": 10,
    "options": [],
    "sampleAnswers": [
      "It delays loading of components until they become visible."
    ],
    "hints": [],
    "metadata": {}
  },
  {
    "id": "performance-patterns-loading-sequence-2",
    "title": "Why Optimal Loading Is Difficult",
    "content": "What is one major reason why achieving an optimal loading sequence is challenging?",
    "type": "multiple-choice",
    "category": "Performance Patterns",
    "topic": "Loading Challenges",
    "difficulty": "intermediate",
    "learningCardId": "system-design",
    "isActive": true,
    "createdAt": "2025-10-10T00:00:00Z",
    "updatedAt": "2025-11-11T18:50:32.217Z",
    "createdBy": "admin",
    "updatedBy": "admin",
    "tags": [
      "performance-patterns",
      "loading-challenges",
      "intermediate"
    ],
    "explanation": "Developers often expect browsers to prioritize resources in a specific order, but browsers handle requests differently, leading to suboptimal performance.",
    "points": 10,
    "options": [
      {
        "id": "o1",
        "text": "Browsers follow a standard universal resource prioritization model",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "o2",
        "text": "Developers and browsers often differ in how they prioritize resources",
        "isCorrect": true,
        "explanation": ""
      },
      {
        "id": "o3",
        "text": "All third-party scripts automatically optimize for performance",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "o4",
        "text": "HTTP/2 always provides perfect prioritization",
        "isCorrect": false,
        "explanation": ""
      }
    ],
    "sampleAnswers": [
      "Developers and browsers often differ in how they prioritize resources"
    ],
    "hints": [],
    "metadata": {}
  },
  {
    "id": "performance-patterns-compression-6",
    "title": "What does minification do before compression?",
    "content": "Minification removes unnecessary syntax like spaces, comments, and line breaks to reduce file size.",
    "type": "multiple-choice",
    "category": "Performance Patterns",
    "topic": "Minification",
    "difficulty": "intermediate",
    "learningCardId": "system-design",
    "isActive": true,
    "createdAt": "2025-10-10T00:00:00Z",
    "updatedAt": "2025-11-11T18:50:32.172Z",
    "createdBy": "admin",
    "updatedBy": "admin",
    "tags": [
      "performance-patterns",
      "minification",
      "intermediate"
    ],
    "explanation": "Minification optimizes code before compression, enabling smaller payloads without changing functionality.",
    "points": 10,
    "options": [
      {
        "id": "o1",
        "text": "Adds whitespace for readability",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "o2",
        "text": "Removes unnecessary syntax to shrink file size",
        "isCorrect": true,
        "explanation": ""
      },
      {
        "id": "o3",
        "text": "Combines multiple files into one",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "o4",
        "text": "Encrypts JavaScript files",
        "isCorrect": false,
        "explanation": ""
      }
    ],
    "sampleAnswers": [
      "Removes unnecessary syntax to shrink file size"
    ],
    "hints": [],
    "metadata": {}
  },
  {
    "id": "performance-patterns-loading-sequence-3",
    "title": "Network and CPU Utilization",
    "content": "What happens if resources are not pipelined correctly in terms of CPU and network usage?",
    "type": "multiple-choice",
    "category": "Performance Patterns",
    "topic": "Network Optimization",
    "difficulty": "intermediate",
    "learningCardId": "system-design",
    "isActive": true,
    "createdAt": "2025-10-10T00:00:00Z",
    "updatedAt": "2025-11-11T18:50:32.217Z",
    "createdBy": "admin",
    "updatedBy": "admin",
    "tags": [
      "performance-patterns",
      "network-optimization",
      "intermediate"
    ],
    "explanation": "Improper pipelining can lead to idle CPU or network times, where one waits for the other, decreasing efficiency.",
    "points": 10,
    "options": [
      {
        "id": "o1",
        "text": "The browser caches all resources automatically",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "o2",
        "text": "The CPU and network are always fully utilized",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "o3",
        "text": "Dead time occurs on either CPU or network, causing delays",
        "isCorrect": true,
        "explanation": ""
      },
      {
        "id": "o4",
        "text": "LCP is achieved faster",
        "isCorrect": false,
        "explanation": ""
      }
    ],
    "sampleAnswers": [
      "Dead time occurs on either CPU or network, causing delays"
    ],
    "hints": [],
    "metadata": {}
  },
  {
    "id": "performance-patterns-loading-sequence-9",
    "title": "Lazy-Onload Scripts",
    "content": "When should you use the 'Lazy-Onload' priority for third-party scripts in Next.js?",
    "type": "multiple-choice",
    "category": "Performance Patterns",
    "topic": "Next.js Script Management",
    "difficulty": "intermediate",
    "learningCardId": "system-design",
    "isActive": true,
    "createdAt": "2025-10-10T00:00:00Z",
    "updatedAt": "2025-11-11T18:50:32.218Z",
    "createdBy": "admin",
    "updatedBy": "admin",
    "tags": [
      "performance-patterns",
      "next.js-script-management",
      "intermediate"
    ],
    "explanation": "'Lazy-Onload' should be used for non-critical third-party scripts like social widgets that can load after all main content.",
    "points": 10,
    "options": [
      {
        "id": "o1",
        "text": "For critical polyfills and security scripts",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "o2",
        "text": "For social widgets and feedback scripts",
        "isCorrect": true,
        "explanation": ""
      },
      {
        "id": "o3",
        "text": "For hydration-related scripts",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "o4",
        "text": "For critical fonts and CSS",
        "isCorrect": false,
        "explanation": ""
      }
    ],
    "sampleAnswers": [
      "For social widgets and feedback scripts"
    ],
    "hints": [],
    "metadata": {}
  },
  {
    "id": "performance-patterns-third-party-tp7",
    "title": "Which strategy does Next.js provide to optimize third-party scripts?",
    "content": "Identify the strategies available in the Next.js Script component.",
    "type": "multiple-choice",
    "category": "Performance Patterns",
    "topic": "Next.js Third-Party Scripts",
    "difficulty": "intermediate",
    "learningCardId": "system-design",
    "isActive": true,
    "createdAt": "2025-10-11T00:00:00.000Z",
    "updatedAt": "2025-11-11T18:50:32.264Z",
    "createdBy": "admin",
    "updatedBy": "admin",
    "tags": [
      "performance-patterns",
      "next.js-third-party-scripts",
      "intermediate"
    ],
    "explanation": "Next.js Script component allows beforeInteractive for critical scripts, afterInteractive for deferred scripts, and lazyOnload for scripts to load when idle.",
    "points": 10,
    "options": [
      {
        "id": "o1",
        "text": "beforeInteractive",
        "isCorrect": true,
        "explanation": ""
      },
      {
        "id": "o2",
        "text": "afterInteractive",
        "isCorrect": true,
        "explanation": ""
      },
      {
        "id": "o3",
        "text": "lazyOnload",
        "isCorrect": true,
        "explanation": ""
      },
      {
        "id": "o4",
        "text": "documentWrite",
        "isCorrect": false,
        "explanation": ""
      }
    ],
    "hints": [],
    "metadata": {}
  },
  {
    "id": "performance-patterns-pre-load-8",
    "title": "Best Practices for Using Preload",
    "content": "Which of the following is a recommended best practice when using preload?",
    "type": "multiple-choice",
    "category": "Performance Patterns",
    "topic": "Optimization Guidelines",
    "difficulty": "intermediate",
    "learningCardId": "system-design",
    "isActive": true,
    "createdAt": "2025-10-10T00:00:00Z",
    "updatedAt": "2025-11-11T18:50:32.240Z",
    "createdBy": "admin",
    "updatedBy": "admin",
    "tags": [
      "performance-patterns",
      "optimization-guidelines",
      "intermediate"
    ],
    "explanation": "Preload should only be used for critical resources and its performance impact should be measured carefully.",
    "points": 10,
    "options": [
      {
        "id": "a",
        "text": "Use preload sparingly and measure its impact in production",
        "isCorrect": true,
        "explanation": ""
      },
      {
        "id": "b",
        "text": "Preload all JavaScript files to reduce bundle size",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "c",
        "text": "Always preload images before any CSS files",
        "isCorrect": false,
        "explanation": ""
      }
    ],
    "sampleAnswers": [
      "Use preload only for critical assets and monitor performance impact."
    ],
    "hints": [],
    "metadata": {}
  },
  {
    "id": "performance-patterns-prefetch-6",
    "title": "When to Prefetch",
    "content": "Which is a good scenario to use prefetching in a web application?",
    "type": "multiple-choice",
    "category": "Performance Patterns",
    "topic": "Optimization Scenarios",
    "difficulty": "intermediate",
    "learningCardId": "system-design",
    "isActive": true,
    "createdAt": "2025-10-10T00:00:00Z",
    "updatedAt": "2025-11-11T18:50:32.241Z",
    "createdBy": "admin",
    "updatedBy": "admin",
    "tags": [
      "performance-patterns",
      "optimization-scenarios",
      "intermediate"
    ],
    "explanation": "Prefetching should be used for predictable user paths to balance performance and bandwidth usage.",
    "points": 10,
    "options": [
      {
        "id": "a",
        "text": "For pages or components the user is likely to visit soon",
        "isCorrect": true,
        "explanation": ""
      },
      {
        "id": "b",
        "text": "For every resource in the application",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "c",
        "text": "Only for images in the viewport",
        "isCorrect": false,
        "explanation": ""
      }
    ],
    "sampleAnswers": [
      "Prefetch resources users are likely to access next to improve perceived speed."
    ],
    "hints": [],
    "metadata": {}
  },
  {
    "id": "performance-patterns-prefetch-5",
    "title": "Prefetching Trade-offs",
    "content": "Why should developers avoid excessive use of prefetching?",
    "type": "multiple-choice",
    "category": "Performance Patterns",
    "topic": "Performance Best Practices",
    "difficulty": "intermediate",
    "learningCardId": "system-design",
    "isActive": true,
    "createdAt": "2025-10-10T00:00:00Z",
    "updatedAt": "2025-11-11T18:50:32.241Z",
    "createdBy": "admin",
    "updatedBy": "admin",
    "tags": [
      "performance-patterns",
      "performance-best-practices",
      "intermediate"
    ],
    "explanation": "Overusing prefetch may waste bandwidth and slow down critical resource loading if prefetched assets are never used.",
    "points": 10,
    "options": [
      {
        "id": "o1",
        "text": "Prefetching too many unused resources can waste network bandwidth and harm performance.",
        "isCorrect": true,
        "explanation": "Overusing prefetch may waste bandwidth and slow down critical resource loading if prefetched assets are never used."
      },
      {
        "id": "o2",
        "text": "This is not correct. Please refer to the explanation.",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "o3",
        "text": "Incorrect. Review performance optimization concepts.",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "o4",
        "text": "This is a common misconception. The correct answer is different.",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "o5",
        "text": "Not quite. Consider web performance best practices.",
        "isCorrect": false,
        "explanation": ""
      }
    ],
    "sampleAnswers": [
      "Prefetching too many unused resources can waste network bandwidth and harm performance."
    ],
    "hints": [],
    "metadata": {}
  },
  {
    "id": "performance-patterns-pre-load-2",
    "title": "Preload vs Prefetch",
    "content": "What is the main difference between preloading and prefetching resources?",
    "type": "multiple-choice",
    "category": "Performance Patterns",
    "topic": "Performance Comparison",
    "difficulty": "intermediate",
    "learningCardId": "system-design",
    "isActive": true,
    "createdAt": "2025-10-10T00:00:00Z",
    "updatedAt": "2025-11-11T18:50:32.232Z",
    "createdBy": "admin",
    "updatedBy": "admin",
    "tags": [
      "performance-patterns",
      "performance-comparison",
      "intermediate"
    ],
    "explanation": "Preload prioritizes resources needed right away; prefetch prepares resources for potential future use.",
    "points": 10,
    "options": [
      {
        "id": "a",
        "text": "Preload is for resources needed immediately, prefetch is for resources needed soon",
        "isCorrect": true,
        "explanation": ""
      },
      {
        "id": "b",
        "text": "Prefetch loads higher priority resources than preload",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "c",
        "text": "Preload is always handled automatically by the browser",
        "isCorrect": false,
        "explanation": ""
      }
    ],
    "sampleAnswers": [
      "Preload fetches resources needed instantly, while prefetch prepares for later needs."
    ],
    "hints": [],
    "metadata": {}
  },
  {
    "id": "performance-patterns-import-on-interaction-8",
    "title": "What trade-off can occur with Import On Interaction?",
    "content": "Users may experience a delay after clicking while the script loads if the resource is large or network is slow.",
    "type": "multiple-choice",
    "category": "Performance Patterns",
    "topic": "Performance Trade-offs",
    "difficulty": "intermediate",
    "learningCardId": "system-design",
    "isActive": true,
    "createdAt": "2025-10-10T00:00:00Z",
    "updatedAt": "2025-11-11T18:50:32.201Z",
    "createdBy": "admin",
    "updatedBy": "admin",
    "tags": [
      "performance-patterns",
      "performance-trade-offs",
      "intermediate"
    ],
    "explanation": "While the page loads faster initially, there might be a small delay when the resource is fetched on demand.",
    "points": 10,
    "options": [
      {
        "id": "o1",
        "text": "Reduced memory usage",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "o2",
        "text": "Instantaneous interactivity always",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "o3",
        "text": "Possible delay after user interaction",
        "isCorrect": true,
        "explanation": ""
      },
      {
        "id": "o4",
        "text": "Improved SEO performance",
        "isCorrect": false,
        "explanation": ""
      }
    ],
    "sampleAnswers": [
      "Possible delay after user interaction"
    ],
    "hints": [],
    "metadata": {}
  },
  {
    "id": "performance-patterns-pre-load-4",
    "title": "Trade-offs of Using Preload",
    "content": "What is a potential downside of preloading too many resources?",
    "type": "multiple-choice",
    "category": "Performance Patterns",
    "topic": "Performance Trade-offs",
    "difficulty": "intermediate",
    "learningCardId": "system-design",
    "isActive": true,
    "createdAt": "2025-10-10T00:00:00Z",
    "updatedAt": "2025-11-11T18:50:32.232Z",
    "createdBy": "admin",
    "updatedBy": "admin",
    "tags": [
      "performance-patterns",
      "performance-trade-offs",
      "intermediate"
    ],
    "explanation": "Preloading too many assets can block more important ones, increasing First Contentful Paint time.",
    "points": 10,
    "options": [
      {
        "id": "a",
        "text": "It can delay critical rendering paths like CSS and hero images",
        "isCorrect": true,
        "explanation": ""
      },
      {
        "id": "b",
        "text": "It causes the browser to ignore other preload hints",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "c",
        "text": "It disables the browser cache for those resources",
        "isCorrect": false,
        "explanation": ""
      }
    ],
    "sampleAnswers": [
      "Too many preloads can block essential resources and harm performance."
    ],
    "hints": [],
    "metadata": {}
  },
  {
    "id": "performance-patterns-dynamic-import-20",
    "title": "Why does dynamic import improve the user experience?",
    "content": "It lets the app load faster by deferring non-critical resources, making the UI interactive sooner.",
    "type": "multiple-choice",
    "category": "Performance Patterns",
    "topic": "Performance UX",
    "difficulty": "intermediate",
    "learningCardId": "system-design",
    "isActive": true,
    "createdAt": "2025-10-10T00:00:00Z",
    "updatedAt": "2025-11-11T18:50:32.188Z",
    "createdBy": "admin",
    "updatedBy": "admin",
    "tags": [
      "performance-patterns",
      "performance-ux",
      "intermediate"
    ],
    "explanation": "By deferring low-priority code, dynamic imports shorten Time to Interactive (TTI) and improve perceived performance.",
    "points": 10,
    "options": [
      {
        "id": "o1",
        "text": "It preloads everything at once",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "o2",
        "text": "It blocks rendering until all files are loaded",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "o3",
        "text": "It reduces initial bundle size and improves interactivity",
        "isCorrect": true,
        "explanation": ""
      },
      {
        "id": "o4",
        "text": "It disables animations to speed up UI",
        "isCorrect": false,
        "explanation": ""
      }
    ],
    "sampleAnswers": [
      "It reduces initial bundle size and improves interactivity"
    ],
    "hints": [],
    "metadata": {}
  },
  {
    "id": "performance-patterns-prefetch-1",
    "title": "Understanding Prefetch in Web Performance",
    "content": "What is the purpose of using <code>&lt;link rel=\"prefetch\"&gt;</code> in web applications?",
    "type": "multiple-choice",
    "category": "Performance Patterns",
    "topic": "Prefetch Optimization",
    "difficulty": "intermediate",
    "learningCardId": "system-design",
    "isActive": true,
    "createdAt": "2025-10-10T00:00:00Z",
    "updatedAt": "2025-11-11T18:50:32.241Z",
    "createdBy": "admin",
    "updatedBy": "admin",
    "tags": [
      "performance-patterns",
      "prefetch-optimization",
      "beginner",
      "intermediate"
    ],
    "explanation": "Prefetch allows browsers to fetch resources that may be needed later, improving responsiveness for upcoming interactions.",
    "points": 10,
    "options": [
      {
        "id": "a",
        "text": "To load resources that may be needed in the future",
        "isCorrect": true,
        "explanation": ""
      },
      {
        "id": "b",
        "text": "To defer resource loading until the user interacts",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "c",
        "text": "To immediately execute a script when the page loads",
        "isCorrect": false,
        "explanation": ""
      }
    ],
    "sampleAnswers": [
      "Prefetch helps reduce perceived latency by loading resources before they are needed."
    ],
    "hints": [],
    "metadata": {}
  },
  {
    "id": "performance-patterns-prefetch-2",
    "title": "Prefetch vs Lazy Loading",
    "content": "How does prefetch differ from lazy loading when optimizing resources?",
    "type": "multiple-choice",
    "category": "Performance Patterns",
    "topic": "Prefetch Optimization",
    "difficulty": "intermediate",
    "learningCardId": "system-design",
    "isActive": true,
    "createdAt": "2025-10-10T00:00:00Z",
    "updatedAt": "2025-11-11T18:50:32.241Z",
    "createdBy": "admin",
    "updatedBy": "admin",
    "tags": [
      "performance-patterns",
      "prefetch-optimization",
      "intermediate"
    ],
    "explanation": "Prefetch loads resources before they are needed (proactively), while lazy loading loads them only when required (reactively).",
    "points": 10,
    "options": [
      {
        "id": "o1",
        "text": "Prefetching anticipates future needs; lazy loading reacts to user actions or visibility.",
        "isCorrect": true,
        "explanation": "Prefetch loads resources before they are needed (proactively), while lazy loading loads them only when required (reactively)."
      },
      {
        "id": "o2",
        "text": "This is not correct. Please refer to the explanation.",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "o3",
        "text": "Incorrect. Review performance optimization concepts.",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "o4",
        "text": "This is a common misconception. The correct answer is different.",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "o5",
        "text": "Not quite. Consider web performance best practices.",
        "isCorrect": false,
        "explanation": ""
      }
    ],
    "sampleAnswers": [
      "Prefetching anticipates future needs; lazy loading reacts to user actions or visibility."
    ],
    "hints": [],
    "metadata": {}
  },
  {
    "id": "performance-patterns-prefetch-4",
    "title": "Performance Benefit of Prefetch",
    "content": "What happens when a prefetched module is requested by the user?",
    "type": "multiple-choice",
    "category": "Performance Patterns",
    "topic": "Prefetch Optimization",
    "difficulty": "intermediate",
    "learningCardId": "system-design",
    "isActive": true,
    "createdAt": "2025-10-10T00:00:00Z",
    "updatedAt": "2025-11-11T18:50:32.241Z",
    "createdBy": "admin",
    "updatedBy": "admin",
    "tags": [
      "performance-patterns",
      "prefetch-optimization",
      "beginner",
      "intermediate"
    ],
    "explanation": "Prefetched resources are cached by the browser, allowing instant retrieval when the user requests them.",
    "points": 10,
    "options": [
      {
        "id": "a",
        "text": "It is fetched from cache instantly",
        "isCorrect": true,
        "explanation": ""
      },
      {
        "id": "b",
        "text": "It triggers a network request",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "c",
        "text": "It delays rendering until all resources are loaded",
        "isCorrect": false,
        "explanation": ""
      }
    ],
    "sampleAnswers": [
      "The module loads from cache, minimizing wait time for the user."
    ],
    "hints": [],
    "metadata": {}
  },
  {
    "id": "performance-patterns-pre-load-1",
    "title": "Understanding Preload in Web Performance",
    "content": "What is the purpose of using <code>&lt;link rel=\"preload\"&gt;</code> in a web application?",
    "type": "multiple-choice",
    "category": "Performance Patterns",
    "topic": "Preload Optimization",
    "difficulty": "intermediate",
    "learningCardId": "system-design",
    "isActive": true,
    "createdAt": "2025-10-10T00:00:00Z",
    "updatedAt": "2025-11-11T18:50:32.232Z",
    "createdBy": "admin",
    "updatedBy": "admin",
    "tags": [
      "performance-patterns",
      "preload-optimization",
      "beginner",
      "intermediate"
    ],
    "explanation": "Preload helps load critical resources early to improve metrics like Time to Interactive or First Input Delay.",
    "points": 10,
    "options": [
      {
        "id": "a",
        "text": "To load critical resources earlier for faster interactivity",
        "isCorrect": true,
        "explanation": ""
      },
      {
        "id": "b",
        "text": "To defer resource loading until needed",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "c",
        "text": "To lazy load components on user interaction",
        "isCorrect": false,
        "explanation": ""
      }
    ],
    "sampleAnswers": [
      "Preload ensures critical assets are downloaded earlier, speeding up interactivity."
    ],
    "hints": [],
    "metadata": {}
  },
  {
    "id": "performance-patterns-prpl-pp1",
    "title": "What is the PRPL Pattern?",
    "content": "### PRPL Pattern\nThe **PRPL Pattern** is a web performance optimization strategy that focuses on making applications load and run efficiently, even on low-end devices or slow networks.\n\n**PRPL** stands for:\n- **P**: Push critical resources for the initial route.\n- **R**: Render the initial route as soon as possible.\n- **P**: Pre-cache assets for future routes.\n- **L**: Lazy-load remaining routes and assets.\n\nThis approach improves load times, offline experience, and caching efficiency.\n\n**Example:** Progressive Web Apps (PWAs) that use an app shell, service workers, and code-splitting to load only what’s needed.\n\n**Pros:**\n- Faster first render.\n- Improved caching and offline usability.\n- Reduced bandwidth usage.\n\n**Cons:**\n- Requires careful bundling and caching strategy.\n- Over-pushing or preloading can waste bandwidth.",
    "type": "multiple-choice",
    "category": "Performance Patterns",
    "topic": "PRPL Pattern",
    "difficulty": "intermediate",
    "learningCardId": "system-design",
    "isActive": true,
    "createdAt": "2025-10-10T00:00:00.000Z",
    "updatedAt": "2025-11-11T18:50:32.257Z",
    "createdBy": "admin",
    "updatedBy": "admin",
    "tags": [
      "performance-patterns",
      "prpl-pattern",
      "intermediate"
    ],
    "explanation": "A web performance pattern that optimizes loading by pushing critical resources, rendering fast, pre-caching assets, and lazy-loading the rest.",
    "points": 10,
    "sampleAnswers": [
      "A web performance pattern that optimizes loading by pushing critical resources, rendering fast, pre-caching assets, and lazy-loading the rest."
    ],
    "hints": [],
    "metadata": {},
    "options": [
      {
        "id": "o1",
        "text": "A web performance pattern that optimizes loading by pushing critical resources, rendering fast, pre-caching assets, and lazy-loading the rest.",
        "isCorrect": true,
        "explanation": "A web performance pattern that optimizes loading by pushing critical resources, rendering fast, pre-caching assets, and lazy-loading the rest."
      },
      {
        "id": "o2",
        "text": "This is not correct. Please refer to the explanation.",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "o3",
        "text": "Incorrect. Review performance optimization concepts.",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "o4",
        "text": "This is a common misconception. The correct answer is different.",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "o5",
        "text": "Not quite. Consider web performance best practices.",
        "isCorrect": false,
        "explanation": ""
      }
    ]
  },
  {
    "id": "performance-patterns-prpl-pp2",
    "title": "What does each letter in the PRPL acronym stand for?",
    "content": "Choose the correct expansion of PRPL.",
    "type": "multiple-choice",
    "category": "Performance Patterns",
    "topic": "PRPL Pattern",
    "difficulty": "intermediate",
    "learningCardId": "system-design",
    "isActive": true,
    "createdAt": "2025-10-10T00:00:00.000Z",
    "updatedAt": "2025-11-11T18:50:32.257Z",
    "createdBy": "admin",
    "updatedBy": "admin",
    "tags": [
      "performance-patterns",
      "prpl-pattern",
      "beginner",
      "intermediate"
    ],
    "explanation": "PRPL stands for Push critical resources, Render initial route, Pre-cache assets, and Lazy-load remaining routes.",
    "points": 10,
    "options": [
      {
        "id": "o1",
        "text": "Push, Render, Pre-cache, Lazy-load",
        "isCorrect": true,
        "explanation": ""
      },
      {
        "id": "o2",
        "text": "Preload, Render, Pre-fetch, Load",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "o3",
        "text": "Push, Render, Preload, Link",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "o4",
        "text": "Prepare, Run, Pre-cache, Load",
        "isCorrect": false,
        "explanation": ""
      }
    ],
    "hints": [],
    "metadata": {}
  },
  {
    "id": "performance-patterns-prpl-pp3",
    "title": "True or False: The PRPL pattern focuses on optimizing the first route before loading any other resources.",
    "content": "Evaluate the statement about PRPL’s optimization focus.",
    "type": "multiple-choice",
    "category": "Performance Patterns",
    "topic": "PRPL Pattern",
    "difficulty": "intermediate",
    "learningCardId": "system-design",
    "isActive": true,
    "createdAt": "2025-10-10T00:00:00.000Z",
    "updatedAt": "2025-11-11T18:50:32.257Z",
    "createdBy": "admin",
    "updatedBy": "admin",
    "tags": [
      "performance-patterns",
      "prpl-pattern",
      "beginner",
      "intermediate"
    ],
    "explanation": "The correct answer is: True",
    "points": 10,
    "options": [
      {
        "id": "o1",
        "text": "True",
        "isCorrect": true,
        "explanation": "PRPL prioritizes loading and rendering the initial route first, then caching and lazy-loading the rest."
      },
      {
        "id": "o2",
        "text": "False",
        "isCorrect": false,
        "explanation": "Other resources load only after the initial route completes."
      },
      {
        "id": "o3",
        "text": "Partially true - depends on the context",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "o4",
        "text": "Not applicable",
        "isCorrect": false,
        "explanation": ""
      }
    ],
    "hints": [],
    "metadata": {}
  },
  {
    "id": "performance-patterns-prpl-pp4",
    "title": "Which of the following technologies does the PRPL pattern often rely on?",
    "content": "Select all the technologies that typically support PRPL pattern implementation.",
    "type": "multiple-choice",
    "category": "Performance Patterns",
    "topic": "PRPL Pattern",
    "difficulty": "intermediate",
    "learningCardId": "system-design",
    "isActive": true,
    "createdAt": "2025-10-10T00:00:00.000Z",
    "updatedAt": "2025-11-11T18:50:32.257Z",
    "createdBy": "admin",
    "updatedBy": "admin",
    "tags": [
      "performance-patterns",
      "prpl-pattern",
      "intermediate"
    ],
    "explanation": "PRPL commonly uses HTTP/2 server push, service workers for caching, and an app shell for faster rendering.",
    "points": 10,
    "options": [
      {
        "id": "o1",
        "text": "HTTP/2 Server Push",
        "isCorrect": true,
        "explanation": ""
      },
      {
        "id": "o2",
        "text": "Service Workers",
        "isCorrect": true,
        "explanation": ""
      },
      {
        "id": "o3",
        "text": "App Shell Architecture",
        "isCorrect": true,
        "explanation": ""
      },
      {
        "id": "o4",
        "text": "jQuery AJAX for resource loading",
        "isCorrect": false,
        "explanation": ""
      }
    ],
    "hints": [],
    "metadata": {}
  },
  {
    "id": "performance-patterns-prpl-pp5",
    "title": "Why is code-splitting important in the PRPL pattern?",
    "content": "### Code-Splitting in PRPL\nCode-splitting divides the application into smaller, cachable chunks. This helps browsers load only what's necessary for the current route, improving performance and reducing cache bloat.",
    "type": "multiple-choice",
    "category": "Performance Patterns",
    "topic": "PRPL Pattern",
    "difficulty": "intermediate",
    "learningCardId": "system-design",
    "isActive": true,
    "createdAt": "2025-10-10T00:00:00.000Z",
    "updatedAt": "2025-11-11T18:50:32.257Z",
    "createdBy": "admin",
    "updatedBy": "admin",
    "tags": [
      "performance-patterns",
      "prpl-pattern",
      "intermediate"
    ],
    "explanation": "It ensures only the necessary parts of the app are loaded, improving performance and caching efficiency.",
    "points": 10,
    "sampleAnswers": [
      "It ensures only the necessary parts of the app are loaded, improving performance and caching efficiency."
    ],
    "hints": [],
    "metadata": {},
    "options": [
      {
        "id": "o1",
        "text": "It ensures only the necessary parts of the app are loaded, improving performance and caching efficiency.",
        "isCorrect": true,
        "explanation": "It ensures only the necessary parts of the app are loaded, improving performance and caching efficiency."
      },
      {
        "id": "o2",
        "text": "This is not correct. Please refer to the explanation.",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "o3",
        "text": "Incorrect. Review performance optimization concepts.",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "o4",
        "text": "This is a common misconception. The correct answer is different.",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "o5",
        "text": "Not quite. Consider web performance best practices.",
        "isCorrect": false,
        "explanation": ""
      }
    ]
  },
  {
    "id": "performance-patterns-prpl-pp6",
    "title": "Which step in PRPL involves caching frequently visited routes?",
    "content": "Identify which phase of the PRPL process focuses on pre-caching routes for better offline performance.",
    "type": "multiple-choice",
    "category": "Performance Patterns",
    "topic": "PRPL Pattern",
    "difficulty": "intermediate",
    "learningCardId": "system-design",
    "isActive": true,
    "createdAt": "2025-10-10T00:00:00.000Z",
    "updatedAt": "2025-11-11T18:50:32.257Z",
    "createdBy": "admin",
    "updatedBy": "admin",
    "tags": [
      "performance-patterns",
      "prpl-pattern",
      "beginner",
      "intermediate"
    ],
    "explanation": "Pre-caching ensures frequently visited routes and assets are stored for quick access and offline use.",
    "points": 10,
    "options": [
      {
        "id": "o1",
        "text": "Push",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "o2",
        "text": "Render",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "o3",
        "text": "Pre-cache",
        "isCorrect": true,
        "explanation": ""
      },
      {
        "id": "o4",
        "text": "Lazy-load",
        "isCorrect": false,
        "explanation": ""
      }
    ],
    "hints": [],
    "metadata": {}
  },
  {
    "id": "performance-patterns-prpl-pp7",
    "title": "What is a potential drawback of pushing too many resources in PRPL?",
    "content": "Select the correct consequence of over-pushing or over-preloading resources.",
    "type": "multiple-choice",
    "category": "Performance Patterns",
    "topic": "PRPL Pattern",
    "difficulty": "intermediate",
    "learningCardId": "system-design",
    "isActive": true,
    "createdAt": "2025-10-10T00:00:00.000Z",
    "updatedAt": "2025-11-11T18:50:32.257Z",
    "createdBy": "admin",
    "updatedBy": "admin",
    "tags": [
      "performance-patterns",
      "prpl-pattern",
      "intermediate"
    ],
    "explanation": "Pushing unnecessary files wastes bandwidth and fills the browser cache, reducing overall performance.",
    "points": 10,
    "options": [
      {
        "id": "o1",
        "text": "Improved caching performance",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "o2",
        "text": "Wasted bandwidth and filled browser cache",
        "isCorrect": true,
        "explanation": ""
      },
      {
        "id": "o3",
        "text": "Better offline support",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "o4",
        "text": "Reduced initial load time",
        "isCorrect": false,
        "explanation": ""
      }
    ],
    "hints": [],
    "metadata": {}
  },
  {
    "id": "performance-patterns-prpl-pp8",
    "title": "How does HTTP/2 improve performance for the PRPL pattern?",
    "content": "### HTTP/2 and PRPL\nHTTP/2 enables multiplexing — allowing multiple request/response streams over a single TCP connection. This reduces 'head-of-line' blocking and speeds up resource delivery, which complements PRPL’s 'Push' and 'Render' steps.",
    "type": "multiple-choice",
    "category": "Performance Patterns",
    "topic": "PRPL Pattern",
    "difficulty": "advanced",
    "learningCardId": "system-design",
    "isActive": true,
    "createdAt": "2025-10-10T00:00:00.000Z",
    "updatedAt": "2025-11-11T18:50:32.257Z",
    "createdBy": "admin",
    "updatedBy": "admin",
    "tags": [
      "performance-patterns",
      "prpl-pattern",
      "advanced"
    ],
    "explanation": "HTTP/2 allows multiple requests in one TCP connection, reducing latency and supporting PRPL’s goal of faster initial route rendering.",
    "points": 10,
    "sampleAnswers": [
      "HTTP/2 allows multiple requests in one TCP connection, reducing latency and supporting PRPL’s goal of faster initial route rendering."
    ],
    "hints": [],
    "metadata": {},
    "options": [
      {
        "id": "o1",
        "text": "HTTP/2 allows multiple requests in one TCP connection, reducing latency and supporting PRPL’s goal of faster initial route rendering.",
        "isCorrect": true,
        "explanation": "HTTP/2 allows multiple requests in one TCP connection, reducing latency and supporting PRPL’s goal of faster initial route rendering."
      },
      {
        "id": "o2",
        "text": "This is not correct. Please refer to the explanation.",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "o3",
        "text": "Incorrect. Review performance optimization concepts.",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "o4",
        "text": "This is a common misconception. The correct answer is different.",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "o5",
        "text": "Not quite. Consider web performance best practices.",
        "isCorrect": false,
        "explanation": ""
      }
    ]
  },
  {
    "id": "performance-patterns-prpl-pp9",
    "title": "What role does the App Shell play in the PRPL pattern?",
    "content": "Identify how the App Shell architecture supports the PRPL pattern.",
    "type": "multiple-choice",
    "category": "Performance Patterns",
    "topic": "PRPL Pattern",
    "difficulty": "intermediate",
    "learningCardId": "system-design",
    "isActive": true,
    "createdAt": "2025-10-10T00:00:00.000Z",
    "updatedAt": "2025-11-11T18:50:32.257Z",
    "createdBy": "admin",
    "updatedBy": "admin",
    "tags": [
      "performance-patterns",
      "prpl-pattern",
      "intermediate"
    ],
    "explanation": "The App Shell delivers the minimal UI structure immediately, allowing PRPL to render the first route quickly and cache other assets later.",
    "points": 10,
    "options": [
      {
        "id": "o1",
        "text": "Provides a minimal structure that loads instantly and handles routing",
        "isCorrect": true,
        "explanation": ""
      },
      {
        "id": "o2",
        "text": "Delays rendering until all assets are fetched",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "o3",
        "text": "Caches server responses in memory only",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "o4",
        "text": "Forces the app to reload on each navigation",
        "isCorrect": false,
        "explanation": ""
      }
    ],
    "hints": [],
    "metadata": {}
  },
  {
    "id": "performance-patterns-prpl-pp10",
    "title": "True or False: Service Workers are essential to implement the 'Pre-cache' and 'Lazy-load' steps of PRPL.",
    "content": "Assess whether Service Workers are necessary for caching and lazy loading in PRPL.",
    "type": "multiple-choice",
    "category": "Performance Patterns",
    "topic": "PRPL Pattern",
    "difficulty": "intermediate",
    "learningCardId": "system-design",
    "isActive": true,
    "createdAt": "2025-10-10T00:00:00.000Z",
    "updatedAt": "2025-11-11T18:50:32.257Z",
    "createdBy": "admin",
    "updatedBy": "admin",
    "tags": [
      "performance-patterns",
      "prpl-pattern",
      "intermediate"
    ],
    "explanation": "The correct answer is: True",
    "points": 10,
    "options": [
      {
        "id": "o1",
        "text": "True",
        "isCorrect": true,
        "explanation": "Service Workers enable background caching and lazy-loading of routes and assets in PRPL."
      },
      {
        "id": "o2",
        "text": "False",
        "isCorrect": false,
        "explanation": "PRPL relies heavily on Service Workers for offline caching and background resource fetching."
      },
      {
        "id": "o3",
        "text": "Partially true - depends on the context",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "o4",
        "text": "Not applicable",
        "isCorrect": false,
        "explanation": ""
      }
    ],
    "hints": [],
    "metadata": {}
  },
  {
    "id": "performance-patterns-prpl-pp11",
    "title": "What happens if we preload too many resources in the PRPL pattern?",
    "content": "### Over-Preloading\nPreloading too many assets increases competition for bandwidth, delaying critical resources like CSS or hero images and worsening Core Web Vitals such as Largest Contentful Paint (LCP).",
    "type": "multiple-choice",
    "category": "Performance Patterns",
    "topic": "PRPL Pattern",
    "difficulty": "advanced",
    "learningCardId": "system-design",
    "isActive": true,
    "createdAt": "2025-10-10T00:00:00.000Z",
    "updatedAt": "2025-11-11T18:50:32.257Z",
    "createdBy": "admin",
    "updatedBy": "admin",
    "tags": [
      "performance-patterns",
      "prpl-pattern",
      "advanced"
    ],
    "explanation": "It can delay critical rendering assets like CSS and images, worsening user-perceived performance metrics.",
    "points": 10,
    "sampleAnswers": [
      "It can delay critical rendering assets like CSS and images, worsening user-perceived performance metrics."
    ],
    "hints": [],
    "metadata": {},
    "options": [
      {
        "id": "o1",
        "text": "It can delay critical rendering assets like CSS and images, worsening user-perceived performance metrics.",
        "isCorrect": true,
        "explanation": "It can delay critical rendering assets like CSS and images, worsening user-perceived performance metrics."
      },
      {
        "id": "o2",
        "text": "This is not correct. Please refer to the explanation.",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "o3",
        "text": "Incorrect. Review performance optimization concepts.",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "o4",
        "text": "This is a common misconception. The correct answer is different.",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "o5",
        "text": "Not quite. Consider web performance best practices.",
        "isCorrect": false,
        "explanation": ""
      }
    ]
  },
  {
    "id": "performance-patterns-prpl-pp12",
    "title": "Which PRPL step directly improves the Time to Interactive (TTI) metric?",
    "content": "Select which part of the PRPL process helps achieve a faster TTI.",
    "type": "multiple-choice",
    "category": "Performance Patterns",
    "topic": "PRPL Pattern",
    "difficulty": "intermediate",
    "learningCardId": "system-design",
    "isActive": true,
    "createdAt": "2025-10-10T00:00:00.000Z",
    "updatedAt": "2025-11-11T18:50:32.257Z",
    "createdBy": "admin",
    "updatedBy": "admin",
    "tags": [
      "performance-patterns",
      "prpl-pattern",
      "intermediate"
    ],
    "explanation": "Rendering the initial route early reduces the time before a user can interact, improving TTI.",
    "points": 10,
    "options": [
      {
        "id": "o1",
        "text": "Render initial route quickly",
        "isCorrect": true,
        "explanation": ""
      },
      {
        "id": "o2",
        "text": "Pre-cache assets in background",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "o3",
        "text": "Lazy-load unused modules",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "o4",
        "text": "Push critical resources after render",
        "isCorrect": false,
        "explanation": ""
      }
    ],
    "hints": [],
    "metadata": {}
  },
  {
    "id": "performance-patterns-prpl-pp13",
    "title": "How does PRPL enhance offline experience?",
    "content": "Explain how PRPL ensures an app remains functional even without an internet connection.",
    "type": "multiple-choice",
    "category": "Performance Patterns",
    "topic": "PRPL Pattern",
    "difficulty": "intermediate",
    "learningCardId": "system-design",
    "isActive": true,
    "createdAt": "2025-10-10T00:00:00.000Z",
    "updatedAt": "2025-11-11T18:50:32.257Z",
    "createdBy": "admin",
    "updatedBy": "admin",
    "tags": [
      "performance-patterns",
      "prpl-pattern",
      "intermediate"
    ],
    "explanation": "By using Service Workers to pre-cache frequently visited routes and assets, so they can load from cache when offline.",
    "points": 10,
    "sampleAnswers": [
      "By using Service Workers to pre-cache frequently visited routes and assets, so they can load from cache when offline."
    ],
    "hints": [],
    "metadata": {},
    "options": [
      {
        "id": "o1",
        "text": "By using Service Workers to pre-cache frequently visited routes and assets, so they can load from cache when offline.",
        "isCorrect": true,
        "explanation": "By using Service Workers to pre-cache frequently visited routes and assets, so they can load from cache when offline."
      },
      {
        "id": "o2",
        "text": "This is not correct. Please refer to the explanation.",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "o3",
        "text": "Incorrect. Review performance optimization concepts.",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "o4",
        "text": "This is a common misconception. The correct answer is different.",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "o5",
        "text": "Not quite. Consider web performance best practices.",
        "isCorrect": false,
        "explanation": ""
      }
    ]
  },
  {
    "id": "performance-patterns-prpl-pp14",
    "title": "Which step in PRPL primarily benefits from HTTP/2 server push?",
    "content": "Identify where HTTP/2 server push has the most effect in the PRPL process.",
    "type": "multiple-choice",
    "category": "Performance Patterns",
    "topic": "PRPL Pattern",
    "difficulty": "intermediate",
    "learningCardId": "system-design",
    "isActive": true,
    "createdAt": "2025-10-10T00:00:00.000Z",
    "updatedAt": "2025-11-11T18:50:32.257Z",
    "createdBy": "admin",
    "updatedBy": "admin",
    "tags": [
      "performance-patterns",
      "prpl-pattern",
      "intermediate"
    ],
    "explanation": "HTTP/2 server push accelerates the 'Push' step by sending critical resources before the browser requests them.",
    "points": 10,
    "options": [
      {
        "id": "o1",
        "text": "Push",
        "isCorrect": true,
        "explanation": ""
      },
      {
        "id": "o2",
        "text": "Render",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "o3",
        "text": "Pre-cache",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "o4",
        "text": "Lazy-load",
        "isCorrect": false,
        "explanation": ""
      }
    ],
    "hints": [],
    "metadata": {}
  },
  {
    "id": "performance-patterns-prpl-pp15",
    "title": "True or False: PRPL can only be implemented in Progressive Web Apps (PWAs).",
    "content": "Evaluate the statement about PRPL’s application scope.",
    "type": "multiple-choice",
    "category": "Performance Patterns",
    "topic": "PRPL Pattern",
    "difficulty": "intermediate",
    "learningCardId": "system-design",
    "isActive": true,
    "createdAt": "2025-10-10T00:00:00.000Z",
    "updatedAt": "2025-11-11T18:50:32.257Z",
    "createdBy": "admin",
    "updatedBy": "admin",
    "tags": [
      "performance-patterns",
      "prpl-pattern",
      "beginner",
      "intermediate"
    ],
    "explanation": "The correct answer is: False",
    "points": 10,
    "options": [
      {
        "id": "o1",
        "text": "True",
        "isCorrect": false,
        "explanation": "While PWAs benefit most, PRPL can be used in any web app with modular architecture and caching."
      },
      {
        "id": "o2",
        "text": "False",
        "isCorrect": false,
        "explanation": "While PWAs benefit most, PRPL can be used in any web app with modular architecture and caching."
      },
      {
        "id": "o3",
        "text": "Partially true - depends on the context",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "o4",
        "text": "Not applicable",
        "isCorrect": false,
        "explanation": ""
      }
    ],
    "hints": [],
    "metadata": {}
  },
  {
    "id": "performance-patterns-dynamic-import-13",
    "title": "Which React function is used to dynamically import components?",
    "content": "React.lazy is used to dynamically import components at runtime.",
    "type": "multiple-choice",
    "category": "Performance Patterns",
    "topic": "React Lazy Loading",
    "difficulty": "intermediate",
    "learningCardId": "system-design",
    "isActive": true,
    "createdAt": "2025-10-10T00:00:00Z",
    "updatedAt": "2025-11-11T18:50:32.188Z",
    "createdBy": "admin",
    "updatedBy": "admin",
    "tags": [
      "performance-patterns",
      "react-lazy-loading",
      "beginner",
      "intermediate"
    ],
    "explanation": "<code>React.lazy(() =&gt; import('./Component'))</code> loads a component only when it is rendered for the first time.",
    "points": 10,
    "options": [
      {
        "id": "o1",
        "text": "React.useMemo",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "o2",
        "text": "React.lazy",
        "isCorrect": true,
        "explanation": ""
      },
      {
        "id": "o3",
        "text": "React.load",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "o4",
        "text": "React.defer",
        "isCorrect": false,
        "explanation": ""
      }
    ],
    "sampleAnswers": [
      "React.lazy"
    ],
    "hints": [],
    "metadata": {}
  },
  {
    "id": "performance-patterns-import-on-interaction-7",
    "title": "How does React support Import On Interaction?",
    "content": "React supports lazy-loading components using React.lazy and Suspense, or by dynamically importing a component on user interaction.",
    "type": "multiple-choice",
    "category": "Performance Patterns",
    "topic": "React Lazy Loading",
    "difficulty": "intermediate",
    "learningCardId": "system-design",
    "isActive": true,
    "createdAt": "2025-10-10T00:00:00Z",
    "updatedAt": "2025-11-11T18:50:32.201Z",
    "createdBy": "admin",
    "updatedBy": "admin",
    "tags": [
      "performance-patterns",
      "react-lazy-loading",
      "intermediate"
    ],
    "explanation": "React’s <code>lazy()</code> and <code>Suspense</code> make it easy to defer loading non-critical components until interaction occurs.",
    "points": 10,
    "options": [
      {
        "id": "o1",
        "text": "By compiling components on the server",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "o2",
        "text": "Using React.lazy and Suspense or dynamic import on click",
        "isCorrect": true,
        "explanation": ""
      },
      {
        "id": "o3",
        "text": "By using React.useMemo for caching",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "o4",
        "text": "Through hydration delay APIs",
        "isCorrect": false,
        "explanation": ""
      }
    ],
    "sampleAnswers": [
      "Using React.lazy and Suspense or dynamic import on click"
    ],
    "hints": [],
    "metadata": {}
  },
  {
    "id": "performance-patterns-dynamic-import-12",
    "title": "How does React Suspense help in dynamic importing?",
    "content": "React Suspense allows components to wait for a dynamically imported module to load, showing a fallback while loading.",
    "type": "multiple-choice",
    "category": "Performance Patterns",
    "topic": "React Suspense",
    "difficulty": "intermediate",
    "learningCardId": "system-design",
    "isActive": true,
    "createdAt": "2025-10-10T00:00:00Z",
    "updatedAt": "2025-11-11T18:50:32.187Z",
    "createdBy": "admin",
    "updatedBy": "admin",
    "tags": [
      "performance-patterns",
      "react-suspense",
      "beginner",
      "intermediate"
    ],
    "explanation": "Suspense provides a fallback UI while waiting for the dynamically imported component to be fetched and rendered.",
    "points": 10,
    "options": [
      {
        "id": "o1",
        "text": "It preloads all components before rendering",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "o2",
        "text": "It blocks rendering until all resources are loaded",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "o3",
        "text": "It renders a fallback while a lazy component loads",
        "isCorrect": true,
        "explanation": ""
      },
      {
        "id": "o4",
        "text": "It disables lazy loading",
        "isCorrect": false,
        "explanation": ""
      }
    ],
    "sampleAnswers": [
      "It renders a fallback while a lazy component loads"
    ],
    "hints": [],
    "metadata": {}
  },
  {
    "id": "performance-patterns-dynamic-import-16",
    "title": "What is the purpose of the fallback prop in Suspense?",
    "content": "The fallback prop defines what should be rendered while a component is being dynamically loaded.",
    "type": "multiple-choice",
    "category": "Performance Patterns",
    "topic": "React Suspense Fallback",
    "difficulty": "intermediate",
    "learningCardId": "system-design",
    "isActive": true,
    "createdAt": "2025-10-10T00:00:00Z",
    "updatedAt": "2025-11-11T18:50:32.188Z",
    "createdBy": "admin",
    "updatedBy": "admin",
    "tags": [
      "performance-patterns",
      "react-suspense-fallback",
      "beginner",
      "intermediate"
    ],
    "explanation": "Suspense uses the fallback UI (like a loader or placeholder) until the lazy component finishes loading.",
    "points": 10,
    "options": [
      {
        "id": "o1",
        "text": "Defines a backup component to use if loading fails",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "o2",
        "text": "Displays content while waiting for lazy component",
        "isCorrect": true,
        "explanation": ""
      },
      {
        "id": "o3",
        "text": "Triggers a re-render on error",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "o4",
        "text": "Caches the lazy component",
        "isCorrect": false,
        "explanation": ""
      }
    ],
    "sampleAnswers": [
      "Displays content while waiting for lazy component"
    ],
    "hints": [],
    "metadata": {}
  },
  {
    "id": "performance-patterns-import-on-visibility-11",
    "title": "How does “react-loadable-visibility” enhance lazy loading in React?",
    "content": "It combines dynamic imports with visibility detection, ensuring components are only loaded when they are about to appear on screen.",
    "type": "open-ended",
    "category": "Performance Patterns",
    "topic": "react-loadable-visibility",
    "difficulty": "intermediate",
    "learningCardId": "system-design",
    "isActive": true,
    "createdAt": "2025-10-10",
    "updatedAt": "2025-11-11T18:50:32.209Z",
    "createdBy": "admin",
    "updatedBy": "admin",
    "tags": [
      "performance-patterns",
      "react-loadable-visibility",
      "intermediate"
    ],
    "explanation": "Instead of pre-loading all lazy components, it waits until the user scrolls to them, saving bandwidth and improving UX.",
    "points": 10,
    "options": [],
    "sampleAnswers": [
      "It lazy loads components only when visible."
    ],
    "hints": [],
    "metadata": {}
  },
  {
    "id": "performance-patterns-virtualization-lv5",
    "title": "Which components in react-window render virtualized content?",
    "content": "Name and describe the main components in react-window used for list and grid virtualization.",
    "type": "multiple-choice",
    "category": "Performance Patterns",
    "topic": "React-Window Components",
    "difficulty": "intermediate",
    "learningCardId": "system-design",
    "isActive": true,
    "createdAt": "2025-10-11T00:00:00.000Z",
    "updatedAt": "2025-11-11T18:50:32.271Z",
    "createdBy": "admin",
    "updatedBy": "admin",
    "tags": [
      "performance-patterns",
      "react-window-components",
      "intermediate"
    ],
    "explanation": "react-window provides FixedSizeList/VariableSizeList for virtualized lists and FixedSizeGrid/VariableSizeGrid for virtualized grids.",
    "points": 10,
    "options": [
      {
        "id": "o1",
        "text": "FixedSizeList and VariableSizeList for lists; FixedSizeGrid and VariableSizeGrid for grids",
        "isCorrect": true,
        "explanation": ""
      },
      {
        "id": "o2",
        "text": "InfiniteScrollList and TableGrid",
        "isCorrect": false,
        "explanation": ""
      }
    ],
    "hints": [],
    "metadata": {}
  },
  {
    "id": "performance-patterns-import-on-interaction-9",
    "title": "What is an example of Import On Interaction in Google Docs?",
    "content": "Google Docs loads the 500KB share feature script only when the user clicks the Share button.",
    "type": "multiple-choice",
    "category": "Performance Patterns",
    "topic": "Real World Example",
    "difficulty": "intermediate",
    "learningCardId": "system-design",
    "isActive": true,
    "createdAt": "2025-10-10T00:00:00Z",
    "updatedAt": "2025-11-11T18:50:32.201Z",
    "createdBy": "admin",
    "updatedBy": "admin",
    "tags": [
      "performance-patterns",
      "real-world-example",
      "beginner",
      "intermediate"
    ],
    "explanation": "Google Docs defers loading large non-critical scripts until the user actually interacts with the Share feature.",
    "points": 10,
    "options": [
      {
        "id": "o1",
        "text": "It preloads all scripts on startup",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "o2",
        "text": "It loads the share feature dynamically on click",
        "isCorrect": true,
        "explanation": ""
      },
      {
        "id": "o3",
        "text": "It blocks the main thread for performance",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "o4",
        "text": "It disables user interactions during load",
        "isCorrect": false,
        "explanation": ""
      }
    ],
    "sampleAnswers": [
      "It loads the share feature dynamically on click"
    ],
    "hints": [],
    "metadata": {}
  },
  {
    "id": "performance-patterns-loading-sequence-8",
    "title": "Next.js ScriptLoader Usage",
    "content": "Which Next.js ScriptLoader priority should be used for scripts that run after hydration, such as analytics?",
    "type": "multiple-choice",
    "category": "Performance Patterns",
    "topic": "Script Loading",
    "difficulty": "intermediate",
    "learningCardId": "system-design",
    "isActive": true,
    "createdAt": "2025-10-10T00:00:00Z",
    "updatedAt": "2025-11-11T18:50:32.218Z",
    "createdBy": "admin",
    "updatedBy": "admin",
    "tags": [
      "performance-patterns",
      "script-loading",
      "intermediate"
    ],
    "explanation": "Scripts like analytics should use 'After-Interactive' so they load after hydration without blocking critical rendering.",
    "points": 10,
    "options": [
      {
        "id": "o1",
        "text": "Before-Interactive",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "o2",
        "text": "After-Interactive",
        "isCorrect": true,
        "explanation": ""
      },
      {
        "id": "o3",
        "text": "Lazy-Onload",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "o4",
        "text": "Async-Preload",
        "isCorrect": false,
        "explanation": ""
      }
    ],
    "sampleAnswers": [
      "After-Interactive"
    ],
    "hints": [],
    "metadata": {}
  },
  {
    "id": "performance-patterns-pre-load-6",
    "title": "Preload + Async Hack",
    "content": "What is the goal of combining <code>&lt;link rel='preload'&gt;</code> with <code>&lt;script async&gt;</code>?",
    "type": "multiple-choice",
    "category": "Performance Patterns",
    "topic": "Script Optimization",
    "difficulty": "advanced",
    "learningCardId": "system-design",
    "isActive": true,
    "createdAt": "2025-10-10T00:00:00Z",
    "updatedAt": "2025-11-11T18:50:32.240Z",
    "createdBy": "admin",
    "updatedBy": "admin",
    "tags": [
      "performance-patterns",
      "script-optimization",
      "advanced"
    ],
    "explanation": "This technique downloads the script as a high-priority resource but doesn’t block parsing while it loads.",
    "points": 10,
    "options": [
      {
        "id": "a",
        "text": "To load a script early without blocking the HTML parser",
        "isCorrect": true,
        "explanation": ""
      },
      {
        "id": "b",
        "text": "To execute the script synchronously",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "c",
        "text": "To delay the script until the user interacts",
        "isCorrect": false,
        "explanation": ""
      }
    ],
    "sampleAnswers": [
      "It lets browsers fetch scripts early without blocking page rendering."
    ],
    "hints": [],
    "metadata": {}
  },
  {
    "id": "performance-patterns-import-on-visibility-14",
    "title": "What benefits does import-on-visibility offer for large single-page applications?",
    "content": "It helps reduce main bundle size, optimizes network requests, and improves time-to-interactive (TTI) by loading only visible components.",
    "type": "open-ended",
    "category": "Performance Patterns",
    "topic": "SPA Optimization",
    "difficulty": "intermediate",
    "learningCardId": "system-design",
    "isActive": true,
    "createdAt": "2025-10-10",
    "updatedAt": "2025-11-11T18:50:32.209Z",
    "createdBy": "admin",
    "updatedBy": "admin",
    "tags": [
      "performance-patterns",
      "spa-optimization",
      "intermediate"
    ],
    "explanation": "Users experience faster initial render and smoother scrolling as code loads progressively.",
    "points": 10,
    "options": [],
    "sampleAnswers": [
      "Smaller bundles and faster initial render."
    ],
    "hints": [],
    "metadata": {}
  },
  {
    "id": "performance-patterns-pre-load-5",
    "title": "Preload in Single-Page Applications",
    "content": "In SPAs, when is preloading most useful?",
    "type": "multiple-choice",
    "category": "Performance Patterns",
    "topic": "SPA Optimization",
    "difficulty": "intermediate",
    "learningCardId": "system-design",
    "isActive": true,
    "createdAt": "2025-10-10T00:00:00Z",
    "updatedAt": "2025-11-11T18:50:32.240Z",
    "createdBy": "admin",
    "updatedBy": "admin",
    "tags": [
      "performance-patterns",
      "spa-optimization",
      "intermediate"
    ],
    "explanation": "Preloading helps ensure components needed immediately after page load are ready without waiting for network fetches.",
    "points": 10,
    "options": [
      {
        "id": "o1",
        "text": "When a component or font must be available instantly on the first render.",
        "isCorrect": true,
        "explanation": "Preloading helps ensure components needed immediately after page load are ready without waiting for network fetches."
      },
      {
        "id": "o2",
        "text": "This is not correct. Please refer to the explanation.",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "o3",
        "text": "Incorrect. Review performance optimization concepts.",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "o4",
        "text": "This is a common misconception. The correct answer is different.",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "o5",
        "text": "Not quite. Consider web performance best practices.",
        "isCorrect": false,
        "explanation": ""
      }
    ],
    "sampleAnswers": [
      "When a component or font must be available instantly on the first render."
    ],
    "hints": [],
    "metadata": {}
  },
  {
    "id": "performance-patterns-dynamic-import-18",
    "title": "What library is recommended for dynamic imports in SSR applications?",
    "content": "The loadable-components library is recommended for SSR applications since React Suspense does not yet support SSR.",
    "type": "multiple-choice",
    "category": "Performance Patterns",
    "topic": "SSR Alternatives",
    "difficulty": "intermediate",
    "learningCardId": "system-design",
    "isActive": true,
    "createdAt": "2025-10-10T00:00:00Z",
    "updatedAt": "2025-11-11T18:50:32.188Z",
    "createdBy": "admin",
    "updatedBy": "admin",
    "tags": [
      "performance-patterns",
      "ssr-alternatives",
      "intermediate"
    ],
    "explanation": "The <code>@loadable/component</code> library provides a Suspense-like API compatible with both SSR and CSR environments.",
    "points": 10,
    "options": [
      {
        "id": "o1",
        "text": "React.lazy",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "o2",
        "text": "React.Suspense",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "o3",
        "text": "@loadable/component",
        "isCorrect": true,
        "explanation": ""
      },
      {
        "id": "o4",
        "text": "NextDynamic",
        "isCorrect": false,
        "explanation": ""
      }
    ],
    "sampleAnswers": [
      "@loadable/component"
    ],
    "hints": [],
    "metadata": {}
  },
  {
    "id": "performance-patterns-dynamic-import-17",
    "title": "Why is React Suspense not ideal for server-side rendering (SSR)?",
    "content": "React Suspense currently lacks SSR support, meaning lazy-loaded components can’t be pre-rendered on the server.",
    "type": "multiple-choice",
    "category": "Performance Patterns",
    "topic": "SSR Limitation",
    "difficulty": "intermediate",
    "learningCardId": "system-design",
    "isActive": true,
    "createdAt": "2025-10-10T00:00:00Z",
    "updatedAt": "2025-11-11T18:50:32.188Z",
    "createdBy": "admin",
    "updatedBy": "admin",
    "tags": [
      "performance-patterns",
      "ssr-limitation",
      "intermediate"
    ],
    "explanation": "Suspense currently only supports client-side rendering; SSR requires libraries like <code>@loadable/component</code> to manage lazy imports.",
    "points": 10,
    "options": [
      {
        "id": "o1",
        "text": "Because SSR can’t handle async operations",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "o2",
        "text": "Because Suspense can’t yet stream server-rendered lazy components",
        "isCorrect": true,
        "explanation": ""
      },
      {
        "id": "o3",
        "text": "Because it increases bundle size",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "o4",
        "text": "Because Suspense only works in Next.js",
        "isCorrect": false,
        "explanation": ""
      }
    ],
    "sampleAnswers": [
      "Because Suspense can’t yet stream server-rendered lazy components"
    ],
    "hints": [],
    "metadata": {}
  },
  {
    "id": "performance-patterns-third-party-tp3",
    "title": "How can you optimize non-critical third-party JavaScript?",
    "content": "Explain async and defer usage for non-critical third-party scripts.",
    "type": "multiple-choice",
    "category": "Performance Patterns",
    "topic": "Third-Party Loading",
    "difficulty": "intermediate",
    "learningCardId": "system-design",
    "isActive": true,
    "createdAt": "2025-10-11T00:00:00.000Z",
    "updatedAt": "2025-11-11T18:50:32.264Z",
    "createdBy": "admin",
    "updatedBy": "admin",
    "tags": [
      "performance-patterns",
      "third-party-loading",
      "intermediate"
    ],
    "explanation": "Use defer to fetch scripts in parallel and execute after DOM parsing, or async to execute as soon as available without blocking the parser, for scripts that are not critical to initial rendering.",
    "points": 10,
    "sampleAnswers": [
      "Use defer to fetch scripts in parallel and execute after DOM parsing, or async to execute as soon as available without blocking the parser, for scripts that are not critical to initial rendering."
    ],
    "hints": [],
    "metadata": {},
    "options": [
      {
        "id": "o1",
        "text": "Use defer to fetch scripts in parallel and execute after DOM parsing, or async to execute as soon as available without blocking the parser, for scripts that are not critical to initial rendering.",
        "isCorrect": true,
        "explanation": "Use defer to fetch scripts in parallel and execute after DOM parsing, or async to execute as soon as available without blocking the parser, for scripts that are not critical to initial rendering."
      },
      {
        "id": "o2",
        "text": "This is not correct. Please refer to the explanation.",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "o3",
        "text": "Incorrect. Review performance optimization concepts.",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "o4",
        "text": "This is a common misconception. The correct answer is different.",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "o5",
        "text": "Not quite. Consider web performance best practices.",
        "isCorrect": false,
        "explanation": ""
      }
    ]
  },
  {
    "id": "performance-patterns-third-party-tp4",
    "title": "True or False: Preconnect and dns-prefetch can speed up third-party resource loading.",
    "content": "Evaluate whether resource hints improve third-party performance.",
    "type": "multiple-choice",
    "category": "Performance Patterns",
    "topic": "Third-Party Loading",
    "difficulty": "intermediate",
    "learningCardId": "system-design",
    "isActive": true,
    "createdAt": "2025-10-11T00:00:00.000Z",
    "updatedAt": "2025-11-11T18:50:32.264Z",
    "createdBy": "admin",
    "updatedBy": "admin",
    "tags": [
      "performance-patterns",
      "third-party-loading",
      "intermediate"
    ],
    "explanation": "The correct answer is: True",
    "points": 10,
    "options": [
      {
        "id": "o1",
        "text": "True",
        "isCorrect": true,
        "explanation": "Resource hints like dns-prefetch and preconnect reduce latency by initiating DNS lookups and TCP/TLS connections early."
      },
      {
        "id": "o2",
        "text": "False",
        "isCorrect": false,
        "explanation": "Resource hints are effective and recommended for critical third-party resources."
      },
      {
        "id": "o3",
        "text": "Partially true - depends on the context",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "o4",
        "text": "Not applicable",
        "isCorrect": false,
        "explanation": ""
      }
    ],
    "hints": [],
    "metadata": {}
  },
  {
    "id": "performance-patterns-third-party-tp5",
    "title": "What is the benefit of lazy-loading third-party embeds?",
    "content": "Explain why lazy-loading YouTube, maps, and social media embeds improves page performance.",
    "type": "multiple-choice",
    "category": "Performance Patterns",
    "topic": "Third-Party Loading",
    "difficulty": "intermediate",
    "learningCardId": "system-design",
    "isActive": true,
    "createdAt": "2025-10-11T00:00:00.000Z",
    "updatedAt": "2025-11-11T18:50:32.264Z",
    "createdBy": "admin",
    "updatedBy": "admin",
    "tags": [
      "performance-patterns",
      "third-party-loading",
      "intermediate"
    ],
    "explanation": "Embeds not visible on page load are delayed until needed, reducing initial load times and blocking of critical rendering.",
    "points": 10,
    "sampleAnswers": [
      "Embeds not visible on page load are delayed until needed, reducing initial load times and blocking of critical rendering."
    ],
    "hints": [],
    "metadata": {},
    "options": [
      {
        "id": "o1",
        "text": "Embeds not visible on page load are delayed until needed, reducing initial load times and blocking of critical rendering.",
        "isCorrect": true,
        "explanation": "Embeds not visible on page load are delayed until needed, reducing initial load times and blocking of critical rendering."
      },
      {
        "id": "o2",
        "text": "This is not correct. Please refer to the explanation.",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "o3",
        "text": "Incorrect. Review performance optimization concepts.",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "o4",
        "text": "This is a common misconception. The correct answer is different.",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "o5",
        "text": "Not quite. Consider web performance best practices.",
        "isCorrect": false,
        "explanation": ""
      }
    ]
  },
  {
    "id": "performance-patterns-third-party-tp6",
    "title": "Why might self-hosting third-party scripts improve performance?",
    "content": "Describe the advantages and caveats of self-hosting 3P scripts.",
    "type": "multiple-choice",
    "category": "Performance Patterns",
    "topic": "Third-Party Loading",
    "difficulty": "advanced",
    "learningCardId": "system-design",
    "isActive": true,
    "createdAt": "2025-10-11T00:00:00.000Z",
    "updatedAt": "2025-11-11T18:50:32.264Z",
    "createdBy": "admin",
    "updatedBy": "admin",
    "tags": [
      "performance-patterns",
      "third-party-loading",
      "advanced"
    ],
    "explanation": "Reduces DNS lookups, allows better caching control, and can use HTTP/2 push, but scripts must be updated regularly to stay current.",
    "points": 10,
    "sampleAnswers": [
      "Reduces DNS lookups, allows better caching control, and can use HTTP/2 push, but scripts must be updated regularly to stay current."
    ],
    "hints": [],
    "metadata": {},
    "options": [
      {
        "id": "o1",
        "text": "Reduces DNS lookups, allows better caching control, and can use HTTP/2 push, but scripts must be updated regularly to stay current.",
        "isCorrect": true,
        "explanation": "Reduces DNS lookups, allows better caching control, and can use HTTP/2 push, but scripts must be updated regularly to stay current."
      },
      {
        "id": "o2",
        "text": "This is not correct. Please refer to the explanation.",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "o3",
        "text": "Incorrect. Review performance optimization concepts.",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "o4",
        "text": "This is a common misconception. The correct answer is different.",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "o5",
        "text": "Not quite. Consider web performance best practices.",
        "isCorrect": false,
        "explanation": ""
      }
    ]
  },
  {
    "id": "performance-patterns-import-on-interaction-10",
    "title": "What is a common use case for Import On Interaction with third-party widgets?",
    "content": "Loading chat widgets, video players, or authentication SDKs only after user interaction to save initial load time.",
    "type": "multiple-choice",
    "category": "Performance Patterns",
    "topic": "Third-Party Optimization",
    "difficulty": "intermediate",
    "learningCardId": "system-design",
    "isActive": true,
    "createdAt": "2025-10-10T00:00:00Z",
    "updatedAt": "2025-11-11T18:50:32.201Z",
    "createdBy": "admin",
    "updatedBy": "admin",
    "tags": [
      "performance-patterns",
      "third-party-optimization",
      "intermediate"
    ],
    "explanation": "Deferring third-party widget code until interaction avoids blocking critical rendering and reduces main-thread congestion.",
    "points": 10,
    "options": [
      {
        "id": "o1",
        "text": "Preloading all external SDKs",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "o2",
        "text": "Lazy-loading non-critical third-party widgets",
        "isCorrect": true,
        "explanation": ""
      },
      {
        "id": "o3",
        "text": "Loading all widgets synchronously",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "o4",
        "text": "Disabling widgets for performance",
        "isCorrect": false,
        "explanation": ""
      }
    ],
    "sampleAnswers": [
      "Lazy-loading non-critical third-party widgets"
    ],
    "hints": [],
    "metadata": {}
  },
  {
    "id": "performance-patterns-loading-sequence-4",
    "title": "Third-Party Scripts Impact",
    "content": "How do third-party scripts usually affect page load performance?",
    "type": "multiple-choice",
    "category": "Performance Patterns",
    "topic": "Third-Party Performance",
    "difficulty": "intermediate",
    "learningCardId": "system-design",
    "isActive": true,
    "createdAt": "2025-10-10T00:00:00Z",
    "updatedAt": "2025-11-11T18:50:32.217Z",
    "createdBy": "admin",
    "updatedBy": "admin",
    "tags": [
      "performance-patterns",
      "third-party-performance",
      "intermediate"
    ],
    "explanation": "Third-party scripts like ads or analytics often block rendering or delay other resources, harming metrics like FID and LCP.",
    "points": 10,
    "options": [
      {
        "id": "o1",
        "text": "They optimize the sequence automatically",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "o2",
        "text": "They often block rendering and delay critical resource loading",
        "isCorrect": true,
        "explanation": ""
      },
      {
        "id": "o3",
        "text": "They improve CPU utilization",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "o4",
        "text": "They load after all first-party scripts by default",
        "isCorrect": false,
        "explanation": ""
      }
    ],
    "sampleAnswers": [
      "They often block rendering and delay critical resource loading"
    ],
    "hints": [],
    "metadata": {}
  },
  {
    "id": "performance-patterns-third-party-tp2",
    "title": "Why can third-party scripts slow down your website?",
    "content": "Identify the main ways third-party scripts negatively impact performance.",
    "type": "multiple-choice",
    "category": "Performance Patterns",
    "topic": "Third-Party Performance Impact",
    "difficulty": "intermediate",
    "learningCardId": "system-design",
    "isActive": true,
    "createdAt": "2025-10-11T00:00:00.000Z",
    "updatedAt": "2025-11-11T18:50:32.264Z",
    "createdBy": "admin",
    "updatedBy": "admin",
    "tags": [
      "performance-patterns",
      "third-party-performance-impact",
      "intermediate"
    ],
    "explanation": "Third-party scripts can block rendering, increase network requests, and execute heavy JS, negatively impacting Core Web Vitals.",
    "points": 10,
    "options": [
      {
        "id": "o1",
        "text": "Additional round trips to other domains",
        "isCorrect": true,
        "explanation": ""
      },
      {
        "id": "o2",
        "text": "Bulky or unoptimized JavaScript",
        "isCorrect": true,
        "explanation": ""
      },
      {
        "id": "o3",
        "text": "Blocking rendering of critical resources",
        "isCorrect": true,
        "explanation": ""
      },
      {
        "id": "o4",
        "text": "Always reduces DNS lookup times",
        "isCorrect": false,
        "explanation": ""
      }
    ],
    "hints": [],
    "metadata": {}
  },
  {
    "id": "performance-patterns-third-party-tp1",
    "title": "What are third-party resources on a website?",
    "content": "Define third-party resources and give examples.",
    "type": "multiple-choice",
    "category": "Performance Patterns",
    "topic": "Third-Party Resources",
    "difficulty": "intermediate",
    "learningCardId": "system-design",
    "isActive": true,
    "createdAt": "2025-10-11T00:00:00.000Z",
    "updatedAt": "2025-11-11T18:50:32.264Z",
    "createdBy": "admin",
    "updatedBy": "admin",
    "tags": [
      "performance-patterns",
      "third-party-resources",
      "beginner",
      "intermediate"
    ],
    "explanation": "Resources hosted on another domain and used by your site, e.g., YouTube embeds, Google Analytics, social media widgets, maps, advertisements.",
    "points": 10,
    "sampleAnswers": [
      "Resources hosted on another domain and used by your site, e.g., YouTube embeds, Google Analytics, social media widgets, maps, advertisements."
    ],
    "hints": [],
    "metadata": {},
    "options": [
      {
        "id": "o1",
        "text": "Resources hosted on another domain and used by your site, e.g., YouTube embeds, Google Analytics, social media widgets, maps, advertisements.",
        "isCorrect": true,
        "explanation": "Resources hosted on another domain and used by your site, e.g., YouTube embeds, Google Analytics, social media widgets, maps, advertisements."
      },
      {
        "id": "o2",
        "text": "This is not correct. Please refer to the explanation.",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "o3",
        "text": "Incorrect. Review performance optimization concepts.",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "o4",
        "text": "This is a common misconception. The correct answer is different.",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "o5",
        "text": "Not quite. Consider web performance best practices.",
        "isCorrect": false,
        "explanation": ""
      }
    ]
  },
  {
    "id": "performance-patterns-import-on-interaction-4",
    "title": "What problem does Import On Interaction solve with third-party scripts?",
    "content": "Third-party scripts can block rendering or hydration. Import On Interaction delays their load until user interaction.",
    "type": "multiple-choice",
    "category": "Performance Patterns",
    "topic": "Third-Party Script Optimization",
    "difficulty": "intermediate",
    "learningCardId": "system-design",
    "isActive": true,
    "createdAt": "2025-10-10T00:00:00Z",
    "updatedAt": "2025-11-11T18:50:32.201Z",
    "createdBy": "admin",
    "updatedBy": "admin",
    "tags": [
      "performance-patterns",
      "third-party-script-optimization",
      "intermediate"
    ],
    "explanation": "By loading third-party scripts only when needed, the main thread remains available for critical tasks like rendering and user input.",
    "points": 10,
    "options": [
      {
        "id": "o1",
        "text": "It blocks third-party scripts completely",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "o2",
        "text": "It ensures third-party scripts load before first paint",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "o3",
        "text": "It defers non-critical third-party scripts until needed",
        "isCorrect": true,
        "explanation": ""
      },
      {
        "id": "o4",
        "text": "It preloads all external scripts",
        "isCorrect": false,
        "explanation": ""
      }
    ],
    "sampleAnswers": [
      "It defers non-critical third-party scripts until needed"
    ],
    "hints": [],
    "metadata": {}
  },
  {
    "id": "performance-patterns-bundle-splitting-pp6",
    "title": "Which of the following statements best describes Time To Interactive (TTI)?",
    "content": "Select the correct definition for TTI in the context of performance patterns.",
    "type": "multiple-choice",
    "category": "Performance Patterns",
    "topic": "Time To Interactive",
    "difficulty": "intermediate",
    "learningCardId": "system-design",
    "isActive": true,
    "createdAt": "2025-10-10T00:00:00.000Z",
    "updatedAt": "2025-11-11T18:50:32.164Z",
    "createdBy": "admin",
    "updatedBy": "admin",
    "tags": [
      "performance-patterns",
      "time-to-interactive",
      "beginner",
      "intermediate"
    ],
    "explanation": "TTI measures how long it takes for the page to become fully interactive, which bundle splitting helps improve by reducing load and execution time.",
    "points": 10,
    "options": [
      {
        "id": "c1",
        "text": "The time it takes for all content to be painted and interactive after the bundle loads",
        "isCorrect": true,
        "explanation": ""
      },
      {
        "id": "c2",
        "text": "The time between a user's first input and a response",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "c3",
        "text": "The time it takes to fetch the HTML document from the server",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "c4",
        "text": "The total JavaScript execution time",
        "isCorrect": false,
        "explanation": ""
      }
    ],
    "hints": [],
    "metadata": {}
  },
  {
    "id": "performance-patterns-tree-shaking-ts4",
    "title": "Given the following code, which function will be included in the final bundle?",
    "content": "<pre><code>// utilities.js\nexport function read(props) { return props.book; }\nexport function nap(props) { return props.winks; }\n\n// index.js\nimport { read } from 'utilities';\nconst eventHandler = (e) =&gt; { read({ book: e.target.value }); };</code></pre>",
    "type": "multiple-choice",
    "category": "Performance Patterns",
    "topic": "Tree Shaking Example",
    "difficulty": "intermediate",
    "learningCardId": "system-design",
    "isActive": true,
    "createdAt": "2025-10-11T00:00:00.000Z",
    "updatedAt": "2025-11-11T18:50:32.264Z",
    "createdBy": "admin",
    "updatedBy": "admin",
    "tags": [
      "performance-patterns",
      "tree-shaking-example",
      "intermediate"
    ],
    "explanation": "Only read() is used in index.js, so nap() is considered dead code and excluded from the bundle.",
    "points": 10,
    "options": [
      {
        "id": "o1",
        "text": "read()",
        "isCorrect": true,
        "explanation": ""
      },
      {
        "id": "o2",
        "text": "nap()",
        "isCorrect": false,
        "explanation": ""
      }
    ],
    "hints": [],
    "metadata": {}
  },
  {
    "id": "performance-patterns-tree-shaking-ts5",
    "title": "How does tree shaking determine which parts of the code to include?",
    "content": "Explain the traversal process used in tree shaking.",
    "type": "multiple-choice",
    "category": "Performance Patterns",
    "topic": "Tree Shaking Mechanism",
    "difficulty": "advanced",
    "learningCardId": "system-design",
    "isActive": true,
    "createdAt": "2025-10-11T00:00:00.000Z",
    "updatedAt": "2025-11-11T18:50:32.264Z",
    "createdBy": "admin",
    "updatedBy": "admin",
    "tags": [
      "performance-patterns",
      "tree-shaking-mechanism",
      "advanced"
    ],
    "explanation": "Tree shaking starts at the entry point and traverses the dependency graph, marking only the code paths that are used. Unused paths are excluded from the final bundle.",
    "points": 10,
    "sampleAnswers": [
      "Tree shaking starts at the entry point and traverses the dependency graph, marking only the code paths that are used. Unused paths are excluded from the final bundle."
    ],
    "hints": [],
    "metadata": {},
    "options": [
      {
        "id": "o1",
        "text": "Tree shaking starts at the entry point and traverses the dependency graph, marking only the code paths that are used. Unused paths are excluded from the final bundle.",
        "isCorrect": true,
        "explanation": "Tree shaking starts at the entry point and traverses the dependency graph, marking only the code paths that are used. Unused paths are excluded from the final bundle."
      },
      {
        "id": "o2",
        "text": "This is not correct. Please refer to the explanation.",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "o3",
        "text": "Incorrect. Review performance optimization concepts.",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "o4",
        "text": "This is a common misconception. The correct answer is different.",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "o5",
        "text": "Not quite. Consider web performance best practices.",
        "isCorrect": false,
        "explanation": ""
      }
    ]
  },
  {
    "id": "performance-patterns-tree-shaking-ts3",
    "title": "Why does tree shaking consider side effects in modules?",
    "content": "Explain what side effects are and why they affect tree shaking.",
    "type": "multiple-choice",
    "category": "Performance Patterns",
    "topic": "Tree Shaking Side Effects",
    "difficulty": "intermediate",
    "learningCardId": "system-design",
    "isActive": true,
    "createdAt": "2025-10-11T00:00:00.000Z",
    "updatedAt": "2025-11-11T18:50:32.264Z",
    "createdBy": "admin",
    "updatedBy": "admin",
    "tags": [
      "performance-patterns",
      "tree-shaking-side-effects",
      "intermediate"
    ],
    "explanation": "A module has side effects if importing it changes the global scope or performs actions even if its exports are not used. Such modules cannot be safely removed by tree shaking.",
    "points": 10,
    "sampleAnswers": [
      "A module has side effects if importing it changes the global scope or performs actions even if its exports are not used. Such modules cannot be safely removed by tree shaking."
    ],
    "hints": [],
    "metadata": {},
    "options": [
      {
        "id": "o1",
        "text": "A module has side effects if importing it changes the global scope or performs actions even if its exports are not used. Such modules cannot be safely removed by tree shaking.",
        "isCorrect": true,
        "explanation": "A module has side effects if importing it changes the global scope or performs actions even if its exports are not used. Such modules cannot be safely removed by tree shaking."
      },
      {
        "id": "o2",
        "text": "This is not correct. Please refer to the explanation.",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "o3",
        "text": "Incorrect. Review performance optimization concepts.",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "o4",
        "text": "This is a common misconception. The correct answer is different.",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "o5",
        "text": "Not quite. Consider web performance best practices.",
        "isCorrect": false,
        "explanation": ""
      }
    ]
  },
  {
    "id": "performance-patterns-dynamic-import-19",
    "title": "What happens while a lazy-loaded module is still being fetched?",
    "content": "The fallback component (e.g., a loading message) is rendered until the lazy-loaded component is ready.",
    "type": "multiple-choice",
    "category": "Performance Patterns",
    "topic": "User Experience",
    "difficulty": "intermediate",
    "learningCardId": "system-design",
    "isActive": true,
    "createdAt": "2025-10-10T00:00:00Z",
    "updatedAt": "2025-11-11T18:50:32.188Z",
    "createdBy": "admin",
    "updatedBy": "admin",
    "tags": [
      "performance-patterns",
      "user-experience",
      "beginner",
      "intermediate"
    ],
    "explanation": "A fallback placeholder keeps the UI responsive and visually communicates that the module is still loading.",
    "points": 10,
    "options": [
      {
        "id": "o1",
        "text": "The app freezes",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "o2",
        "text": "The page reloads",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "o3",
        "text": "The fallback component displays temporarily",
        "isCorrect": true,
        "explanation": ""
      },
      {
        "id": "o4",
        "text": "Nothing happens until it loads",
        "isCorrect": false,
        "explanation": ""
      }
    ],
    "sampleAnswers": [
      "The fallback component displays temporarily"
    ],
    "hints": [],
    "metadata": {}
  },
  {
    "id": "performance-patterns-import-on-interaction-2",
    "title": "Which user actions typically trigger Import On Interaction?",
    "content": "The pattern can be triggered when a user clicks, scrolls into view, or when the browser is idle.",
    "type": "multiple-choice",
    "category": "Performance Patterns",
    "topic": "User Interaction Events",
    "difficulty": "intermediate",
    "learningCardId": "system-design",
    "isActive": true,
    "createdAt": "2025-10-10T00:00:00Z",
    "updatedAt": "2025-11-11T18:50:32.201Z",
    "createdBy": "admin",
    "updatedBy": "admin",
    "tags": [
      "performance-patterns",
      "user-interaction-events",
      "intermediate"
    ],
    "explanation": "The pattern optimizes performance by waiting for direct user interactions or idle time before loading heavy resources.",
    "points": 10,
    "options": [
      {
        "id": "o1",
        "text": "Only when a user refreshes the page",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "o2",
        "text": "On user click, scroll, or idle time",
        "isCorrect": true,
        "explanation": ""
      },
      {
        "id": "o3",
        "text": "When data fetching completes",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "o4",
        "text": "During server-side rendering",
        "isCorrect": false,
        "explanation": ""
      }
    ],
    "sampleAnswers": [
      "On user click, scroll, or idle time"
    ],
    "hints": [],
    "metadata": {}
  },
  {
    "id": "performance-patterns-import-on-visibility-12",
    "title": "What is the role of the fallback component in import-on-visibility?",
    "content": "The fallback UI is displayed while the requested module is being fetched, parsed, and executed, giving users feedback instead of a blank screen.",
    "type": "open-ended",
    "category": "Performance Patterns",
    "topic": "UX During Lazy Load",
    "difficulty": "intermediate",
    "learningCardId": "system-design",
    "isActive": true,
    "createdAt": "2025-10-10",
    "updatedAt": "2025-11-11T18:50:32.209Z",
    "createdBy": "admin",
    "updatedBy": "admin",
    "tags": [
      "performance-patterns",
      "ux-during-lazy-load",
      "beginner",
      "intermediate"
    ],
    "explanation": "The fallback reassures users that loading is in progress, preventing perceived freezes.",
    "points": 10,
    "options": [],
    "sampleAnswers": [
      "It shows a loading indicator during module load."
    ],
    "hints": [],
    "metadata": {}
  },
  {
    "id": "performance-patterns-virtualization-lv1",
    "title": "What is list virtualization (or windowing)?",
    "content": "Explain the concept of list virtualization and its main benefit.",
    "type": "multiple-choice",
    "category": "Performance Patterns",
    "topic": "Virtual Lists",
    "difficulty": "intermediate",
    "learningCardId": "system-design",
    "isActive": true,
    "createdAt": "2025-10-11T00:00:00.000Z",
    "updatedAt": "2025-11-11T18:50:32.271Z",
    "createdBy": "admin",
    "updatedBy": "admin",
    "tags": [
      "performance-patterns",
      "virtual-lists",
      "beginner",
      "intermediate"
    ],
    "explanation": "List virtualization is a technique where only the visible rows of a list are rendered at a time, rather than the entire list. This improves rendering performance and scroll efficiency.",
    "points": 10,
    "sampleAnswers": [
      "List virtualization is a technique where only the visible rows of a list are rendered at a time, rather than the entire list. This improves rendering performance and scroll efficiency."
    ],
    "hints": [],
    "metadata": {},
    "options": [
      {
        "id": "o1",
        "text": "List virtualization is a technique where only the visible rows of a list are rendered at a time, rather than the entire list. This improves rendering performance and scroll efficiency.",
        "isCorrect": true,
        "explanation": "List virtualization is a technique where only the visible rows of a list are rendered at a time, rather than the entire list. This improves rendering performance and scroll efficiency."
      },
      {
        "id": "o2",
        "text": "This is not correct. Please refer to the explanation.",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "o3",
        "text": "Incorrect. Review performance optimization concepts.",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "o4",
        "text": "This is a common misconception. The correct answer is different.",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "o5",
        "text": "Not quite. Consider web performance best practices.",
        "isCorrect": false,
        "explanation": ""
      }
    ]
  },
  {
    "id": "performance-patterns-virtualization-lv2",
    "title": "Why is react-window preferred over react-virtualized in some cases?",
    "content": "Describe the differences between react-window and react-virtualized and why react-window might be chosen.",
    "type": "multiple-choice",
    "category": "Performance Patterns",
    "topic": "Virtual Lists Libraries",
    "difficulty": "intermediate",
    "learningCardId": "system-design",
    "isActive": true,
    "createdAt": "2025-10-11T00:00:00.000Z",
    "updatedAt": "2025-11-11T18:50:32.271Z",
    "createdBy": "admin",
    "updatedBy": "admin",
    "tags": [
      "performance-patterns",
      "virtual-lists-libraries",
      "intermediate"
    ],
    "explanation": "React-window is smaller, faster, and more tree-shakeable than react-virtualized. It provides simpler APIs for most virtualization use cases and reduces bundle size significantly.",
    "points": 10,
    "sampleAnswers": [
      "React-window is smaller, faster, and more tree-shakeable than react-virtualized. It provides simpler APIs for most virtualization use cases and reduces bundle size significantly."
    ],
    "hints": [],
    "metadata": {},
    "options": [
      {
        "id": "o1",
        "text": "React-window is smaller, faster, and more tree-shakeable than react-virtualized. It provides simpler APIs for most virtualization use cases and reduces bundle size significantly.",
        "isCorrect": true,
        "explanation": "React-window is smaller, faster, and more tree-shakeable than react-virtualized. It provides simpler APIs for most virtualization use cases and reduces bundle size significantly."
      },
      {
        "id": "o2",
        "text": "This is not correct. Please refer to the explanation.",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "o3",
        "text": "Incorrect. Review performance optimization concepts.",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "o4",
        "text": "This is a common misconception. The correct answer is different.",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "o5",
        "text": "Not quite. Consider web performance best practices.",
        "isCorrect": false,
        "explanation": ""
      }
    ]
  },
  {
    "id": "performance-patterns-virtualization-lv6",
    "title": "What are some limitations of react-window compared to react-virtualized?",
    "content": "List missing features/components in react-window.",
    "type": "multiple-choice",
    "category": "Performance Patterns",
    "topic": "Virtual Lists Limitations",
    "difficulty": "advanced",
    "learningCardId": "system-design",
    "isActive": true,
    "createdAt": "2025-10-11T00:00:00.000Z",
    "updatedAt": "2025-11-11T18:50:32.271Z",
    "createdBy": "admin",
    "updatedBy": "admin",
    "tags": [
      "performance-patterns",
      "virtual-lists-limitations",
      "advanced"
    ],
    "explanation": "React-window does not include WindowScroller, AutoSizer, or CellMeasurer by default. These need to be implemented separately if needed.",
    "points": 10,
    "sampleAnswers": [
      "React-window does not include WindowScroller, AutoSizer, or CellMeasurer by default. These need to be implemented separately if needed."
    ],
    "hints": [],
    "metadata": {},
    "options": [
      {
        "id": "o1",
        "text": "React-window does not include WindowScroller, AutoSizer, or CellMeasurer by default. These need to be implemented separately if needed.",
        "isCorrect": true,
        "explanation": "React-window does not include WindowScroller, AutoSizer, or CellMeasurer by default. These need to be implemented separately if needed."
      },
      {
        "id": "o2",
        "text": "This is not correct. Please refer to the explanation.",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "o3",
        "text": "Incorrect. Review performance optimization concepts.",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "o4",
        "text": "This is a common misconception. The correct answer is different.",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "o5",
        "text": "Not quite. Consider web performance best practices.",
        "isCorrect": false,
        "explanation": ""
      }
    ]
  },
  {
    "id": "performance-patterns-virtualization-lv7",
    "title": "How does list virtualization improve performance on mid to low-end devices?",
    "content": "Explain the mechanism by which virtualization keeps rendering fast on slower devices.",
    "type": "multiple-choice",
    "category": "Performance Patterns",
    "topic": "Virtual Lists Performance",
    "difficulty": "intermediate",
    "learningCardId": "system-design",
    "isActive": true,
    "createdAt": "2025-10-11T00:00:00.000Z",
    "updatedAt": "2025-11-11T18:50:32.271Z",
    "createdBy": "admin",
    "updatedBy": "admin",
    "tags": [
      "performance-patterns",
      "virtual-lists-performance",
      "intermediate"
    ],
    "explanation": "By rendering only the visible items and not the entire list, virtualization reduces DOM nodes, lowering layout, paint, and reflow costs, which keeps frame rates smooth.",
    "points": 10,
    "sampleAnswers": [
      "By rendering only the visible items and not the entire list, virtualization reduces DOM nodes, lowering layout, paint, and reflow costs, which keeps frame rates smooth."
    ],
    "hints": [],
    "metadata": {},
    "options": [
      {
        "id": "o1",
        "text": "By rendering only the visible items and not the entire list, virtualization reduces DOM nodes, lowering layout, paint, and reflow costs, which keeps frame rates smooth.",
        "isCorrect": true,
        "explanation": "By rendering only the visible items and not the entire list, virtualization reduces DOM nodes, lowering layout, paint, and reflow costs, which keeps frame rates smooth."
      },
      {
        "id": "o2",
        "text": "This is not correct. Please refer to the explanation.",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "o3",
        "text": "Incorrect. Review performance optimization concepts.",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "o4",
        "text": "This is a common misconception. The correct answer is different.",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "o5",
        "text": "Not quite. Consider web performance best practices.",
        "isCorrect": false,
        "explanation": ""
      }
    ]
  },
  {
    "id": "performance-patterns-virtualization-lv3",
    "title": "True or False: List virtualization renders all items in the DOM at once.",
    "content": "Evaluate whether virtualization renders all items immediately.",
    "type": "multiple-choice",
    "category": "Performance Patterns",
    "topic": "Virtual Lists Rendering",
    "difficulty": "intermediate",
    "learningCardId": "system-design",
    "isActive": true,
    "createdAt": "2025-10-11T00:00:00.000Z",
    "updatedAt": "2025-11-11T18:50:32.271Z",
    "createdBy": "admin",
    "updatedBy": "admin",
    "tags": [
      "performance-patterns",
      "virtual-lists-rendering",
      "beginner",
      "intermediate"
    ],
    "explanation": "The correct answer is: False",
    "points": 10,
    "options": [
      {
        "id": "o1",
        "text": "True",
        "isCorrect": false,
        "explanation": "Virtualization renders only the visible items, not the entire list, to improve performance."
      },
      {
        "id": "o2",
        "text": "False",
        "isCorrect": false,
        "explanation": "Virtualization renders only the visible items, not the entire list, to improve performance."
      },
      {
        "id": "o3",
        "text": "Partially true - depends on the context",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "o4",
        "text": "Not applicable",
        "isCorrect": false,
        "explanation": ""
      }
    ],
    "hints": [],
    "metadata": {}
  },
  {
    "id": "performance-patterns-virtualization-lv4",
    "title": "What is the role of a 'window' in list virtualization?",
    "content": "Explain what a 'window' represents in the context of virtualized lists.",
    "type": "multiple-choice",
    "category": "Performance Patterns",
    "topic": "Virtual Lists Windowing",
    "difficulty": "intermediate",
    "learningCardId": "system-design",
    "isActive": true,
    "createdAt": "2025-10-11T00:00:00.000Z",
    "updatedAt": "2025-11-11T18:50:32.271Z",
    "createdBy": "admin",
    "updatedBy": "admin",
    "tags": [
      "performance-patterns",
      "virtual-lists-windowing",
      "intermediate"
    ],
    "explanation": "The 'window' refers to the subset of list items that are currently visible and rendered in the DOM. As the user scrolls, the window moves along the list, rendering new items and removing old ones.",
    "points": 10,
    "sampleAnswers": [
      "The 'window' refers to the subset of list items that are currently visible and rendered in the DOM. As the user scrolls, the window moves along the list, rendering new items and removing old ones."
    ],
    "hints": [],
    "metadata": {},
    "options": [
      {
        "id": "o1",
        "text": "The 'window' refers to the subset of list items that are currently visible and rendered in the DOM. As the user scrolls, the window moves along the list, rendering new items and removing old ones.",
        "isCorrect": true,
        "explanation": "The 'window' refers to the subset of list items that are currently visible and rendered in the DOM. As the user scrolls, the window moves along the list, rendering new items and removing old ones."
      },
      {
        "id": "o2",
        "text": "This is not correct. Please refer to the explanation.",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "o3",
        "text": "Incorrect. Review performance optimization concepts.",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "o4",
        "text": "This is a common misconception. The correct answer is different.",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "o5",
        "text": "Not quite. Consider web performance best practices.",
        "isCorrect": false,
        "explanation": ""
      }
    ]
  },
  {
    "id": "performance-patterns-import-on-visibility-16",
    "title": "What are potential drawbacks of import-on-visibility?",
    "content": "Components might have a short delay when they first appear, especially on slow networks, since the import happens only when visible.",
    "type": "open-ended",
    "category": "Performance Patterns",
    "topic": "Visibility-based Loading",
    "difficulty": "intermediate",
    "learningCardId": "system-design",
    "isActive": true,
    "createdAt": "2025-10-10",
    "updatedAt": "2025-11-11T18:50:32.209Z",
    "createdBy": "admin",
    "updatedBy": "admin",
    "tags": [
      "performance-patterns",
      "visibility-based-loading",
      "intermediate"
    ],
    "explanation": "Balancing performance and perceived speed requires good fallback UIs and caching strategies.",
    "points": 10,
    "options": [],
    "sampleAnswers": [
      "Visible delay if network is slow."
    ],
    "hints": [],
    "metadata": {}
  },
  {
    "id": "performance-patterns-loading-sequence-1",
    "title": "Understanding Loading Sequence",
    "content": "What is the primary goal of optimizing the loading sequence in web performance?",
    "type": "multiple-choice",
    "category": "Performance Patterns",
    "topic": "Web Performance",
    "difficulty": "intermediate",
    "learningCardId": "system-design",
    "isActive": true,
    "createdAt": "2025-10-10T00:00:00Z",
    "updatedAt": "2025-11-11T18:50:32.217Z",
    "createdBy": "admin",
    "updatedBy": "admin",
    "tags": [
      "performance-patterns",
      "web-performance",
      "beginner",
      "intermediate"
    ],
    "explanation": "Optimizing the loading sequence ensures that critical resources load at the right time, improving perceived performance and metrics like FCP and LCP.",
    "points": 10,
    "options": [
      {
        "id": "o1",
        "text": "To improve SEO ranking",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "o2",
        "text": "To enhance perceived performance and achieve better Core Web Vitals",
        "isCorrect": true,
        "explanation": ""
      },
      {
        "id": "o3",
        "text": "To reduce the number of network requests",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "o4",
        "text": "To prevent CSS and JS conflicts",
        "isCorrect": false,
        "explanation": ""
      }
    ],
    "sampleAnswers": [
      "To enhance perceived performance and achieve better Core Web Vitals"
    ],
    "hints": [],
    "metadata": {}
  },
  {
    "id": "performance-patterns-compression-1",
    "title": "What is the main purpose of JavaScript compression?",
    "content": "JavaScript compression reduces the size of scripts to improve transfer, load, and execution time over the network.",
    "type": "multiple-choice",
    "category": "Performance Patterns",
    "topic": "Web Performance Optimization",
    "difficulty": "intermediate",
    "learningCardId": "system-design",
    "isActive": true,
    "createdAt": "2025-10-10T00:00:00Z",
    "updatedAt": "2025-11-11T18:50:32.172Z",
    "createdBy": "admin",
    "updatedBy": "admin",
    "tags": [
      "performance-patterns",
      "web-performance-optimization",
      "beginner",
      "intermediate"
    ],
    "explanation": "Compression minimizes script size, making downloads faster and reducing network bandwidth usage.",
    "points": 10,
    "options": [
      {
        "id": "o1",
        "text": "To increase readability of JavaScript code",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "o2",
        "text": "To improve execution speed by increasing file size",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "o3",
        "text": "To reduce file size and improve loading performance",
        "isCorrect": true,
        "explanation": ""
      },
      {
        "id": "o4",
        "text": "To replace unused code automatically",
        "isCorrect": false,
        "explanation": ""
      }
    ],
    "sampleAnswers": [
      "To reduce file size and improve loading performance"
    ],
    "hints": [],
    "metadata": {}
  },
  {
    "id": "performance-patterns-import-on-interaction-5",
    "title": "Which metrics can Import On Interaction improve?",
    "content": "By reducing blocking resources, it improves First Input Delay (FID), Total Blocking Time (TBT), and Time to Interactive (TTI).",
    "type": "multiple-choice",
    "category": "Performance Patterns",
    "topic": "Web Vitals",
    "difficulty": "intermediate",
    "learningCardId": "system-design",
    "isActive": true,
    "createdAt": "2025-10-10T00:00:00Z",
    "updatedAt": "2025-11-11T18:50:32.201Z",
    "createdBy": "admin",
    "updatedBy": "admin",
    "tags": [
      "performance-patterns",
      "web-vitals",
      "intermediate"
    ],
    "explanation": "Deferring heavy scripts helps the browser respond to user input faster, improving FID, TBT, and TTI metrics.",
    "points": 10,
    "options": [
      {
        "id": "o1",
        "text": "Largest Contentful Paint (LCP) and Cumulative Layout Shift (CLS)",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "o2",
        "text": "First Input Delay (FID), Total Blocking Time (TBT), Time to Interactive (TTI)",
        "isCorrect": true,
        "explanation": ""
      },
      {
        "id": "o3",
        "text": "Bounce rate and SEO ranking",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "o4",
        "text": "Server response time and bandwidth",
        "isCorrect": false,
        "explanation": ""
      }
    ],
    "sampleAnswers": [
      "First Input Delay (FID), Total Blocking Time (TBT), Time to Interactive (TTI)"
    ],
    "hints": [],
    "metadata": {}
  },
  {
    "id": "performance-patterns-compression-9",
    "title": "Which Webpack plugin enables Brotli compression?",
    "content": "You can use the BrotliWebpackPlugin in Webpack to enable Brotli compression for bundled assets.",
    "type": "multiple-choice",
    "category": "Performance Patterns",
    "topic": "Webpack Configuration",
    "difficulty": "intermediate",
    "learningCardId": "system-design",
    "isActive": true,
    "createdAt": "2025-10-10T00:00:00Z",
    "updatedAt": "2025-11-11T18:50:32.172Z",
    "createdBy": "admin",
    "updatedBy": "admin",
    "tags": [
      "performance-patterns",
      "webpack-configuration",
      "intermediate"
    ],
    "explanation": "Webpack supports Brotli through BrotliWebpackPlugin, enabling efficient compression of assets for production builds.",
    "points": 10,
    "options": [
      {
        "id": "o1",
        "text": "CompressionPlugin",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "o2",
        "text": "MinifyPlugin",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "o3",
        "text": "BrotliWebpackPlugin",
        "isCorrect": true,
        "explanation": ""
      },
      {
        "id": "o4",
        "text": "OptimizeCSSAssetsPlugin",
        "isCorrect": false,
        "explanation": ""
      }
    ],
    "sampleAnswers": [
      "BrotliWebpackPlugin"
    ],
    "hints": [],
    "metadata": {}
  },
  {
    "id": "performance-patterns-performance-1-pp9",
    "title": "True or False: Bundle Splitting can be applied manually using Webpack entry points.",
    "content": "Evaluate whether developers can configure multiple entry points in Webpack to create separate bundles manually.",
    "type": "multiple-choice",
    "category": "Performance Patterns",
    "topic": "Webpack Configuration",
    "difficulty": "intermediate",
    "learningCardId": "system-design",
    "isActive": true,
    "createdAt": "2025-10-10T00:00:00.000Z",
    "updatedAt": "2025-11-11T18:50:32.225Z",
    "createdBy": "admin",
    "updatedBy": "admin",
    "tags": [
      "performance-patterns",
      "webpack-configuration",
      "intermediate"
    ],
    "explanation": "The correct answer is: True",
    "points": 10,
    "options": [
      {
        "id": "o1",
        "text": "True",
        "isCorrect": true,
        "explanation": "Developers can define multiple entry points in Webpack to generate multiple bundles, allowing control over what loads initially versus later."
      },
      {
        "id": "o2",
        "text": "False",
        "isCorrect": false,
        "explanation": "Webpack supports manual splitting via multiple entry points or dynamic imports."
      },
      {
        "id": "o3",
        "text": "Partially true - depends on the context",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "o4",
        "text": "Not applicable",
        "isCorrect": false,
        "explanation": ""
      }
    ],
    "hints": [],
    "metadata": {}
  },
  {
    "id": "performance-patterns-pre-load-3",
    "title": "Webpack Preload Magic Comment",
    "content": "What does adding <code>/* webpackPreload: true */</code> to a dynamic import do?",
    "type": "multiple-choice",
    "category": "Performance Patterns",
    "topic": "Webpack Optimization",
    "difficulty": "intermediate",
    "learningCardId": "system-design",
    "isActive": true,
    "createdAt": "2025-10-10T00:00:00Z",
    "updatedAt": "2025-11-11T18:50:32.232Z",
    "createdBy": "admin",
    "updatedBy": "admin",
    "tags": [
      "performance-patterns",
      "webpack-optimization",
      "intermediate"
    ],
    "explanation": "The magic comment tells Webpack to emit a preload link for that resource, so the browser fetches it immediately.",
    "points": 10,
    "options": [
      {
        "id": "a",
        "text": "It bundles the module into the main chunk",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "b",
        "text": "It adds a `<link rel='preload'>` tag for that chunk",
        "isCorrect": true,
        "explanation": ""
      },
      {
        "id": "c",
        "text": "It delays loading of the module until user interaction",
        "isCorrect": false,
        "explanation": ""
      }
    ],
    "sampleAnswers": [
      "It signals Webpack to preload that module so it’s available on initial render."
    ],
    "hints": [],
    "metadata": {}
  },
  {
    "id": "performance-patterns-prefetch-3",
    "title": "Webpack Prefetch Magic Comment",
    "content": "What is the purpose of adding the <code>/* webpackPrefetch: true */</code> comment to a dynamic import?",
    "type": "multiple-choice",
    "category": "Performance Patterns",
    "topic": "Webpack Optimization",
    "difficulty": "intermediate",
    "learningCardId": "system-design",
    "isActive": true,
    "createdAt": "2025-10-10T00:00:00Z",
    "updatedAt": "2025-11-11T18:50:32.241Z",
    "createdBy": "admin",
    "updatedBy": "admin",
    "tags": [
      "performance-patterns",
      "webpack-optimization",
      "intermediate"
    ],
    "explanation": "The magic comment tells Webpack to include a <code>&lt;link rel='prefetch'&gt;</code> for the specified chunk, allowing the browser to load it in advance.",
    "points": 10,
    "options": [
      {
        "id": "a",
        "text": "To bundle the file immediately into the main chunk",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "b",
        "text": "To hint the browser to prefetch the resource during idle time",
        "isCorrect": true,
        "explanation": ""
      },
      {
        "id": "c",
        "text": "To force lazy loading of the component",
        "isCorrect": false,
        "explanation": ""
      }
    ],
    "sampleAnswers": [
      "It hints the browser to prefetch the module, improving perceived load time."
    ],
    "hints": [],
    "metadata": {}
  }
]