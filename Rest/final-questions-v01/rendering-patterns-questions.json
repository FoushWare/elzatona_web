[
  {
    "id": "rendering-patterns-rendering10-1",
    "title": "What is the purpose of the View Transitions API?",
    "content": "It provides a simple way to animate visual DOM changes between two states, enabling smooth transitions between UI views or pages.",
    "type": "multiple-choice",
    "category": "Rendering Patterns",
    "topic": "Advanced Patterns",
    "difficulty": "intermediate",
    "learningCardId": "system-design",
    "isActive": true,
    "createdAt": "2024-01-01T00:00:00.000Z",
    "updatedAt": "2025-11-11T18:59:32.539Z",
    "createdBy": "admin",
    "updatedBy": "admin",
    "tags": [
      "rendering-patterns",
      "advanced-patterns",
      "intermediate"
    ],
    "explanation": "It provides a simple way to animate visual DOM changes between two states, enabling smooth transitions between UI views or pages.",
    "points": 10,
    "options": [
      {
        "id": "o1",
        "text": "To animate data fetching operations",
        "isCorrect": true,
        "explanation": ""
      },
      {
        "id": "o2",
        "text": "To transition visual changes between DOM states smoothly",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "o3",
        "text": "To handle form validation errors visually",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "o4",
        "text": "To optimize network requests",
        "isCorrect": false,
        "explanation": ""
      }
    ],
    "hints": [
      "Review rendering pattern documentation",
      "Consider server vs client rendering trade-offs",
      "Think about performance and SEO implications"
    ]
  },
  {
    "id": "rendering-patterns-rendering10-2",
    "title": "Which method is central to the View Transitions API?",
    "content": "The document.startViewTransition(callback) method initiates a view transition and calls the provided callback to update the DOM.",
    "type": "multiple-choice",
    "category": "Rendering Patterns",
    "topic": "Advanced Patterns",
    "difficulty": "intermediate",
    "learningCardId": "system-design",
    "isActive": true,
    "createdAt": "2024-01-01T00:00:00.000Z",
    "updatedAt": "2025-11-11T18:59:32.539Z",
    "createdBy": "admin",
    "updatedBy": "admin",
    "tags": [
      "rendering-patterns",
      "advanced-patterns",
      "intermediate"
    ],
    "explanation": "The document.startViewTransition(callback) method initiates a view transition and calls the provided callback to update the DOM.",
    "points": 10,
    "options": [
      {
        "id": "o1",
        "text": "document.animateTransition()",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "o2",
        "text": "window.beginViewChange()",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "o3",
        "text": "document.startViewTransition()",
        "isCorrect": true,
        "explanation": ""
      },
      {
        "id": "o4",
        "text": "window.transitionTo()",
        "isCorrect": false,
        "explanation": ""
      }
    ],
    "hints": [
      "Review rendering pattern documentation",
      "Consider server vs client rendering trade-offs",
      "Think about performance and SEO implications"
    ]
  },
  {
    "id": "rendering-patterns-rendering10-3",
    "title": "What does document.startViewTransition(callback) do before executing the callback?",
    "content": "It takes a screenshot of the current DOM state before applying the callback changes.",
    "type": "multiple-choice",
    "category": "Rendering Patterns",
    "topic": "Advanced Patterns",
    "difficulty": "intermediate",
    "learningCardId": "system-design",
    "isActive": true,
    "createdAt": "2024-01-01T00:00:00.000Z",
    "updatedAt": "2025-11-11T18:59:32.539Z",
    "createdBy": "admin",
    "updatedBy": "admin",
    "tags": [
      "rendering-patterns",
      "advanced-patterns",
      "intermediate"
    ],
    "explanation": "It takes a screenshot of the current DOM state before applying the callback changes.",
    "points": 10,
    "options": [
      {
        "id": "o1",
        "text": "Preloads all CSS animations",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "o2",
        "text": "Takes a screenshot of the current DOM",
        "isCorrect": true,
        "explanation": ""
      },
      {
        "id": "o3",
        "text": "Stores a snapshot of localStorage",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "o4",
        "text": "Pauses all event listeners",
        "isCorrect": false,
        "explanation": ""
      }
    ],
    "hints": [
      "Review rendering pattern documentation",
      "Consider server vs client rendering trade-offs",
      "Think about performance and SEO implications"
    ]
  },
  {
    "id": "rendering-patterns-rendering10-4",
    "title": "Which CSS pseudo-elements allow developers to style the before and after states of a transition?",
    "content": "Developers can use ::view-transition-old(root) and ::view-transition-new(root) to style the old and new DOM states during a transition.",
    "type": "multiple-choice",
    "category": "Rendering Patterns",
    "topic": "Advanced Patterns",
    "difficulty": "intermediate",
    "learningCardId": "system-design",
    "isActive": true,
    "createdAt": "2024-01-01T00:00:00.000Z",
    "updatedAt": "2025-11-11T18:59:32.539Z",
    "createdBy": "admin",
    "updatedBy": "admin",
    "tags": [
      "rendering-patterns",
      "advanced-patterns",
      "intermediate"
    ],
    "explanation": "Developers can use ::view-transition-old(root) and ::view-transition-new(root) to style the old and new DOM states during a transition.",
    "points": 10,
    "options": [
      {
        "id": "o1",
        "text": "::before and ::after",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "o2",
        "text": "::view-transition-old(root) and ::view-transition-new(root)",
        "isCorrect": true,
        "explanation": ""
      },
      {
        "id": "o3",
        "text": "::transition-old and ::transition-new",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "o4",
        "text": "::prev-state and ::next-state",
        "isCorrect": false,
        "explanation": ""
      }
    ],
    "hints": [
      "Review rendering pattern documentation",
      "Consider server vs client rendering trade-offs",
      "Think about performance and SEO implications"
    ]
  },
  {
    "id": "rendering-patterns-rendering10-5",
    "title": "What is the role of view-transition-name in the View Transitions API?",
    "content": "It assigns a unique name to elements so that matching elements across states can be smoothly animated together.",
    "type": "multiple-choice",
    "category": "Rendering Patterns",
    "topic": "Advanced Patterns",
    "difficulty": "intermediate",
    "learningCardId": "system-design",
    "isActive": true,
    "createdAt": "2024-01-01T00:00:00.000Z",
    "updatedAt": "2025-11-11T18:59:32.539Z",
    "createdBy": "admin",
    "updatedBy": "admin",
    "tags": [
      "rendering-patterns",
      "advanced-patterns",
      "intermediate"
    ],
    "explanation": "It assigns a unique name to elements so that matching elements across states can be smoothly animated together.",
    "points": 10,
    "options": [
      {
        "id": "o1",
        "text": "It defines a CSS keyframe",
        "isCorrect": true,
        "explanation": ""
      },
      {
        "id": "o2",
        "text": "It assigns an animation ID for transitions",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "o3",
        "text": "It uniquely identifies elements for smooth state transitions",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "o4",
        "text": "It determines animation duration",
        "isCorrect": false,
        "explanation": ""
      }
    ],
    "hints": [
      "Review rendering pattern documentation",
      "Consider server vs client rendering trade-offs",
      "Think about performance and SEO implications"
    ]
  },
  {
    "id": "rendering-patterns-rendering10-6",
    "title": "What happens to the DOM during a view transition callback?",
    "content": "The DOM becomes non-interactive (frozen) until the callback and transition animation complete.",
    "type": "multiple-choice",
    "category": "Rendering Patterns",
    "topic": "Advanced Patterns",
    "difficulty": "advanced",
    "learningCardId": "system-design",
    "isActive": true,
    "createdAt": "2024-01-01T00:00:00.000Z",
    "updatedAt": "2025-11-11T18:59:32.539Z",
    "createdBy": "admin",
    "updatedBy": "admin",
    "tags": [
      "rendering-patterns",
      "advanced-patterns",
      "advanced"
    ],
    "explanation": "The DOM becomes non-interactive (frozen) until the callback and transition animation complete.",
    "points": 10,
    "options": [
      {
        "id": "o1",
        "text": "The DOM remains interactive",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "o2",
        "text": "The DOM becomes non-interactive until the callback resolves",
        "isCorrect": true,
        "explanation": ""
      },
      {
        "id": "o3",
        "text": "Only CSS changes are blocked",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "o4",
        "text": "Event listeners are temporarily removed",
        "isCorrect": false,
        "explanation": ""
      }
    ],
    "hints": [
      "Review rendering pattern documentation",
      "Consider server vs client rendering trade-offs",
      "Think about performance and SEO implications"
    ]
  },
  {
    "id": "rendering-patterns-rendering10-7",
    "title": "When should document.startViewTransition ideally be called during page navigation?",
    "content": "After the data request completes to minimize the time the DOM is frozen and improve user experience.",
    "type": "multiple-choice",
    "category": "Rendering Patterns",
    "topic": "Advanced Patterns",
    "difficulty": "intermediate",
    "learningCardId": "system-design",
    "isActive": true,
    "createdAt": "2024-01-01T00:00:00.000Z",
    "updatedAt": "2025-11-11T18:59:32.539Z",
    "createdBy": "admin",
    "updatedBy": "admin",
    "tags": [
      "rendering-patterns",
      "advanced-patterns",
      "intermediate"
    ],
    "explanation": "After the data request completes to minimize the time the DOM is frozen and improve user experience.",
    "points": 10,
    "options": [
      {
        "id": "o1",
        "text": "Before sending the data request",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "o2",
        "text": "Immediately on link click",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "o3",
        "text": "After the data request completes",
        "isCorrect": true,
        "explanation": ""
      },
      {
        "id": "o4",
        "text": "After component unmount",
        "isCorrect": false,
        "explanation": ""
      }
    ],
    "hints": [
      "Review rendering pattern documentation",
      "Consider server vs client rendering trade-offs",
      "Think about performance and SEO implications"
    ]
  },
  {
    "id": "rendering-patterns-rendering10-8",
    "title": "How can developers delay the completion of a transition?",
    "content": "By returning a Promise from the callback, which must resolve before the animation completes.",
    "type": "multiple-choice",
    "category": "Rendering Patterns",
    "topic": "Advanced Patterns",
    "difficulty": "advanced",
    "learningCardId": "system-design",
    "isActive": true,
    "createdAt": "2024-01-01T00:00:00.000Z",
    "updatedAt": "2025-11-11T18:59:32.539Z",
    "createdBy": "admin",
    "updatedBy": "admin",
    "tags": [
      "rendering-patterns",
      "advanced-patterns",
      "advanced"
    ],
    "explanation": "By returning a Promise from the callback, which must resolve before the animation completes.",
    "points": 10,
    "options": [
      {
        "id": "o1",
        "text": "By using setTimeout inside the callback",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "o2",
        "text": "By returning a Promise that resolves when the DOM update is complete",
        "isCorrect": true,
        "explanation": ""
      },
      {
        "id": "o3",
        "text": "By pausing the animation manually",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "o4",
        "text": "By re-rendering the DOM asynchronously",
        "isCorrect": false,
        "explanation": ""
      }
    ],
    "hints": [
      "Review rendering pattern documentation",
      "Consider server vs client rendering trade-offs",
      "Think about performance and SEO implications"
    ]
  },
  {
    "id": "rendering-patterns-rendering10-9",
    "title": "Which React lifecycle method is used in the example to prevent premature rendering during a transition?",
    "content": "shouldComponentUpdate() is overridden to return false, delaying rendering until the view transition begins.",
    "type": "multiple-choice",
    "category": "Rendering Patterns",
    "topic": "Advanced Patterns",
    "difficulty": "advanced",
    "learningCardId": "system-design",
    "isActive": true,
    "createdAt": "2024-01-01T00:00:00.000Z",
    "updatedAt": "2025-11-11T18:59:32.539Z",
    "createdBy": "admin",
    "updatedBy": "admin",
    "tags": [
      "rendering-patterns",
      "advanced-patterns",
      "advanced"
    ],
    "explanation": "shouldComponentUpdate() is overridden to return false, delaying rendering until the view transition begins.",
    "points": 10,
    "options": [
      {
        "id": "o1",
        "text": "componentDidMount()",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "o2",
        "text": "componentWillUnmount()",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "o3",
        "text": "shouldComponentUpdate()",
        "isCorrect": true,
        "explanation": ""
      },
      {
        "id": "o4",
        "text": "getSnapshotBeforeUpdate()",
        "isCorrect": false,
        "explanation": ""
      }
    ],
    "hints": [
      "Review rendering pattern documentation",
      "Consider server vs client rendering trade-offs",
      "Think about performance and SEO implications"
    ]
  },
  {
    "id": "rendering-patterns-rendering10-10",
    "title": "What does the componentDidUpdate() method do in the React example?",
    "content": "It resolves the promise returned during the DOM update, notifying the View Transition API that the DOM has been updated.",
    "type": "multiple-choice",
    "category": "Rendering Patterns",
    "topic": "Advanced Patterns",
    "difficulty": "advanced",
    "learningCardId": "system-design",
    "isActive": true,
    "createdAt": "2024-01-01T00:00:00.000Z",
    "updatedAt": "2025-11-11T18:59:32.539Z",
    "createdBy": "admin",
    "updatedBy": "admin",
    "tags": [
      "rendering-patterns",
      "advanced-patterns",
      "advanced"
    ],
    "explanation": "It resolves the promise returned during the DOM update, notifying the View Transition API that the DOM has been updated.",
    "points": 10,
    "options": [
      {
        "id": "o1",
        "text": "Starts a new transition",
        "isCorrect": true,
        "explanation": ""
      },
      {
        "id": "o2",
        "text": "Forces a DOM re-render",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "o3",
        "text": "Resolves the update promise for the transition",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "o4",
        "text": "Triggers a fade-out animation",
        "isCorrect": false,
        "explanation": ""
      }
    ],
    "hints": [
      "Review rendering pattern documentation",
      "Consider server vs client rendering trade-offs",
      "Think about performance and SEO implications"
    ]
  },
  {
    "id": "rendering-patterns-rendering10-11",
    "title": "Why is React’s strict mode disabled in the Next.js example?",
    "content": "Because React’s strict mode causes double rendering in development, interfering with the transition flow.",
    "type": "multiple-choice",
    "category": "Rendering Patterns",
    "topic": "Advanced Patterns",
    "difficulty": "intermediate",
    "learningCardId": "system-design",
    "isActive": true,
    "createdAt": "2024-01-01T00:00:00.000Z",
    "updatedAt": "2025-11-11T18:59:32.539Z",
    "createdBy": "admin",
    "updatedBy": "admin",
    "tags": [
      "rendering-patterns",
      "advanced-patterns",
      "intermediate"
    ],
    "explanation": "Because React’s strict mode causes double rendering in development, interfering with the transition flow.",
    "points": 10,
    "options": [
      {
        "id": "o1",
        "text": "It breaks routing",
        "isCorrect": true,
        "explanation": ""
      },
      {
        "id": "o2",
        "text": "It prevents componentDidUpdate from firing",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "o3",
        "text": "It causes components to render twice and disrupts transitions",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "o4",
        "text": "It disables animation hooks",
        "isCorrect": false,
        "explanation": ""
      }
    ],
    "hints": [
      "Review rendering pattern documentation",
      "Consider server vs client rendering trade-offs",
      "Think about performance and SEO implications"
    ]
  },
  {
    "id": "rendering-patterns-rendering10-12",
    "title": "What is the main limitation of using the View Transitions API for page transitions?",
    "content": "It requires the new page HTML to be available before animating, potentially delaying feedback for users.",
    "type": "multiple-choice",
    "category": "Rendering Patterns",
    "topic": "Advanced Patterns",
    "difficulty": "advanced",
    "learningCardId": "system-design",
    "isActive": true,
    "createdAt": "2024-01-01T00:00:00.000Z",
    "updatedAt": "2025-11-11T18:59:32.539Z",
    "createdBy": "admin",
    "updatedBy": "admin",
    "tags": [
      "rendering-patterns",
      "advanced-patterns",
      "advanced"
    ],
    "explanation": "It requires the new page HTML to be available before animating, potentially delaying feedback for users.",
    "points": 10,
    "options": [
      {
        "id": "o1",
        "text": "It only supports inline styles",
        "isCorrect": true,
        "explanation": ""
      },
      {
        "id": "o2",
        "text": "It can’t animate DOM elements",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "o3",
        "text": "It needs new page HTML before animating",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "o4",
        "text": "It blocks network requests",
        "isCorrect": false,
        "explanation": ""
      }
    ],
    "hints": [
      "Review rendering pattern documentation",
      "Consider server vs client rendering trade-offs",
      "Think about performance and SEO implications"
    ]
  },
  {
    "id": "rendering-patterns-rendering10-13",
    "title": "What is the advantage of performing exit animations immediately after a link click?",
    "content": "It provides instant feedback while waiting for the new content to load, improving perceived performance.",
    "type": "multiple-choice",
    "category": "Rendering Patterns",
    "topic": "Advanced Patterns",
    "difficulty": "intermediate",
    "learningCardId": "system-design",
    "isActive": true,
    "createdAt": "2024-01-01T00:00:00.000Z",
    "updatedAt": "2025-11-11T18:59:32.539Z",
    "createdBy": "admin",
    "updatedBy": "admin",
    "tags": [
      "rendering-patterns",
      "advanced-patterns",
      "intermediate"
    ],
    "explanation": "It provides instant feedback while waiting for the new content to load, improving perceived performance.",
    "points": 10,
    "options": [
      {
        "id": "o1",
        "text": "It improves SEO performance",
        "isCorrect": true,
        "explanation": ""
      },
      {
        "id": "o2",
        "text": "It reduces memory usage",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "o3",
        "text": "It offers immediate visual feedback to the user",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "o4",
        "text": "It prevents animation jank",
        "isCorrect": false,
        "explanation": ""
      }
    ],
    "hints": [
      "Review rendering pattern documentation",
      "Consider server vs client rendering trade-offs",
      "Think about performance and SEO implications"
    ]
  },
  {
    "id": "rendering-patterns-rendering10-14",
    "title": "Which library enhances server-side rendered MPAs with SPA-like speeds by replacing the <body> with new HTML from the response?",
    "content": "Turbo, part of the Hotwire suite, enhances MPAs by replacing the page body dynamically using JavaScript.",
    "type": "multiple-choice",
    "category": "Rendering Patterns",
    "topic": "Advanced Patterns",
    "difficulty": "intermediate",
    "learningCardId": "system-design",
    "isActive": true,
    "createdAt": "2024-01-01T00:00:00.000Z",
    "updatedAt": "2025-11-11T18:59:32.539Z",
    "createdBy": "admin",
    "updatedBy": "admin",
    "tags": [
      "rendering-patterns",
      "advanced-patterns",
      "intermediate"
    ],
    "explanation": "Turbo, part of the Hotwire suite, enhances MPAs by replacing the page body dynamically using JavaScript.",
    "points": 10,
    "options": [
      {
        "id": "o1",
        "text": "Turn",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "o2",
        "text": "Turbo",
        "isCorrect": true,
        "explanation": ""
      },
      {
        "id": "o3",
        "text": "Astro",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "o4",
        "text": "Remix",
        "isCorrect": false,
        "explanation": ""
      }
    ],
    "hints": [
      "Review rendering pattern documentation",
      "Consider server vs client rendering trade-offs",
      "Think about performance and SEO implications"
    ]
  },
  {
    "id": "rendering-patterns-rendering10-15",
    "title": "What is Turn used for in combination with Turbo?",
    "content": "Turn handles animating page navigations by adding classes like turn-exit and turn-enter to trigger CSS transitions.",
    "type": "multiple-choice",
    "category": "Rendering Patterns",
    "topic": "Advanced Patterns",
    "difficulty": "intermediate",
    "learningCardId": "system-design",
    "isActive": true,
    "createdAt": "2024-01-01T00:00:00.000Z",
    "updatedAt": "2025-11-11T18:59:32.539Z",
    "createdBy": "admin",
    "updatedBy": "admin",
    "tags": [
      "rendering-patterns",
      "advanced-patterns",
      "intermediate"
    ],
    "explanation": "Turn handles animating page navigations by adding classes like turn-exit and turn-enter to trigger CSS transitions.",
    "points": 10,
    "options": [
      {
        "id": "o1",
        "text": "It performs server rendering",
        "isCorrect": true,
        "explanation": ""
      },
      {
        "id": "o2",
        "text": "It adds routing capabilities",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "o3",
        "text": "It animates page navigations via CSS classes",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "o4",
        "text": "It caches HTML responses",
        "isCorrect": false,
        "explanation": ""
      }
    ],
    "hints": [
      "Review rendering pattern documentation",
      "Consider server vs client rendering trade-offs",
      "Think about performance and SEO implications"
    ]
  },
  {
    "id": "rendering-patterns-rendering10-16",
    "title": "Which events does Turn hook into to manage the flow of page animations?",
    "content": "Turn listens to Turbo events such as turbo:visit, turbo:before-render, and turbo:render to control animations.",
    "type": "multiple-choice",
    "category": "Rendering Patterns",
    "topic": "Advanced Patterns",
    "difficulty": "advanced",
    "learningCardId": "system-design",
    "isActive": true,
    "createdAt": "2024-01-01T00:00:00.000Z",
    "updatedAt": "2025-11-11T18:59:32.539Z",
    "createdBy": "admin",
    "updatedBy": "admin",
    "tags": [
      "rendering-patterns",
      "advanced-patterns",
      "advanced"
    ],
    "explanation": "Turn listens to Turbo events such as turbo:visit, turbo:before-render, and turbo:render to control animations.",
    "points": 10,
    "options": [
      {
        "id": "o1",
        "text": "turbo:start and turbo:end",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "o2",
        "text": "turbo:visit, turbo:before-render, turbo:render",
        "isCorrect": true,
        "explanation": ""
      },
      {
        "id": "o3",
        "text": "turbo:click and turbo:load",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "o4",
        "text": "animationstart and animationend",
        "isCorrect": false,
        "explanation": ""
      }
    ],
    "hints": [
      "Review rendering pattern documentation",
      "Consider server vs client rendering trade-offs",
      "Think about performance and SEO implications"
    ]
  },
  {
    "id": "rendering-patterns-rendering10-17",
    "title": "What does setting Turn.config.experimental.viewTransitions = true enable?",
    "content": "It activates experimental support for the View Transitions API, falling back to CSS animations when unsupported.",
    "type": "multiple-choice",
    "category": "Rendering Patterns",
    "topic": "Advanced Patterns",
    "difficulty": "advanced",
    "learningCardId": "system-design",
    "isActive": true,
    "createdAt": "2024-01-01T00:00:00.000Z",
    "updatedAt": "2025-11-11T18:59:32.539Z",
    "createdBy": "admin",
    "updatedBy": "admin",
    "tags": [
      "rendering-patterns",
      "advanced-patterns",
      "advanced"
    ],
    "explanation": "It activates experimental support for the View Transitions API, falling back to CSS animations when unsupported.",
    "points": 10,
    "options": [
      {
        "id": "o1",
        "text": "It disables animations completely",
        "isCorrect": true,
        "explanation": ""
      },
      {
        "id": "o2",
        "text": "It enables experimental view transitions with fallback",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "o3",
        "text": "It triggers full page reloads",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "o4",
        "text": "It forces server-side rendering",
        "isCorrect": false,
        "explanation": ""
      }
    ],
    "hints": [
      "Review rendering pattern documentation",
      "Consider server vs client rendering trade-offs",
      "Think about performance and SEO implications"
    ]
  },
  {
    "id": "rendering-patterns-rendering10-18",
    "title": "What is the main design trade-off between the View Transitions API and traditional exit animations?",
    "content": "The View Transitions API can animate shared elements across pages but requires waiting for new content, while exit animations give instant feedback but can’t transition shared elements.",
    "type": "multiple-choice",
    "category": "Rendering Patterns",
    "topic": "Advanced Patterns",
    "difficulty": "advanced",
    "learningCardId": "system-design",
    "isActive": true,
    "createdAt": "2024-01-01T00:00:00.000Z",
    "updatedAt": "2025-11-11T18:59:32.539Z",
    "createdBy": "admin",
    "updatedBy": "admin",
    "tags": [
      "rendering-patterns",
      "advanced-patterns",
      "advanced"
    ],
    "explanation": "The View Transitions API can animate shared elements across pages but requires waiting for new content, while exit animations give instant feedback but can’t transition shared elements.",
    "points": 10,
    "options": [
      {
        "id": "o1",
        "text": "View transitions are faster in all cases",
        "isCorrect": true,
        "explanation": ""
      },
      {
        "id": "o2",
        "text": "Exit animations support cross-page element morphing",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "o3",
        "text": "View transitions handle shared elements but may delay feedback",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "o4",
        "text": "Exit animations require the new HTML before starting",
        "isCorrect": false,
        "explanation": ""
      }
    ],
    "hints": [
      "Review rendering pattern documentation",
      "Consider server vs client rendering trade-offs",
      "Think about performance and SEO implications"
    ]
  },
  {
    "id": "rendering-patterns-rendering4-1",
    "title": "Client-Side Rendering (CSR) Fundamentals",
    "content": "What happens during the Client-Side Rendering (CSR) process in a React application?",
    "type": "multiple-choice",
    "category": "Rendering Patterns",
    "topic": "Client-Side Rendering",
    "difficulty": "intermediate",
    "learningCardId": "system-design",
    "isActive": true,
    "createdAt": "2024-01-01T00:00:00.000Z",
    "updatedAt": "2025-11-11T18:59:32.540Z",
    "createdBy": "admin",
    "updatedBy": "admin",
    "tags": [
      "rendering-patterns",
      "client-side-rendering",
      "intermediate"
    ],
    "explanation": "In CSR, the browser loads a minimal HTML shell and JavaScript bundles.",
    "points": 10,
    "sampleAnswers": [
      "In CSR, the browser loads a minimal HTML shell and JavaScript bundles.",
      "React builds and renders the entire UI in the client’s browser."
    ],
    "options": [
      {
        "id": "o1",
        "text": "In CSR, the browser loads a minimal HTML shell and JavaScript bundles.",
        "isCorrect": true,
        "explanation": "In CSR, the browser loads a minimal HTML shell and JavaScript bundles."
      },
      {
        "id": "o2",
        "text": "This is not correct. Please refer to the explanation.",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "o3",
        "text": "Incorrect. Review rendering pattern concepts.",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "o4",
        "text": "This is a common misconception. The correct answer is different.",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "o5",
        "text": "Not quite. Consider rendering strategy best practices.",
        "isCorrect": false,
        "explanation": ""
      }
    ],
    "hints": [
      "Review rendering pattern documentation",
      "Consider server vs client rendering trade-offs",
      "Think about performance and SEO implications"
    ]
  },
  {
    "id": "rendering-patterns-rendering4-2",
    "title": "CSR and SEO Challenges",
    "content": "Why can Client-Side Rendering negatively affect SEO?",
    "type": "multiple-choice",
    "category": "Rendering Patterns",
    "topic": "Client-Side Rendering",
    "difficulty": "intermediate",
    "learningCardId": "system-design",
    "isActive": true,
    "createdAt": "2024-01-01T00:00:00.000Z",
    "updatedAt": "2025-11-11T18:59:32.540Z",
    "createdBy": "admin",
    "updatedBy": "admin",
    "tags": [
      "rendering-patterns",
      "client-side-rendering",
      "intermediate"
    ],
    "explanation": "Search engines struggle to index JavaScript-rendered pages",
    "points": 10,
    "options": [
      {
        "id": "a",
        "text": "Search engines struggle to index JavaScript-rendered pages",
        "isCorrect": true,
        "explanation": ""
      },
      {
        "id": "b",
        "text": "CSR prevents the use of meta tags",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "c",
        "text": "CSR makes sites slower for all users",
        "isCorrect": false,
        "explanation": ""
      }
    ],
    "hints": [
      "Review rendering pattern documentation",
      "Consider server vs client rendering trade-offs",
      "Think about performance and SEO implications"
    ]
  },
  {
    "id": "rendering-patterns-rendering4-3",
    "title": "Improving CSR Performance",
    "content": "What is a common technique to improve perceived performance in Client-Side Rendering?",
    "type": "multiple-choice",
    "category": "Rendering Patterns",
    "topic": "Client-Side Rendering",
    "difficulty": "intermediate",
    "learningCardId": "system-design",
    "isActive": true,
    "createdAt": "2024-01-01T00:00:00.000Z",
    "updatedAt": "2025-11-11T18:59:32.540Z",
    "createdBy": "admin",
    "updatedBy": "admin",
    "tags": [
      "rendering-patterns",
      "client-side-rendering",
      "intermediate"
    ],
    "explanation": "Use code-splitting and lazy loading to reduce the initial bundle size.",
    "points": 10,
    "sampleAnswers": [
      "Use code-splitting and lazy loading to reduce the initial bundle size.",
      "Show loading skeletons while data is being fetched."
    ],
    "options": [
      {
        "id": "o1",
        "text": "Use code-splitting and lazy loading to reduce the initial bundle size.",
        "isCorrect": true,
        "explanation": "Use code-splitting and lazy loading to reduce the initial bundle size."
      },
      {
        "id": "o2",
        "text": "This is not correct. Please refer to the explanation.",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "o3",
        "text": "Incorrect. Review rendering pattern concepts.",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "o4",
        "text": "This is a common misconception. The correct answer is different.",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "o5",
        "text": "Not quite. Consider rendering strategy best practices.",
        "isCorrect": false,
        "explanation": ""
      }
    ],
    "hints": [
      "Review rendering pattern documentation",
      "Consider server vs client rendering trade-offs",
      "Think about performance and SEO implications"
    ]
  },
  {
    "id": "rendering-patterns-rendering4-4",
    "title": "CSR vs SSR Trade-offs",
    "content": "Which of the following best describes the difference between CSR and SSR?",
    "type": "multiple-choice",
    "category": "Rendering Patterns",
    "topic": "Client-Side Rendering",
    "difficulty": "intermediate",
    "learningCardId": "system-design",
    "isActive": true,
    "createdAt": "2024-01-01T00:00:00.000Z",
    "updatedAt": "2025-11-11T18:59:32.540Z",
    "createdBy": "admin",
    "updatedBy": "admin",
    "tags": [
      "rendering-patterns",
      "client-side-rendering",
      "intermediate"
    ],
    "explanation": "CSR renders pages on the client, SSR renders them on the server before sending HTML",
    "points": 10,
    "options": [
      {
        "id": "a",
        "text": "CSR renders pages on the client, SSR renders them on the server before sending HTML",
        "isCorrect": true,
        "explanation": ""
      },
      {
        "id": "b",
        "text": "SSR requires no JavaScript on the client",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "c",
        "text": "CSR is faster than SSR in all cases",
        "isCorrect": false,
        "explanation": ""
      }
    ],
    "hints": [
      "Review rendering pattern documentation",
      "Consider server vs client rendering trade-offs",
      "Think about performance and SEO implications"
    ]
  },
  {
    "id": "rendering-patterns-rendering4-5",
    "title": "Islands Architecture Concept",
    "content": "What is the core principle of the Islands Architecture pattern?",
    "type": "multiple-choice",
    "category": "Rendering Patterns",
    "topic": "Client-Side Rendering",
    "difficulty": "intermediate",
    "learningCardId": "system-design",
    "isActive": true,
    "createdAt": "2024-01-01T00:00:00.000Z",
    "updatedAt": "2025-11-11T18:59:32.540Z",
    "createdBy": "admin",
    "updatedBy": "admin",
    "tags": [
      "rendering-patterns",
      "client-side-rendering",
      "intermediate"
    ],
    "explanation": "Islands Architecture renders mostly static HTML on the server and hydrates only small interactive 'islands' on the client.",
    "points": 10,
    "sampleAnswers": [
      "Islands Architecture renders mostly static HTML on the server and hydrates only small interactive 'islands' on the client.",
      "It helps reduce the amount of JavaScript shipped to the user."
    ],
    "options": [
      {
        "id": "o1",
        "text": "Islands Architecture renders mostly static HTML on the server and hydrates only small interactive 'islands' on the client.",
        "isCorrect": true,
        "explanation": "Islands Architecture renders mostly static HTML on the server and hydrates only small interactive 'islands' on the client."
      },
      {
        "id": "o2",
        "text": "This is not correct. Please refer to the explanation.",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "o3",
        "text": "Incorrect. Review rendering pattern concepts.",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "o4",
        "text": "This is a common misconception. The correct answer is different.",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "o5",
        "text": "Not quite. Consider rendering strategy best practices.",
        "isCorrect": false,
        "explanation": ""
      }
    ],
    "hints": [
      "Review rendering pattern documentation",
      "Consider server vs client rendering trade-offs",
      "Think about performance and SEO implications"
    ]
  },
  {
    "id": "rendering-patterns-rendering4-6",
    "title": "Dynamic Islands Example",
    "content": "Which of these is an example of a dynamic island on a static page?",
    "type": "multiple-choice",
    "category": "Rendering Patterns",
    "topic": "Client-Side Rendering",
    "difficulty": "intermediate",
    "learningCardId": "system-design",
    "isActive": true,
    "createdAt": "2024-01-01T00:00:00.000Z",
    "updatedAt": "2025-11-11T18:59:32.540Z",
    "createdBy": "admin",
    "updatedBy": "admin",
    "tags": [
      "rendering-patterns",
      "client-side-rendering",
      "intermediate"
    ],
    "explanation": "A social media share widget inside a static blog post",
    "points": 10,
    "options": [
      {
        "id": "a",
        "text": "A social media share widget inside a static blog post",
        "isCorrect": true,
        "explanation": ""
      },
      {
        "id": "b",
        "text": "Static article text with no JavaScript",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "c",
        "text": "Server-rendered navigation bar",
        "isCorrect": false,
        "explanation": ""
      }
    ],
    "hints": [
      "Review rendering pattern documentation",
      "Consider server vs client rendering trade-offs",
      "Think about performance and SEO implications"
    ]
  },
  {
    "id": "rendering-patterns-rendering4-7",
    "title": "Partial Hydration",
    "content": "How does Partial Hydration improve performance in the Islands Architecture?",
    "type": "multiple-choice",
    "category": "Rendering Patterns",
    "topic": "Client-Side Rendering",
    "difficulty": "advanced",
    "learningCardId": "system-design",
    "isActive": true,
    "createdAt": "2024-01-01T00:00:00.000Z",
    "updatedAt": "2025-11-11T18:59:32.540Z",
    "createdBy": "admin",
    "updatedBy": "admin",
    "tags": [
      "rendering-patterns",
      "client-side-rendering",
      "advanced"
    ],
    "explanation": "It allows each component to hydrate independently rather than rehydrating the entire page.",
    "points": 10,
    "sampleAnswers": [
      "It allows each component to hydrate independently rather than rehydrating the entire page.",
      "This reduces JavaScript execution time and memory usage."
    ],
    "options": [
      {
        "id": "o1",
        "text": "It allows each component to hydrate independently rather than rehydrating the entire page.",
        "isCorrect": true,
        "explanation": "It allows each component to hydrate independently rather than rehydrating the entire page."
      },
      {
        "id": "o2",
        "text": "This is not correct. Please refer to the explanation.",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "o3",
        "text": "Incorrect. Review rendering pattern concepts.",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "o4",
        "text": "This is a common misconception. The correct answer is different.",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "o5",
        "text": "Not quite. Consider rendering strategy best practices.",
        "isCorrect": false,
        "explanation": ""
      }
    ],
    "hints": [
      "Review rendering pattern documentation",
      "Consider server vs client rendering trade-offs",
      "Think about performance and SEO implications"
    ]
  },
  {
    "id": "rendering-patterns-rendering4-8",
    "title": "Frameworks Supporting Islands",
    "content": "Which frameworks natively support Islands Architecture?",
    "type": "multiple-choice",
    "category": "Rendering Patterns",
    "topic": "Client-Side Rendering",
    "difficulty": "intermediate",
    "learningCardId": "system-design",
    "isActive": true,
    "createdAt": "2024-01-01T00:00:00.000Z",
    "updatedAt": "2025-11-11T18:59:32.540Z",
    "createdBy": "admin",
    "updatedBy": "admin",
    "tags": [
      "rendering-patterns",
      "client-side-rendering",
      "intermediate"
    ],
    "explanation": "Astro and Marko",
    "points": 10,
    "options": [
      {
        "id": "a",
        "text": "Astro and Marko",
        "isCorrect": true,
        "explanation": ""
      },
      {
        "id": "b",
        "text": "Next.js only",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "c",
        "text": "Create React App",
        "isCorrect": false,
        "explanation": ""
      }
    ],
    "hints": [
      "Review rendering pattern documentation",
      "Consider server vs client rendering trade-offs",
      "Think about performance and SEO implications"
    ]
  },
  {
    "id": "rendering-patterns-rendering4-9",
    "title": "Advantages of Islands Architecture",
    "content": "What are some benefits of adopting the Islands Architecture?",
    "type": "multiple-choice",
    "category": "Rendering Patterns",
    "topic": "Client-Side Rendering",
    "difficulty": "intermediate",
    "learningCardId": "system-design",
    "isActive": true,
    "createdAt": "2024-01-01T00:00:00.000Z",
    "updatedAt": "2025-11-11T18:59:32.540Z",
    "createdBy": "admin",
    "updatedBy": "admin",
    "tags": [
      "rendering-patterns",
      "client-side-rendering",
      "intermediate"
    ],
    "explanation": "Reduces the amount of JavaScript shipped to the client.",
    "points": 10,
    "sampleAnswers": [
      "Reduces the amount of JavaScript shipped to the client.",
      "Improves SEO and accessibility due to static HTML.",
      "Allows independent hydration of interactive components."
    ],
    "options": [
      {
        "id": "o1",
        "text": "Reduces the amount of JavaScript shipped to the client.",
        "isCorrect": true,
        "explanation": "Reduces the amount of JavaScript shipped to the client."
      },
      {
        "id": "o2",
        "text": "This is not correct. Please refer to the explanation.",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "o3",
        "text": "Incorrect. Review rendering pattern concepts.",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "o4",
        "text": "This is a common misconception. The correct answer is different.",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "o5",
        "text": "Not quite. Consider rendering strategy best practices.",
        "isCorrect": false,
        "explanation": ""
      }
    ],
    "hints": [
      "Review rendering pattern documentation",
      "Consider server vs client rendering trade-offs",
      "Think about performance and SEO implications"
    ]
  },
  {
    "id": "rendering-patterns-rendering4-10",
    "title": "Limitations of Islands Architecture",
    "content": "What is a limitation of the Islands Architecture approach?",
    "type": "multiple-choice",
    "category": "Rendering Patterns",
    "topic": "Client-Side Rendering",
    "difficulty": "advanced",
    "learningCardId": "system-design",
    "isActive": true,
    "createdAt": "2024-01-01T00:00:00.000Z",
    "updatedAt": "2025-11-11T18:59:32.540Z",
    "createdBy": "admin",
    "updatedBy": "admin",
    "tags": [
      "rendering-patterns",
      "client-side-rendering",
      "advanced"
    ],
    "explanation": "It’s difficult to scale for highly interactive apps like social media feeds",
    "points": 10,
    "options": [
      {
        "id": "a",
        "text": "It’s difficult to scale for highly interactive apps like social media feeds",
        "isCorrect": true,
        "explanation": ""
      },
      {
        "id": "b",
        "text": "It cannot be used with React",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "c",
        "text": "It requires a full backend rewrite",
        "isCorrect": false,
        "explanation": ""
      }
    ],
    "hints": [
      "Review rendering pattern documentation",
      "Consider server vs client rendering trade-offs",
      "Think about performance and SEO implications"
    ]
  },
  {
    "id": "rendering-patterns-render6-1",
    "title": "Edge Rendering Basics",
    "content": "What is Edge Rendering and how does it differ from traditional SSR?",
    "type": "multiple-choice",
    "category": "Rendering Patterns",
    "topic": "Edge Rendering",
    "difficulty": "intermediate",
    "learningCardId": "system-design",
    "isActive": true,
    "createdAt": "2024-01-01T00:00:00.000Z",
    "updatedAt": "2025-11-11T18:59:32.537Z",
    "createdBy": "admin",
    "updatedBy": "admin",
    "tags": [
      "rendering-patterns",
      "edge-rendering",
      "intermediate"
    ],
    "explanation": "Edge Rendering executes server-side logic at CDN edge locations, closer to the user.",
    "points": 10,
    "sampleAnswers": [
      "Edge Rendering executes server-side logic at CDN edge locations, closer to the user.",
      "It differs from traditional SSR because responses are generated with lower latency and faster Time To First Byte (TTFB)."
    ],
    "options": [
      {
        "id": "o1",
        "text": "Edge Rendering executes server-side logic at CDN edge locations, closer to the user.",
        "isCorrect": true,
        "explanation": "Edge Rendering executes server-side logic at CDN edge locations, closer to the user."
      },
      {
        "id": "o2",
        "text": "This is not correct. Please refer to the explanation.",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "o3",
        "text": "Incorrect. Review rendering pattern concepts.",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "o4",
        "text": "This is a common misconception. The correct answer is different.",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "o5",
        "text": "Not quite. Consider rendering strategy best practices.",
        "isCorrect": false,
        "explanation": ""
      }
    ],
    "hints": [
      "Review rendering pattern documentation",
      "Consider server vs client rendering trade-offs",
      "Think about performance and SEO implications"
    ]
  },
  {
    "id": "rendering-patterns-render6-2",
    "title": "Advantages of Edge Rendering",
    "content": "Which of the following is a main advantage of Edge Rendering?",
    "type": "multiple-choice",
    "category": "Rendering Patterns",
    "topic": "Edge Rendering",
    "difficulty": "intermediate",
    "learningCardId": "system-design",
    "isActive": true,
    "createdAt": "2024-01-01T00:00:00.000Z",
    "updatedAt": "2025-11-11T18:59:32.537Z",
    "createdBy": "admin",
    "updatedBy": "admin",
    "tags": [
      "rendering-patterns",
      "edge-rendering",
      "intermediate"
    ],
    "explanation": "Reduced latency due to geographical proximity to users",
    "points": 10,
    "options": [
      {
        "id": "a",
        "text": "Reduced latency due to geographical proximity to users",
        "isCorrect": true,
        "explanation": ""
      },
      {
        "id": "b",
        "text": "It replaces all client-side rendering logic",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "c",
        "text": "It always increases server costs",
        "isCorrect": false,
        "explanation": ""
      }
    ],
    "hints": [
      "Review rendering pattern documentation",
      "Consider server vs client rendering trade-offs",
      "Think about performance and SEO implications"
    ]
  },
  {
    "id": "rendering-patterns-render6-3",
    "title": "Edge vs CDN Caching",
    "content": "How is Edge Rendering different from traditional CDN caching?",
    "type": "multiple-choice",
    "category": "Rendering Patterns",
    "topic": "Edge Rendering",
    "difficulty": "advanced",
    "learningCardId": "system-design",
    "isActive": true,
    "createdAt": "2024-01-01T00:00:00.000Z",
    "updatedAt": "2025-11-11T18:59:32.537Z",
    "createdBy": "admin",
    "updatedBy": "admin",
    "tags": [
      "rendering-patterns",
      "edge-rendering",
      "advanced"
    ],
    "explanation": "CDN caching serves static assets, while Edge Rendering runs dynamic server code at the edge.",
    "points": 10,
    "sampleAnswers": [
      "CDN caching serves static assets, while Edge Rendering runs dynamic server code at the edge.",
      "Edge rendering can personalize responses per user, unlike static CDN cache."
    ],
    "options": [
      {
        "id": "o1",
        "text": "CDN caching serves static assets, while Edge Rendering runs dynamic server code at the edge.",
        "isCorrect": true,
        "explanation": "CDN caching serves static assets, while Edge Rendering runs dynamic server code at the edge."
      },
      {
        "id": "o2",
        "text": "This is not correct. Please refer to the explanation.",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "o3",
        "text": "Incorrect. Review rendering pattern concepts.",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "o4",
        "text": "This is a common misconception. The correct answer is different.",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "o5",
        "text": "Not quite. Consider rendering strategy best practices.",
        "isCorrect": false,
        "explanation": ""
      }
    ],
    "hints": [
      "Review rendering pattern documentation",
      "Consider server vs client rendering trade-offs",
      "Think about performance and SEO implications"
    ]
  },
  {
    "id": "rendering-patterns-render6-4",
    "title": "Progressive Hydration Concept",
    "content": "What is Progressive Hydration in React or similar frameworks?",
    "type": "multiple-choice",
    "category": "Rendering Patterns",
    "topic": "Edge Rendering",
    "difficulty": "intermediate",
    "learningCardId": "system-design",
    "isActive": true,
    "createdAt": "2024-01-01T00:00:00.000Z",
    "updatedAt": "2025-11-11T18:59:32.537Z",
    "createdBy": "admin",
    "updatedBy": "admin",
    "tags": [
      "rendering-patterns",
      "edge-rendering",
      "intermediate"
    ],
    "explanation": "It hydrates parts of the UI gradually as JavaScript loads or user interacts",
    "points": 10,
    "options": [
      {
        "id": "a",
        "text": "It hydrates parts of the UI gradually as JavaScript loads or user interacts",
        "isCorrect": true,
        "explanation": ""
      },
      {
        "id": "b",
        "text": "It waits until all components are fully loaded before rendering anything",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "c",
        "text": "It disables interactivity completely",
        "isCorrect": false,
        "explanation": ""
      }
    ],
    "hints": [
      "Review rendering pattern documentation",
      "Consider server vs client rendering trade-offs",
      "Think about performance and SEO implications"
    ]
  },
  {
    "id": "rendering-patterns-render6-5",
    "title": "Why Progressive Hydration Matters",
    "content": "Why is Progressive Hydration beneficial for large, complex pages?",
    "type": "multiple-choice",
    "category": "Rendering Patterns",
    "topic": "Edge Rendering",
    "difficulty": "intermediate",
    "learningCardId": "system-design",
    "isActive": true,
    "createdAt": "2024-01-01T00:00:00.000Z",
    "updatedAt": "2025-11-11T18:59:32.537Z",
    "createdBy": "admin",
    "updatedBy": "admin",
    "tags": [
      "rendering-patterns",
      "edge-rendering",
      "intermediate"
    ],
    "explanation": "It reduces the blocking time by enabling interaction in critical parts of the page before the entire app hydrates.",
    "points": 10,
    "sampleAnswers": [
      "It reduces the blocking time by enabling interaction in critical parts of the page before the entire app hydrates.",
      "Improves perceived performance by prioritizing above-the-fold components."
    ],
    "options": [
      {
        "id": "o1",
        "text": "It reduces the blocking time by enabling interaction in critical parts of the page before the entire app hydrates.",
        "isCorrect": true,
        "explanation": "It reduces the blocking time by enabling interaction in critical parts of the page before the entire app hydrates."
      },
      {
        "id": "o2",
        "text": "This is not correct. Please refer to the explanation.",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "o3",
        "text": "Incorrect. Review rendering pattern concepts.",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "o4",
        "text": "This is a common misconception. The correct answer is different.",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "o5",
        "text": "Not quite. Consider rendering strategy best practices.",
        "isCorrect": false,
        "explanation": ""
      }
    ],
    "hints": [
      "Review rendering pattern documentation",
      "Consider server vs client rendering trade-offs",
      "Think about performance and SEO implications"
    ]
  },
  {
    "id": "rendering-patterns-render6-6",
    "title": "Resumability Explained",
    "content": "What is Resumability in frameworks like Qwik?",
    "type": "multiple-choice",
    "category": "Rendering Patterns",
    "topic": "Edge Rendering",
    "difficulty": "advanced",
    "learningCardId": "system-design",
    "isActive": true,
    "createdAt": "2024-01-01T00:00:00.000Z",
    "updatedAt": "2025-11-11T18:59:32.537Z",
    "createdBy": "admin",
    "updatedBy": "admin",
    "tags": [
      "rendering-patterns",
      "edge-rendering",
      "advanced"
    ],
    "explanation": "Resumability allows the browser to resume application execution without rehydrating all components.",
    "points": 10,
    "sampleAnswers": [
      "Resumability allows the browser to resume application execution without rehydrating all components.",
      "Instead of downloading and re-running the full JS, it resumes from pre-serialized state."
    ],
    "options": [
      {
        "id": "o1",
        "text": "Resumability allows the browser to resume application execution without rehydrating all components.",
        "isCorrect": true,
        "explanation": "Resumability allows the browser to resume application execution without rehydrating all components."
      },
      {
        "id": "o2",
        "text": "This is not correct. Please refer to the explanation.",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "o3",
        "text": "Incorrect. Review rendering pattern concepts.",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "o4",
        "text": "This is a common misconception. The correct answer is different.",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "o5",
        "text": "Not quite. Consider rendering strategy best practices.",
        "isCorrect": false,
        "explanation": ""
      }
    ],
    "hints": [
      "Review rendering pattern documentation",
      "Consider server vs client rendering trade-offs",
      "Think about performance and SEO implications"
    ]
  },
  {
    "id": "rendering-patterns-render6-7",
    "title": "Resumability vs Hydration",
    "content": "How does Resumability differ from traditional hydration?",
    "type": "multiple-choice",
    "category": "Rendering Patterns",
    "topic": "Edge Rendering",
    "difficulty": "advanced",
    "learningCardId": "system-design",
    "isActive": true,
    "createdAt": "2024-01-01T00:00:00.000Z",
    "updatedAt": "2025-11-11T18:59:32.537Z",
    "createdBy": "admin",
    "updatedBy": "admin",
    "tags": [
      "rendering-patterns",
      "edge-rendering",
      "advanced"
    ],
    "explanation": "Resumability skips full rehydration by resuming the app state directly from serialized data",
    "points": 10,
    "options": [
      {
        "id": "a",
        "text": "Resumability skips full rehydration by resuming the app state directly from serialized data",
        "isCorrect": true,
        "explanation": ""
      },
      {
        "id": "b",
        "text": "Resumability re-renders everything on the server",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "c",
        "text": "They are the same process with different names",
        "isCorrect": false,
        "explanation": ""
      }
    ],
    "hints": [
      "Review rendering pattern documentation",
      "Consider server vs client rendering trade-offs",
      "Think about performance and SEO implications"
    ]
  },
  {
    "id": "rendering-patterns-render6-8",
    "title": "React Server Components (RSC) Role",
    "content": "How do React Server Components improve rendering performance?",
    "type": "multiple-choice",
    "category": "Rendering Patterns",
    "topic": "Edge Rendering",
    "difficulty": "advanced",
    "learningCardId": "system-design",
    "isActive": true,
    "createdAt": "2024-01-01T00:00:00.000Z",
    "updatedAt": "2025-11-11T18:59:32.537Z",
    "createdBy": "admin",
    "updatedBy": "admin",
    "tags": [
      "rendering-patterns",
      "edge-rendering",
      "advanced"
    ],
    "explanation": "RSCs allow heavy computation and data fetching to happen on the server, reducing client bundle size.",
    "points": 10,
    "sampleAnswers": [
      "RSCs allow heavy computation and data fetching to happen on the server, reducing client bundle size.",
      "They send minimal serialized output to the browser and improve render speed."
    ],
    "options": [
      {
        "id": "o1",
        "text": "RSCs allow heavy computation and data fetching to happen on the server, reducing client bundle size.",
        "isCorrect": true,
        "explanation": "RSCs allow heavy computation and data fetching to happen on the server, reducing client bundle size."
      },
      {
        "id": "o2",
        "text": "This is not correct. Please refer to the explanation.",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "o3",
        "text": "Incorrect. Review rendering pattern concepts.",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "o4",
        "text": "This is a common misconception. The correct answer is different.",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "o5",
        "text": "Not quite. Consider rendering strategy best practices.",
        "isCorrect": false,
        "explanation": ""
      }
    ],
    "hints": [
      "Review rendering pattern documentation",
      "Consider server vs client rendering trade-offs",
      "Think about performance and SEO implications"
    ]
  },
  {
    "id": "rendering-patterns-render6-9",
    "title": "Streaming + RSC Integration",
    "content": "What benefit do we get when combining React Server Components with streaming rendering?",
    "type": "multiple-choice",
    "category": "Rendering Patterns",
    "topic": "Edge Rendering",
    "difficulty": "advanced",
    "learningCardId": "system-design",
    "isActive": true,
    "createdAt": "2024-01-01T00:00:00.000Z",
    "updatedAt": "2025-11-11T18:59:32.537Z",
    "createdBy": "admin",
    "updatedBy": "admin",
    "tags": [
      "rendering-patterns",
      "edge-rendering",
      "advanced"
    ],
    "explanation": "Users see parts of the UI sooner while server components load progressively",
    "points": 10,
    "options": [
      {
        "id": "a",
        "text": "Users see parts of the UI sooner while server components load progressively",
        "isCorrect": true,
        "explanation": ""
      },
      {
        "id": "b",
        "text": "It delays rendering until all components are ready",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "c",
        "text": "It removes the need for client components entirely",
        "isCorrect": false,
        "explanation": ""
      }
    ],
    "hints": [
      "Review rendering pattern documentation",
      "Consider server vs client rendering trade-offs",
      "Think about performance and SEO implications"
    ]
  },
  {
    "id": "rendering-patterns-render6-10",
    "title": "Choosing Rendering Strategy",
    "content": "How should a developer decide between SSR, ISR, Edge, and Resumable approaches?",
    "type": "multiple-choice",
    "category": "Rendering Patterns",
    "topic": "Edge Rendering",
    "difficulty": "advanced",
    "learningCardId": "system-design",
    "isActive": true,
    "createdAt": "2024-01-01T00:00:00.000Z",
    "updatedAt": "2025-11-11T18:59:32.537Z",
    "createdBy": "admin",
    "updatedBy": "admin",
    "tags": [
      "rendering-patterns",
      "edge-rendering",
      "advanced"
    ],
    "explanation": "Use SSR for dynamic personalized content, ISR for semi-static content, Edge Rendering for global low-latency responses, and Resumability for ultra-fast interactivity without full hydration.",
    "points": 10,
    "sampleAnswers": [
      "Use SSR for dynamic personalized content, ISR for semi-static content, Edge Rendering for global low-latency responses, and Resumability for ultra-fast interactivity without full hydration.",
      "The choice depends on user proximity, data volatility, and performance goals."
    ],
    "options": [
      {
        "id": "o1",
        "text": "Use SSR for dynamic personalized content, ISR for semi-static content, Edge Rendering for global low-latency responses, and Resumability for ultra-fast interactivity without full hydration.",
        "isCorrect": true,
        "explanation": "Use SSR for dynamic personalized content, ISR for semi-static content, Edge Rendering for global low-latency responses, and Resumability for ultra-fast interactivity without full hydration."
      },
      {
        "id": "o2",
        "text": "This is not correct. Please refer to the explanation.",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "o3",
        "text": "Incorrect. Review rendering pattern concepts.",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "o4",
        "text": "This is a common misconception. The correct answer is different.",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "o5",
        "text": "Not quite. Consider rendering strategy best practices.",
        "isCorrect": false,
        "explanation": ""
      }
    ],
    "hints": [
      "Review rendering pattern documentation",
      "Consider server vs client rendering trade-offs",
      "Think about performance and SEO implications"
    ]
  },
  {
    "id": "rendering-patterns-rendering5-1",
    "title": "Incremental Static Regeneration (ISR) Basics",
    "content": "What problem does Incremental Static Regeneration (ISR) solve compared to standard static generation?",
    "type": "multiple-choice",
    "category": "Rendering Patterns",
    "topic": "Hybrid Rendering",
    "difficulty": "intermediate",
    "learningCardId": "system-design",
    "isActive": true,
    "createdAt": "2024-01-01T00:00:00.000Z",
    "updatedAt": "2025-11-11T18:59:32.540Z",
    "createdBy": "admin",
    "updatedBy": "admin",
    "tags": [
      "rendering-patterns",
      "hybrid-rendering",
      "intermediate"
    ],
    "explanation": "ISR allows pages to be updated after the initial build without rebuilding the entire site.",
    "points": 10,
    "sampleAnswers": [
      "ISR allows pages to be updated after the initial build without rebuilding the entire site.",
      "It helps maintain dynamic content with fast load times."
    ],
    "options": [
      {
        "id": "o1",
        "text": "ISR allows pages to be updated after the initial build without rebuilding the entire site.",
        "isCorrect": true,
        "explanation": "ISR allows pages to be updated after the initial build without rebuilding the entire site."
      },
      {
        "id": "o2",
        "text": "This is not correct. Please refer to the explanation.",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "o3",
        "text": "Incorrect. Review rendering pattern concepts.",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "o4",
        "text": "This is a common misconception. The correct answer is different.",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "o5",
        "text": "Not quite. Consider rendering strategy best practices.",
        "isCorrect": false,
        "explanation": ""
      }
    ],
    "hints": [
      "Review rendering pattern documentation",
      "Consider server vs client rendering trade-offs",
      "Think about performance and SEO implications"
    ]
  },
  {
    "id": "rendering-patterns-rendering5-2",
    "title": "ISR Workflow",
    "content": "How does ISR update static pages over time?",
    "type": "multiple-choice",
    "category": "Rendering Patterns",
    "topic": "Hybrid Rendering",
    "difficulty": "intermediate",
    "learningCardId": "system-design",
    "isActive": true,
    "createdAt": "2024-01-01T00:00:00.000Z",
    "updatedAt": "2025-11-11T18:59:32.540Z",
    "createdBy": "admin",
    "updatedBy": "admin",
    "tags": [
      "rendering-patterns",
      "hybrid-rendering",
      "intermediate"
    ],
    "explanation": "It regenerates pages on-demand when a user visits an outdated page",
    "points": 10,
    "options": [
      {
        "id": "a",
        "text": "It regenerates pages on-demand when a user visits an outdated page",
        "isCorrect": true,
        "explanation": ""
      },
      {
        "id": "b",
        "text": "It rebuilds the entire website daily",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "c",
        "text": "It updates pages manually via admin dashboard",
        "isCorrect": false,
        "explanation": ""
      }
    ],
    "hints": [
      "Review rendering pattern documentation",
      "Consider server vs client rendering trade-offs",
      "Think about performance and SEO implications"
    ]
  },
  {
    "id": "rendering-patterns-rendering5-3",
    "title": "Revalidation in ISR",
    "content": "What does the 'revalidate' field do in Next.js Incremental Static Regeneration?",
    "type": "multiple-choice",
    "category": "Rendering Patterns",
    "topic": "Hybrid Rendering",
    "difficulty": "intermediate",
    "learningCardId": "system-design",
    "isActive": true,
    "createdAt": "2024-01-01T00:00:00.000Z",
    "updatedAt": "2025-11-11T18:59:32.540Z",
    "createdBy": "admin",
    "updatedBy": "admin",
    "tags": [
      "rendering-patterns",
      "hybrid-rendering",
      "intermediate"
    ],
    "explanation": "It defines how often a static page should be regenerated in the background.",
    "points": 10,
    "sampleAnswers": [
      "It defines how often a static page should be regenerated in the background.",
      "Once the revalidation interval passes, the next request triggers page regeneration."
    ],
    "options": [
      {
        "id": "o1",
        "text": "It defines how often a static page should be regenerated in the background.",
        "isCorrect": true,
        "explanation": "It defines how often a static page should be regenerated in the background."
      },
      {
        "id": "o2",
        "text": "This is not correct. Please refer to the explanation.",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "o3",
        "text": "Incorrect. Review rendering pattern concepts.",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "o4",
        "text": "This is a common misconception. The correct answer is different.",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "o5",
        "text": "Not quite. Consider rendering strategy best practices.",
        "isCorrect": false,
        "explanation": ""
      }
    ],
    "hints": [
      "Review rendering pattern documentation",
      "Consider server vs client rendering trade-offs",
      "Think about performance and SEO implications"
    ]
  },
  {
    "id": "rendering-patterns-rendering5-4",
    "title": "ISR and Performance",
    "content": "Why does ISR improve performance compared to SSR for frequently accessed pages?",
    "type": "multiple-choice",
    "category": "Rendering Patterns",
    "topic": "Hybrid Rendering",
    "difficulty": "intermediate",
    "learningCardId": "system-design",
    "isActive": true,
    "createdAt": "2024-01-01T00:00:00.000Z",
    "updatedAt": "2025-11-11T18:59:32.540Z",
    "createdBy": "admin",
    "updatedBy": "admin",
    "tags": [
      "rendering-patterns",
      "hybrid-rendering",
      "intermediate"
    ],
    "explanation": "ISR caches pre-rendered pages at the edge and avoids regenerating on every request",
    "points": 10,
    "options": [
      {
        "id": "a",
        "text": "ISR caches pre-rendered pages at the edge and avoids regenerating on every request",
        "isCorrect": true,
        "explanation": ""
      },
      {
        "id": "b",
        "text": "ISR avoids hydration completely",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "c",
        "text": "ISR runs entirely on the client",
        "isCorrect": false,
        "explanation": ""
      }
    ],
    "hints": [
      "Review rendering pattern documentation",
      "Consider server vs client rendering trade-offs",
      "Think about performance and SEO implications"
    ]
  },
  {
    "id": "rendering-patterns-rendering5-5",
    "title": "On-Demand ISR",
    "content": "How is On-Demand ISR different from regular ISR?",
    "type": "multiple-choice",
    "category": "Rendering Patterns",
    "topic": "Hybrid Rendering",
    "difficulty": "advanced",
    "learningCardId": "system-design",
    "isActive": true,
    "createdAt": "2024-01-01T00:00:00.000Z",
    "updatedAt": "2025-11-11T18:59:32.540Z",
    "createdBy": "admin",
    "updatedBy": "admin",
    "tags": [
      "rendering-patterns",
      "hybrid-rendering",
      "advanced"
    ],
    "explanation": "On-Demand ISR regenerates pages when triggered by specific events like webhook updates instead of fixed time intervals.",
    "points": 10,
    "sampleAnswers": [
      "On-Demand ISR regenerates pages when triggered by specific events like webhook updates instead of fixed time intervals.",
      "It avoids unnecessary revalidations and reduces serverless costs."
    ],
    "options": [
      {
        "id": "o1",
        "text": "On-Demand ISR regenerates pages when triggered by specific events like webhook updates instead of fixed time intervals.",
        "isCorrect": true,
        "explanation": "On-Demand ISR regenerates pages when triggered by specific events like webhook updates instead of fixed time intervals."
      },
      {
        "id": "o2",
        "text": "This is not correct. Please refer to the explanation.",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "o3",
        "text": "Incorrect. Review rendering pattern concepts.",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "o4",
        "text": "This is a common misconception. The correct answer is different.",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "o5",
        "text": "Not quite. Consider rendering strategy best practices.",
        "isCorrect": false,
        "explanation": ""
      }
    ],
    "hints": [
      "Review rendering pattern documentation",
      "Consider server vs client rendering trade-offs",
      "Think about performance and SEO implications"
    ]
  },
  {
    "id": "rendering-patterns-rendering5-6",
    "title": "Use Case for On-Demand ISR",
    "content": "When should you prefer On-Demand ISR over time-based ISR?",
    "type": "multiple-choice",
    "category": "Rendering Patterns",
    "topic": "Hybrid Rendering",
    "difficulty": "intermediate",
    "learningCardId": "system-design",
    "isActive": true,
    "createdAt": "2024-01-01T00:00:00.000Z",
    "updatedAt": "2025-11-11T18:59:32.540Z",
    "createdBy": "admin",
    "updatedBy": "admin",
    "tags": [
      "rendering-patterns",
      "hybrid-rendering",
      "intermediate"
    ],
    "explanation": "When content changes are event-driven, such as CMS updates",
    "points": 10,
    "options": [
      {
        "id": "a",
        "text": "When content changes are event-driven, such as CMS updates",
        "isCorrect": true,
        "explanation": ""
      },
      {
        "id": "b",
        "text": "When your website never changes",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "c",
        "text": "When you have no API data",
        "isCorrect": false,
        "explanation": ""
      }
    ],
    "hints": [
      "Review rendering pattern documentation",
      "Consider server vs client rendering trade-offs",
      "Think about performance and SEO implications"
    ]
  },
  {
    "id": "rendering-patterns-rendering5-7",
    "title": "Streaming Server-Side Rendering",
    "content": "What is the main benefit of streaming SSR compared to traditional SSR?",
    "type": "multiple-choice",
    "category": "Rendering Patterns",
    "topic": "Hybrid Rendering",
    "difficulty": "advanced",
    "learningCardId": "system-design",
    "isActive": true,
    "createdAt": "2024-01-01T00:00:00.000Z",
    "updatedAt": "2025-11-11T18:59:32.540Z",
    "createdBy": "admin",
    "updatedBy": "admin",
    "tags": [
      "rendering-patterns",
      "hybrid-rendering",
      "advanced"
    ],
    "explanation": "Streaming SSR allows sending parts of the page to the browser as they are generated, reducing time to first paint.",
    "points": 10,
    "sampleAnswers": [
      "Streaming SSR allows sending parts of the page to the browser as they are generated, reducing time to first paint.",
      "Users see content progressively instead of waiting for the full page to render."
    ],
    "options": [
      {
        "id": "o1",
        "text": "Streaming SSR allows sending parts of the page to the browser as they are generated, reducing time to first paint.",
        "isCorrect": true,
        "explanation": "Streaming SSR allows sending parts of the page to the browser as they are generated, reducing time to first paint."
      },
      {
        "id": "o2",
        "text": "This is not correct. Please refer to the explanation.",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "o3",
        "text": "Incorrect. Review rendering pattern concepts.",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "o4",
        "text": "This is a common misconception. The correct answer is different.",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "o5",
        "text": "Not quite. Consider rendering strategy best practices.",
        "isCorrect": false,
        "explanation": ""
      }
    ],
    "hints": [
      "Review rendering pattern documentation",
      "Consider server vs client rendering trade-offs",
      "Think about performance and SEO implications"
    ]
  },
  {
    "id": "rendering-patterns-rendering5-8",
    "title": "React Server Components (RSC)",
    "content": "What role do React Server Components play in modern rendering strategies?",
    "type": "multiple-choice",
    "category": "Rendering Patterns",
    "topic": "Hybrid Rendering",
    "difficulty": "advanced",
    "learningCardId": "system-design",
    "isActive": true,
    "createdAt": "2024-01-01T00:00:00.000Z",
    "updatedAt": "2025-11-11T18:59:32.540Z",
    "createdBy": "admin",
    "updatedBy": "admin",
    "tags": [
      "rendering-patterns",
      "hybrid-rendering",
      "advanced"
    ],
    "explanation": "They allow parts of React components to render on the server without sending unnecessary JavaScript to the client",
    "points": 10,
    "options": [
      {
        "id": "a",
        "text": "They allow parts of React components to render on the server without sending unnecessary JavaScript to the client",
        "isCorrect": true,
        "explanation": ""
      },
      {
        "id": "b",
        "text": "They replace all client-side interactivity",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "c",
        "text": "They only work in static generation",
        "isCorrect": false,
        "explanation": ""
      }
    ],
    "hints": [
      "Review rendering pattern documentation",
      "Consider server vs client rendering trade-offs",
      "Think about performance and SEO implications"
    ]
  },
  {
    "id": "rendering-patterns-rendering5-9",
    "title": "Edge SSR and Cold Boots",
    "content": "Why is Edge SSR often faster than traditional serverless SSR?",
    "type": "multiple-choice",
    "category": "Rendering Patterns",
    "topic": "Hybrid Rendering",
    "difficulty": "advanced",
    "learningCardId": "system-design",
    "isActive": true,
    "createdAt": "2024-01-01T00:00:00.000Z",
    "updatedAt": "2025-11-11T18:59:32.540Z",
    "createdBy": "admin",
    "updatedBy": "admin",
    "tags": [
      "rendering-patterns",
      "hybrid-rendering",
      "advanced"
    ],
    "explanation": "Edge SSR runs closer to users, reducing latency and cold boot times.",
    "points": 10,
    "sampleAnswers": [
      "Edge SSR runs closer to users, reducing latency and cold boot times.",
      "It also enables HTTP streaming for faster content delivery."
    ],
    "options": [
      {
        "id": "o1",
        "text": "Edge SSR runs closer to users, reducing latency and cold boot times.",
        "isCorrect": true,
        "explanation": "Edge SSR runs closer to users, reducing latency and cold boot times."
      },
      {
        "id": "o2",
        "text": "This is not correct. Please refer to the explanation.",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "o3",
        "text": "Incorrect. Review rendering pattern concepts.",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "o4",
        "text": "This is a common misconception. The correct answer is different.",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "o5",
        "text": "Not quite. Consider rendering strategy best practices.",
        "isCorrect": false,
        "explanation": ""
      }
    ],
    "hints": [
      "Review rendering pattern documentation",
      "Consider server vs client rendering trade-offs",
      "Think about performance and SEO implications"
    ]
  },
  {
    "id": "rendering-patterns-rendering5-10",
    "title": "Choosing Between Patterns",
    "content": "When should you choose SSR over ISR or Static Generation?",
    "type": "multiple-choice",
    "category": "Rendering Patterns",
    "topic": "Hybrid Rendering",
    "difficulty": "advanced",
    "learningCardId": "system-design",
    "isActive": true,
    "createdAt": "2024-01-01T00:00:00.000Z",
    "updatedAt": "2025-11-11T18:59:32.540Z",
    "createdBy": "admin",
    "updatedBy": "admin",
    "tags": [
      "rendering-patterns",
      "hybrid-rendering",
      "advanced"
    ],
    "explanation": "When your page depends on highly personalized data that changes per user request",
    "points": 10,
    "options": [
      {
        "id": "a",
        "text": "When your page depends on highly personalized data that changes per user request",
        "isCorrect": true,
        "explanation": ""
      },
      {
        "id": "b",
        "text": "When the content is static and rarely changes",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "c",
        "text": "When build times are slow",
        "isCorrect": false,
        "explanation": ""
      }
    ],
    "hints": [
      "Review rendering pattern documentation",
      "Consider server vs client rendering trade-offs",
      "Think about performance and SEO implications"
    ]
  },
  {
    "id": "rendering-patterns-islandarcheticure-1",
    "title": "Understanding Islands Architecture",
    "content": "What is the core idea behind the Islands Architecture rendering pattern?",
    "type": "multiple-choice",
    "category": "Rendering Patterns",
    "topic": "Islands Architecture",
    "difficulty": "intermediate",
    "learningCardId": "system-design",
    "isActive": true,
    "createdAt": "2024-01-01T00:00:00.000Z",
    "updatedAt": "2025-11-11T18:59:32.524Z",
    "createdBy": "admin",
    "updatedBy": "admin",
    "tags": [
      "rendering-patterns",
      "islands-architecture",
      "intermediate"
    ],
    "explanation": "It divides a web page into small independent interactive sections called islands, while keeping the rest of the page static HTML.",
    "points": 10,
    "sampleAnswers": [
      "It divides a web page into small independent interactive sections called islands, while keeping the rest of the page static HTML.",
      "Each island is hydrated independently, reducing JavaScript load and improving performance."
    ],
    "options": [
      {
        "id": "o1",
        "text": "It divides a web page into small independent interactive sections called islands, while keeping the rest of the page static HTML.",
        "isCorrect": true,
        "explanation": "It divides a web page into small independent interactive sections called islands, while keeping the rest of the page static HTML."
      },
      {
        "id": "o2",
        "text": "This is not correct. Please refer to the explanation.",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "o3",
        "text": "Incorrect. Review rendering pattern concepts.",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "o4",
        "text": "This is a common misconception. The correct answer is different.",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "o5",
        "text": "Not quite. Consider rendering strategy best practices.",
        "isCorrect": false,
        "explanation": ""
      }
    ],
    "hints": [
      "Review rendering pattern documentation",
      "Consider server vs client rendering trade-offs",
      "Think about performance and SEO implications"
    ]
  },
  {
    "id": "rendering-patterns-islandarcheticure-2",
    "title": "Islands vs Client-Side Rendering",
    "content": "How does Islands Architecture differ from traditional Client-Side Rendering (CSR)?",
    "type": "multiple-choice",
    "category": "Rendering Patterns",
    "topic": "Islands Architecture",
    "difficulty": "intermediate",
    "learningCardId": "system-design",
    "isActive": true,
    "createdAt": "2024-01-01T00:00:00.000Z",
    "updatedAt": "2025-11-11T18:59:32.536Z",
    "createdBy": "admin",
    "updatedBy": "admin",
    "tags": [
      "rendering-patterns",
      "islands-architecture",
      "intermediate"
    ],
    "explanation": "CSR loads all JavaScript at once, while Islands only hydrate interactive components",
    "points": 10,
    "options": [
      {
        "id": "a",
        "text": "CSR loads all JavaScript at once, while Islands only hydrate interactive components",
        "isCorrect": true,
        "explanation": ""
      },
      {
        "id": "b",
        "text": "Islands Architecture doesn’t support user interactions",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "c",
        "text": "CSR is faster than Islands because it’s fully client-driven",
        "isCorrect": false,
        "explanation": ""
      }
    ],
    "hints": [
      "Review rendering pattern documentation",
      "Consider server vs client rendering trade-offs",
      "Think about performance and SEO implications"
    ]
  },
  {
    "id": "rendering-patterns-islandarcheticure-3",
    "title": "Performance Benefits",
    "content": "Why does Islands Architecture improve performance?",
    "type": "multiple-choice",
    "category": "Rendering Patterns",
    "topic": "Islands Architecture",
    "difficulty": "intermediate",
    "learningCardId": "system-design",
    "isActive": true,
    "createdAt": "2024-01-01T00:00:00.000Z",
    "updatedAt": "2025-11-11T18:59:32.536Z",
    "createdBy": "admin",
    "updatedBy": "admin",
    "tags": [
      "rendering-patterns",
      "islands-architecture",
      "intermediate"
    ],
    "explanation": "Because it ships less JavaScript and hydrates only necessary interactive components.",
    "points": 10,
    "sampleAnswers": [
      "Because it ships less JavaScript and hydrates only necessary interactive components.",
      "The static HTML renders instantly while islands load independently without blocking the main thread."
    ],
    "options": [
      {
        "id": "o1",
        "text": "Because it ships less JavaScript and hydrates only necessary interactive components.",
        "isCorrect": true,
        "explanation": "Because it ships less JavaScript and hydrates only necessary interactive components."
      },
      {
        "id": "o2",
        "text": "This is not correct. Please refer to the explanation.",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "o3",
        "text": "Incorrect. Review rendering pattern concepts.",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "o4",
        "text": "This is a common misconception. The correct answer is different.",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "o5",
        "text": "Not quite. Consider rendering strategy best practices.",
        "isCorrect": false,
        "explanation": ""
      }
    ],
    "hints": [
      "Review rendering pattern documentation",
      "Consider server vs client rendering trade-offs",
      "Think about performance and SEO implications"
    ]
  },
  {
    "id": "rendering-patterns-islandarcheticure-4",
    "title": "Islands in Practice",
    "content": "Which of the following frameworks is primarily designed around the Islands Architecture concept?",
    "type": "multiple-choice",
    "category": "Rendering Patterns",
    "topic": "Islands Architecture",
    "difficulty": "intermediate",
    "learningCardId": "system-design",
    "isActive": true,
    "createdAt": "2024-01-01T00:00:00.000Z",
    "updatedAt": "2025-11-11T18:59:32.536Z",
    "createdBy": "admin",
    "updatedBy": "admin",
    "tags": [
      "rendering-patterns",
      "islands-architecture",
      "intermediate"
    ],
    "explanation": "Astro",
    "points": 10,
    "options": [
      {
        "id": "a",
        "text": "Next.js",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "b",
        "text": "Astro",
        "isCorrect": true,
        "explanation": ""
      },
      {
        "id": "c",
        "text": "Nuxt.js",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "d",
        "text": "Remix",
        "isCorrect": false,
        "explanation": ""
      }
    ],
    "hints": [
      "Review rendering pattern documentation",
      "Consider server vs client rendering trade-offs",
      "Think about performance and SEO implications"
    ]
  },
  {
    "id": "rendering-patterns-islandarcheticure-5",
    "title": "Hydration Behavior",
    "content": "In Islands Architecture, when are the interactive islands hydrated?",
    "type": "multiple-choice",
    "category": "Rendering Patterns",
    "topic": "Islands Architecture",
    "difficulty": "intermediate",
    "learningCardId": "system-design",
    "isActive": true,
    "createdAt": "2024-01-01T00:00:00.000Z",
    "updatedAt": "2025-11-11T18:59:32.536Z",
    "createdBy": "admin",
    "updatedBy": "admin",
    "tags": [
      "rendering-patterns",
      "islands-architecture",
      "intermediate"
    ],
    "explanation": "After the static HTML has been rendered and the browser is idle",
    "points": 10,
    "options": [
      {
        "id": "a",
        "text": "During the initial HTML parsing",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "b",
        "text": "After the static HTML has been rendered and the browser is idle",
        "isCorrect": true,
        "explanation": ""
      },
      {
        "id": "c",
        "text": "Only after a user clicks a button",
        "isCorrect": false,
        "explanation": ""
      }
    ],
    "hints": [
      "Review rendering pattern documentation",
      "Consider server vs client rendering trade-offs",
      "Think about performance and SEO implications"
    ]
  },
  {
    "id": "rendering-patterns-islandarcheticure-6",
    "title": "Comparing with Progressive Hydration",
    "content": "What’s a key difference between Islands Architecture and Progressive Hydration?",
    "type": "multiple-choice",
    "category": "Rendering Patterns",
    "topic": "Islands Architecture",
    "difficulty": "advanced",
    "learningCardId": "system-design",
    "isActive": true,
    "createdAt": "2024-01-01T00:00:00.000Z",
    "updatedAt": "2025-11-11T18:59:32.536Z",
    "createdBy": "admin",
    "updatedBy": "admin",
    "tags": [
      "rendering-patterns",
      "islands-architecture",
      "advanced"
    ],
    "explanation": "Progressive Hydration hydrates components in sequence across the page, while Islands Architecture hydrates independent islands in isolation.",
    "points": 10,
    "sampleAnswers": [
      "Progressive Hydration hydrates components in sequence across the page, while Islands Architecture hydrates independent islands in isolation.",
      "Islands focus on independence and smaller isolated bundles, while Progressive Hydration still considers the page as one app."
    ],
    "options": [
      {
        "id": "o1",
        "text": "Progressive Hydration hydrates components in sequence across the page, while Islands Architecture hydrates independent islands in isolation.",
        "isCorrect": true,
        "explanation": "Progressive Hydration hydrates components in sequence across the page, while Islands Architecture hydrates independent islands in isolation."
      },
      {
        "id": "o2",
        "text": "This is not correct. Please refer to the explanation.",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "o3",
        "text": "Incorrect. Review rendering pattern concepts.",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "o4",
        "text": "This is a common misconception. The correct answer is different.",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "o5",
        "text": "Not quite. Consider rendering strategy best practices.",
        "isCorrect": false,
        "explanation": ""
      }
    ],
    "hints": [
      "Review rendering pattern documentation",
      "Consider server vs client rendering trade-offs",
      "Think about performance and SEO implications"
    ]
  },
  {
    "id": "rendering-patterns-islandarcheticure-7",
    "title": "Use Case Fit",
    "content": "Which type of application benefits most from Islands Architecture?",
    "type": "multiple-choice",
    "category": "Rendering Patterns",
    "topic": "Islands Architecture",
    "difficulty": "intermediate",
    "learningCardId": "system-design",
    "isActive": true,
    "createdAt": "2024-01-01T00:00:00.000Z",
    "updatedAt": "2025-11-11T18:59:32.536Z",
    "createdBy": "admin",
    "updatedBy": "admin",
    "tags": [
      "rendering-patterns",
      "islands-architecture",
      "intermediate"
    ],
    "explanation": "Content-heavy websites like blogs or marketing pages",
    "points": 10,
    "options": [
      {
        "id": "a",
        "text": "Highly interactive dashboards",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "b",
        "text": "Content-heavy websites like blogs or marketing pages",
        "isCorrect": true,
        "explanation": ""
      },
      {
        "id": "c",
        "text": "Real-time gaming apps",
        "isCorrect": false,
        "explanation": ""
      }
    ],
    "hints": [
      "Review rendering pattern documentation",
      "Consider server vs client rendering trade-offs",
      "Think about performance and SEO implications"
    ]
  },
  {
    "id": "rendering-patterns-islandarcheticure-8",
    "title": "Tradeoffs",
    "content": "What’s one major drawback of adopting Islands Architecture today?",
    "type": "multiple-choice",
    "category": "Rendering Patterns",
    "topic": "Islands Architecture",
    "difficulty": "intermediate",
    "learningCardId": "system-design",
    "isActive": true,
    "createdAt": "2024-01-01T00:00:00.000Z",
    "updatedAt": "2025-11-11T18:59:32.536Z",
    "createdBy": "admin",
    "updatedBy": "admin",
    "tags": [
      "rendering-patterns",
      "islands-architecture",
      "intermediate"
    ],
    "explanation": "Limited framework support outside of Astro and Marko.",
    "points": 10,
    "sampleAnswers": [
      "Limited framework support outside of Astro and Marko.",
      "Migration from traditional CSR or SSR frameworks can be complex."
    ],
    "options": [
      {
        "id": "o1",
        "text": "Limited framework support outside of Astro and Marko.",
        "isCorrect": true,
        "explanation": "Limited framework support outside of Astro and Marko."
      },
      {
        "id": "o2",
        "text": "This is not correct. Please refer to the explanation.",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "o3",
        "text": "Incorrect. Review rendering pattern concepts.",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "o4",
        "text": "This is a common misconception. The correct answer is different.",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "o5",
        "text": "Not quite. Consider rendering strategy best practices.",
        "isCorrect": false,
        "explanation": ""
      }
    ],
    "hints": [
      "Review rendering pattern documentation",
      "Consider server vs client rendering trade-offs",
      "Think about performance and SEO implications"
    ]
  },
  {
    "id": "rendering-patterns-islandarcheticure-9",
    "title": "SEO Advantage",
    "content": "Why is Islands Architecture more SEO-friendly compared to Client-Side Rendering?",
    "type": "multiple-choice",
    "category": "Rendering Patterns",
    "topic": "Islands Architecture",
    "difficulty": "intermediate",
    "learningCardId": "system-design",
    "isActive": true,
    "createdAt": "2024-01-01T00:00:00.000Z",
    "updatedAt": "2025-11-11T18:59:32.536Z",
    "createdBy": "admin",
    "updatedBy": "admin",
    "tags": [
      "rendering-patterns",
      "islands-architecture",
      "intermediate"
    ],
    "explanation": "It serves fully rendered HTML to crawlers before hydration",
    "points": 10,
    "options": [
      {
        "id": "a",
        "text": "It serves fully rendered HTML to crawlers before hydration",
        "isCorrect": true,
        "explanation": ""
      },
      {
        "id": "b",
        "text": "It delays rendering until user interaction",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "c",
        "text": "It hides interactive components from crawlers",
        "isCorrect": false,
        "explanation": ""
      }
    ],
    "hints": [
      "Review rendering pattern documentation",
      "Consider server vs client rendering trade-offs",
      "Think about performance and SEO implications"
    ]
  },
  {
    "id": "rendering-patterns-islandarcheticure-10",
    "title": "Implementation Example",
    "content": "In an Astro project, how could you create a 'Like' button as an island on a static blog page?",
    "type": "multiple-choice",
    "category": "Rendering Patterns",
    "topic": "Islands Architecture",
    "difficulty": "advanced",
    "learningCardId": "system-design",
    "isActive": true,
    "createdAt": "2024-01-01T00:00:00.000Z",
    "updatedAt": "2025-11-11T18:59:32.536Z",
    "createdBy": "admin",
    "updatedBy": "admin",
    "tags": [
      "rendering-patterns",
      "islands-architecture",
      "advanced"
    ],
    "explanation": "By creating a separate React component for the Like button and importing it using Astro’s client directive like <code>client:load</code> or <code>client:idle</code>.",
    "points": 10,
    "sampleAnswers": [
      "By creating a separate React component for the Like button and importing it using Astro’s client directive like `client:load` or `client:idle`.",
      "This ensures the rest of the page remains static while only the Like button’s script is loaded and hydrated on demand."
    ],
    "options": [
      {
        "id": "o1",
        "text": "By creating a separate React component for the Like button and importing it using Astro’s client directive like `client:load` or `client:idle`.",
        "isCorrect": true,
        "explanation": "By creating a separate React component for the Like button and importing it using Astro’s client directive like <code>client:load</code> or <code>client:idle</code>."
      },
      {
        "id": "o2",
        "text": "This is not correct. Please refer to the explanation.",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "o3",
        "text": "Incorrect. Review rendering pattern concepts.",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "o4",
        "text": "This is a common misconception. The correct answer is different.",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "o5",
        "text": "Not quite. Consider rendering strategy best practices.",
        "isCorrect": false,
        "explanation": ""
      }
    ],
    "hints": [
      "Review rendering pattern documentation",
      "Consider server vs client rendering trade-offs",
      "Think about performance and SEO implications"
    ]
  },
  {
    "id": "rendering-patterns-render7-1",
    "title": "Partial Hydration Concept",
    "content": "What is Partial Hydration and when is it beneficial?",
    "type": "multiple-choice",
    "category": "Rendering Patterns",
    "topic": "Progressive Hydration",
    "difficulty": "advanced",
    "learningCardId": "system-design",
    "isActive": true,
    "createdAt": "2024-01-01T00:00:00.000Z",
    "updatedAt": "2025-11-11T18:59:32.538Z",
    "createdBy": "admin",
    "updatedBy": "admin",
    "tags": [
      "rendering-patterns",
      "progressive-hydration",
      "advanced"
    ],
    "explanation": "Partial Hydration means hydrating only parts of a statically rendered page that require interactivity.",
    "points": 10,
    "sampleAnswers": [
      "Partial Hydration means hydrating only parts of a statically rendered page that require interactivity.",
      "It is beneficial for pages with mostly static content and a few interactive widgets."
    ],
    "options": [
      {
        "id": "o1",
        "text": "Partial Hydration means hydrating only parts of a statically rendered page that require interactivity.",
        "isCorrect": true,
        "explanation": "Partial Hydration means hydrating only parts of a statically rendered page that require interactivity."
      },
      {
        "id": "o2",
        "text": "This is not correct. Please refer to the explanation.",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "o3",
        "text": "Incorrect. Review rendering pattern concepts.",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "o4",
        "text": "This is a common misconception. The correct answer is different.",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "o5",
        "text": "Not quite. Consider rendering strategy best practices.",
        "isCorrect": false,
        "explanation": ""
      }
    ],
    "hints": [
      "Review rendering pattern documentation",
      "Consider server vs client rendering trade-offs",
      "Think about performance and SEO implications"
    ]
  },
  {
    "id": "rendering-patterns-render7-2",
    "title": "Partial vs Progressive Hydration",
    "content": "How is Partial Hydration different from Progressive Hydration?",
    "type": "multiple-choice",
    "category": "Rendering Patterns",
    "topic": "Progressive Hydration",
    "difficulty": "advanced",
    "learningCardId": "system-design",
    "isActive": true,
    "createdAt": "2024-01-01T00:00:00.000Z",
    "updatedAt": "2025-11-11T18:59:32.538Z",
    "createdBy": "admin",
    "updatedBy": "admin",
    "tags": [
      "rendering-patterns",
      "progressive-hydration",
      "advanced"
    ],
    "explanation": "Partial Hydration only hydrates selected components, Progressive Hydration hydrates sequentially over time",
    "points": 10,
    "options": [
      {
        "id": "a",
        "text": "Partial Hydration only hydrates selected components, Progressive Hydration hydrates sequentially over time",
        "isCorrect": true,
        "explanation": ""
      },
      {
        "id": "b",
        "text": "They are identical processes",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "c",
        "text": "Partial Hydration works only on client-side rendering",
        "isCorrect": false,
        "explanation": ""
      }
    ],
    "hints": [
      "Review rendering pattern documentation",
      "Consider server vs client rendering trade-offs",
      "Think about performance and SEO implications"
    ]
  },
  {
    "id": "rendering-patterns-render7-3",
    "title": "Selective Prefetching",
    "content": "What is Selective Prefetching and why is it important?",
    "type": "multiple-choice",
    "category": "Rendering Patterns",
    "topic": "Progressive Hydration",
    "difficulty": "intermediate",
    "learningCardId": "system-design",
    "isActive": true,
    "createdAt": "2024-01-01T00:00:00.000Z",
    "updatedAt": "2025-11-11T18:59:32.538Z",
    "createdBy": "admin",
    "updatedBy": "admin",
    "tags": [
      "rendering-patterns",
      "progressive-hydration",
      "intermediate"
    ],
    "explanation": "Selective Prefetching fetches data or resources only for components likely to be used soon, based on user behavior.",
    "points": 10,
    "sampleAnswers": [
      "Selective Prefetching fetches data or resources only for components likely to be used soon, based on user behavior.",
      "It prevents bandwidth waste and improves perceived performance on slow networks."
    ],
    "options": [
      {
        "id": "o1",
        "text": "Selective Prefetching fetches data or resources only for components likely to be used soon, based on user behavior.",
        "isCorrect": true,
        "explanation": "Selective Prefetching fetches data or resources only for components likely to be used soon, based on user behavior."
      },
      {
        "id": "o2",
        "text": "This is not correct. Please refer to the explanation.",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "o3",
        "text": "Incorrect. Review rendering pattern concepts.",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "o4",
        "text": "This is a common misconception. The correct answer is different.",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "o5",
        "text": "Not quite. Consider rendering strategy best practices.",
        "isCorrect": false,
        "explanation": ""
      }
    ],
    "hints": [
      "Review rendering pattern documentation",
      "Consider server vs client rendering trade-offs",
      "Think about performance and SEO implications"
    ]
  },
  {
    "id": "rendering-patterns-render7-4",
    "title": "When to Use Selective Prefetching",
    "content": "In what scenario is Selective Prefetching most effective?",
    "type": "multiple-choice",
    "category": "Rendering Patterns",
    "topic": "Progressive Hydration",
    "difficulty": "intermediate",
    "learningCardId": "system-design",
    "isActive": true,
    "createdAt": "2024-01-01T00:00:00.000Z",
    "updatedAt": "2025-11-11T18:59:32.538Z",
    "createdBy": "admin",
    "updatedBy": "admin",
    "tags": [
      "rendering-patterns",
      "progressive-hydration",
      "intermediate"
    ],
    "explanation": "On pages with many navigation routes where user intent can be predicted",
    "points": 10,
    "options": [
      {
        "id": "a",
        "text": "On pages with many navigation routes where user intent can be predicted",
        "isCorrect": true,
        "explanation": ""
      },
      {
        "id": "b",
        "text": "On static single-page apps with no dynamic routing",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "c",
        "text": "When caching is disabled entirely",
        "isCorrect": false,
        "explanation": ""
      }
    ],
    "hints": [
      "Review rendering pattern documentation",
      "Consider server vs client rendering trade-offs",
      "Think about performance and SEO implications"
    ]
  },
  {
    "id": "rendering-patterns-render7-5",
    "title": "Lazy Streaming Rendering",
    "content": "What is Lazy Streaming Rendering and how does it differ from normal streaming?",
    "type": "multiple-choice",
    "category": "Rendering Patterns",
    "topic": "Progressive Hydration",
    "difficulty": "advanced",
    "learningCardId": "system-design",
    "isActive": true,
    "createdAt": "2024-01-01T00:00:00.000Z",
    "updatedAt": "2025-11-11T18:59:32.538Z",
    "createdBy": "admin",
    "updatedBy": "admin",
    "tags": [
      "rendering-patterns",
      "progressive-hydration",
      "advanced"
    ],
    "explanation": "Lazy Streaming defers rendering of non-critical content until it’s needed, reducing initial TTFB.",
    "points": 10,
    "sampleAnswers": [
      "Lazy Streaming defers rendering of non-critical content until it’s needed, reducing initial TTFB.",
      "Unlike standard streaming, it doesn’t stream everything immediately—it prioritizes essential chunks."
    ],
    "options": [
      {
        "id": "o1",
        "text": "Lazy Streaming defers rendering of non-critical content until it’s needed, reducing initial TTFB.",
        "isCorrect": true,
        "explanation": "Lazy Streaming defers rendering of non-critical content until it’s needed, reducing initial TTFB."
      },
      {
        "id": "o2",
        "text": "This is not correct. Please refer to the explanation.",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "o3",
        "text": "Incorrect. Review rendering pattern concepts.",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "o4",
        "text": "This is a common misconception. The correct answer is different.",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "o5",
        "text": "Not quite. Consider rendering strategy best practices.",
        "isCorrect": false,
        "explanation": ""
      }
    ],
    "hints": [
      "Review rendering pattern documentation",
      "Consider server vs client rendering trade-offs",
      "Think about performance and SEO implications"
    ]
  },
  {
    "id": "rendering-patterns-render7-6",
    "title": "React Suspense for Data Fetching",
    "content": "What role does React Suspense play in rendering optimization?",
    "type": "multiple-choice",
    "category": "Rendering Patterns",
    "topic": "Progressive Hydration",
    "difficulty": "advanced",
    "learningCardId": "system-design",
    "isActive": true,
    "createdAt": "2024-01-01T00:00:00.000Z",
    "updatedAt": "2025-11-11T18:59:32.538Z",
    "createdBy": "admin",
    "updatedBy": "admin",
    "tags": [
      "rendering-patterns",
      "progressive-hydration",
      "advanced"
    ],
    "explanation": "It allows components to wait for data before rendering while showing fallback UI",
    "points": 10,
    "options": [
      {
        "id": "a",
        "text": "It allows components to wait for data before rendering while showing fallback UI",
        "isCorrect": true,
        "explanation": ""
      },
      {
        "id": "b",
        "text": "It blocks all rendering until the entire app loads",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "c",
        "text": "It only works for routing, not data fetching",
        "isCorrect": false,
        "explanation": ""
      }
    ],
    "hints": [
      "Review rendering pattern documentation",
      "Consider server vs client rendering trade-offs",
      "Think about performance and SEO implications"
    ]
  },
  {
    "id": "rendering-patterns-render7-7",
    "title": "Concurrent Rendering Advantage",
    "content": "How does React 18's concurrent rendering improve user experience?",
    "type": "multiple-choice",
    "category": "Rendering Patterns",
    "topic": "Progressive Hydration",
    "difficulty": "advanced",
    "learningCardId": "system-design",
    "isActive": true,
    "createdAt": "2024-01-01T00:00:00.000Z",
    "updatedAt": "2025-11-11T18:59:32.538Z",
    "createdBy": "admin",
    "updatedBy": "admin",
    "tags": [
      "rendering-patterns",
      "progressive-hydration",
      "advanced"
    ],
    "explanation": "Concurrent Rendering enables React to interrupt non-urgent renders to prioritize important updates, improving responsiveness.",
    "points": 10,
    "sampleAnswers": [
      "Concurrent Rendering enables React to interrupt non-urgent renders to prioritize important updates, improving responsiveness.",
      "It helps avoid UI freezes during heavy computation or re-renders."
    ],
    "options": [
      {
        "id": "o1",
        "text": "Concurrent Rendering enables React to interrupt non-urgent renders to prioritize important updates, improving responsiveness.",
        "isCorrect": true,
        "explanation": "Concurrent Rendering enables React to interrupt non-urgent renders to prioritize important updates, improving responsiveness."
      },
      {
        "id": "o2",
        "text": "This is not correct. Please refer to the explanation.",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "o3",
        "text": "Incorrect. Review rendering pattern concepts.",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "o4",
        "text": "This is a common misconception. The correct answer is different.",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "o5",
        "text": "Not quite. Consider rendering strategy best practices.",
        "isCorrect": false,
        "explanation": ""
      }
    ],
    "hints": [
      "Review rendering pattern documentation",
      "Consider server vs client rendering trade-offs",
      "Think about performance and SEO implications"
    ]
  },
  {
    "id": "rendering-patterns-render7-8",
    "title": "Concurrent vs Synchronous Rendering",
    "content": "What is the difference between concurrent and synchronous rendering in React?",
    "type": "multiple-choice",
    "category": "Rendering Patterns",
    "topic": "Progressive Hydration",
    "difficulty": "intermediate",
    "learningCardId": "system-design",
    "isActive": true,
    "createdAt": "2024-01-01T00:00:00.000Z",
    "updatedAt": "2025-11-11T18:59:32.538Z",
    "createdBy": "admin",
    "updatedBy": "admin",
    "tags": [
      "rendering-patterns",
      "progressive-hydration",
      "intermediate"
    ],
    "explanation": "Concurrent rendering can pause and resume renders, synchronous rendering blocks until completion",
    "points": 10,
    "options": [
      {
        "id": "a",
        "text": "Concurrent rendering can pause and resume renders, synchronous rendering blocks until completion",
        "isCorrect": true,
        "explanation": ""
      },
      {
        "id": "b",
        "text": "Concurrent rendering executes faster JavaScript",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "c",
        "text": "Synchronous rendering can handle multiple threads",
        "isCorrect": false,
        "explanation": ""
      }
    ],
    "hints": [
      "Review rendering pattern documentation",
      "Consider server vs client rendering trade-offs",
      "Think about performance and SEO implications"
    ]
  },
  {
    "id": "rendering-patterns-render7-9",
    "title": "Idle Time Rendering",
    "content": "What is Idle Time Rendering and how does it optimize performance?",
    "type": "multiple-choice",
    "category": "Rendering Patterns",
    "topic": "Progressive Hydration",
    "difficulty": "intermediate",
    "learningCardId": "system-design",
    "isActive": true,
    "createdAt": "2024-01-01T00:00:00.000Z",
    "updatedAt": "2025-11-11T18:59:32.538Z",
    "createdBy": "admin",
    "updatedBy": "admin",
    "tags": [
      "rendering-patterns",
      "progressive-hydration",
      "intermediate"
    ],
    "explanation": "Idle Time Rendering defers rendering of non-critical UI parts until the main thread is idle.",
    "points": 10,
    "sampleAnswers": [
      "Idle Time Rendering defers rendering of non-critical UI parts until the main thread is idle.",
      "It uses browser APIs like requestIdleCallback to improve smoothness."
    ],
    "options": [
      {
        "id": "o1",
        "text": "Idle Time Rendering defers rendering of non-critical UI parts until the main thread is idle.",
        "isCorrect": true,
        "explanation": "Idle Time Rendering defers rendering of non-critical UI parts until the main thread is idle."
      },
      {
        "id": "o2",
        "text": "This is not correct. Please refer to the explanation.",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "o3",
        "text": "Incorrect. Review rendering pattern concepts.",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "o4",
        "text": "This is a common misconception. The correct answer is different.",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "o5",
        "text": "Not quite. Consider rendering strategy best practices.",
        "isCorrect": false,
        "explanation": ""
      }
    ],
    "hints": [
      "Review rendering pattern documentation",
      "Consider server vs client rendering trade-offs",
      "Think about performance and SEO implications"
    ]
  },
  {
    "id": "rendering-patterns-render7-10",
    "title": "Pre-rendering Optimization Tradeoffs",
    "content": "What trade-offs do pre-rendering optimizations (like ISR or static generation) have?",
    "type": "multiple-choice",
    "category": "Rendering Patterns",
    "topic": "Progressive Hydration",
    "difficulty": "advanced",
    "learningCardId": "system-design",
    "isActive": true,
    "createdAt": "2024-01-01T00:00:00.000Z",
    "updatedAt": "2025-11-11T18:59:32.538Z",
    "createdBy": "admin",
    "updatedBy": "admin",
    "tags": [
      "rendering-patterns",
      "progressive-hydration",
      "advanced"
    ],
    "explanation": "They improve initial load but can serve outdated content until revalidated",
    "points": 10,
    "options": [
      {
        "id": "a",
        "text": "They improve initial load but can serve outdated content until revalidated",
        "isCorrect": true,
        "explanation": ""
      },
      {
        "id": "b",
        "text": "They slow down page loads by increasing bundle size",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "c",
        "text": "They disable interactivity on the client",
        "isCorrect": false,
        "explanation": ""
      }
    ],
    "hints": [
      "Review rendering pattern documentation",
      "Consider server vs client rendering trade-offs",
      "Think about performance and SEO implications"
    ]
  },
  {
    "id": "rendering-patterns-rendering9-1",
    "title": "Core Web Vitals Overview",
    "content": "What are Core Web Vitals, and why are they important in rendering performance?",
    "type": "multiple-choice",
    "category": "Rendering Patterns",
    "topic": "Resumability",
    "difficulty": "intermediate",
    "learningCardId": "system-design",
    "isActive": true,
    "createdAt": "2024-01-01T00:00:00.000Z",
    "updatedAt": "2025-11-11T18:59:32.541Z",
    "createdBy": "admin",
    "updatedBy": "admin",
    "tags": [
      "rendering-patterns",
      "resumability",
      "intermediate"
    ],
    "explanation": "Core Web Vitals are a set of metrics—Largest Contentful Paint (LCP), First Input Delay (FID), and Cumulative Layout Shift (CLS)—that measure real-world user experience.",
    "points": 10,
    "sampleAnswers": [
      "Core Web Vitals are a set of metrics—Largest Contentful Paint (LCP), First Input Delay (FID), and Cumulative Layout Shift (CLS)—that measure real-world user experience.",
      "They help evaluate visual stability, interactivity, and loading performance."
    ],
    "options": [
      {
        "id": "o1",
        "text": "Core Web Vitals are a set of metrics—Largest Contentful Paint (LCP), First Input Delay (FID), and Cumulative Layout Shift (CLS)—that measure real-world user experience.",
        "isCorrect": true,
        "explanation": "Core Web Vitals are a set of metrics—Largest Contentful Paint (LCP), First Input Delay (FID), and Cumulative Layout Shift (CLS)—that measure real-world user experience."
      },
      {
        "id": "o2",
        "text": "This is not correct. Please refer to the explanation.",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "o3",
        "text": "Incorrect. Review rendering pattern concepts.",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "o4",
        "text": "This is a common misconception. The correct answer is different.",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "o5",
        "text": "Not quite. Consider rendering strategy best practices.",
        "isCorrect": false,
        "explanation": ""
      }
    ],
    "hints": [
      "Review rendering pattern documentation",
      "Consider server vs client rendering trade-offs",
      "Think about performance and SEO implications"
    ]
  },
  {
    "id": "rendering-patterns-rendering9-2",
    "title": "Largest Contentful Paint (LCP)",
    "content": "What does the Largest Contentful Paint (LCP) metric measure?",
    "type": "multiple-choice",
    "category": "Rendering Patterns",
    "topic": "Resumability",
    "difficulty": "intermediate",
    "learningCardId": "system-design",
    "isActive": true,
    "createdAt": "2024-01-01T00:00:00.000Z",
    "updatedAt": "2025-11-11T18:59:32.541Z",
    "createdBy": "admin",
    "updatedBy": "admin",
    "tags": [
      "rendering-patterns",
      "resumability",
      "intermediate"
    ],
    "explanation": "Time until the largest visible element (image or text block) renders",
    "points": 10,
    "options": [
      {
        "id": "a",
        "text": "Time until the largest visible element (image or text block) renders",
        "isCorrect": true,
        "explanation": ""
      },
      {
        "id": "b",
        "text": "Total load time of all resources",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "c",
        "text": "Delay before the first user input is processed",
        "isCorrect": false,
        "explanation": ""
      }
    ],
    "hints": [
      "Review rendering pattern documentation",
      "Consider server vs client rendering trade-offs",
      "Think about performance and SEO implications"
    ]
  },
  {
    "id": "rendering-patterns-rendering9-3",
    "title": "First Input Delay (FID)",
    "content": "What does the First Input Delay (FID) metric represent?",
    "type": "multiple-choice",
    "category": "Rendering Patterns",
    "topic": "Resumability",
    "difficulty": "intermediate",
    "learningCardId": "system-design",
    "isActive": true,
    "createdAt": "2024-01-01T00:00:00.000Z",
    "updatedAt": "2025-11-11T18:59:32.541Z",
    "createdBy": "admin",
    "updatedBy": "admin",
    "tags": [
      "rendering-patterns",
      "resumability",
      "intermediate"
    ],
    "explanation": "FID measures the delay between a user’s first interaction (e.g., clicking a button) and the browser’s ability to respond to that interaction.",
    "points": 10,
    "sampleAnswers": [
      "FID measures the delay between a user’s first interaction (e.g., clicking a button) and the browser’s ability to respond to that interaction.",
      "It helps quantify responsiveness."
    ],
    "options": [
      {
        "id": "o1",
        "text": "FID measures the delay between a user’s first interaction (e.g., clicking a button) and the browser’s ability to respond to that interaction.",
        "isCorrect": true,
        "explanation": "FID measures the delay between a user’s first interaction (e.g., clicking a button) and the browser’s ability to respond to that interaction."
      },
      {
        "id": "o2",
        "text": "This is not correct. Please refer to the explanation.",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "o3",
        "text": "Incorrect. Review rendering pattern concepts.",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "o4",
        "text": "This is a common misconception. The correct answer is different.",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "o5",
        "text": "Not quite. Consider rendering strategy best practices.",
        "isCorrect": false,
        "explanation": ""
      }
    ],
    "hints": [
      "Review rendering pattern documentation",
      "Consider server vs client rendering trade-offs",
      "Think about performance and SEO implications"
    ]
  },
  {
    "id": "rendering-patterns-rendering9-4",
    "title": "Cumulative Layout Shift (CLS)",
    "content": "Which user experience issue does Cumulative Layout Shift (CLS) help detect?",
    "type": "multiple-choice",
    "category": "Rendering Patterns",
    "topic": "Resumability",
    "difficulty": "intermediate",
    "learningCardId": "system-design",
    "isActive": true,
    "createdAt": "2024-01-01T00:00:00.000Z",
    "updatedAt": "2025-11-11T18:59:32.541Z",
    "createdBy": "admin",
    "updatedBy": "admin",
    "tags": [
      "rendering-patterns",
      "resumability",
      "intermediate"
    ],
    "explanation": "Visual instability caused by unexpected layout movements",
    "points": 10,
    "options": [
      {
        "id": "a",
        "text": "Visual instability caused by unexpected layout movements",
        "isCorrect": true,
        "explanation": ""
      },
      {
        "id": "b",
        "text": "Slow data fetching",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "c",
        "text": "JavaScript bundle size issues",
        "isCorrect": false,
        "explanation": ""
      }
    ],
    "hints": [
      "Review rendering pattern documentation",
      "Consider server vs client rendering trade-offs",
      "Think about performance and SEO implications"
    ]
  },
  {
    "id": "rendering-patterns-rendering9-5",
    "title": "First Contentful Paint (FCP)",
    "content": "What is the difference between FCP and LCP?",
    "type": "multiple-choice",
    "category": "Rendering Patterns",
    "topic": "Resumability",
    "difficulty": "intermediate",
    "learningCardId": "system-design",
    "isActive": true,
    "createdAt": "2024-01-01T00:00:00.000Z",
    "updatedAt": "2025-11-11T18:59:32.541Z",
    "createdBy": "admin",
    "updatedBy": "admin",
    "tags": [
      "rendering-patterns",
      "resumability",
      "intermediate"
    ],
    "explanation": "FCP measures when the browser first renders any content from the DOM.",
    "points": 10,
    "sampleAnswers": [
      "FCP measures when the browser first renders any content from the DOM.",
      "LCP measures when the largest visible content element has been rendered."
    ],
    "options": [
      {
        "id": "o1",
        "text": "FCP measures when the browser first renders any content from the DOM.",
        "isCorrect": true,
        "explanation": "FCP measures when the browser first renders any content from the DOM."
      },
      {
        "id": "o2",
        "text": "This is not correct. Please refer to the explanation.",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "o3",
        "text": "Incorrect. Review rendering pattern concepts.",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "o4",
        "text": "This is a common misconception. The correct answer is different.",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "o5",
        "text": "Not quite. Consider rendering strategy best practices.",
        "isCorrect": false,
        "explanation": ""
      }
    ],
    "hints": [
      "Review rendering pattern documentation",
      "Consider server vs client rendering trade-offs",
      "Think about performance and SEO implications"
    ]
  },
  {
    "id": "rendering-patterns-rendering9-6",
    "title": "TTFB in Rendering",
    "content": "How does Time To First Byte (TTFB) affect perceived performance in SSR apps?",
    "type": "multiple-choice",
    "category": "Rendering Patterns",
    "topic": "Resumability",
    "difficulty": "intermediate",
    "learningCardId": "system-design",
    "isActive": true,
    "createdAt": "2024-01-01T00:00:00.000Z",
    "updatedAt": "2025-11-11T18:59:32.541Z",
    "createdBy": "admin",
    "updatedBy": "admin",
    "tags": [
      "rendering-patterns",
      "resumability",
      "intermediate"
    ],
    "explanation": "TTFB represents the time it takes for the server to start sending a response.",
    "points": 10,
    "sampleAnswers": [
      "TTFB represents the time it takes for the server to start sending a response.",
      "A higher TTFB delays all other metrics, including FCP and LCP, especially in SSR apps."
    ],
    "options": [
      {
        "id": "o1",
        "text": "TTFB represents the time it takes for the server to start sending a response.",
        "isCorrect": true,
        "explanation": "TTFB represents the time it takes for the server to start sending a response."
      },
      {
        "id": "o2",
        "text": "This is not correct. Please refer to the explanation.",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "o3",
        "text": "Incorrect. Review rendering pattern concepts.",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "o4",
        "text": "This is a common misconception. The correct answer is different.",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "o5",
        "text": "Not quite. Consider rendering strategy best practices.",
        "isCorrect": false,
        "explanation": ""
      }
    ],
    "hints": [
      "Review rendering pattern documentation",
      "Consider server vs client rendering trade-offs",
      "Think about performance and SEO implications"
    ]
  },
  {
    "id": "rendering-patterns-rendering9-7",
    "title": "Real User Monitoring (RUM)",
    "content": "What is Real User Monitoring and how does it differ from synthetic testing?",
    "type": "multiple-choice",
    "category": "Rendering Patterns",
    "topic": "Resumability",
    "difficulty": "advanced",
    "learningCardId": "system-design",
    "isActive": true,
    "createdAt": "2024-01-01T00:00:00.000Z",
    "updatedAt": "2025-11-11T18:59:32.541Z",
    "createdBy": "admin",
    "updatedBy": "admin",
    "tags": [
      "rendering-patterns",
      "resumability",
      "advanced"
    ],
    "explanation": "RUM collects performance data from actual users in the wild, giving real-world insights.",
    "points": 10,
    "sampleAnswers": [
      "RUM collects performance data from actual users in the wild, giving real-world insights.",
      "Synthetic testing simulates performance in controlled environments, not actual usage."
    ],
    "options": [
      {
        "id": "o1",
        "text": "RUM collects performance data from actual users in the wild, giving real-world insights.",
        "isCorrect": true,
        "explanation": "RUM collects performance data from actual users in the wild, giving real-world insights."
      },
      {
        "id": "o2",
        "text": "This is not correct. Please refer to the explanation.",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "o3",
        "text": "Incorrect. Review rendering pattern concepts.",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "o4",
        "text": "This is a common misconception. The correct answer is different.",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "o5",
        "text": "Not quite. Consider rendering strategy best practices.",
        "isCorrect": false,
        "explanation": ""
      }
    ],
    "hints": [
      "Review rendering pattern documentation",
      "Consider server vs client rendering trade-offs",
      "Think about performance and SEO implications"
    ]
  },
  {
    "id": "rendering-patterns-rendering9-8",
    "title": "Performance Budgets",
    "content": "How do performance budgets help teams maintain rendering performance?",
    "type": "multiple-choice",
    "category": "Rendering Patterns",
    "topic": "Resumability",
    "difficulty": "intermediate",
    "learningCardId": "system-design",
    "isActive": true,
    "createdAt": "2024-01-01T00:00:00.000Z",
    "updatedAt": "2025-11-11T18:59:32.541Z",
    "createdBy": "admin",
    "updatedBy": "admin",
    "tags": [
      "rendering-patterns",
      "resumability",
      "intermediate"
    ],
    "explanation": "They define quantitative limits (like max JS size or LCP time) to prevent regressions",
    "points": 10,
    "options": [
      {
        "id": "a",
        "text": "They define quantitative limits (like max JS size or LCP time) to prevent regressions",
        "isCorrect": true,
        "explanation": ""
      },
      {
        "id": "b",
        "text": "They automatically compress code bundles",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "c",
        "text": "They control the rendering order of components",
        "isCorrect": false,
        "explanation": ""
      }
    ],
    "hints": [
      "Review rendering pattern documentation",
      "Consider server vs client rendering trade-offs",
      "Think about performance and SEO implications"
    ]
  },
  {
    "id": "rendering-patterns-rendering9-9",
    "title": "Hydration and Performance Monitoring",
    "content": "Which metric is most affected by slow hydration in client-side rendered apps?",
    "type": "multiple-choice",
    "category": "Rendering Patterns",
    "topic": "Resumability",
    "difficulty": "advanced",
    "learningCardId": "system-design",
    "isActive": true,
    "createdAt": "2024-01-01T00:00:00.000Z",
    "updatedAt": "2025-11-11T18:59:32.541Z",
    "createdBy": "admin",
    "updatedBy": "admin",
    "tags": [
      "rendering-patterns",
      "resumability",
      "advanced"
    ],
    "explanation": "First Input Delay (FID)",
    "points": 10,
    "options": [
      {
        "id": "a",
        "text": "First Input Delay (FID)",
        "isCorrect": true,
        "explanation": ""
      },
      {
        "id": "b",
        "text": "Cumulative Layout Shift (CLS)",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "c",
        "text": "Time To First Byte (TTFB)",
        "isCorrect": false,
        "explanation": ""
      }
    ],
    "hints": [
      "Review rendering pattern documentation",
      "Consider server vs client rendering trade-offs",
      "Think about performance and SEO implications"
    ]
  },
  {
    "id": "rendering-patterns-rendering9-10",
    "title": "Monitoring Rendering in CI/CD",
    "content": "How can rendering performance be monitored in CI/CD pipelines?",
    "type": "multiple-choice",
    "category": "Rendering Patterns",
    "topic": "Resumability",
    "difficulty": "advanced",
    "learningCardId": "system-design",
    "isActive": true,
    "createdAt": "2024-01-01T00:00:00.000Z",
    "updatedAt": "2025-11-11T18:59:32.541Z",
    "createdBy": "admin",
    "updatedBy": "admin",
    "tags": [
      "rendering-patterns",
      "resumability",
      "advanced"
    ],
    "explanation": "Integrate Lighthouse CI or WebPageTest in the pipeline to measure metrics like LCP and CLS on each deployment.",
    "points": 10,
    "sampleAnswers": [
      "Integrate Lighthouse CI or WebPageTest in the pipeline to measure metrics like LCP and CLS on each deployment.",
      "Set performance budgets that fail builds when metrics exceed thresholds."
    ],
    "options": [
      {
        "id": "o1",
        "text": "Integrate Lighthouse CI or WebPageTest in the pipeline to measure metrics like LCP and CLS on each deployment.",
        "isCorrect": true,
        "explanation": "Integrate Lighthouse CI or WebPageTest in the pipeline to measure metrics like LCP and CLS on each deployment."
      },
      {
        "id": "o2",
        "text": "This is not correct. Please refer to the explanation.",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "o3",
        "text": "Incorrect. Review rendering pattern concepts.",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "o4",
        "text": "This is a common misconception. The correct answer is different.",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "o5",
        "text": "Not quite. Consider rendering strategy best practices.",
        "isCorrect": false,
        "explanation": ""
      }
    ],
    "hints": [
      "Review rendering pattern documentation",
      "Consider server vs client rendering trade-offs",
      "Think about performance and SEO implications"
    ]
  },
  {
    "id": "rendering-patterns-rendering2-1",
    "title": "Understanding Server-Side Rendering (SSR)",
    "content": "What happens during the Server-Side Rendering (SSR) process in frameworks like Next.js?",
    "type": "multiple-choice",
    "category": "Rendering Patterns",
    "topic": "Server-Side Rendering",
    "difficulty": "intermediate",
    "learningCardId": "system-design",
    "isActive": true,
    "createdAt": "2024-01-01T00:00:00.000Z",
    "updatedAt": "2025-11-11T18:59:32.539Z",
    "createdBy": "admin",
    "updatedBy": "admin",
    "tags": [
      "rendering-patterns",
      "server-side-rendering",
      "intermediate"
    ],
    "explanation": "The server executes React components to generate HTML on each request and sends it to the client.",
    "points": 10,
    "sampleAnswers": [
      "The server executes React components to generate HTML on each request and sends it to the client.",
      "The client then hydrates the HTML to make it interactive."
    ],
    "options": [
      {
        "id": "o1",
        "text": "The server executes React components to generate HTML on each request and sends it to the client.",
        "isCorrect": true,
        "explanation": "The server executes React components to generate HTML on each request and sends it to the client."
      },
      {
        "id": "o2",
        "text": "This is not correct. Please refer to the explanation.",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "o3",
        "text": "Incorrect. Review rendering pattern concepts.",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "o4",
        "text": "This is a common misconception. The correct answer is different.",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "o5",
        "text": "Not quite. Consider rendering strategy best practices.",
        "isCorrect": false,
        "explanation": ""
      }
    ],
    "hints": [
      "Review rendering pattern documentation",
      "Consider server vs client rendering trade-offs",
      "Think about performance and SEO implications"
    ]
  },
  {
    "id": "rendering-patterns-rendering2-2",
    "title": "SSR Performance Trade-off",
    "content": "What is the main trade-off when using Server-Side Rendering?",
    "type": "multiple-choice",
    "category": "Rendering Patterns",
    "topic": "Server-Side Rendering",
    "difficulty": "intermediate",
    "learningCardId": "system-design",
    "isActive": true,
    "createdAt": "2024-01-01T00:00:00.000Z",
    "updatedAt": "2025-11-11T18:59:32.539Z",
    "createdBy": "admin",
    "updatedBy": "admin",
    "tags": [
      "rendering-patterns",
      "server-side-rendering",
      "intermediate"
    ],
    "explanation": "Higher server load and slower TTFB compared to static rendering",
    "points": 10,
    "options": [
      {
        "id": "a",
        "text": "Faster Time to First Byte (TTFB)",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "b",
        "text": "Higher server load and slower TTFB compared to static rendering",
        "isCorrect": true,
        "explanation": ""
      },
      {
        "id": "c",
        "text": "Improved client-side bundle size",
        "isCorrect": false,
        "explanation": ""
      }
    ],
    "hints": [
      "Review rendering pattern documentation",
      "Consider server vs client rendering trade-offs",
      "Think about performance and SEO implications"
    ]
  },
  {
    "id": "rendering-patterns-rendering2-3",
    "title": "SSR Use Case",
    "content": "Which scenario best benefits from Server-Side Rendering?",
    "type": "multiple-choice",
    "category": "Rendering Patterns",
    "topic": "Server-Side Rendering",
    "difficulty": "intermediate",
    "learningCardId": "system-design",
    "isActive": true,
    "createdAt": "2024-01-01T00:00:00.000Z",
    "updatedAt": "2025-11-11T18:59:32.539Z",
    "createdBy": "admin",
    "updatedBy": "admin",
    "tags": [
      "rendering-patterns",
      "server-side-rendering",
      "intermediate"
    ],
    "explanation": "A dashboard showing real-time user data",
    "points": 10,
    "options": [
      {
        "id": "a",
        "text": "A marketing blog updated monthly",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "b",
        "text": "A dashboard showing real-time user data",
        "isCorrect": true,
        "explanation": ""
      },
      {
        "id": "c",
        "text": "A static documentation website",
        "isCorrect": false,
        "explanation": ""
      }
    ],
    "hints": [
      "Review rendering pattern documentation",
      "Consider server vs client rendering trade-offs",
      "Think about performance and SEO implications"
    ]
  },
  {
    "id": "rendering-patterns-rendering2-4",
    "title": "Hydration in SSR",
    "content": "What does 'hydration' mean in the context of SSR?",
    "type": "multiple-choice",
    "category": "Rendering Patterns",
    "topic": "Server-Side Rendering",
    "difficulty": "intermediate",
    "learningCardId": "system-design",
    "isActive": true,
    "createdAt": "2024-01-01T00:00:00.000Z",
    "updatedAt": "2025-11-11T18:59:32.539Z",
    "createdBy": "admin",
    "updatedBy": "admin",
    "tags": [
      "rendering-patterns",
      "server-side-rendering",
      "intermediate"
    ],
    "explanation": "Hydration is the process where React attaches event listeners and reuses server-rendered HTML to make the page interactive.",
    "points": 10,
    "sampleAnswers": [
      "Hydration is the process where React attaches event listeners and reuses server-rendered HTML to make the page interactive.",
      "It bridges the server-rendered static HTML with client-side React logic."
    ],
    "options": [
      {
        "id": "o1",
        "text": "Hydration is the process where React attaches event listeners and reuses server-rendered HTML to make the page interactive.",
        "isCorrect": true,
        "explanation": "Hydration is the process where React attaches event listeners and reuses server-rendered HTML to make the page interactive."
      },
      {
        "id": "o2",
        "text": "This is not correct. Please refer to the explanation.",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "o3",
        "text": "Incorrect. Review rendering pattern concepts.",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "o4",
        "text": "This is a common misconception. The correct answer is different.",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "o5",
        "text": "Not quite. Consider rendering strategy best practices.",
        "isCorrect": false,
        "explanation": ""
      }
    ],
    "hints": [
      "Review rendering pattern documentation",
      "Consider server vs client rendering trade-offs",
      "Think about performance and SEO implications"
    ]
  },
  {
    "id": "rendering-patterns-rendering2-5",
    "title": "Streaming SSR",
    "content": "How does Streaming SSR differ from traditional SSR?",
    "type": "multiple-choice",
    "category": "Rendering Patterns",
    "topic": "Server-Side Rendering",
    "difficulty": "advanced",
    "learningCardId": "system-design",
    "isActive": true,
    "createdAt": "2024-01-01T00:00:00.000Z",
    "updatedAt": "2025-11-11T18:59:32.539Z",
    "createdBy": "admin",
    "updatedBy": "admin",
    "tags": [
      "rendering-patterns",
      "server-side-rendering",
      "advanced"
    ],
    "explanation": "Streaming SSR sends HTML to the browser in chunks as components are rendered, instead of waiting for the full page to be ready.",
    "points": 10,
    "sampleAnswers": [
      "Streaming SSR sends HTML to the browser in chunks as components are rendered, instead of waiting for the full page to be ready.",
      "It improves TTFB and makes perceived performance faster."
    ],
    "options": [
      {
        "id": "o1",
        "text": "Streaming SSR sends HTML to the browser in chunks as components are rendered, instead of waiting for the full page to be ready.",
        "isCorrect": true,
        "explanation": "Streaming SSR sends HTML to the browser in chunks as components are rendered, instead of waiting for the full page to be ready."
      },
      {
        "id": "o2",
        "text": "This is not correct. Please refer to the explanation.",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "o3",
        "text": "Incorrect. Review rendering pattern concepts.",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "o4",
        "text": "This is a common misconception. The correct answer is different.",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "o5",
        "text": "Not quite. Consider rendering strategy best practices.",
        "isCorrect": false,
        "explanation": ""
      }
    ],
    "hints": [
      "Review rendering pattern documentation",
      "Consider server vs client rendering trade-offs",
      "Think about performance and SEO implications"
    ]
  },
  {
    "id": "rendering-patterns-rendering2-6",
    "title": "React 18 and Streaming SSR",
    "content": "Which React feature introduced in React 18 enhances Streaming SSR?",
    "type": "multiple-choice",
    "category": "Rendering Patterns",
    "topic": "Server-Side Rendering",
    "difficulty": "intermediate",
    "learningCardId": "system-design",
    "isActive": true,
    "createdAt": "2024-01-01T00:00:00.000Z",
    "updatedAt": "2025-11-11T18:59:32.539Z",
    "createdBy": "admin",
    "updatedBy": "admin",
    "tags": [
      "rendering-patterns",
      "server-side-rendering",
      "intermediate"
    ],
    "explanation": "React Suspense for data fetching",
    "points": 10,
    "options": [
      {
        "id": "a",
        "text": "React Suspense for data fetching",
        "isCorrect": true,
        "explanation": ""
      },
      {
        "id": "b",
        "text": "React Context API",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "c",
        "text": "React.memo",
        "isCorrect": false,
        "explanation": ""
      }
    ],
    "hints": [
      "Review rendering pattern documentation",
      "Consider server vs client rendering trade-offs",
      "Think about performance and SEO implications"
    ]
  },
  {
    "id": "rendering-patterns-rendering2-7",
    "title": "Edge Rendering",
    "content": "What is Edge Rendering and why is it becoming popular?",
    "type": "multiple-choice",
    "category": "Rendering Patterns",
    "topic": "Server-Side Rendering",
    "difficulty": "advanced",
    "learningCardId": "system-design",
    "isActive": true,
    "createdAt": "2024-01-01T00:00:00.000Z",
    "updatedAt": "2025-11-11T18:59:32.539Z",
    "createdBy": "admin",
    "updatedBy": "admin",
    "tags": [
      "rendering-patterns",
      "server-side-rendering",
      "advanced"
    ],
    "explanation": "Edge Rendering runs SSR logic on edge servers close to the user, reducing latency and improving global performance.",
    "points": 10,
    "sampleAnswers": [
      "Edge Rendering runs SSR logic on edge servers close to the user, reducing latency and improving global performance.",
      "It’s ideal for personalization with low latency."
    ],
    "options": [
      {
        "id": "o1",
        "text": "Edge Rendering runs SSR logic on edge servers close to the user, reducing latency and improving global performance.",
        "isCorrect": true,
        "explanation": "Edge Rendering runs SSR logic on edge servers close to the user, reducing latency and improving global performance."
      },
      {
        "id": "o2",
        "text": "This is not correct. Please refer to the explanation.",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "o3",
        "text": "Incorrect. Review rendering pattern concepts.",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "o4",
        "text": "This is a common misconception. The correct answer is different.",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "o5",
        "text": "Not quite. Consider rendering strategy best practices.",
        "isCorrect": false,
        "explanation": ""
      }
    ],
    "hints": [
      "Review rendering pattern documentation",
      "Consider server vs client rendering trade-offs",
      "Think about performance and SEO implications"
    ]
  },
  {
    "id": "rendering-patterns-rendering2-8",
    "title": "Edge vs Server Rendering",
    "content": "How does Edge Rendering differ from traditional SSR?",
    "type": "multiple-choice",
    "category": "Rendering Patterns",
    "topic": "Server-Side Rendering",
    "difficulty": "advanced",
    "learningCardId": "system-design",
    "isActive": true,
    "createdAt": "2024-01-01T00:00:00.000Z",
    "updatedAt": "2025-11-11T18:59:32.539Z",
    "createdBy": "admin",
    "updatedBy": "admin",
    "tags": [
      "rendering-patterns",
      "server-side-rendering",
      "advanced"
    ],
    "explanation": "Edge Rendering happens on globally distributed edge nodes rather than a central server",
    "points": 10,
    "options": [
      {
        "id": "a",
        "text": "Edge Rendering happens on globally distributed edge nodes rather than a central server",
        "isCorrect": true,
        "explanation": ""
      },
      {
        "id": "b",
        "text": "Edge Rendering always requires a CDN",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "c",
        "text": "Edge Rendering only works for static pages",
        "isCorrect": false,
        "explanation": ""
      }
    ],
    "hints": [
      "Review rendering pattern documentation",
      "Consider server vs client rendering trade-offs",
      "Think about performance and SEO implications"
    ]
  },
  {
    "id": "rendering-patterns-rendering2-9",
    "title": "React Server Components (RSC)",
    "content": "How do React Server Components (RSC) improve rendering performance?",
    "type": "multiple-choice",
    "category": "Rendering Patterns",
    "topic": "Server-Side Rendering",
    "difficulty": "advanced",
    "learningCardId": "system-design",
    "isActive": true,
    "createdAt": "2024-01-01T00:00:00.000Z",
    "updatedAt": "2025-11-11T18:59:32.539Z",
    "createdBy": "admin",
    "updatedBy": "admin",
    "tags": [
      "rendering-patterns",
      "server-side-rendering",
      "advanced"
    ],
    "explanation": "RSC allow parts of the React tree to render on the server without sending extra JavaScript to the client.",
    "points": 10,
    "sampleAnswers": [
      "RSC allow parts of the React tree to render on the server without sending extra JavaScript to the client.",
      "They reduce hydration cost and client bundle size."
    ],
    "options": [
      {
        "id": "o1",
        "text": "RSC allow parts of the React tree to render on the server without sending extra JavaScript to the client.",
        "isCorrect": true,
        "explanation": "RSC allow parts of the React tree to render on the server without sending extra JavaScript to the client."
      },
      {
        "id": "o2",
        "text": "This is not correct. Please refer to the explanation.",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "o3",
        "text": "Incorrect. Review rendering pattern concepts.",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "o4",
        "text": "This is a common misconception. The correct answer is different.",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "o5",
        "text": "Not quite. Consider rendering strategy best practices.",
        "isCorrect": false,
        "explanation": ""
      }
    ],
    "hints": [
      "Review rendering pattern documentation",
      "Consider server vs client rendering trade-offs",
      "Think about performance and SEO implications"
    ]
  },
  {
    "id": "rendering-patterns-rendering2-10",
    "title": "Combining Rendering Strategies",
    "content": "Which rendering approach combines static and dynamic techniques for optimal performance?",
    "type": "multiple-choice",
    "category": "Rendering Patterns",
    "topic": "Server-Side Rendering",
    "difficulty": "intermediate",
    "learningCardId": "system-design",
    "isActive": true,
    "createdAt": "2024-01-01T00:00:00.000Z",
    "updatedAt": "2025-11-11T18:59:32.539Z",
    "createdBy": "admin",
    "updatedBy": "admin",
    "tags": [
      "rendering-patterns",
      "server-side-rendering",
      "intermediate"
    ],
    "explanation": "Hybrid Rendering — mixing SSG, SSR, and ISR depending on route needs",
    "points": 10,
    "options": [
      {
        "id": "a",
        "text": "Hybrid Rendering — mixing SSG, SSR, and ISR depending on route needs",
        "isCorrect": true,
        "explanation": ""
      },
      {
        "id": "b",
        "text": "Full Client-Side Rendering only",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "c",
        "text": "Single Static HTML rendering",
        "isCorrect": false,
        "explanation": ""
      }
    ],
    "hints": [
      "Review rendering pattern documentation",
      "Consider server vs client rendering trade-offs",
      "Think about performance and SEO implications"
    ]
  },
  {
    "id": "rendering-patterns-rendering-1",
    "title": "Understanding Static Rendering",
    "content": "What is Static Rendering and when is it most suitable?",
    "type": "multiple-choice",
    "category": "Rendering Patterns",
    "topic": "Static Rendering",
    "difficulty": "intermediate",
    "learningCardId": "system-design",
    "isActive": true,
    "createdAt": "2024-01-01T00:00:00.000Z",
    "updatedAt": "2025-11-11T18:59:32.541Z",
    "createdBy": "admin",
    "updatedBy": "admin",
    "tags": [
      "rendering-patterns",
      "static-rendering",
      "intermediate"
    ],
    "explanation": "Static Rendering generates HTML at build time and serves pre-rendered pages from a CDN or edge cache.",
    "points": 10,
    "sampleAnswers": [
      "Static Rendering generates HTML at build time and serves pre-rendered pages from a CDN or edge cache.",
      "It's best for content that doesn't change often, like blogs, marketing pages, or documentation."
    ],
    "options": [
      {
        "id": "o1",
        "text": "Static Rendering generates HTML at build time and serves pre-rendered pages from a CDN or edge cache.",
        "isCorrect": true,
        "explanation": "Static Rendering generates HTML at build time and serves pre-rendered pages from a CDN or edge cache."
      },
      {
        "id": "o2",
        "text": "This is not correct. Please refer to the explanation.",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "o3",
        "text": "Incorrect. Review rendering pattern concepts.",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "o4",
        "text": "This is a common misconception. The correct answer is different.",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "o5",
        "text": "Not quite. Consider rendering strategy best practices.",
        "isCorrect": false,
        "explanation": ""
      }
    ],
    "hints": [
      "Review rendering pattern documentation",
      "Consider server vs client rendering trade-offs",
      "Think about performance and SEO implications"
    ]
  },
  {
    "id": "rendering-patterns-rendering-2",
    "title": "Benefits of Static Rendering",
    "content": "Which of the following is a key advantage of static rendering?",
    "type": "multiple-choice",
    "category": "Rendering Patterns",
    "topic": "Static Rendering",
    "difficulty": "intermediate",
    "learningCardId": "system-design",
    "isActive": true,
    "createdAt": "2024-01-01T00:00:00.000Z",
    "updatedAt": "2025-11-11T18:59:32.541Z",
    "createdBy": "admin",
    "updatedBy": "admin",
    "tags": [
      "rendering-patterns",
      "static-rendering",
      "intermediate"
    ],
    "explanation": "HTML is pre-generated and can be cached for near-instant TTFB",
    "points": 10,
    "options": [
      {
        "id": "a",
        "text": "HTML is pre-generated and can be cached for near-instant TTFB",
        "isCorrect": true,
        "explanation": ""
      },
      {
        "id": "b",
        "text": "The server generates HTML for every request",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "c",
        "text": "Users must fetch data before rendering",
        "isCorrect": false,
        "explanation": ""
      }
    ],
    "hints": [
      "Review rendering pattern documentation",
      "Consider server vs client rendering trade-offs",
      "Think about performance and SEO implications"
    ]
  },
  {
    "id": "rendering-patterns-rendering-3",
    "title": "Static Rendering with Client-Side Fetch",
    "content": "What is the drawback of using Client-Side fetch in a static rendered page?",
    "type": "multiple-choice",
    "category": "Rendering Patterns",
    "topic": "Static Rendering",
    "difficulty": "intermediate",
    "learningCardId": "system-design",
    "isActive": true,
    "createdAt": "2024-01-01T00:00:00.000Z",
    "updatedAt": "2025-11-11T18:59:32.541Z",
    "createdBy": "admin",
    "updatedBy": "admin",
    "tags": [
      "rendering-patterns",
      "static-rendering",
      "intermediate"
    ],
    "explanation": "Delayed Largest Contentful Paint (LCP) since main content loads after client fetch",
    "points": 10,
    "options": [
      {
        "id": "a",
        "text": "Poor SEO due to server-side rendering",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "b",
        "text": "Delayed Largest Contentful Paint (LCP) since main content loads after client fetch",
        "isCorrect": true,
        "explanation": ""
      },
      {
        "id": "c",
        "text": "Cannot cache responses on a CDN",
        "isCorrect": false,
        "explanation": ""
      }
    ],
    "hints": [
      "Review rendering pattern documentation",
      "Consider server vs client rendering trade-offs",
      "Think about performance and SEO implications"
    ]
  },
  {
    "id": "rendering-patterns-rendering-4",
    "title": "Static Rendering with getStaticProps",
    "content": "What is the primary purpose of using getStaticProps in Next.js?",
    "type": "multiple-choice",
    "category": "Rendering Patterns",
    "topic": "Static Rendering",
    "difficulty": "intermediate",
    "learningCardId": "system-design",
    "isActive": true,
    "createdAt": "2024-01-01T00:00:00.000Z",
    "updatedAt": "2025-11-11T18:59:32.541Z",
    "createdBy": "admin",
    "updatedBy": "admin",
    "tags": [
      "rendering-patterns",
      "static-rendering",
      "intermediate"
    ],
    "explanation": "It allows fetching data at build time to generate static HTML with data baked in, avoiding client-side API calls.",
    "points": 10,
    "sampleAnswers": [
      "It allows fetching data at build time to generate static HTML with data baked in, avoiding client-side API calls.",
      "It improves performance by reducing runtime data fetching."
    ],
    "options": [
      {
        "id": "o1",
        "text": "It allows fetching data at build time to generate static HTML with data baked in, avoiding client-side API calls.",
        "isCorrect": true,
        "explanation": "It allows fetching data at build time to generate static HTML with data baked in, avoiding client-side API calls."
      },
      {
        "id": "o2",
        "text": "This is not correct. Please refer to the explanation.",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "o3",
        "text": "Incorrect. Review rendering pattern concepts.",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "o4",
        "text": "This is a common misconception. The correct answer is different.",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "o5",
        "text": "Not quite. Consider rendering strategy best practices.",
        "isCorrect": false,
        "explanation": ""
      }
    ],
    "hints": [
      "Review rendering pattern documentation",
      "Consider server vs client rendering trade-offs",
      "Think about performance and SEO implications"
    ]
  },
  {
    "id": "rendering-patterns-rendering-5",
    "title": "Drawback of getStaticProps",
    "content": "What problem can arise when using getStaticProps for large sites with many pages?",
    "type": "multiple-choice",
    "category": "Rendering Patterns",
    "topic": "Static Rendering",
    "difficulty": "intermediate",
    "learningCardId": "system-design",
    "isActive": true,
    "createdAt": "2024-01-01T00:00:00.000Z",
    "updatedAt": "2025-11-11T18:59:32.541Z",
    "createdBy": "admin",
    "updatedBy": "admin",
    "tags": [
      "rendering-patterns",
      "static-rendering",
      "intermediate"
    ],
    "explanation": "Long build times and hitting API request limits",
    "points": 10,
    "options": [
      {
        "id": "a",
        "text": "Long build times and hitting API request limits",
        "isCorrect": true,
        "explanation": ""
      },
      {
        "id": "b",
        "text": "Poor SEO optimization",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "c",
        "text": "Increased client-side bundle size",
        "isCorrect": false,
        "explanation": ""
      }
    ],
    "hints": [
      "Review rendering pattern documentation",
      "Consider server vs client rendering trade-offs",
      "Think about performance and SEO implications"
    ]
  },
  {
    "id": "rendering-patterns-rendering-6",
    "title": "Incremental Static Regeneration (ISR)",
    "content": "How does Incremental Static Regeneration improve over plain static rendering?",
    "type": "multiple-choice",
    "category": "Rendering Patterns",
    "topic": "Static Rendering",
    "difficulty": "advanced",
    "learningCardId": "system-design",
    "isActive": true,
    "createdAt": "2024-01-01T00:00:00.000Z",
    "updatedAt": "2025-11-11T18:59:32.541Z",
    "createdBy": "admin",
    "updatedBy": "admin",
    "tags": [
      "rendering-patterns",
      "static-rendering",
      "advanced"
    ],
    "explanation": "ISR allows selective regeneration of pages after deployment without rebuilding the whole site.",
    "points": 10,
    "sampleAnswers": [
      "ISR allows selective regeneration of pages after deployment without rebuilding the whole site.",
      "It reduces build times and enables automatic cache invalidation for dynamic content."
    ],
    "options": [
      {
        "id": "o1",
        "text": "ISR allows selective regeneration of pages after deployment without rebuilding the whole site.",
        "isCorrect": true,
        "explanation": "ISR allows selective regeneration of pages after deployment without rebuilding the whole site."
      },
      {
        "id": "o2",
        "text": "This is not correct. Please refer to the explanation.",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "o3",
        "text": "Incorrect. Review rendering pattern concepts.",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "o4",
        "text": "This is a common misconception. The correct answer is different.",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "o5",
        "text": "Not quite. Consider rendering strategy best practices.",
        "isCorrect": false,
        "explanation": ""
      }
    ],
    "hints": [
      "Review rendering pattern documentation",
      "Consider server vs client rendering trade-offs",
      "Think about performance and SEO implications"
    ]
  },
  {
    "id": "rendering-patterns-rendering-7",
    "title": "ISR Fallback Behavior",
    "content": "What happens when a user requests a page that hasn’t been generated yet in ISR?",
    "type": "multiple-choice",
    "category": "Rendering Patterns",
    "topic": "Static Rendering",
    "difficulty": "intermediate",
    "learningCardId": "system-design",
    "isActive": true,
    "createdAt": "2024-01-01T00:00:00.000Z",
    "updatedAt": "2025-11-11T18:59:32.541Z",
    "createdBy": "admin",
    "updatedBy": "admin",
    "tags": [
      "rendering-patterns",
      "static-rendering",
      "intermediate"
    ],
    "explanation": "The page is generated on-demand and cached for future requests",
    "points": 10,
    "options": [
      {
        "id": "a",
        "text": "The server immediately returns a 404 error",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "b",
        "text": "The page is generated on-demand and cached for future requests",
        "isCorrect": true,
        "explanation": ""
      },
      {
        "id": "c",
        "text": "The user sees a loading spinner until next build",
        "isCorrect": false,
        "explanation": ""
      }
    ],
    "hints": [
      "Review rendering pattern documentation",
      "Consider server vs client rendering trade-offs",
      "Think about performance and SEO implications"
    ]
  },
  {
    "id": "rendering-patterns-rendering-8",
    "title": "On-Demand Incremental Static Regeneration",
    "content": "How does On-Demand ISR differ from regular ISR?",
    "type": "multiple-choice",
    "category": "Rendering Patterns",
    "topic": "Static Rendering",
    "difficulty": "advanced",
    "learningCardId": "system-design",
    "isActive": true,
    "createdAt": "2024-01-01T00:00:00.000Z",
    "updatedAt": "2025-11-11T18:59:32.541Z",
    "createdBy": "admin",
    "updatedBy": "admin",
    "tags": [
      "rendering-patterns",
      "static-rendering",
      "advanced"
    ],
    "explanation": "Instead of regenerating pages at fixed intervals, On-Demand ISR regenerates pages in response to specific events like webhooks or data updates.",
    "points": 10,
    "sampleAnswers": [
      "Instead of regenerating pages at fixed intervals, On-Demand ISR regenerates pages in response to specific events like webhooks or data updates.",
      "It reduces unnecessary rebuilds and operational costs."
    ],
    "options": [
      {
        "id": "o1",
        "text": "Instead of regenerating pages at fixed intervals, On-Demand ISR regenerates pages in response to specific events like webhooks or data updates.",
        "isCorrect": true,
        "explanation": "Instead of regenerating pages at fixed intervals, On-Demand ISR regenerates pages in response to specific events like webhooks or data updates."
      },
      {
        "id": "o2",
        "text": "This is not correct. Please refer to the explanation.",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "o3",
        "text": "Incorrect. Review rendering pattern concepts.",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "o4",
        "text": "This is a common misconception. The correct answer is different.",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "o5",
        "text": "Not quite. Consider rendering strategy best practices.",
        "isCorrect": false,
        "explanation": ""
      }
    ],
    "hints": [
      "Review rendering pattern documentation",
      "Consider server vs client rendering trade-offs",
      "Think about performance and SEO implications"
    ]
  },
  {
    "id": "rendering-patterns-rendering-9",
    "title": "Performance Metric Association",
    "content": "Which Core Web Vital is most improved by Static Rendering?",
    "type": "multiple-choice",
    "category": "Rendering Patterns",
    "topic": "Static Rendering",
    "difficulty": "intermediate",
    "learningCardId": "system-design",
    "isActive": true,
    "createdAt": "2024-01-01T00:00:00.000Z",
    "updatedAt": "2025-11-11T18:59:32.541Z",
    "createdBy": "admin",
    "updatedBy": "admin",
    "tags": [
      "rendering-patterns",
      "static-rendering",
      "intermediate"
    ],
    "explanation": "Largest Contentful Paint (LCP)",
    "points": 10,
    "options": [
      {
        "id": "a",
        "text": "Largest Contentful Paint (LCP)",
        "isCorrect": true,
        "explanation": ""
      },
      {
        "id": "b",
        "text": "Cumulative Layout Shift (CLS)",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "c",
        "text": "First Input Delay (FID)",
        "isCorrect": false,
        "explanation": ""
      }
    ],
    "hints": [
      "Review rendering pattern documentation",
      "Consider server vs client rendering trade-offs",
      "Think about performance and SEO implications"
    ]
  },
  {
    "id": "rendering-patterns-rendering-10",
    "title": "Choosing Between Static and Server Rendering",
    "content": "When should you avoid using Static Rendering?",
    "type": "multiple-choice",
    "category": "Rendering Patterns",
    "topic": "Static Rendering",
    "difficulty": "intermediate",
    "learningCardId": "system-design",
    "isActive": true,
    "createdAt": "2024-01-01T00:00:00.000Z",
    "updatedAt": "2025-11-11T18:59:32.541Z",
    "createdBy": "admin",
    "updatedBy": "admin",
    "tags": [
      "rendering-patterns",
      "static-rendering",
      "intermediate"
    ],
    "explanation": "For highly personalized pages or data that changes per user request",
    "points": 10,
    "options": [
      {
        "id": "a",
        "text": "For highly personalized pages or data that changes per user request",
        "isCorrect": true,
        "explanation": ""
      },
      {
        "id": "b",
        "text": "For blogs and documentation",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "c",
        "text": "For e-commerce product pages updated daily",
        "isCorrect": false,
        "explanation": ""
      }
    ],
    "hints": [
      "Review rendering pattern documentation",
      "Consider server vs client rendering trade-offs",
      "Think about performance and SEO implications"
    ]
  },
  {
    "id": "rendering-patterns-rendering8-1",
    "title": "HTTP Caching Basics",
    "content": "What is the main purpose of HTTP caching in web applications?",
    "type": "multiple-choice",
    "category": "Rendering Patterns",
    "topic": "Streaming Rendering",
    "difficulty": "intermediate",
    "learningCardId": "system-design",
    "isActive": true,
    "createdAt": "2024-01-01T00:00:00.000Z",
    "updatedAt": "2025-11-11T18:59:32.541Z",
    "createdBy": "admin",
    "updatedBy": "admin",
    "tags": [
      "rendering-patterns",
      "streaming-rendering",
      "intermediate"
    ],
    "explanation": "To store responses locally or on a CDN to reduce server load and speed up subsequent requests.",
    "points": 10,
    "sampleAnswers": [
      "To store responses locally or on a CDN to reduce server load and speed up subsequent requests.",
      "It improves performance by serving cached responses without re-fetching from the server."
    ],
    "options": [
      {
        "id": "o1",
        "text": "To store responses locally or on a CDN to reduce server load and speed up subsequent requests.",
        "isCorrect": true,
        "explanation": "To store responses locally or on a CDN to reduce server load and speed up subsequent requests."
      },
      {
        "id": "o2",
        "text": "This is not correct. Please refer to the explanation.",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "o3",
        "text": "Incorrect. Review rendering pattern concepts.",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "o4",
        "text": "This is a common misconception. The correct answer is different.",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "o5",
        "text": "Not quite. Consider rendering strategy best practices.",
        "isCorrect": false,
        "explanation": ""
      }
    ],
    "hints": [
      "Review rendering pattern documentation",
      "Consider server vs client rendering trade-offs",
      "Think about performance and SEO implications"
    ]
  },
  {
    "id": "rendering-patterns-rendering8-2",
    "title": "Cache-Control Headers",
    "content": "Which HTTP header directive ensures a resource is revalidated after expiration?",
    "type": "multiple-choice",
    "category": "Rendering Patterns",
    "topic": "Streaming Rendering",
    "difficulty": "intermediate",
    "learningCardId": "system-design",
    "isActive": true,
    "createdAt": "2024-01-01T00:00:00.000Z",
    "updatedAt": "2025-11-11T18:59:32.541Z",
    "createdBy": "admin",
    "updatedBy": "admin",
    "tags": [
      "rendering-patterns",
      "streaming-rendering",
      "intermediate"
    ],
    "explanation": "Cache-Control: must-revalidate",
    "points": 10,
    "options": [
      {
        "id": "a",
        "text": "Cache-Control: must-revalidate",
        "isCorrect": true,
        "explanation": ""
      },
      {
        "id": "b",
        "text": "Cache-Control: immutable",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "c",
        "text": "ETag: strong",
        "isCorrect": false,
        "explanation": ""
      }
    ],
    "hints": [
      "Review rendering pattern documentation",
      "Consider server vs client rendering trade-offs",
      "Think about performance and SEO implications"
    ]
  },
  {
    "id": "rendering-patterns-rendering8-3",
    "title": "ETag Function",
    "content": "What role does an ETag header play in caching?",
    "type": "multiple-choice",
    "category": "Rendering Patterns",
    "topic": "Streaming Rendering",
    "difficulty": "intermediate",
    "learningCardId": "system-design",
    "isActive": true,
    "createdAt": "2024-01-01T00:00:00.000Z",
    "updatedAt": "2025-11-11T18:59:32.541Z",
    "createdBy": "admin",
    "updatedBy": "admin",
    "tags": [
      "rendering-patterns",
      "streaming-rendering",
      "intermediate"
    ],
    "explanation": "ETag is a unique identifier for a resource version that helps browsers validate if content has changed.",
    "points": 10,
    "sampleAnswers": [
      "ETag is a unique identifier for a resource version that helps browsers validate if content has changed.",
      "If the ETag matches, the cached version is reused without downloading the full file."
    ],
    "options": [
      {
        "id": "o1",
        "text": "ETag is a unique identifier for a resource version that helps browsers validate if content has changed.",
        "isCorrect": true,
        "explanation": "ETag is a unique identifier for a resource version that helps browsers validate if content has changed."
      },
      {
        "id": "o2",
        "text": "This is not correct. Please refer to the explanation.",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "o3",
        "text": "Incorrect. Review rendering pattern concepts.",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "o4",
        "text": "This is a common misconception. The correct answer is different.",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "o5",
        "text": "Not quite. Consider rendering strategy best practices.",
        "isCorrect": false,
        "explanation": ""
      }
    ],
    "hints": [
      "Review rendering pattern documentation",
      "Consider server vs client rendering trade-offs",
      "Think about performance and SEO implications"
    ]
  },
  {
    "id": "rendering-patterns-rendering8-4",
    "title": "CDN Edge Caching",
    "content": "How does CDN edge caching improve rendering performance?",
    "type": "multiple-choice",
    "category": "Rendering Patterns",
    "topic": "Streaming Rendering",
    "difficulty": "intermediate",
    "learningCardId": "system-design",
    "isActive": true,
    "createdAt": "2024-01-01T00:00:00.000Z",
    "updatedAt": "2025-11-11T18:59:32.541Z",
    "createdBy": "admin",
    "updatedBy": "admin",
    "tags": [
      "rendering-patterns",
      "streaming-rendering",
      "intermediate"
    ],
    "explanation": "It stores static assets closer to the user geographically to reduce latency",
    "points": 10,
    "options": [
      {
        "id": "a",
        "text": "It stores static assets closer to the user geographically to reduce latency",
        "isCorrect": true,
        "explanation": ""
      },
      {
        "id": "b",
        "text": "It only caches dynamic content for faster hydration",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "c",
        "text": "It disables browser caching entirely",
        "isCorrect": false,
        "explanation": ""
      }
    ],
    "hints": [
      "Review rendering pattern documentation",
      "Consider server vs client rendering trade-offs",
      "Think about performance and SEO implications"
    ]
  },
  {
    "id": "rendering-patterns-rendering8-5",
    "title": "Preconnect and Prefetch",
    "content": "What is the difference between preconnect and prefetch in web performance optimization?",
    "type": "multiple-choice",
    "category": "Rendering Patterns",
    "topic": "Streaming Rendering",
    "difficulty": "intermediate",
    "learningCardId": "system-design",
    "isActive": true,
    "createdAt": "2024-01-01T00:00:00.000Z",
    "updatedAt": "2025-11-11T18:59:32.541Z",
    "createdBy": "admin",
    "updatedBy": "admin",
    "tags": [
      "rendering-patterns",
      "streaming-rendering",
      "intermediate"
    ],
    "explanation": "Preconnect establishes early network connections (DNS, TCP, TLS) to improve later requests.",
    "points": 10,
    "sampleAnswers": [
      "Preconnect establishes early network connections (DNS, TCP, TLS) to improve later requests.",
      "Prefetch fetches resources ahead of time that the user is likely to need soon."
    ],
    "options": [
      {
        "id": "o1",
        "text": "Preconnect establishes early network connections (DNS, TCP, TLS) to improve later requests.",
        "isCorrect": true,
        "explanation": "Preconnect establishes early network connections (DNS, TCP, TLS) to improve later requests."
      },
      {
        "id": "o2",
        "text": "This is not correct. Please refer to the explanation.",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "o3",
        "text": "Incorrect. Review rendering pattern concepts.",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "o4",
        "text": "This is a common misconception. The correct answer is different.",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "o5",
        "text": "Not quite. Consider rendering strategy best practices.",
        "isCorrect": false,
        "explanation": ""
      }
    ],
    "hints": [
      "Review rendering pattern documentation",
      "Consider server vs client rendering trade-offs",
      "Think about performance and SEO implications"
    ]
  },
  {
    "id": "rendering-patterns-rendering8-6",
    "title": "Static Asset Versioning",
    "content": "Why is versioning important for static assets in caching?",
    "type": "multiple-choice",
    "category": "Rendering Patterns",
    "topic": "Streaming Rendering",
    "difficulty": "intermediate",
    "learningCardId": "system-design",
    "isActive": true,
    "createdAt": "2024-01-01T00:00:00.000Z",
    "updatedAt": "2025-11-11T18:59:32.541Z",
    "createdBy": "admin",
    "updatedBy": "admin",
    "tags": [
      "rendering-patterns",
      "streaming-rendering",
      "intermediate"
    ],
    "explanation": "It ensures browsers fetch updated assets when changes occur",
    "points": 10,
    "options": [
      {
        "id": "a",
        "text": "It ensures browsers fetch updated assets when changes occur",
        "isCorrect": true,
        "explanation": ""
      },
      {
        "id": "b",
        "text": "It prevents caching altogether",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "c",
        "text": "It slows down content delivery",
        "isCorrect": false,
        "explanation": ""
      }
    ],
    "hints": [
      "Review rendering pattern documentation",
      "Consider server vs client rendering trade-offs",
      "Think about performance and SEO implications"
    ]
  },
  {
    "id": "rendering-patterns-rendering8-7",
    "title": "Client-Side Cache Invalidation",
    "content": "How can a front-end app force invalidation of a stale cache?",
    "type": "multiple-choice",
    "category": "Rendering Patterns",
    "topic": "Streaming Rendering",
    "difficulty": "advanced",
    "learningCardId": "system-design",
    "isActive": true,
    "createdAt": "2024-01-01T00:00:00.000Z",
    "updatedAt": "2025-11-11T18:59:32.541Z",
    "createdBy": "admin",
    "updatedBy": "admin",
    "tags": [
      "rendering-patterns",
      "streaming-rendering",
      "advanced"
    ],
    "explanation": "By updating the asset version hash or using service worker cache management APIs.",
    "points": 10,
    "sampleAnswers": [
      "By updating the asset version hash or using service worker cache management APIs.",
      "It can also append query parameters to resource URLs to bypass old caches."
    ],
    "options": [
      {
        "id": "o1",
        "text": "By updating the asset version hash or using service worker cache management APIs.",
        "isCorrect": true,
        "explanation": "By updating the asset version hash or using service worker cache management APIs."
      },
      {
        "id": "o2",
        "text": "This is not correct. Please refer to the explanation.",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "o3",
        "text": "Incorrect. Review rendering pattern concepts.",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "o4",
        "text": "This is a common misconception. The correct answer is different.",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "o5",
        "text": "Not quite. Consider rendering strategy best practices.",
        "isCorrect": false,
        "explanation": ""
      }
    ],
    "hints": [
      "Review rendering pattern documentation",
      "Consider server vs client rendering trade-offs",
      "Think about performance and SEO implications"
    ]
  },
  {
    "id": "rendering-patterns-rendering8-8",
    "title": "Revalidation Techniques",
    "content": "Which caching header combination supports conditional revalidation?",
    "type": "multiple-choice",
    "category": "Rendering Patterns",
    "topic": "Streaming Rendering",
    "difficulty": "advanced",
    "learningCardId": "system-design",
    "isActive": true,
    "createdAt": "2024-01-01T00:00:00.000Z",
    "updatedAt": "2025-11-11T18:59:32.541Z",
    "createdBy": "admin",
    "updatedBy": "admin",
    "tags": [
      "rendering-patterns",
      "streaming-rendering",
      "advanced"
    ],
    "explanation": "ETag and If-None-Match",
    "points": 10,
    "options": [
      {
        "id": "a",
        "text": "ETag and If-None-Match",
        "isCorrect": true,
        "explanation": ""
      },
      {
        "id": "b",
        "text": "Cache-Control: immutable",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "c",
        "text": "Last-Modified and If-Match",
        "isCorrect": false,
        "explanation": ""
      }
    ],
    "hints": [
      "Review rendering pattern documentation",
      "Consider server vs client rendering trade-offs",
      "Think about performance and SEO implications"
    ]
  },
  {
    "id": "rendering-patterns-rendering8-9",
    "title": "Incremental Static Regeneration (ISR)",
    "content": "How does ISR improve performance in frameworks like Next.js?",
    "type": "multiple-choice",
    "category": "Rendering Patterns",
    "topic": "Streaming Rendering",
    "difficulty": "advanced",
    "learningCardId": "system-design",
    "isActive": true,
    "createdAt": "2024-01-01T00:00:00.000Z",
    "updatedAt": "2025-11-11T18:59:32.541Z",
    "createdBy": "admin",
    "updatedBy": "admin",
    "tags": [
      "rendering-patterns",
      "streaming-rendering",
      "advanced"
    ],
    "explanation": "ISR allows static pages to be regenerated in the background at runtime while serving cached versions to users.",
    "points": 10,
    "sampleAnswers": [
      "ISR allows static pages to be regenerated in the background at runtime while serving cached versions to users.",
      "This enables near-instant load times with up-to-date content."
    ],
    "options": [
      {
        "id": "o1",
        "text": "ISR allows static pages to be regenerated in the background at runtime while serving cached versions to users.",
        "isCorrect": true,
        "explanation": "ISR allows static pages to be regenerated in the background at runtime while serving cached versions to users."
      },
      {
        "id": "o2",
        "text": "This is not correct. Please refer to the explanation.",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "o3",
        "text": "Incorrect. Review rendering pattern concepts.",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "o4",
        "text": "This is a common misconception. The correct answer is different.",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "o5",
        "text": "Not quite. Consider rendering strategy best practices.",
        "isCorrect": false,
        "explanation": ""
      }
    ],
    "hints": [
      "Review rendering pattern documentation",
      "Consider server vs client rendering trade-offs",
      "Think about performance and SEO implications"
    ]
  },
  {
    "id": "rendering-patterns-rendering8-10",
    "title": "Stale-While-Revalidate",
    "content": "What does the stale-while-revalidate caching strategy do?",
    "type": "multiple-choice",
    "category": "Rendering Patterns",
    "topic": "Streaming Rendering",
    "difficulty": "advanced",
    "learningCardId": "system-design",
    "isActive": true,
    "createdAt": "2024-01-01T00:00:00.000Z",
    "updatedAt": "2025-11-11T18:59:32.541Z",
    "createdBy": "admin",
    "updatedBy": "admin",
    "tags": [
      "rendering-patterns",
      "streaming-rendering",
      "advanced"
    ],
    "explanation": "Serves a stale cache immediately and revalidates it in the background",
    "points": 10,
    "options": [
      {
        "id": "a",
        "text": "Serves a stale cache immediately and revalidates it in the background",
        "isCorrect": true,
        "explanation": ""
      },
      {
        "id": "b",
        "text": "Deletes old cache entries before fetching new ones",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "c",
        "text": "Disables revalidation for dynamic pages",
        "isCorrect": false,
        "explanation": ""
      }
    ],
    "hints": [
      "Review rendering pattern documentation",
      "Consider server vs client rendering trade-offs",
      "Think about performance and SEO implications"
    ]
  }
]