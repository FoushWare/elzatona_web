[
  {
    "id": "problem-solving-easy-1",
    "title": "Find Two Numbers That Add Up to Target",
    "content": "Given an array of numbers and a target sum, find two numbers that add up to the target. Return their indices.\n\nExample: nums = [2, 7, 11, 15], target = 9\nOutput: [0, 1] (because 2 + 7 = 9)",
    "type": "multiple-choice",
    "category": "Problem Solving",
    "topic": "Easy Problems",
    "difficulty": "easy",
    "learningCardId": "problem-solving",
    "isActive": true,
    "createdAt": "2025-11-11T20:16:30.708Z",
    "updatedAt": "2025-11-11T20:16:30.713Z",
    "createdBy": "admin",
    "updatedBy": "admin",
    "tags": [
      "problem-solving",
      "algorithms",
      "javascript",
      "easy"
    ],
    "explanation": "Use a hash map (object) to store each number and its index. For each number, check if the complement (target - current number) exists in the map. This gives O(n) time complexity.",
    "points": 10,
    "options": [
      {
        "id": "o1",
        "text": "Use a hash map to store complements. Iterate once, checking if complement exists. Time: O(n), Space: O(n)",
        "isCorrect": true,
        "explanation": ""
      },
      {
        "id": "o2",
        "text": "Use nested loops to check all pairs. Time: O(n²), Space: O(1)",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "o3",
        "text": "Sort the array first, then use two pointers. Time: O(n log n), Space: O(1)",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "o4",
        "text": "Use recursion to check all combinations. Time: O(2ⁿ), Space: O(n)",
        "isCorrect": false,
        "explanation": ""
      }
    ],
    "hints": [
      "Think about the time and space complexity",
      "Consider edge cases (empty arrays, single elements, etc.)",
      "Try to solve it step by step"
    ],
    "metadata": {}
  },
  {
    "id": "problem-solving-easy-2",
    "title": "Validate Balanced Parentheses",
    "content": "Given a string containing only parentheses, brackets, and braces, determine if the string is valid (properly closed).\n\nExample: \"()[]{}\" → true, \"([)]\" → false",
    "type": "multiple-choice",
    "category": "Problem Solving",
    "topic": "Easy Problems",
    "difficulty": "easy",
    "learningCardId": "problem-solving",
    "isActive": true,
    "createdAt": "2025-11-11T20:16:30.714Z",
    "updatedAt": "2025-11-11T20:16:30.714Z",
    "createdBy": "admin",
    "updatedBy": "admin",
    "tags": [
      "problem-solving",
      "algorithms",
      "javascript",
      "easy"
    ],
    "explanation": "Use a stack data structure. Push opening brackets onto the stack. When encountering a closing bracket, check if it matches the top of the stack. If stack is empty at the end, the string is valid.",
    "points": 10,
    "options": [
      {
        "id": "o1",
        "text": "Use a stack. Push opening brackets, pop when matching closing bracket. Check if stack is empty at end. Time: O(n), Space: O(n)",
        "isCorrect": true,
        "explanation": ""
      },
      {
        "id": "o2",
        "text": "Count opening and closing brackets. If counts match, it's valid. Time: O(n), Space: O(1)",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "o3",
        "text": "Use regex to remove pairs repeatedly until no more pairs. Time: O(n²), Space: O(n)",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "o4",
        "text": "Check if string length is even. Time: O(1), Space: O(1)",
        "isCorrect": false,
        "explanation": ""
      }
    ],
    "hints": [
      "Think about the time and space complexity",
      "Consider edge cases (empty arrays, single elements, etc.)",
      "Try to solve it step by step"
    ],
    "metadata": {}
  },
  {
    "id": "problem-solving-easy-3",
    "title": "Reverse a String",
    "content": "Given a string, reverse it in-place (if array) or return reversed string.\n\nExample: \"hello\" → \"olleh\"",
    "type": "multiple-choice",
    "category": "Problem Solving",
    "topic": "Easy Problems",
    "difficulty": "easy",
    "learningCardId": "problem-solving",
    "isActive": true,
    "createdAt": "2025-11-11T20:16:30.714Z",
    "updatedAt": "2025-11-11T20:16:30.714Z",
    "createdBy": "admin",
    "updatedBy": "admin",
    "tags": [
      "problem-solving",
      "algorithms",
      "javascript",
      "easy"
    ],
    "explanation": "For arrays, use two pointers (start and end) and swap characters while moving pointers towards center. For strings in JavaScript, convert to array first since strings are immutable.",
    "points": 10,
    "options": [
      {
        "id": "o1",
        "text": "Use two pointers from start and end, swap characters. Time: O(n), Space: O(1) for array, O(n) for string",
        "isCorrect": true,
        "explanation": ""
      },
      {
        "id": "o2",
        "text": "Create new string by iterating backwards. Time: O(n), Space: O(n)",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "o3",
        "text": "Use built-in reverse() method. Time: O(n), Space: O(n)",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "o4",
        "text": "Use recursion to swap characters. Time: O(n), Space: O(n)",
        "isCorrect": false,
        "explanation": ""
      }
    ],
    "hints": [
      "Think about the time and space complexity",
      "Consider edge cases (empty arrays, single elements, etc.)",
      "Try to solve it step by step"
    ],
    "metadata": {}
  },
  {
    "id": "problem-solving-easy-4",
    "title": "Check for Duplicate Values",
    "content": "Given an array, determine if any value appears at least twice.\n\nExample: [1, 2, 3, 1] → true",
    "type": "multiple-choice",
    "category": "Problem Solving",
    "topic": "Easy Problems",
    "difficulty": "easy",
    "learningCardId": "problem-solving",
    "isActive": true,
    "createdAt": "2025-11-11T20:16:30.714Z",
    "updatedAt": "2025-11-11T20:16:30.714Z",
    "createdBy": "admin",
    "updatedBy": "admin",
    "tags": [
      "problem-solving",
      "algorithms",
      "javascript",
      "easy"
    ],
    "explanation": "Use a Set data structure. Iterate through the array, adding each element to the Set. If an element already exists in the Set, return true. This is the most efficient approach.",
    "points": 10,
    "options": [
      {
        "id": "o1",
        "text": "Use a Set to track seen values. If value exists in Set, return true. Time: O(n), Space: O(n)",
        "isCorrect": true,
        "explanation": ""
      },
      {
        "id": "o2",
        "text": "Sort array and check adjacent elements. Time: O(n log n), Space: O(1)",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "o3",
        "text": "Use nested loops to compare all pairs. Time: O(n²), Space: O(1)",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "o4",
        "text": "Use filter and length comparison. Time: O(n), Space: O(n)",
        "isCorrect": false,
        "explanation": ""
      }
    ],
    "hints": [
      "Think about the time and space complexity",
      "Consider edge cases (empty arrays, single elements, etc.)",
      "Try to solve it step by step"
    ],
    "metadata": {}
  },
  {
    "id": "problem-solving-easy-5",
    "title": "Find Maximum Profit from Stock Prices",
    "content": "Given an array of stock prices, find the maximum profit from buying and selling once.\n\nExample: [7, 1, 5, 3, 6, 4] → 5 (buy at 1, sell at 6)",
    "type": "multiple-choice",
    "category": "Problem Solving",
    "topic": "Easy Problems",
    "difficulty": "easy",
    "learningCardId": "problem-solving",
    "isActive": true,
    "createdAt": "2025-11-11T20:16:30.714Z",
    "updatedAt": "2025-11-11T20:16:30.714Z",
    "createdBy": "admin",
    "updatedBy": "admin",
    "tags": [
      "problem-solving",
      "algorithms",
      "javascript",
      "easy"
    ],
    "explanation": "Keep track of the minimum price encountered so far. For each day, calculate the profit if selling today (current price - min price) and update the maximum profit seen.",
    "points": 10,
    "options": [
      {
        "id": "o1",
        "text": "Track minimum price seen so far. For each price, calculate profit and update max profit. Time: O(n), Space: O(1)",
        "isCorrect": true,
        "explanation": ""
      },
      {
        "id": "o2",
        "text": "Try all buy-sell pairs using nested loops. Time: O(n²), Space: O(1)",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "o3",
        "text": "Find min and max values. Time: O(n), Space: O(1)",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "o4",
        "text": "Sort prices and find difference. Time: O(n log n), Space: O(n)",
        "isCorrect": false,
        "explanation": ""
      }
    ],
    "hints": [
      "Think about the time and space complexity",
      "Consider edge cases (empty arrays, single elements, etc.)",
      "Try to solve it step by step"
    ],
    "metadata": {}
  },
  {
    "id": "problem-solving-easy-6",
    "title": "Check if Two Strings are Anagrams",
    "content": "Given two strings, determine if they are anagrams (same characters, different order).\n\nExample: \"listen\" and \"silent\" → true",
    "type": "multiple-choice",
    "category": "Problem Solving",
    "topic": "Easy Problems",
    "difficulty": "easy",
    "learningCardId": "problem-solving",
    "isActive": true,
    "createdAt": "2025-11-11T20:16:30.714Z",
    "updatedAt": "2025-11-11T20:16:30.714Z",
    "createdBy": "admin",
    "updatedBy": "admin",
    "tags": [
      "problem-solving",
      "algorithms",
      "javascript",
      "easy"
    ],
    "explanation": "Two approaches: 1) Sort both strings and compare (simpler). 2) Count character frequencies using a hash map (more efficient for large strings). Both are valid solutions.",
    "points": 10,
    "options": [
      {
        "id": "o1",
        "text": "Sort both strings and compare. Time: O(n log n), Space: O(n)",
        "isCorrect": true,
        "explanation": ""
      },
      {
        "id": "o2",
        "text": "Count character frequencies using hash map. Compare counts. Time: O(n), Space: O(1) - limited alphabet",
        "isCorrect": true,
        "explanation": ""
      },
      {
        "id": "o3",
        "text": "Use nested loops to check each character. Time: O(n²), Space: O(1)",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "o4",
        "text": "Compare string lengths only. Time: O(1), Space: O(1)",
        "isCorrect": false,
        "explanation": ""
      }
    ],
    "hints": [
      "Think about the time and space complexity",
      "Consider edge cases (empty arrays, single elements, etc.)",
      "Try to solve it step by step"
    ],
    "metadata": {}
  },
  {
    "id": "problem-solving-easy-7",
    "title": "Find Maximum Sum Subarray",
    "content": "Given an array of integers, find the contiguous subarray with the largest sum.\n\nExample: [-2, 1, -3, 4, -1, 2, 1, -5, 4] → 6 ([4, -1, 2, 1])",
    "type": "multiple-choice",
    "category": "Problem Solving",
    "topic": "Easy Problems",
    "difficulty": "easy",
    "learningCardId": "problem-solving",
    "isActive": true,
    "createdAt": "2025-11-11T20:16:30.714Z",
    "updatedAt": "2025-11-11T20:16:30.714Z",
    "createdBy": "admin",
    "updatedBy": "admin",
    "tags": [
      "problem-solving",
      "algorithms",
      "javascript",
      "easy"
    ],
    "explanation": "Kadane's algorithm: iterate through array, maintaining current sum. If current sum becomes negative, reset it to 0. Keep track of maximum sum seen so far.",
    "points": 10,
    "options": [
      {
        "id": "o1",
        "text": "Kadane's algorithm: track current sum and max sum. Reset current sum if negative. Time: O(n), Space: O(1)",
        "isCorrect": true,
        "explanation": ""
      },
      {
        "id": "o2",
        "text": "Try all possible subarrays using nested loops. Time: O(n²), Space: O(1)",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "o3",
        "text": "Use divide and conquer approach. Time: O(n log n), Space: O(log n)",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "o4",
        "text": "Find sum of all positive numbers. Time: O(n), Space: O(1)",
        "isCorrect": false,
        "explanation": ""
      }
    ],
    "hints": [
      "Think about the time and space complexity",
      "Consider edge cases (empty arrays, single elements, etc.)",
      "Try to solve it step by step"
    ],
    "metadata": {}
  },
  {
    "id": "problem-solving-easy-8",
    "title": "Merge Two Sorted Arrays",
    "content": "Given two sorted arrays, merge them into one sorted array.\n\nExample: [1, 2, 3] and [2, 5, 6] → [1, 2, 2, 3, 5, 6]",
    "type": "multiple-choice",
    "category": "Problem Solving",
    "topic": "Easy Problems",
    "difficulty": "easy",
    "learningCardId": "problem-solving",
    "isActive": true,
    "createdAt": "2025-11-11T20:16:30.714Z",
    "updatedAt": "2025-11-11T20:16:30.714Z",
    "createdBy": "admin",
    "updatedBy": "admin",
    "tags": [
      "problem-solving",
      "algorithms",
      "javascript",
      "easy"
    ],
    "explanation": "Use two pointers, one for each array. Compare elements at both pointers, add the smaller one to result, and advance that pointer. Continue until both arrays are processed.",
    "points": 10,
    "options": [
      {
        "id": "o1",
        "text": "Use two pointers, compare elements and add smaller one. Time: O(n + m), Space: O(n + m)",
        "isCorrect": true,
        "explanation": ""
      },
      {
        "id": "o2",
        "text": "Concatenate and sort. Time: O((n+m) log(n+m)), Space: O(n+m)",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "o3",
        "text": "Use nested loops to insert elements. Time: O(n*m), Space: O(n+m)",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "o4",
        "text": "Use Set to remove duplicates then sort. Time: O((n+m) log(n+m)), Space: O(n+m)",
        "isCorrect": false,
        "explanation": ""
      }
    ],
    "hints": [
      "Think about the time and space complexity",
      "Consider edge cases (empty arrays, single elements, etc.)",
      "Try to solve it step by step"
    ],
    "metadata": {}
  },
  {
    "id": "problem-solving-easy-9",
    "title": "Count Ways to Climb Stairs",
    "content": "You are climbing a staircase. It takes n steps to reach the top. Each time you can climb 1 or 2 steps. How many distinct ways can you climb?\n\nExample: n = 3 → 3 ways (1+1+1, 1+2, 2+1)",
    "type": "multiple-choice",
    "category": "Problem Solving",
    "topic": "Easy Problems",
    "difficulty": "easy",
    "learningCardId": "problem-solving",
    "isActive": true,
    "createdAt": "2025-11-11T20:16:30.714Z",
    "updatedAt": "2025-11-11T20:16:30.714Z",
    "createdBy": "admin",
    "updatedBy": "admin",
    "tags": [
      "problem-solving",
      "algorithms",
      "javascript",
      "easy"
    ],
    "explanation": "This is a Fibonacci sequence problem. Use dynamic programming: ways to reach step i = ways to reach step (i-1) + ways to reach step (i-2). Can optimize space to O(1) by only keeping last two values.",
    "points": 10,
    "options": [
      {
        "id": "o1",
        "text": "Use dynamic programming: ways[i] = ways[i-1] + ways[i-2]. Time: O(n), Space: O(n) or O(1) with optimization",
        "isCorrect": true,
        "explanation": ""
      },
      {
        "id": "o2",
        "text": "Use recursion without memoization. Time: O(2ⁿ), Space: O(n)",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "o3",
        "text": "Try all possible combinations. Time: O(2ⁿ), Space: O(n)",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "o4",
        "text": "Use factorial calculation. Time: O(n), Space: O(1)",
        "isCorrect": false,
        "explanation": ""
      }
    ],
    "hints": [
      "Think about the time and space complexity",
      "Consider edge cases (empty arrays, single elements, etc.)",
      "Try to solve it step by step"
    ],
    "metadata": {}
  },
  {
    "id": "problem-solving-easy-10",
    "title": "Check if Number is Palindrome",
    "content": "Determine if an integer is a palindrome (reads same forwards and backwards).\n\nExample: 121 → true, -121 → false",
    "type": "multiple-choice",
    "category": "Problem Solving",
    "topic": "Easy Problems",
    "difficulty": "easy",
    "learningCardId": "problem-solving",
    "isActive": true,
    "createdAt": "2025-11-11T20:16:30.714Z",
    "updatedAt": "2025-11-11T20:16:30.714Z",
    "createdBy": "admin",
    "updatedBy": "admin",
    "tags": [
      "problem-solving",
      "algorithms",
      "javascript",
      "easy"
    ],
    "explanation": "Two approaches: 1) Convert to string and compare with reversed version. 2) Reverse half the number mathematically and compare with the other half (more efficient, no string conversion).",
    "points": 10,
    "options": [
      {
        "id": "o1",
        "text": "Reverse half of the number and compare with other half. Time: O(log n), Space: O(1)",
        "isCorrect": true,
        "explanation": ""
      },
      {
        "id": "o2",
        "text": "Convert to string and check if reversed equals original. Time: O(log n), Space: O(log n)",
        "isCorrect": true,
        "explanation": ""
      },
      {
        "id": "o3",
        "text": "Use modulo and division to extract digits. Time: O(log n), Space: O(log n)",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "o4",
        "text": "Compare first and last digit only. Time: O(1), Space: O(1)",
        "isCorrect": false,
        "explanation": ""
      }
    ],
    "hints": [
      "Think about the time and space complexity",
      "Consider edge cases (empty arrays, single elements, etc.)",
      "Try to solve it step by step"
    ],
    "metadata": {}
  },
  {
    "id": "problem-solving-medium-1",
    "title": "Find Longest Substring Without Repeating Characters",
    "content": "Given a string, find the length of the longest substring without repeating characters.\n\nExample: \"abcabcbb\" → 3 (\"abc\")",
    "type": "multiple-choice",
    "category": "Problem Solving",
    "topic": "Medium Problems",
    "difficulty": "medium",
    "learningCardId": "problem-solving",
    "isActive": true,
    "createdAt": "2025-11-11T20:16:30.714Z",
    "updatedAt": "2025-11-11T20:16:30.714Z",
    "createdBy": "admin",
    "updatedBy": "admin",
    "tags": [
      "problem-solving",
      "algorithms",
      "javascript",
      "medium"
    ],
    "explanation": "Use sliding window technique with a hash map. Expand window by moving right pointer, track characters in current window. When duplicate found, move left pointer past the duplicate. Track maximum window size.",
    "points": 15,
    "options": [
      {
        "id": "o1",
        "text": "Use sliding window with hash map. Expand window, shrink when duplicate found. Time: O(n), Space: O(min(n, m)) where m is charset size",
        "isCorrect": true,
        "explanation": ""
      },
      {
        "id": "o2",
        "text": "Check all possible substrings. Time: O(n³), Space: O(n)",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "o3",
        "text": "Use Set and check each substring. Time: O(n²), Space: O(n)",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "o4",
        "text": "Sort characters and find longest sequence. Time: O(n log n), Space: O(n)",
        "isCorrect": false,
        "explanation": ""
      }
    ],
    "hints": [
      "Think about the time and space complexity",
      "Consider edge cases (empty arrays, single elements, etc.)",
      "Try to solve it step by step"
    ],
    "metadata": {}
  },
  {
    "id": "problem-solving-medium-2",
    "title": "Find Container With Most Water",
    "content": "Given an array of heights, find two lines that together with x-axis form a container that holds the most water.\n\nExample: [1, 8, 6, 2, 5, 4, 8, 3, 7] → 49",
    "type": "multiple-choice",
    "category": "Problem Solving",
    "topic": "Medium Problems",
    "difficulty": "medium",
    "learningCardId": "problem-solving",
    "isActive": true,
    "createdAt": "2025-11-11T20:16:30.714Z",
    "updatedAt": "2025-11-11T20:16:30.714Z",
    "createdBy": "admin",
    "updatedBy": "admin",
    "tags": [
      "problem-solving",
      "algorithms",
      "javascript",
      "medium"
    ],
    "explanation": "Use two pointers technique: start with pointers at both ends. Calculate area (min(height[left], height[right]) * (right - left)). Move the pointer with smaller height inward, as moving the larger one cannot increase area.",
    "points": 15,
    "options": [
      {
        "id": "o1",
        "text": "Use two pointers at start and end. Move pointer with smaller height. Calculate area and track max. Time: O(n), Space: O(1)",
        "isCorrect": true,
        "explanation": ""
      },
      {
        "id": "o2",
        "text": "Try all pairs of lines. Time: O(n²), Space: O(1)",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "o3",
        "text": "Find two tallest lines. Time: O(n), Space: O(1)",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "o4",
        "text": "Sort heights and use top two. Time: O(n log n), Space: O(n)",
        "isCorrect": false,
        "explanation": ""
      }
    ],
    "hints": [
      "Think about the time and space complexity",
      "Consider edge cases (empty arrays, single elements, etc.)",
      "Try to solve it step by step"
    ],
    "metadata": {}
  },
  {
    "id": "problem-solving-medium-3",
    "title": "Find All Unique Triplets That Sum to Zero",
    "content": "Given an array, find all unique triplets that sum to zero.\n\nExample: [-1, 0, 1, 2, -1, -4] → [[-1, -1, 2], [-1, 0, 1]]",
    "type": "multiple-choice",
    "category": "Problem Solving",
    "topic": "Medium Problems",
    "difficulty": "medium",
    "learningCardId": "problem-solving",
    "isActive": true,
    "createdAt": "2025-11-11T20:16:30.714Z",
    "updatedAt": "2025-11-11T20:16:30.714Z",
    "createdBy": "admin",
    "updatedBy": "admin",
    "tags": [
      "problem-solving",
      "algorithms",
      "javascript",
      "medium"
    ],
    "explanation": "Sort the array first. For each element, use two pointers (left and right) to find pairs that sum to the negative of the current element. Skip duplicate values to avoid duplicate triplets.",
    "points": 15,
    "options": [
      {
        "id": "o1",
        "text": "Sort array. For each element, use two pointers to find pairs that sum to negative of current element. Skip duplicates. Time: O(n²), Space: O(1) excluding output",
        "isCorrect": true,
        "explanation": ""
      },
      {
        "id": "o2",
        "text": "Use three nested loops. Time: O(n³), Space: O(1)",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "o3",
        "text": "Use hash map for all pairs, then check for third element. Time: O(n²), Space: O(n²)",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "o4",
        "text": "Find all combinations using recursion. Time: O(2ⁿ), Space: O(n)",
        "isCorrect": false,
        "explanation": ""
      }
    ],
    "hints": [
      "Think about the time and space complexity",
      "Consider edge cases (empty arrays, single elements, etc.)",
      "Try to solve it step by step"
    ],
    "metadata": {}
  },
  {
    "id": "problem-solving-medium-4",
    "title": "Group Strings by Anagram",
    "content": "Given an array of strings, group anagrams together.\n\nExample: [\"eat\", \"tea\", \"tan\", \"ate\", \"nat\", \"bat\"] → [[\"eat\",\"tea\",\"ate\"], [\"tan\",\"nat\"], [\"bat\"]]",
    "type": "multiple-choice",
    "category": "Problem Solving",
    "topic": "Medium Problems",
    "difficulty": "medium",
    "learningCardId": "problem-solving",
    "isActive": true,
    "createdAt": "2025-11-11T20:16:30.714Z",
    "updatedAt": "2025-11-11T20:16:30.714Z",
    "createdBy": "admin",
    "updatedBy": "admin",
    "tags": [
      "problem-solving",
      "algorithms",
      "javascript",
      "medium"
    ],
    "explanation": "Two approaches: 1) Sort each string and use sorted string as key in hash map. 2) Use character frequency count as key (more efficient). Group strings with same key together.",
    "points": 15,
    "options": [
      {
        "id": "o1",
        "text": "Use sorted string as key in hash map. Group strings with same sorted key. Time: O(n*k log k) where k is avg string length, Space: O(n*k)",
        "isCorrect": true,
        "explanation": ""
      },
      {
        "id": "o2",
        "text": "Compare each string with all others. Time: O(n²*k), Space: O(n)",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "o3",
        "text": "Use character frequency as key. Time: O(n*k), Space: O(n*k)",
        "isCorrect": true,
        "explanation": ""
      },
      {
        "id": "o4",
        "text": "Sort entire array and group adjacent anagrams. Time: O(n*k log(n*k)), Space: O(n*k)",
        "isCorrect": false,
        "explanation": ""
      }
    ],
    "hints": [
      "Think about the time and space complexity",
      "Consider edge cases (empty arrays, single elements, etc.)",
      "Try to solve it step by step"
    ],
    "metadata": {}
  },
  {
    "id": "problem-solving-medium-5",
    "title": "Find Longest Palindromic Substring",
    "content": "Given a string, find the longest palindromic substring.\n\nExample: \"babad\" → \"bab\" or \"aba\"",
    "type": "multiple-choice",
    "category": "Problem Solving",
    "topic": "Medium Problems",
    "difficulty": "medium",
    "learningCardId": "problem-solving",
    "isActive": true,
    "createdAt": "2025-11-11T20:16:30.714Z",
    "updatedAt": "2025-11-11T20:16:30.714Z",
    "createdBy": "admin",
    "updatedBy": "admin",
    "tags": [
      "problem-solving",
      "algorithms",
      "javascript",
      "medium"
    ],
    "explanation": "Expand around center: for each possible center (considering both odd and even length palindromes), expand outward while characters match. Track the longest palindrome found. More space-efficient than DP.",
    "points": 15,
    "options": [
      {
        "id": "o1",
        "text": "Expand around center for each possible center (odd and even length). Track longest. Time: O(n²), Space: O(1)",
        "isCorrect": true,
        "explanation": ""
      },
      {
        "id": "o2",
        "text": "Check all possible substrings. Time: O(n³), Space: O(1)",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "o3",
        "text": "Use dynamic programming. Time: O(n²), Space: O(n²)",
        "isCorrect": true,
        "explanation": ""
      },
      {
        "id": "o4",
        "text": "Reverse string and find longest common substring. Time: O(n²), Space: O(n²)",
        "isCorrect": false,
        "explanation": ""
      }
    ],
    "hints": [
      "Think about the time and space complexity",
      "Consider edge cases (empty arrays, single elements, etc.)",
      "Try to solve it step by step"
    ],
    "metadata": {}
  },
  {
    "id": "problem-solving-medium-6",
    "title": "Product of Array Except Self",
    "content": "Given an array, return an array where each element is the product of all other elements (without using division).\n\nExample: [1, 2, 3, 4] → [24, 12, 8, 6]",
    "type": "multiple-choice",
    "category": "Problem Solving",
    "topic": "Medium Problems",
    "difficulty": "medium",
    "learningCardId": "problem-solving",
    "isActive": true,
    "createdAt": "2025-11-11T20:16:30.714Z",
    "updatedAt": "2025-11-11T20:16:30.714Z",
    "createdBy": "admin",
    "updatedBy": "admin",
    "tags": [
      "problem-solving",
      "algorithms",
      "javascript",
      "medium"
    ],
    "explanation": "Use two passes: first pass calculates left products (product of all elements to the left), second pass multiplies by right products (product of all elements to the right). This avoids division and handles zeros.",
    "points": 15,
    "options": [
      {
        "id": "o1",
        "text": "Two passes: left products, then right products. Multiply corresponding elements. Time: O(n), Space: O(1) excluding output",
        "isCorrect": true,
        "explanation": ""
      },
      {
        "id": "o2",
        "text": "Calculate product of all elements, divide by each element. Time: O(n), Space: O(1)",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "o3",
        "text": "For each element, calculate product of all others. Time: O(n²), Space: O(1)",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "o4",
        "text": "Use nested loops to calculate products. Time: O(n²), Space: O(n)",
        "isCorrect": false,
        "explanation": ""
      }
    ],
    "hints": [
      "Think about the time and space complexity",
      "Consider edge cases (empty arrays, single elements, etc.)",
      "Try to solve it step by step"
    ],
    "metadata": {}
  },
  {
    "id": "problem-solving-medium-7",
    "title": "Validate Sudoku Board",
    "content": "Determine if a 9x9 Sudoku board is valid (no duplicates in rows, columns, or 3x3 boxes).\n\nExample: Valid board returns true",
    "type": "multiple-choice",
    "category": "Problem Solving",
    "topic": "Medium Problems",
    "difficulty": "medium",
    "learningCardId": "problem-solving",
    "isActive": true,
    "createdAt": "2025-11-11T20:16:30.714Z",
    "updatedAt": "2025-11-11T20:16:30.714Z",
    "createdBy": "admin",
    "updatedBy": "admin",
    "tags": [
      "problem-solving",
      "algorithms",
      "javascript",
      "medium"
    ],
    "explanation": "Use hash sets to track seen numbers in each row, column, and 3x3 box. For each cell, check if the number exists in the corresponding row, column, and box sets. Since board is fixed 9x9, complexity is O(1).",
    "points": 15,
    "options": [
      {
        "id": "o1",
        "text": "Use three sets of hash maps: one for rows, one for columns, one for boxes. Check each cell against all three. Time: O(1) - fixed 81 cells, Space: O(1)",
        "isCorrect": true,
        "explanation": ""
      },
      {
        "id": "o2",
        "text": "Check each row, column, and box separately. Time: O(1), Space: O(1)",
        "isCorrect": true,
        "explanation": ""
      },
      {
        "id": "o3",
        "text": "Use nested loops to check all combinations. Time: O(n⁴), Space: O(1)",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "o4",
        "text": "Sort each row, column, and box. Time: O(1), Space: O(1)",
        "isCorrect": false,
        "explanation": ""
      }
    ],
    "hints": [
      "Think about the time and space complexity",
      "Consider edge cases (empty arrays, single elements, etc.)",
      "Try to solve it step by step"
    ],
    "metadata": {}
  },
  {
    "id": "problem-solving-medium-8",
    "title": "Find Longest Increasing Subsequence",
    "content": "Given an array, find the length of the longest strictly increasing subsequence.\n\nExample: [10, 9, 2, 5, 3, 7, 101, 18] → 4 ([2, 3, 7, 101])",
    "type": "multiple-choice",
    "category": "Problem Solving",
    "topic": "Medium Problems",
    "difficulty": "medium",
    "learningCardId": "problem-solving",
    "isActive": true,
    "createdAt": "2025-11-11T20:16:30.714Z",
    "updatedAt": "2025-11-11T20:16:30.714Z",
    "createdBy": "admin",
    "updatedBy": "admin",
    "tags": [
      "problem-solving",
      "algorithms",
      "javascript",
      "medium"
    ],
    "explanation": "Two approaches: 1) DP: for each element, check all previous elements and update LIS length. 2) Binary search: maintain array of smallest tail values, use binary search to find insertion point (more efficient O(n log n)).",
    "points": 15,
    "options": [
      {
        "id": "o1",
        "text": "Use dynamic programming: dp[i] = length of LIS ending at i. Time: O(n²), Space: O(n)",
        "isCorrect": true,
        "explanation": ""
      },
      {
        "id": "o2",
        "text": "Use binary search with patience sorting. Maintain array of smallest tail of increasing subsequences. Time: O(n log n), Space: O(n)",
        "isCorrect": true,
        "explanation": ""
      },
      {
        "id": "o3",
        "text": "Try all possible subsequences. Time: O(2ⁿ), Space: O(n)",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "o4",
        "text": "Sort array and find longest consecutive sequence. Time: O(n log n), Space: O(1)",
        "isCorrect": false,
        "explanation": ""
      }
    ],
    "hints": [
      "Think about the time and space complexity",
      "Consider edge cases (empty arrays, single elements, etc.)",
      "Try to solve it step by step"
    ],
    "metadata": {}
  },
  {
    "id": "problem-solving-medium-9",
    "title": "Minimum Coins to Make Amount",
    "content": "Given coins of different denominations and a total amount, find the minimum number of coins needed.\n\nExample: coins = [1, 2, 5], amount = 11 → 3 (5 + 5 + 1)",
    "type": "multiple-choice",
    "category": "Problem Solving",
    "topic": "Medium Problems",
    "difficulty": "medium",
    "learningCardId": "problem-solving",
    "isActive": true,
    "createdAt": "2025-11-11T20:16:30.714Z",
    "updatedAt": "2025-11-11T20:16:30.714Z",
    "createdBy": "admin",
    "updatedBy": "admin",
    "tags": [
      "problem-solving",
      "algorithms",
      "javascript",
      "medium"
    ],
    "explanation": "Use dynamic programming: create array dp where dp[i] represents minimum coins for amount i. Initialize dp[0] = 0. For each coin, update dp[i + coin] = min(dp[i + coin], dp[i] + 1).",
    "points": 15,
    "options": [
      {
        "id": "o1",
        "text": "Use dynamic programming: dp[i] = min coins for amount i. For each coin, update dp[i + coin]. Time: O(amount * coins.length), Space: O(amount)",
        "isCorrect": true,
        "explanation": ""
      },
      {
        "id": "o2",
        "text": "Use greedy: always pick largest coin. Time: O(amount), Space: O(1)",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "o3",
        "text": "Try all combinations using recursion. Time: O(2ⁿ), Space: O(n)",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "o4",
        "text": "Sort coins and use largest first. Time: O(n log n), Space: O(1)",
        "isCorrect": false,
        "explanation": ""
      }
    ],
    "hints": [
      "Think about the time and space complexity",
      "Consider edge cases (empty arrays, single elements, etc.)",
      "Try to solve it step by step"
    ],
    "metadata": {}
  },
  {
    "id": "problem-solving-medium-10",
    "title": "Find Word in 2D Grid",
    "content": "Given a 2D board and a word, determine if the word exists in the board (can move horizontally or vertically).\n\nExample: board with \"ABCE\", \"SFCS\", \"ADEE\" and word \"ABCCED\" → true",
    "type": "multiple-choice",
    "category": "Problem Solving",
    "topic": "Medium Problems",
    "difficulty": "medium",
    "learningCardId": "problem-solving",
    "isActive": true,
    "createdAt": "2025-11-11T20:16:30.714Z",
    "updatedAt": "2025-11-11T20:16:30.714Z",
    "createdBy": "admin",
    "updatedBy": "admin",
    "tags": [
      "problem-solving",
      "algorithms",
      "javascript",
      "medium"
    ],
    "explanation": "Use backtracking with DFS: for each cell matching first character, recursively search in all 4 directions. Mark cells as visited during recursion, unmark during backtracking. Return true if word found.",
    "points": 15,
    "options": [
      {
        "id": "o1",
        "text": "Use backtracking with DFS. For each cell, explore all directions, mark visited, backtrack. Time: O(m*n*4^L) where L is word length, Space: O(L)",
        "isCorrect": true,
        "explanation": ""
      },
      {
        "id": "o2",
        "text": "Try all possible paths using BFS. Time: O(m*n*4^L), Space: O(m*n)",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "o3",
        "text": "Check each cell independently. Time: O(m*n*L), Space: O(1)",
        "isCorrect": false,
        "explanation": ""
      },
      {
        "id": "o4",
        "text": "Convert board to string and search. Time: O(m*n), Space: O(m*n)",
        "isCorrect": false,
        "explanation": ""
      }
    ],
    "hints": [
      "Think about the time and space complexity",
      "Consider edge cases (empty arrays, single elements, etc.)",
      "Try to solve it step by step"
    ],
    "metadata": {}
  }
]