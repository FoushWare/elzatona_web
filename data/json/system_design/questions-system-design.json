[
  {
    "id": "q1",
    "title": "What are the different approaches for pagination in frontend?",
    "content": "Compare offset-based pagination, cursor-based pagination, and infinite scrolling. Which approach is better for large datasets?",
    "type": "multiple-choice",
    "category": "Data Flow",
    "subcategory": "Pagination",
    "difficulty": "intermediate",
    "topic": "Frontend System Design",
    "isActive": true,
    "createdAt": "2025-01-08T00:00:00Z",
    "updatedAt": "2025-01-08T00:00:00Z",
    "tags": ["pagination", "data-fetching"],
    "explanation": "Offset pagination is simple but slow at scale. Cursor pagination is efficient and consistent. Infinite scroll provides seamless UX but is harder for bookmarking and SEO.",
    "options": [
      {
        "id": "o1",
        "text": "Offset-based pagination",
        "isCorrect": true
      },
      {
        "id": "o2",
        "text": "Cursor-based pagination",
        "isCorrect": true
      },
      {
        "id": "o3",
        "text": "Infinite scrolling",
        "isCorrect": true
      },
      {
        "id": "o4",
        "text": "Randomized pagination",
        "isCorrect": false
      }
    ]
  },
  {
    "id": "q2",
    "title": "What is a signed URL for images?",
    "content": "Explain how signed URLs are used for secure and performant image delivery in frontend applications.",
    "type": "open-ended",
    "category": "Performance",
    "subcategory": "Network",
    "difficulty": "beginner",
    "topic": "Frontend System Design",
    "isActive": true,
    "createdAt": "2025-01-08T00:00:00Z",
    "updatedAt": "2025-01-08T00:00:00Z",
    "tags": ["signed-url", "cdn", "images"],
    "sampleAnswers": [
      "A signed URL is a temporary, cryptographically signed link that allows secure access to a file. It improves performance because the frontend can fetch directly from CDN/storage instead of proxying through the backend."
    ]
  },
  {
    "id": "q3",
    "title": "How can you apply critical CSS in frontend performance optimization?",
    "content": "Describe what critical CSS is and how to implement it.",
    "type": "open-ended",
    "category": "Performance",
    "subcategory": "Rendering",
    "difficulty": "intermediate",
    "topic": "Frontend System Design",
    "isActive": true,
    "createdAt": "2025-01-08T00:00:00Z",
    "updatedAt": "2025-01-08T00:00:00Z",
    "tags": ["css", "critical-css", "rendering"],
    "sampleAnswers": [
      "Critical CSS means extracting the styles needed for above-the-fold content and inlining them in the HTML. This reduces render-blocking requests and improves time-to-first-paint."
    ]
  },
  {
    "id": "q4",
    "title": "What are the trade-offs between SSR, CSR, and SSG?",
    "content": "Explain the differences between Server-Side Rendering (SSR), Client-Side Rendering (CSR), and Static Site Generation (SSG).",
    "type": "multiple-choice",
    "category": "Architecture",
    "subcategory": "Rendering Models",
    "difficulty": "intermediate",
    "topic": "Frontend System Design",
    "isActive": true,
    "createdAt": "2025-01-08T00:00:00Z",
    "updatedAt": "2025-01-08T00:00:00Z",
    "tags": ["ssr", "csr", "ssg", "performance"],
    "explanation": "SSR improves SEO and first load but increases server cost. CSR shifts load to client but may hurt SEO. SSG is fast but static.",
    "options": [
      {
        "id": "o1",
        "text": "SSR improves SEO but requires servers to render each request",
        "isCorrect": true
      },
      {
        "id": "o2",
        "text": "CSR improves interactivity but may delay first paint",
        "isCorrect": true
      },
      {
        "id": "o3",
        "text": "SSG pre-renders content, making it very fast for static pages",
        "isCorrect": true
      },
      {
        "id": "o4",
        "text": "CSR is always better than SSR",
        "isCorrect": false
      }
    ]
  },
  {
    "id": "q5",
    "title": "What is bundle splitting and why is it important?",
    "content": "Explain the concept of bundle splitting in frontend applications.",
    "type": "true-false",
    "category": "Performance",
    "subcategory": "JavaScript",
    "difficulty": "beginner",
    "topic": "Frontend System Design",
    "isActive": true,
    "createdAt": "2025-01-08T00:00:00Z",
    "updatedAt": "2025-01-08T00:00:00Z",
    "tags": ["javascript", "bundling", "performance"],
    "explanation": "Bundle splitting breaks the app into smaller chunks that can be loaded on demand, reducing initial load time.",
    "options": [
      {
        "id": "o1",
        "text": "Bundle splitting reduces initial load size by loading code on demand",
        "isCorrect": true
      },
      {
        "id": "o2",
        "text": "Bundle splitting always increases initial load time",
        "isCorrect": false
      }
    ]
  },
  {
    "id": "q6",
    "title": "What is the difference between Context API and Redux for state management?",
    "content": "Compare Context API and Redux when designing frontend system state flow.",
    "type": "open-ended",
    "category": "Architecture",
    "subcategory": "State Management",
    "difficulty": "intermediate",
    "topic": "Frontend System Design",
    "isActive": true,
    "createdAt": "2025-01-08T00:00:00Z",
    "updatedAt": "2025-01-08T00:00:00Z",
    "tags": ["redux", "context", "state-management"],
    "sampleAnswers": [
      "Context API is simple for small to medium apps with minimal boilerplate, but can cause re-renders. Redux provides structured state management and debugging tools, better for complex apps."
    ]
  },
  {
    "id": "q7",
    "title": "How do you optimize images for frontend performance?",
    "content": "List and explain techniques to improve image loading performance.",
    "type": "multiple-choice",
    "category": "Performance",
    "subcategory": "Network",
    "difficulty": "beginner",
    "topic": "Frontend System Design",
    "isActive": true,
    "createdAt": "2025-01-08T00:00:00Z",
    "updatedAt": "2025-01-08T00:00:00Z",
    "tags": ["images", "cdn", "performance"],
    "options": [
      {
        "id": "o1",
        "text": "Use WebP or AVIF formats",
        "isCorrect": true
      },
      {
        "id": "o2",
        "text": "Lazy load images below the fold",
        "isCorrect": true
      },
      {
        "id": "o3",
        "text": "Serve images via CDN with caching",
        "isCorrect": true
      },
      {
        "id": "o4",
        "text": "Always use raw PNGs without compression",
        "isCorrect": false
      }
    ],
    "explanation": "Using optimized formats, lazy loading, and CDNs reduces bandwidth and improves load times."
  },
  {
    "id": "q8",
    "title": "What are ARIA roles and why are they important?",
    "content": "Explain ARIA roles in accessibility design.",
    "type": "true-false",
    "category": "Accessibility",
    "subcategory": "ARIA",
    "difficulty": "beginner",
    "topic": "Frontend System Design",
    "isActive": true,
    "createdAt": "2025-01-08T00:00:00Z",
    "updatedAt": "2025-01-08T00:00:00Z",
    "tags": ["aria", "a11y", "accessibility"],
    "explanation": "ARIA roles provide semantic meaning for assistive technologies like screen readers.",
    "options": [
      {
        "id": "o1",
        "text": "ARIA roles improve accessibility for users with disabilities",
        "isCorrect": true
      },
      {
        "id": "o2",
        "text": "ARIA roles are only for styling elements with CSS",
        "isCorrect": false
      }
    ]
  },
  {
    "id": "q9",
    "title": "How do you design a component dependency graph from a Figma design?",
    "content": "Describe how to break down a Figma design into smaller components and map their dependencies.",
    "type": "open-ended",
    "category": "Architecture",
    "subcategory": "Component Design",
    "difficulty": "intermediate",
    "topic": "Frontend System Design",
    "isActive": true,
    "createdAt": "2025-01-08T00:00:00Z",
    "updatedAt": "2025-01-08T00:00:00Z",
    "tags": ["figma", "components", "dependency-graph"],
    "sampleAnswers": [
      "Start with high-level layout containers, identify reusable UI elements (buttons, cards, forms), then map parent-child relationships. Use a dependency graph to track composition and shared props."
    ]
  },
  {
    "id": "q10",
    "title": "What are different approaches for real-time data updates in frontend?",
    "content": "Compare long polling, WebSockets, and Server-Sent Events (SSE).",
    "type": "multiple-choice",
    "category": "Data Flow",
    "subcategory": "Real-Time",
    "difficulty": "advanced",
    "topic": "Frontend System Design",
    "isActive": true,
    "createdAt": "2025-01-08T00:00:00Z",
    "updatedAt": "2025-01-08T00:00:00Z",
    "tags": ["real-time", "websocket", "sse", "long-polling"],
    "explanation": "Long polling repeatedly requests updates. WebSockets provide bi-directional communication. SSE streams updates one way from server to client.",
    "options": [
      {
        "id": "o1",
        "text": "Long polling sends repeated HTTP requests to check for updates",
        "isCorrect": true
      },
      {
        "id": "o2",
        "text": "WebSockets provide full-duplex communication between client and server",
        "isCorrect": true
      },
      {
        "id": "o3",
        "text": "SSE is a one-way push from server to client",
        "isCorrect": true
      },
      {
        "id": "o4",
        "text": "WebSockets are always the best choice",
        "isCorrect": false
      }
    ]
  },
  // ========= Performance =========
  {
    "id": "q11",
    "title": "What is the difference between lazy loading and code splitting?",
    "content": "Explain how lazy loading and code splitting optimize performance.",
    "type": "multiple-choice",
    "category": "Performance",
    "subcategory": "JavaScript",
    "difficulty": "intermediate",
    "topic": "Frontend System Design",
    "isActive": true,
    "createdAt": "2025-01-08T00:00:00Z",
    "updatedAt": "2025-01-08T00:00:00Z",
    "tags": ["lazy-loading", "bundle-splitting", "performance"],
    "explanation": "Code splitting breaks the app into chunks. Lazy loading ensures chunks load only when needed.",
    "options": [
      {
        "id": "o1",
        "text": "Lazy loading delays loading of code/resources until needed",
        "isCorrect": true
      },
      {
        "id": "o2",
        "text": "Code splitting divides the app into smaller chunks",
        "isCorrect": true
      },
      {
        "id": "o3",
        "text": "They are the same concept with different names",
        "isCorrect": false
      }
    ]
  },
  {
    "id": "q12",
    "title": "What are Content Delivery Networks (CDNs) and why are they used?",
    "content": "Describe the role of a CDN in frontend performance.",
    "type": "true-false",
    "category": "Performance",
    "subcategory": "Network",
    "difficulty": "beginner",
    "topic": "Frontend System Design",
    "isActive": true,
    "createdAt": "2025-01-08T00:00:00Z",
    "updatedAt": "2025-01-08T00:00:00Z",
    "tags": ["cdn", "network", "performance"],
    "explanation": "CDNs reduce latency by caching and serving content closer to the user.",
    "options": [
      {
        "id": "o1",
        "text": "CDNs improve performance by serving content from geographically distributed servers",
        "isCorrect": true
      },
      {
        "id": "o2",
        "text": "CDNs make backend APIs faster by replacing servers",
        "isCorrect": false
      }
    ]
  },
  {
    "id": "q13",
    "title": "What is tree-shaking in JavaScript bundling?",
    "content": "Explain how tree-shaking improves frontend performance.",
    "type": "open-ended",
    "category": "Performance",
    "subcategory": "JavaScript",
    "difficulty": "intermediate",
    "topic": "Frontend System Design",
    "isActive": true,
    "createdAt": "2025-01-08T00:00:00Z",
    "updatedAt": "2025-01-08T00:00:00Z",
    "tags": ["javascript", "bundling", "optimization"],
    "sampleAnswers": [
      "Tree-shaking is the process of removing unused code from bundles during build time. It reduces bundle size and improves performance."
    ]
  },
  {
    "id": "q14",
    "title": "What are the main principles of accessibility in frontend design?",
    "content": "List core accessibility principles (POUR: Perceivable, Operable, Understandable, Robust).",
    "type": "multiple-choice",
    "category": "Accessibility",
    "subcategory": "WCAG",
    "difficulty": "beginner",
    "topic": "Frontend System Design",
    "isActive": true,
    "createdAt": "2025-01-08T00:00:00Z",
    "updatedAt": "2025-01-08T00:00:00Z",
    "tags": ["accessibility", "a11y", "wcag"],
    "explanation": "Accessibility guidelines are based on POUR principles.",
    "options": [
      {
        "id": "o1",
        "text": "Perceivable",
        "isCorrect": true
      },
      {
        "id": "o2",
        "text": "Operable",
        "isCorrect": true
      },
      {
        "id": "o3",
        "text": "Understandable",
        "isCorrect": true
      },
      {
        "id": "o4",
        "text": "Robust",
        "isCorrect": true
      },
      {
        "id": "o5",
        "text": "Fast",
        "isCorrect": false
      }
    ]
  },
  {
    "id": "q15",
    "title": "How do you ensure keyboard accessibility in components?",
    "content": "Explain best practices for making UI accessible via keyboard.",
    "type": "open-ended",
    "category": "Accessibility",
    "subcategory": "Keyboard",
    "difficulty": "intermediate",
    "topic": "Frontend System Design",
    "isActive": true,
    "createdAt": "2025-01-08T00:00:00Z",
    "updatedAt": "2025-01-08T00:00:00Z",
    "tags": ["keyboard", "accessibility", "a11y"],
    "sampleAnswers": [
      "Ensure focusable elements use tabindex correctly, use semantic HTML elements, and manage focus state when modals or dialogs open."
    ]
  },
  {
    "id": "q16",
    "title": "What are optimistic and pessimistic updates in frontend data flow?",
    "content": "Describe the difference between optimistic and pessimistic updates in state management.",
    "type": "multiple-choice",
    "category": "Data Flow",
    "subcategory": "State Management",
    "difficulty": "advanced",
    "topic": "Frontend System Design",
    "isActive": true,
    "createdAt": "2025-01-08T00:00:00Z",
    "updatedAt": "2025-01-08T00:00:00Z",
    "tags": ["state-management", "optimistic", "pessimistic"],
    "explanation": "Optimistic updates update UI immediately before server confirmation. Pessimistic updates wait for server response.",
    "options": [
      {
        "id": "o1",
        "text": "Optimistic update: update UI before server confirms",
        "isCorrect": true
      },
      {
        "id": "o2",
        "text": "Pessimistic update: update UI after server confirms",
        "isCorrect": true
      },
      {
        "id": "o3",
        "text": "Both approaches are identical",
        "isCorrect": false
      }
    ]
  },
  {
    "id": "q17",
    "title": "What are idempotent APIs and why are they important for frontend?",
    "content": "Explain idempotency in APIs and its impact on frontend state consistency.",
    "type": "open-ended",
    "category": "Data Flow",
    "subcategory": "API Design",
    "difficulty": "advanced",
    "topic": "Frontend System Design",
    "isActive": true,
    "createdAt": "2025-01-08T00:00:00Z",
    "updatedAt": "2025-01-08T00:00:00Z",
    "tags": ["api", "idempotent", "frontend"],
    "sampleAnswers": [
      "Idempotent APIs produce the same result no matter how many times they are called. They prevent duplicate state changes if frontend retries requests due to network issues."
    ]
  },
  {
    "id": "q18",
    "title": "What is hydration in React?",
    "content": "Explain how hydration works in React SSR.",
    "type": "true-false",
    "category": "Rendering",
    "subcategory": "SSR",
    "difficulty": "intermediate",
    "topic": "Frontend System Design",
    "isActive": true,
    "createdAt": "2025-01-08T00:00:00Z",
    "updatedAt": "2025-01-08T00:00:00Z",
    "tags": ["react", "hydration", "ssr"],
    "explanation": "Hydration attaches event listeners to pre-rendered HTML from SSR, making the page interactive.",
    "options": [
      {
        "id": "o1",
        "text": "Hydration makes static HTML interactive by attaching event listeners",
        "isCorrect": true
      },
      {
        "id": "o2",
        "text": "Hydration is about compressing HTML for faster delivery",
        "isCorrect": false
      }
    ]
  },
  {
    "id": "q19",
    "title": "What is the difference between virtual DOM and real DOM?",
    "content": "Describe how virtual DOM improves rendering performance in frontend frameworks.",
    "type": "open-ended",
    "category": "Rendering",
    "subcategory": "React/Virtual DOM",
    "difficulty": "beginner",
    "topic": "Frontend System Design",
    "isActive": true,
    "createdAt": "2025-01-08T00:00:00Z",
    "updatedAt": "2025-01-08T00:00:00Z",
    "tags": ["virtual-dom", "react", "performance"],
    "sampleAnswers": [
      "The virtual DOM is an in-memory representation of the UI. Instead of updating the real DOM directly, frameworks update the virtual DOM and compute the minimal changes, which are then applied to the real DOM."
    ]
  },
  {
    "id": "q20",
    "title": "What are micro-frontends and when would you use them?",
    "content": "Explain the concept of micro-frontends and their trade-offs.",
    "type": "multiple-choice",
    "category": "Architecture",
    "subcategory": "Micro-frontend",
    "difficulty": "advanced",
    "topic": "Frontend System Design",
    "isActive": true,
    "createdAt": "2025-01-08T00:00:00Z",
    "updatedAt": "2025-01-08T00:00:00Z",
    "tags": ["micro-frontend", "architecture"],
    "explanation": "Micro-frontends split the UI into smaller, independently deployable apps. They improve scalability but increase complexity.",
    "options": [
      {
        "id": "o1",
        "text": "Micro-frontends allow independent teams to build and deploy parts of the UI",
        "isCorrect": true
      },
      {
        "id": "o2",
        "text": "Micro-frontends always simplify performance optimization",
        "isCorrect": false
      },
      {
        "id": "o3",
        "text": "They increase architectural complexity",
        "isCorrect": true
      }
    ]
  },
  {
    "id": "q21",
    "title": "What is the difference between Client-Side Rendering (CSR), Server-Side Rendering (SSR), and Static Site Generation (SSG)?",
    "content": "Compare CSR, SSR, and SSG in terms of performance, SEO, and user experience.",
    "type": "multiple-choice",
    "category": "Rendering",
    "subcategory": "Frontend Architecture",
    "difficulty": "intermediate",
    "topic": "Rendering Strategies",
    "isActive": true,
    "createdAt": "2025-10-08T00:00:00Z",
    "updatedAt": "2025-10-08T00:00:00Z",
    "tags": ["csr", "ssr", "ssg", "frontend rendering"],
    "options": [
      {
        "id": "1",
        "text": "CSR loads JavaScript first and renders in the browser; SSR renders HTML on the server per request; SSG pre-renders HTML at build time.",
        "isCorrect": true,
        "explanation": "CSR delays first render but enables rich interactivity; SSR improves SEO and first load but adds server cost; SSG is best for static content with CDN delivery."
      },
      {
        "id": "2",
        "text": "CSR is faster than SSR in all cases.",
        "isCorrect": false
      },
      {
        "id": "3",
        "text": "SSG cannot be cached on CDN.",
        "isCorrect": false
      }
    ],
    "explanation": "CSR is good for highly interactive apps, SSR helps SEO-driven apps like e-commerce, and SSG is ideal for blogs, docs, and marketing sites.",
    "sampleAnswers": [
      "CSR = client-side execution, SSR = server renders per request, SSG = build-time pre-rendering."
    ]
  },
  {
    "id": "q22",
    "title": "What are frontend caching strategies?",
    "content": "Discuss strategies like browser cache, CDN cache, service workers, and caching APIs.",
    "type": "open-ended",
    "category": "Performance",
    "subcategory": "Caching",
    "difficulty": "intermediate",
    "topic": "Caching",
    "isActive": true,
    "createdAt": "2025-10-08T00:00:00Z",
    "updatedAt": "2025-10-08T00:00:00Z",
    "tags": ["caching", "frontend performance", "cdn"],
    "explanation": "Caching reduces redundant network requests and speeds up page loads. Browser caching handles static assets, CDN caching distributes content closer to users, and service workers enable offline support.",
    "hints": [
      "Think of caching at multiple layers: browser, CDN, service worker."
    ],
    "sampleAnswers": [
      "Use browser caching with Cache-Control headers, CDN caching for static assets, and service workers for offline support."
    ]
  },
  {
    "id": "q23",
    "title": "What is a Content Delivery Network (CDN) and how does it improve frontend performance?",
    "content": "Explain the role of CDNs in reducing latency and improving availability.",
    "type": "true-false",
    "category": "Performance",
    "subcategory": "CDN",
    "difficulty": "beginner",
    "topic": "Content Delivery",
    "isActive": true,
    "createdAt": "2025-10-08T00:00:00Z",
    "updatedAt": "2025-10-08T00:00:00Z",
    "tags": ["cdn", "performance", "latency"],
    "options": [
      {
        "id": "1",
        "text": "A CDN reduces latency by serving content from edge servers close to the user.",
        "isCorrect": true,
        "explanation": "CDNs cache static files at edge locations globally to reduce round-trip times."
      },
      {
        "id": "2",
        "text": "A CDN always replaces the need for backend servers.",
        "isCorrect": false
      }
    ],
    "explanation": "CDNs accelerate delivery of static files (CSS, JS, images, videos) and improve fault tolerance.",
    "sampleAnswers": [
      "A CDN caches and serves assets from geographically closer servers."
    ]
  },
  {
    "id": "q24",
    "title": "What is lazy loading and how does it improve frontend performance?",
    "content": "Explain lazy loading for images, components, and modules in a web app.",
    "type": "multiple-choice",
    "category": "Performance",
    "subcategory": "Loading Optimization",
    "difficulty": "beginner",
    "topic": "Lazy Loading",
    "isActive": true,
    "createdAt": "2025-10-08T00:00:00Z",
    "updatedAt": "2025-10-08T00:00:00Z",
    "tags": ["lazy loading", "performance", "web optimization"],
    "options": [
      {
        "id": "1",
        "text": "Lazy loading defers the loading of non-critical resources until they are needed.",
        "isCorrect": true,
        "explanation": "Helps reduce initial load time and improves perceived performance."
      },
      {
        "id": "2",
        "text": "Lazy loading means loading all resources as early as possible.",
        "isCorrect": false
      },
      {
        "id": "3",
        "text": "Lazy loading only applies to JavaScript modules, not images.",
        "isCorrect": false
      }
    ],
    "explanation": "Lazy loading is especially useful for images, videos, and code-splitting in large applications.",
    "sampleAnswers": [
      "Lazy loading delays loading of resources until needed, improving first paint performance."
    ]
  },
  {
    "id": "q25",
    "title": "What is tree-shaking in frontend build optimization?",
    "content": "Explain how tree-shaking helps in reducing bundle size and when it is most effective.",
    "type": "multiple-choice",
    "category": "Performance",
    "subcategory": "JavaScript Optimization",
    "difficulty": "intermediate",
    "topic": "Frontend System Design",
    "isActive": true,
    "createdAt": "2025-01-08T00:00:00Z",
    "updatedAt": "2025-01-08T00:00:00Z",
    "tags": ["tree-shaking", "webpack", "bundling"],
    "explanation": "Tree-shaking removes unused code from bundles. It works best with ES6 module imports.",
    "options": [
      {
        "id": "o1",
        "text": "Removes unused CSS from the DOM",
        "isCorrect": false
      },
      {
        "id": "o2",
        "text": "Removes unused JavaScript exports from bundles",
        "isCorrect": true
      },
      {
        "id": "o3",
        "text": "Shakes DOM nodes to re-render faster",
        "isCorrect": false
      },
      {
        "id": "o4",
        "text": "Optimizes images automatically",
        "isCorrect": false
      }
    ]
  },
  {
    "id": "q26",
    "title": "What are Web Workers and when should you use them?",
    "content": "Discuss how Web Workers improve performance in web applications and provide an example use case.",
    "type": "open-ended",
    "category": "Performance",
    "subcategory": "JavaScript Optimization",
    "difficulty": "intermediate",
    "topic": "Frontend System Design",
    "isActive": true,
    "createdAt": "2025-01-08T00:00:00Z",
    "updatedAt": "2025-01-08T00:00:00Z",
    "tags": ["web-workers", "parallelism", "performance"],
    "sampleAnswers": [
      "Web Workers run scripts in background threads separate from the main UI thread. They are useful for CPU-intensive tasks like parsing large JSON, image processing, or data transformations without blocking the UI."
    ]
  },
  {
    "id": "q27",
    "title": "What is code splitting and how is it different from tree-shaking?",
    "content": "Explain the concept of code splitting and compare it with tree-shaking.",
    "type": "true-false",
    "category": "Performance",
    "subcategory": "Bundling",
    "difficulty": "beginner",
    "topic": "Frontend System Design",
    "isActive": true,
    "createdAt": "2025-01-08T00:00:00Z",
    "updatedAt": "2025-01-08T00:00:00Z",
    "tags": ["code-splitting", "performance", "webpack"],
    "explanation": "Code splitting splits bundles into smaller chunks loaded on demand, while tree-shaking removes unused code.",
    "options": [
      {
        "id": "o1",
        "text": "Code splitting reduces bundle size by removing unused code",
        "isCorrect": false
      },
      {
        "id": "o2",
        "text": "Code splitting loads code in chunks only when needed",
        "isCorrect": true
      }
    ]
  },
  {
    "id": "q28",
    "title": "What is prefetching vs preloading in frontend performance?",
    "content": "Explain how prefetch and preload directives differ in terms of resource loading strategy.",
    "type": "multiple-choice",
    "category": "Performance",
    "subcategory": "Network Optimization",
    "difficulty": "advanced",
    "topic": "Frontend System Design",
    "isActive": true,
    "createdAt": "2025-01-08T00:00:00Z",
    "updatedAt": "2025-01-08T00:00:00Z",
    "tags": ["prefetch", "preload", "performance"],
    "explanation": "Prefetch loads resources for future navigation, while preload ensures critical resources are fetched earlier for the current page.",
    "options": [
      {
        "id": "o1",
        "text": "Prefetch is for resources needed immediately",
        "isCorrect": false
      },
      {
        "id": "o2",
        "text": "Preload is for resources needed immediately",
        "isCorrect": true
      },
      {
        "id": "o3",
        "text": "Prefetch is for resources likely needed in future",
        "isCorrect": true
      },
      {
        "id": "o4",
        "text": "Preload defers resources until user interaction",
        "isCorrect": false
      }
    ]
  },
  {
    "id": "q29",
    "title": "What is the purpose of ARIA roles in frontend design?",
    "content": "Explain how ARIA roles help assistive technologies interpret UI components.",
    "type": "open-ended",
    "category": "Accessibility",
    "subcategory": "ARIA",
    "difficulty": "beginner",
    "topic": "Frontend System Design",
    "isActive": true,
    "createdAt": "2025-01-08T00:00:00Z",
    "updatedAt": "2025-01-08T00:00:00Z",
    "tags": ["aria", "a11y", "accessibility"],
    "sampleAnswers": [
      "ARIA roles provide semantic information about elements to assistive technologies, improving accessibility for screen readers and keyboard navigation."
    ]
  },
  {
    "id": "q30",
    "title": "What are semantic HTML elements and why are they important for accessibility?",
    "content": "Discuss how semantic HTML improves usability and accessibility.",
    "type": "multiple-choice",
    "category": "Accessibility",
    "subcategory": "HTML",
    "difficulty": "beginner",
    "topic": "Frontend System Design",
    "isActive": true,
    "createdAt": "2025-01-08T00:00:00Z",
    "updatedAt": "2025-01-08T00:00:00Z",
    "tags": ["semantic-html", "a11y", "accessibility"],
    "explanation": "Semantic elements like `<header>`, `<nav>`, `<main>` provide meaning, improving navigation for assistive technologies.",
    "options": [
      {
        "id": "o1",
        "text": "Semantic HTML improves SEO",
        "isCorrect": true
      },
      {
        "id": "o2",
        "text": "Semantic HTML is ignored by screen readers",
        "isCorrect": false
      },
      {
        "id": "o3",
        "text": "Semantic HTML improves accessibility for keyboard and screen reader users",
        "isCorrect": true
      },
      {
        "id": "o4",
        "text": "Semantic HTML automatically optimizes bundle size",
        "isCorrect": false
      }
    ]
  },
  {
    "id": "q31",
    "title": "What is color contrast and how does it affect accessibility?",
    "content": "Explain the importance of sufficient color contrast in frontend UI design.",
    "type": "open-ended",
    "category": "Accessibility",
    "subcategory": "Visual",
    "difficulty": "intermediate",
    "topic": "Frontend System Design",
    "isActive": true,
    "createdAt": "2025-01-08T00:00:00Z",
    "updatedAt": "2025-01-08T00:00:00Z",
    "tags": ["color-contrast", "a11y", "accessibility"],
    "sampleAnswers": [
      "Color contrast ensures that text and UI elements are distinguishable for users with visual impairments. WCAG recommends a minimum contrast ratio of 4.5:1 for normal text."
    ]
  },
  {
    "id": "q32",
    "title": "How can you ensure keyboard navigability for custom components?",
    "content": "Describe best practices to make interactive components accessible via keyboard.",
    "type": "open-ended",
    "category": "Accessibility",
    "subcategory": "Keyboard",
    "difficulty": "intermediate",
    "topic": "Frontend System Design",
    "isActive": true,
    "createdAt": "2025-01-08T00:00:00Z",
    "updatedAt": "2025-01-08T00:00:00Z",
    "tags": ["keyboard-accessibility", "custom-components", "a11y"],
    "sampleAnswers": [
      "Ensure focusable elements have `tabindex`, use `aria` attributes correctly, manage focus order for dialogs/modals, and provide keyboard shortcuts where necessary."
    ]
  },
  {
    "id": "q33",
    "title": "What is an optimistic update in frontend state management?",
    "content": "Explain optimistic updates and when they are used.",
    "type": "open-ended",
    "category": "Data Flow",
    "subcategory": "State Management",
    "difficulty": "intermediate",
    "topic": "Frontend System Design",
    "isActive": true,
    "createdAt": "2025-01-08T00:00:00Z",
    "updatedAt": "2025-01-08T00:00:00Z",
    "tags": ["optimistic-update", "state-management", "frontend"],
    "sampleAnswers": [
      "Optimistic updates immediately update the UI assuming the server request will succeed. If the request fails, the UI is reverted. It improves perceived responsiveness."
    ]
  },
  {
    "id": "q34",
    "title": "What is a pessimistic update in frontend state management?",
    "content": "Explain pessimistic updates and how they differ from optimistic updates.",
    "type": "open-ended",
    "category": "Data Flow",
    "subcategory": "State Management",
    "difficulty": "intermediate",
    "topic": "Frontend System Design",
    "isActive": true,
    "createdAt": "2025-01-08T00:00:00Z",
    "updatedAt": "2025-01-08T00:00:00Z",
    "tags": ["pessimistic-update", "state-management", "frontend"],
    "sampleAnswers": [
      "Pessimistic updates wait for server confirmation before updating the UI. This ensures consistency but may feel slower to the user."
    ]
  },
  {
    "id": "q35",
    "title": "What is long-polling and when would you use it?",
    "content": "Explain how long-polling works for real-time updates.",
    "type": "multiple-choice",
    "category": "Data Flow",
    "subcategory": "Real-Time",
    "difficulty": "intermediate",
    "topic": "Frontend System Design",
    "isActive": true,
    "createdAt": "2025-01-08T00:00:00Z",
    "updatedAt": "2025-01-08T00:00:00Z",
    "tags": ["long-polling", "real-time", "frontend"],
    "explanation": "Long-polling keeps an HTTP request open until the server has data, then immediately sends a new request for the next update.",
    "options": [
      {
        "id": "o1",
        "text": "Client repeatedly sends requests at a fixed interval",
        "isCorrect": false
      },
      {
        "id": "o2",
        "text": "Client sends a request, server responds only when new data is available, then client repeats",
        "isCorrect": true
      },
      {
        "id": "o3",
        "text": "Client uses WebSocket connection for continuous streaming",
        "isCorrect": false
      }
    ]
  },
  {
    "id": "q36",
    "title": "What is WebSocket and why is it used in frontend apps?",
    "content": "Explain the WebSocket protocol and its benefits for real-time communication.",
    "type": "open-ended",
    "category": "Data Flow",
    "subcategory": "Real-Time",
    "difficulty": "intermediate",
    "topic": "Frontend System Design",
    "isActive": true,
    "createdAt": "2025-01-08T00:00:00Z",
    "updatedAt": "2025-01-08T00:00:00Z",
    "tags": ["websocket", "real-time", "frontend"],
    "sampleAnswers": [
      "WebSocket establishes a persistent bidirectional connection between client and server, allowing real-time updates with lower overhead compared to HTTP polling."
    ]
  },
  {
    "id": "q37",
    "title": "What are Server-Sent Events (SSE) and when should they be used?",
    "content": "Explain SSE and how it differs from WebSocket.",
    "type": "multiple-choice",
    "category": "Data Flow",
    "subcategory": "Real-Time",
    "difficulty": "intermediate",
    "topic": "Frontend System Design",
    "isActive": true,
    "createdAt": "2025-01-08T00:00:00Z",
    "updatedAt": "2025-01-08T00:00:00Z",
    "tags": ["sse", "real-time", "frontend"],
    "explanation": "SSE provides a unidirectional stream of updates from server to client over HTTP.",
    "options": [
      {
        "id": "o1",
        "text": "SSE is unidirectional (server -> client)",
        "isCorrect": true
      },
      {
        "id": "o2",
        "text": "WebSocket is bidirectional (client <-> server)",
        "isCorrect": true
      },
      {
        "id": "o3",
        "text": "SSE requires a persistent TCP connection like WebSocket",
        "isCorrect": false
      }
    ]
  },
  {
    "id": "q38",
    "title": "How do you design a frontend entity for a Post with Comments and Media?",
    "content": "Describe the structure of a frontend entity object for a Post.",
    "type": "open-ended",
    "category": "Data Modeling",
    "subcategory": "Entities",
    "difficulty": "intermediate",
    "topic": "Frontend System Design",
    "isActive": true,
    "createdAt": "2025-01-08T00:00:00Z",
    "updatedAt": "2025-01-08T00:00:00Z",
    "tags": ["entity", "data-model", "frontend"],
    "sampleAnswers": [
      "Normalize entities: store posts in a dictionary keyed by id, store comments separately keyed by id, reference relationships via ids to reduce duplication and simplify updates."
    ]
  },
  {
    "id": "q39",
    "title": "What is the difference between REST and GraphQL APIs for frontend consumption?",
    "content": "Compare REST and GraphQL in terms of data fetching and flexibility.",
    "type": "multiple-choice",
    "category": "Data Flow",
    "subcategory": "API Design",
    "difficulty": "intermediate",
    "topic": "Frontend System Design",
    "isActive": true,
    "createdAt": "2025-01-08T00:00:00Z",
    "updatedAt": "2025-01-08T00:00:00Z",
    "tags": ["rest", "graphql", "api"],
    "options": [
      {
        "id": "o1",
        "text": "REST returns fixed data structures per endpoint",
        "isCorrect": true
      },
      {
        "id": "o2",
        "text": "GraphQL allows client to request exactly the fields needed",
        "isCorrect": true
      },
      {
        "id": "o3",
        "text": "GraphQL cannot support real-time updates",
        "isCorrect": false
      },
      {
        "id": "o4",
        "text": "REST APIs can never be cached",
        "isCorrect": false
      }
    ]
  },
  {
    "id": "q40",
    "title": "How do you handle real-time updates for a feed of posts?",
    "content": "Discuss strategies for updating the UI when new posts or comments arrive.",
    "type": "open-ended",
    "category": "Data Flow",
    "subcategory": "Real-Time UI",
    "difficulty": "advanced",
    "topic": "Frontend System Design",
    "isActive": true,
    "createdAt": "2025-01-08T00:00:00Z",
    "updatedAt": "2025-01-08T00:00:00Z",
    "tags": ["real-time", "frontend", "feed"],
    "sampleAnswers": [
      "Use WebSockets or SSE to push updates, update frontend state optimistically, maintain a local cache, and optionally batch updates to reduce re-renders."
    ]
  },
  {
    "id": "q41",
    "title": "What is critical CSS and how do you apply it?",
    "content": "Explain the concept of critical CSS and how it improves page load performance.",
    "type": "open-ended",
    "category": "Performance",
    "subcategory": "Rendering Optimization",
    "difficulty": "intermediate",
    "topic": "Frontend System Design",
    "isActive": true,
    "createdAt": "2025-01-08T00:00:00Z",
    "updatedAt": "2025-01-08T00:00:00Z",
    "tags": ["critical-css", "rendering", "performance"],
    "sampleAnswers": [
      "Critical CSS is the CSS required to render above-the-fold content. Load it inline in the HTML to reduce render-blocking, while deferring non-critical CSS."
    ]
  },
  {
    "id": "q42",
    "title": "What are signed URLs for images and why are they used?",
    "content": "Explain the purpose of signed URLs and their impact on security and performance.",
    "type": "open-ended",
    "category": "Performance",
    "subcategory": "Network Optimization",
    "difficulty": "intermediate",
    "topic": "Frontend System Design",
    "isActive": true,
    "createdAt": "2025-01-08T00:00:00Z",
    "updatedAt": "2025-01-08T00:00:00Z",
    "tags": ["signed-url", "images", "security", "cdn"],
    "sampleAnswers": [
      "Signed URLs provide temporary, time-limited access to private resources (like images) on CDNs. They ensure secure access while allowing caching and CDN optimization."
    ]
  },
  {
    "id": "q43",
    "title": "What are different approaches for pagination and which is better?",
    "content": "Compare offset-based, cursor-based, and infinite scroll pagination in frontend apps.",
    "type": "multiple-choice",
    "category": "Data Flow",
    "subcategory": "Pagination",
    "difficulty": "intermediate",
    "topic": "Frontend System Design",
    "isActive": true,
    "createdAt": "2025-01-08T00:00:00Z",
    "updatedAt": "2025-01-08T00:00:00Z",
    "tags": ["pagination", "frontend", "api"],
    "explanation": "Offset-based pagination is simple but can have duplicates on fast-changing data. Cursor-based is more reliable for real-time feeds. Infinite scroll is UX dependent.",
    "options": [
      {
        "id": "o1",
        "text": "Offset-based: simple, can have duplicates",
        "isCorrect": true
      },
      {
        "id": "o2",
        "text": "Cursor-based: more reliable for dynamic data",
        "isCorrect": true
      },
      {
        "id": "o3",
        "text": "Infinite scroll: UX-friendly but can be tricky to manage state",
        "isCorrect": true
      },
      {
        "id": "o4",
        "text": "All approaches are identical in performance",
        "isCorrect": false
      }
    ]
  },
  {
    "id": "q44",
    "title": "How do you optimize image loading in frontend apps?",
    "content": "Explain techniques like WebP format, responsive images, lazy loading, and CDN caching.",
    "type": "open-ended",
    "category": "Performance",
    "subcategory": "Image Optimization",
    "difficulty": "intermediate",
    "topic": "Frontend System Design",
    "isActive": true,
    "createdAt": "2025-01-08T00:00:00Z",
    "updatedAt": "2025-01-08T00:00:00Z",
    "tags": ["images", "optimization", "webp", "cdn"],
    "sampleAnswers": [
      "Use modern formats like WebP, serve different resolutions with `srcset`, lazy load offscreen images, compress images, and cache via CDN."
    ]
  },
  {
    "id": "q45",
    "title": "How do you improve rendering performance for large lists?",
    "content": "Discuss techniques like windowing, virtualization, and memoization for list rendering.",
    "type": "open-ended",
    "category": "Performance",
    "subcategory": "Rendering Optimization",
    "difficulty": "advanced",
    "topic": "Frontend System Design",
    "isActive": true,
    "createdAt": "2025-01-08T00:00:00Z",
    "updatedAt": "2025-01-08T00:00:00Z",
    "tags": ["list-rendering", "virtualization", "windowing", "react"],
    "sampleAnswers": [
      "Use libraries like react-window or react-virtualized to render only visible items, memoize list items to avoid unnecessary re-renders, and paginate data if possible."
    ]
  },
  {
    "id": "q46",
    "title": "What is the difference between reflow and repaint in the browser?",
    "content": "Explain how reflow and repaint affect rendering performance.",
    "type": "multiple-choice",
    "category": "Performance",
    "subcategory": "Rendering Optimization",
    "difficulty": "intermediate",
    "topic": "Frontend System Design",
    "isActive": true,
    "createdAt": "2025-01-08T00:00:00Z",
    "updatedAt": "2025-01-08T00:00:00Z",
    "tags": ["reflow", "repaint", "performance", "browser"],
    "options": [
      {
        "id": "o1",
        "text": "Reflow recalculates layout and can trigger repaint",
        "isCorrect": true
      },
      {
        "id": "o2",
        "text": "Repaint only redraws pixels without layout calculation",
        "isCorrect": true
      },
      {
        "id": "o3",
        "text": "Reflow and repaint are the same",
        "isCorrect": false
      }
    ]
  },
  {
    "id": "q47",
    "title": "How can HTTPS help with frontend performance?",
    "content": "Explain performance benefits of HTTPS beyond security.",
    "type": "open-ended",
    "category": "Performance",
    "subcategory": "Network Optimization",
    "difficulty": "beginner",
    "topic": "Frontend System Design",
    "isActive": true,
    "createdAt": "2025-01-08T00:00:00Z",
    "updatedAt": "2025-01-08T00:00:00Z",
    "tags": ["https", "performance", "network"],
    "sampleAnswers": [
      "HTTPS enables HTTP/2 or HTTP/3 which supports multiplexing, header compression, and better caching, improving load performance."
    ]
  },
  {
    "id": "q48",
    "title": "What is bundle splitting and why is it important?",
    "content": "Explain how splitting JavaScript bundles improves performance.",
    "type": "open-ended",
    "category": "Performance",
    "subcategory": "JavaScript Optimization",
    "difficulty": "intermediate",
    "topic": "Frontend System Design",
    "isActive": true,
    "createdAt": "2025-01-08T00:00:00Z",
    "updatedAt": "2025-01-08T00:00:00Z",
    "tags": ["bundle-splitting", "performance", "javascript"],
    "sampleAnswers": [
      "Bundle splitting breaks the app into smaller chunks, allowing the browser to load only necessary code on demand, reducing initial load time."
    ]
  },
  {
    "id": "q49",
    "title": "What is memoization in React and when should you use it?",
    "content": "Explain how memoization improves rendering performance in React.",
    "type": "open-ended",
    "category": "Performance",
    "subcategory": "Rendering Optimization",
    "difficulty": "intermediate",
    "topic": "Frontend System Design",
    "isActive": true,
    "createdAt": "2025-01-08T00:00:00Z",
    "updatedAt": "2025-01-08T00:00:00Z",
    "tags": ["memoization", "react", "performance"],
    "sampleAnswers": [
      "Memoization (using React.memo, useMemo, or useCallback) avoids unnecessary re-rendering of components or expensive calculations when props/state havenâ€™t changed."
    ]
  },
  {
    "id": "q50",
    "title": "What is infinite scroll and what are its pros and cons?",
    "content": "Explain how infinite scroll works and its impact on UX and performance.",
    "type": "multiple-choice",
    "category": "Data Flow",
    "subcategory": "Pagination",
    "difficulty": "intermediate",
    "topic": "Frontend System Design",
    "isActive": true,
    "createdAt": "2025-01-08T00:00:00Z",
    "updatedAt": "2025-01-08T00:00:00Z",
    "tags": ["infinite-scroll", "pagination", "ux"],
    "options": [
      {
        "id": "o1",
        "text": "Infinite scroll automatically loads more content as user scrolls",
        "isCorrect": true
      },
      {
        "id": "o2",
        "text": "Pros: improves UX for browsing feeds, keeps engagement high",
        "isCorrect": true
      },
      {
        "id": "o3",
        "text": "Cons: harder to track scroll position and can impact memory",
        "isCorrect": true
      },
      {
        "id": "o4",
        "text": "Infinite scroll replaces the need for backend pagination",
        "isCorrect": false
      }
    ]
  },
  {
    "id": "q51",
    "title": "How do you decide when to break a UI into smaller components?",
    "content": "Explain criteria for dividing a large component into smaller reusable components.",
    "type": "open-ended",
    "category": "Component Architecture",
    "subcategory": "Design Patterns",
    "difficulty": "intermediate",
    "topic": "Frontend System Design",
    "isActive": true,
    "createdAt": "2025-01-08T00:00:00Z",
    "updatedAt": "2025-01-08T00:00:00Z",
    "tags": ["component-design", "architecture", "reusability"],
    "sampleAnswers": [
      "Break components when parts are reusable, have independent state, or to improve readability and maintainability. Follow Single Responsibility Principle and avoid deep prop drilling."
    ]
  },
  {
    "id": "q52",
    "title": "What is the difference between controlled and uncontrolled components in React?",
    "content": "Explain how controlled and uncontrolled components manage state.",
    "type": "multiple-choice",
    "category": "State Management",
    "subcategory": "React",
    "difficulty": "beginner",
    "topic": "Frontend System Design",
    "isActive": true,
    "createdAt": "2025-01-08T00:00:00Z",
    "updatedAt": "2025-01-08T00:00:00Z",
    "tags": ["react", "state", "controlled-components"],
    "options": [
      {
        "id": "o1",
        "text": "Controlled components have state managed by React via props",
        "isCorrect": true
      },
      {
        "id": "o2",
        "text": "Uncontrolled components manage state internally using refs",
        "isCorrect": true
      },
      {
        "id": "o3",
        "text": "Controlled components are faster than uncontrolled in all cases",
        "isCorrect": false
      }
    ]
  },
  {
    "id": "q53",
    "title": "What is Redux and when should you use it?",
    "content": "Explain Redux for state management and use cases for global state.",
    "type": "open-ended",
    "category": "State Management",
    "subcategory": "Global State",
    "difficulty": "intermediate",
    "topic": "Frontend System Design",
    "isActive": true,
    "createdAt": "2025-01-08T00:00:00Z",
    "updatedAt": "2025-01-08T00:00:00Z",
    "tags": ["redux", "state-management", "frontend"],
    "sampleAnswers": [
      "Redux is a predictable state container for JavaScript apps, useful for managing global state shared across multiple components, especially in large or complex apps."
    ]
  },
  {
    "id": "q54",
    "title": "What are the differences between local state, global state, and server state?",
    "content": "Explain how different state types are managed and synchronized.",
    "type": "multiple-choice",
    "category": "State Management",
    "subcategory": "State Types",
    "difficulty": "intermediate",
    "topic": "Frontend System Design",
    "isActive": true,
    "createdAt": "2025-01-08T00:00:00Z",
    "updatedAt": "2025-01-08T00:00:00Z",
    "tags": ["state", "frontend", "global-state", "server-state"],
    "options": [
      {
        "id": "o1",
        "text": "Local state is component-specific",
        "isCorrect": true
      },
      {
        "id": "o2",
        "text": "Global state is shared across multiple components",
        "isCorrect": true
      },
      {
        "id": "o3",
        "text": "Server state comes from APIs and must be synchronized",
        "isCorrect": true
      },
      {
        "id": "o4",
        "text": "All states are automatically synchronized with the server",
        "isCorrect": false
      }
    ]
  },
  {
    "id": "q55",
    "title": "How do you structure a component dependency graph from a Figma design?",
    "content": "Describe the process of identifying components and their hierarchy from design files.",
    "type": "open-ended",
    "category": "Component Architecture",
    "subcategory": "Design Patterns",
    "difficulty": "advanced",
    "topic": "Frontend System Design",
    "isActive": true,
    "createdAt": "2025-01-08T00:00:00Z",
    "updatedAt": "2025-01-08T00:00:00Z",
    "tags": ["component-graph", "figma", "frontend"],
    "sampleAnswers": [
      "Analyze the design, identify repeated patterns, break down UI into smallest reusable components, map dependencies, and visualize parent-child relationships in a graph."
    ]
  },
  {
    "id": "q56",
    "title": "What are the best practices for designing reusable UI components?",
    "content": "Discuss principles for making components modular and reusable.",
    "type": "open-ended",
    "category": "Component Architecture",
    "subcategory": "Reusability",
    "difficulty": "intermediate",
    "topic": "Frontend System Design",
    "isActive": true,
    "createdAt": "2025-01-08T00:00:00Z",
    "updatedAt": "2025-01-08T00:00:00Z",
    "tags": ["reusable-components", "ui-design", "frontend"],
    "sampleAnswers": [
      "Keep components focused on a single responsibility, accept props for configuration, avoid hardcoding styles or behavior, and make them testable and composable."
    ]
  },
  {
    "id": "q57",
    "title": "What is the difference between REST and GraphQL when designing frontend APIs?",
    "content": "Explain how each API style affects data fetching, over-fetching, and frontend flexibility.",
    "type": "multiple-choice",
    "category": "API Design",
    "subcategory": "Frontend APIs",
    "difficulty": "intermediate",
    "topic": "Frontend System Design",
    "isActive": true,
    "createdAt": "2025-01-08T00:00:00Z",
    "updatedAt": "2025-01-08T00:00:00Z",
    "tags": ["api", "rest", "graphql", "frontend"],
    "options": [
      {
        "id": "o1",
        "text": "REST endpoints return fixed data structures",
        "isCorrect": true
      },
      {
        "id": "o2",
        "text": "GraphQL allows querying only required fields",
        "isCorrect": true
      },
      {
        "id": "o3",
        "text": "GraphQL eliminates the need for pagination",
        "isCorrect": false
      }
    ]
  },
  {
    "id": "q58",
    "title": "How do you design a frontend data store for posts and comments?",
    "content": "Explain the structure and normalization strategies for storing related entities in frontend state.",
    "type": "open-ended",
    "category": "Data Store",
    "subcategory": "Entities",
    "difficulty": "advanced",
    "topic": "Frontend System Design",
    "isActive": true,
    "createdAt": "2025-01-08T00:00:00Z",
    "updatedAt": "2025-01-08T00:00:00Z",
    "tags": ["data-store", "state-management", "entities", "normalization"],
    "sampleAnswers": [
      "Normalize entities: store posts in a dictionary keyed by id, store comments separately keyed by id, reference relationships via ids to reduce duplication and simplify updates."
    ]
  },
  {
    "id": "q59",
    "title": "How do you handle data caching in frontend applications?",
    "content": "Explain strategies for caching API responses and syncing with the server.",
    "type": "open-ended",
    "category": "Data Store",
    "subcategory": "Caching",
    "difficulty": "intermediate",
    "topic": "Frontend System Design",
    "isActive": true,
    "createdAt": "2025-01-08T00:00:00Z",
    "updatedAt": "2025-01-08T00:00:00Z",
    "tags": ["caching", "frontend", "api"],
    "sampleAnswers": [
      "Use in-memory stores, IndexedDB, or libraries like React Query / SWR to cache API responses, invalidate stale data, and optionally persist cache across sessions."
    ]
  },
  {
    "id": "q60",
    "title": "What is the difference between localStorage, sessionStorage, and IndexedDB?",
    "content": "Explain when to use each browser storage type for frontend data persistence.",
    "type": "multiple-choice",
    "category": "Data Store",
    "subcategory": "Browser Storage",
    "difficulty": "beginner",
    "topic": "Frontend System Design",
    "isActive": true,
    "createdAt": "2025-01-08T00:00:00Z",
    "updatedAt": "2025-01-08T00:00:00Z",
    "tags": ["storage", "localstorage", "indexeddb", "frontend"],
    "options": [
      {
        "id": "o1",
        "text": "localStorage persists data indefinitely across sessions",
        "isCorrect": true
      },
      {
        "id": "o2",
        "text": "sessionStorage persists data only for the session",
        "isCorrect": true
      },
      {
        "id": "o3",
        "text": "IndexedDB is useful for storing large structured data",
        "isCorrect": true
      },
      {
        "id": "o4",
        "text": "localStorage automatically syncs with the server",
        "isCorrect": false
      }
    ]
  },
  {
    "id": "q61",
    "title": "How do you measure frontend network performance?",
    "content": "Explain tools and metrics used to analyze network requests in frontend applications.",
    "type": "open-ended",
    "category": "Performance",
    "subcategory": "Network",
    "difficulty": "intermediate",
    "topic": "Frontend System Design",
    "isActive": true,
    "createdAt": "2025-01-08T00:00:00Z",
    "updatedAt": "2025-01-08T00:00:00Z",
    "tags": ["network-performance", "frontend", "tools"],
    "sampleAnswers": [
      "Use browser dev tools, Lighthouse, or WebPageTest to measure TTFB, total request size, request count, and loading time for critical assets."
    ]
  },
  {
    "id": "q62",
    "title": "What is a frontend performance budget and why is it important?",
    "content": "Describe the concept of a performance budget and how it helps maintain good UX.",
    "type": "open-ended",
    "category": "Performance",
    "subcategory": "Planning",
    "difficulty": "intermediate",
    "topic": "Frontend System Design",
    "isActive": true,
    "createdAt": "2025-01-08T00:00:00Z",
    "updatedAt": "2025-01-08T00:00:00Z",
    "tags": ["performance-budget", "ux", "frontend"],
    "sampleAnswers": [
      "A performance budget sets limits on page weight, script size, or request counts to prevent regressions and maintain fast load times."
    ]
  },
  {
    "id": "q63",
    "title": "How do you profile and optimize JavaScript performance?",
    "content": "Explain techniques for identifying and fixing slow JS execution.",
    "type": "open-ended",
    "category": "Performance",
    "subcategory": "JavaScript",
    "difficulty": "advanced",
    "topic": "Frontend System Design",
    "isActive": true,
    "createdAt": "2025-01-08T00:00:00Z",
    "updatedAt": "2025-01-08T00:00:00Z",
    "tags": ["javascript-performance", "profiling", "optimization"],
    "sampleAnswers": [
      "Use Chrome DevTools Performance tab to record JS execution, identify long tasks, optimize loops, debounce/throttle events, and memoize expensive calculations."
    ]
  },
  {
    "id": "q64",
    "title": "How do you profile rendering performance in a React app?",
    "content": "Discuss tools and techniques for identifying re-render bottlenecks.",
    "type": "open-ended",
    "category": "Performance",
    "subcategory": "Rendering",
    "difficulty": "advanced",
    "topic": "Frontend System Design",
    "isActive": true,
    "createdAt": "2025-01-08T00:00:00Z",
    "updatedAt": "2025-01-08T00:00:00Z",
    "tags": ["react", "rendering-performance", "profiling"],
    "sampleAnswers": [
      "Use React DevTools Profiler to measure component render times, identify unnecessary renders, optimize with memoization, lazy loading, and virtualization."
    ]
  },
  {
    "id": "q65",
    "title": "What are Lighthouse audits and how do they help in frontend system design?",
    "content": "Explain the purpose of Lighthouse and its reports for performance and accessibility.",
    "type": "open-ended",
    "category": "Observability",
    "subcategory": "Monitoring",
    "difficulty": "intermediate",
    "topic": "Frontend System Design",
    "isActive": true,
    "createdAt": "2025-01-08T00:00:00Z",
    "updatedAt": "2025-01-08T00:00:00Z",
    "tags": ["lighthouse", "monitoring", "performance", "accessibility"],
    "sampleAnswers": [
      "Lighthouse audits provide automated reports for performance, accessibility, best practices, SEO, and PWA compliance, helping developers optimize their apps."
    ]
  },
  {
    "id": "q66",
    "title": "How do you monitor accessibility issues in a frontend application?",
    "content": "Describe tools and methods to detect and fix a11y problems.",
    "type": "open-ended",
    "category": "Accessibility",
    "subcategory": "Monitoring",
    "difficulty": "intermediate",
    "topic": "Frontend System Design",
    "isActive": true,
    "createdAt": "2025-01-08T00:00:00Z",
    "updatedAt": "2025-01-08T00:00:00Z",
    "tags": ["accessibility", "monitoring", "a11y"],
    "sampleAnswers": [
      "Use tools like Axe, Lighthouse, WAVE, or browser extensions to audit accessibility, detect color contrast issues, missing ARIA labels, and keyboard navigation problems."
    ]
  },
  {
    "id": "q67",
    "title": "What is Time to Interactive (TTI) and why is it important?",
    "content": "Explain the TTI metric and its significance for user experience.",
    "type": "open-ended",
    "category": "Performance",
    "subcategory": "Metrics",
    "difficulty": "intermediate",
    "topic": "Frontend System Design",
    "isActive": true,
    "createdAt": "2025-01-08T00:00:00Z",
    "updatedAt": "2025-01-08T00:00:00Z",
    "tags": ["tti", "metrics", "performance"],
    "sampleAnswers": [
      "TTI measures the time until the page becomes fully interactive for users. Lower TTI improves perceived performance and UX."
    ]
  },
  {
    "id": "q68",
    "title": "What is Largest Contentful Paint (LCP) and how can you improve it?",
    "content": "Explain LCP and strategies to reduce its value.",
    "type": "open-ended",
    "category": "Performance",
    "subcategory": "Metrics",
    "difficulty": "intermediate",
    "topic": "Frontend System Design",
    "isActive": true,
    "createdAt": "2025-01-08T00:00:00Z",
    "updatedAt": "2025-01-08T00:00:00Z",
    "tags": ["lcp", "frontend-metrics", "performance"],
    "sampleAnswers": [
      "LCP measures time for the largest visible element to load. Optimize by lazy loading images, compressing resources, using critical CSS, and serving assets via CDN."
    ]
  },
  {
    "id": "q69",
    "title": "How do you detect memory leaks in frontend applications?",
    "content": "Describe methods to identify and fix memory leaks in JavaScript apps.",
    "type": "open-ended",
    "category": "Performance",
    "subcategory": "JavaScript",
    "difficulty": "advanced",
    "topic": "Frontend System Design",
    "isActive": true,
    "createdAt": "2025-01-08T00:00:00Z",
    "updatedAt": "2025-01-08T00:00:00Z",
    "tags": ["memory-leaks", "javascript", "profiling"],
    "sampleAnswers": [
      "Use Chrome DevTools Memory tab, take heap snapshots, look for detached DOM nodes, and clean up event listeners or intervals to prevent leaks."
    ]
  },
  {
    "id": "q70",
    "title": "What are some strategies to monitor frontend errors in production?",
    "content": "Explain how to track and report frontend runtime errors effectively.",
    "type": "open-ended",
    "category": "Observability",
    "subcategory": "Monitoring",
    "difficulty": "intermediate",
    "topic": "Frontend System Design",
    "isActive": true,
    "createdAt": "2025-01-08T00:00:00Z",
    "updatedAt": "2025-01-08T00:00:00Z",
    "tags": ["error-monitoring", "frontend", "observability"],
    "sampleAnswers": [
      "Use services like Sentry, LogRocket, or Rollbar to capture uncaught errors, promise rejections, and user sessions. Include context and stack traces for debugging."
    ]
  },
  {
    "id": "q71",
    "title": "What is a signed URL and why is it important for security?",
    "content": "Explain the purpose of signed URLs for accessing private resources.",
    "type": "open-ended",
    "category": "Security",
    "subcategory": "Signed URLs",
    "difficulty": "intermediate",
    "topic": "Frontend System Design",
    "isActive": true,
    "createdAt": "2025-01-08T00:00:00Z",
    "updatedAt": "2025-01-08T00:00:00Z",
    "tags": ["signed-url", "cdn", "security"],
    "sampleAnswers": [
      "Signed URLs provide temporary, time-limited access to private resources on a server or CDN. They prevent unauthorized access and allow caching while maintaining security."
    ]
  },
  {
    "id": "q72",
    "title": "How do you prevent CSRF attacks in frontend applications?",
    "content": "Describe techniques to protect against Cross-Site Request Forgery.",
    "type": "open-ended",
    "category": "Security",
    "subcategory": "CSRF",
    "difficulty": "intermediate",
    "topic": "Frontend System Design",
    "isActive": true,
    "createdAt": "2025-01-08T00:00:00Z",
    "updatedAt": "2025-01-08T00:00:00Z",
    "tags": ["csrf", "security", "frontend"],
    "sampleAnswers": [
      "Use anti-CSRF tokens in requests, ensure same-site cookies, validate origin headers, and use secure HTTP methods for state-changing requests."
    ]
  },
  {
    "id": "q73",
    "title": "How do you prevent XSS attacks in frontend applications?",
    "content": "Explain strategies to mitigate Cross-Site Scripting vulnerabilities.",
    "type": "open-ended",
    "category": "Security",
    "subcategory": "XSS",
    "difficulty": "intermediate",
    "topic": "Frontend System Design",
    "isActive": true,
    "createdAt": "2025-01-08T00:00:00Z",
    "updatedAt": "2025-01-08T00:00:00Z",
    "tags": ["xss", "security", "frontend"],
    "sampleAnswers": [
      "Escape or sanitize user-generated content, use Content Security Policy (CSP), avoid `innerHTML`, and validate input on both frontend and backend."
    ]
  },
  {
    "id": "q74",
    "title": "What are HTTP-only cookies and why are they important?",
    "content": "Explain the role of HTTP-only cookies in frontend security.",
    "type": "open-ended",
    "category": "Security",
    "subcategory": "Authentication",
    "difficulty": "intermediate",
    "topic": "Frontend System Design",
    "isActive": true,
    "createdAt": "2025-01-08T00:00:00Z",
    "updatedAt": "2025-01-08T00:00:00Z",
    "tags": ["http-only-cookies", "security", "frontend"],
    "sampleAnswers": [
      "HTTP-only cookies cannot be accessed by JavaScript, reducing the risk of XSS attacks stealing session data."
    ]
  },
  {
    "id": "q75",
    "title": "How do you handle authentication in frontend applications?",
    "content": "Discuss strategies for managing user authentication and session state.",
    "type": "open-ended",
    "category": "Security",
    "subcategory": "Authentication",
    "difficulty": "intermediate",
    "topic": "Frontend System Design",
    "isActive": true,
    "createdAt": "2025-01-08T00:00:00Z",
    "updatedAt": "2025-01-08T00:00:00Z",
    "tags": ["authentication", "session", "frontend"],
    "sampleAnswers": [
      "Use tokens (JWT or opaque), store securely in HTTP-only cookies or local storage, handle token refresh, and validate session on API requests."
    ]
  },
  {
    "id": "q76",
    "title": "What is the difference between JWT and opaque tokens?",
    "content": "Compare JWT and opaque tokens for frontend authentication.",
    "type": "multiple-choice",
    "category": "Security",
    "subcategory": "Authentication",
    "difficulty": "intermediate",
    "topic": "Frontend System Design",
    "isActive": true,
    "createdAt": "2025-01-08T00:00:00Z",
    "updatedAt": "2025-01-08T00:00:00Z",
    "tags": ["jwt", "tokens", "security", "frontend"],
    "options": [
      {
        "id": "o1",
        "text": "JWT is self-contained, includes claims, can be verified without server",
        "isCorrect": true
      },
      {
        "id": "o2",
        "text": "Opaque tokens are random identifiers, require server to validate",
        "isCorrect": true
      },
      {
        "id": "o3",
        "text": "JWT cannot be used in SPAs",
        "isCorrect": false
      }
    ]
  },
  {
    "id": "q77",
    "title": "What is CORS and why is it important in frontend apps?",
    "content": "Explain Cross-Origin Resource Sharing and its relevance for security.",
    "type": "open-ended",
    "category": "Security",
    "subcategory": "CORS",
    "difficulty": "beginner",
    "topic": "Frontend System Design",
    "isActive": true,
    "createdAt": "2025-01-08T00:00:00Z",
    "updatedAt": "2025-01-08T00:00:00Z",
    "tags": ["cors", "security", "frontend"],
    "sampleAnswers": [
      "CORS is a browser security mechanism that controls which origins can access resources. It prevents unauthorized cross-origin requests."
    ]
  },
  {
    "id": "q78",
    "title": "How do you securely handle API tokens in frontend applications?",
    "content": "Discuss best practices for storing and using API tokens in the browser.",
    "type": "open-ended",
    "category": "Security",
    "subcategory": "API Security",
    "difficulty": "intermediate",
    "topic": "Frontend System Design",
    "isActive": true,
    "createdAt": "2025-01-08T00:00:00Z",
    "updatedAt": "2025-01-08T00:00:00Z",
    "tags": ["api-tokens", "security", "frontend"],
    "sampleAnswers": [
      "Store tokens in HTTP-only cookies or in-memory storage, avoid localStorage for sensitive tokens, use short-lived tokens with refresh, and send via Authorization header."
    ]
  },
  {
    "id": "q79",
    "title": "What is the difference between authentication and authorization?",
    "content": "Explain the difference between verifying identity and granting access.",
    "type": "multiple-choice",
    "category": "Security",
    "subcategory": "Authentication & Authorization",
    "difficulty": "beginner",
    "topic": "Frontend System Design",
    "isActive": true,
    "createdAt": "2025-01-08T00:00:00Z",
    "updatedAt": "2025-01-08T00:00:00Z",
    "tags": ["auth", "frontend", "security"],
    "options": [
      {
        "id": "o1",
        "text": "Authentication verifies user identity",
        "isCorrect": true
      },
      {
        "id": "o2",
        "text": "Authorization determines access level or permissions",
        "isCorrect": true
      },
      {
        "id": "o3",
        "text": "They are the same",
        "isCorrect": false
      }
    ]
  },
  {
    "id": "q80",
    "title": "How do signed URLs impact performance in frontend applications?",
    "content": "Explain how using signed URLs can improve frontend loading and caching.",
    "type": "open-ended",
    "category": "Performance & Security",
    "subcategory": "Signed URLs",
    "difficulty": "intermediate",
    "topic": "Frontend System Design",
    "isActive": true,
    "createdAt": "2025-01-08T00:00:00Z",
    "updatedAt": "2025-01-08T00:00:00Z",
    "tags": ["signed-url", "performance", "cdn", "frontend"],
    "sampleAnswers": [
      "Signed URLs allow CDNs to cache private resources efficiently, reducing server load and latency, while ensuring secure time-limited access to assets."
    ]
  },
  {
    "id": "q81",
    "title": "What is web accessibility (a11y) and why is it important?",
    "content": "Explain the concept of web accessibility and its significance in frontend design.",
    "type": "open-ended",
    "category": "Accessibility",
    "subcategory": "Basics",
    "difficulty": "beginner",
    "topic": "Frontend System Design",
    "isActive": true,
    "createdAt": "2025-01-08T00:00:00Z",
    "updatedAt": "2025-01-08T00:00:00Z",
    "tags": ["accessibility", "a11y", "frontend", "ux"],
    "sampleAnswers": [
      "Web accessibility ensures that websites are usable by people with disabilities, providing equal access to content and functionality. It improves usability and inclusivity."
    ]
  },
  {
    "id": "q82",
    "title": "What are ARIA roles and how do you use them?",
    "content": "Explain ARIA roles and attributes to improve accessibility.",
    "type": "open-ended",
    "category": "Accessibility",
    "subcategory": "ARIA",
    "difficulty": "intermediate",
    "topic": "Frontend System Design",
    "isActive": true,
    "createdAt": "2025-01-08T00:00:00Z",
    "updatedAt": "2025-01-08T00:00:00Z",
    "tags": ["aria", "roles", "a11y", "frontend"],
    "sampleAnswers": [
      "ARIA roles and attributes provide semantic information for assistive technologies. Use roles like `button`, `dialog`, and states like `aria-expanded` to convey meaning."
    ]
  },
  {
    "id": "q83",
    "title": "How do you test accessibility in frontend applications?",
    "content": "Describe tools and methods to verify a11y compliance.",
    "type": "open-ended",
    "category": "Accessibility",
    "subcategory": "Testing",
    "difficulty": "intermediate",
    "topic": "Frontend System Design",
    "isActive": true,
    "createdAt": "2025-01-08T00:00:00Z",
    "updatedAt": "2025-01-08T00:00:00Z",
    "tags": ["a11y", "testing", "frontend"],
    "sampleAnswers": [
      "Use browser extensions like Axe or WAVE, automated tools like Lighthouse, and manual testing with keyboard navigation and screen readers to ensure accessibility compliance."
    ]
  },
  {
    "id": "q84",
    "title": "What are common accessibility mistakes in frontend apps?",
    "content": "Identify frequent a11y issues and how to avoid them.",
    "type": "multiple-choice",
    "category": "Accessibility",
    "subcategory": "Best Practices",
    "difficulty": "intermediate",
    "topic": "Frontend System Design",
    "isActive": true,
    "createdAt": "2025-01-08T00:00:00Z",
    "updatedAt": "2025-01-08T00:00:00Z",
    "tags": ["a11y", "frontend", "best-practices"],
    "options": [
      {
        "id": "o1",
        "text": "Missing alt text on images",
        "isCorrect": true
      },
      {
        "id": "o2",
        "text": "Poor color contrast",
        "isCorrect": true
      },
      {
        "id": "o3",
        "text": "Non-focusable interactive elements",
        "isCorrect": true
      },
      {
        "id": "o4",
        "text": "Using semantic HTML",
        "isCorrect": false
      }
    ]
  },
  {
    "id": "q85",
    "title": "What is internationalization (i18n) in frontend applications?",
    "content": "Explain the purpose of i18n and how it impacts frontend design.",
    "type": "open-ended",
    "category": "Internationalization",
    "subcategory": "Basics",
    "difficulty": "beginner",
    "topic": "Frontend System Design",
    "isActive": true,
    "createdAt": "2025-01-08T00:00:00Z",
    "updatedAt": "2025-01-08T00:00:00Z",
    "tags": ["i18n", "frontend", "ux", "localization"],
    "sampleAnswers": [
      "Internationalization (i18n) is the process of designing a frontend app to support multiple languages, locales, and cultural conventions without changing code."
    ]
  },
  {
    "id": "q86",
    "title": "What is the difference between i18n and l10n?",
    "content": "Compare internationalization and localization in frontend development.",
    "type": "multiple-choice",
    "category": "Internationalization",
    "subcategory": "Basics",
    "difficulty": "beginner",
    "topic": "Frontend System Design",
    "isActive": true,
    "createdAt": "2025-01-08T00:00:00Z",
    "updatedAt": "2025-01-08T00:00:00Z",
    "tags": ["i18n", "l10n", "frontend", "ux"],
    "options": [
      {
        "id": "o1",
        "text": "i18n is the process of designing for multiple languages",
        "isCorrect": true
      },
      {
        "id": "o2",
        "text": "l10n is the process of adapting content for a specific locale",
        "isCorrect": true
      },
      {
        "id": "o3",
        "text": "i18n and l10n are the same",
        "isCorrect": false
      }
    ]
  },
  {
    "id": "q87",
    "title": "How do you handle right-to-left (RTL) languages in frontend apps?",
    "content": "Explain strategies for supporting RTL layouts and text.",
    "type": "open-ended",
    "category": "Internationalization",
    "subcategory": "RTL",
    "difficulty": "intermediate",
    "topic": "Frontend System Design",
    "isActive": true,
    "createdAt": "2025-01-08T00:00:00Z",
    "updatedAt": "2025-01-08T00:00:00Z",
    "tags": ["rtl", "frontend", "i18n", "ux"],
    "sampleAnswers": [
      "Use CSS logical properties (`margin-inline-start`), direction attributes (`dir='rtl'`), mirrored layout components, and test with RTL content to ensure proper alignment."
    ]
  },
  {
    "id": "q88",
    "title": "What UX considerations should be taken for performance-sensitive pages?",
    "content": "Discuss UX strategies to improve perceived performance.",
    "type": "open-ended",
    "category": "UX",
    "subcategory": "Performance",
    "difficulty": "intermediate",
    "topic": "Frontend System Design",
    "isActive": true,
    "createdAt": "2025-01-08T00:00:00Z",
    "updatedAt": "2025-01-08T00:00:00Z",
    "tags": ["ux", "performance", "frontend"],
    "sampleAnswers": [
      "Use skeleton loaders, progressive rendering, lazy load images and components, provide feedback for user actions, and prioritize above-the-fold content."
    ]
  },
  {
    "id": "q89",
    "title": "What is the difference between progressive enhancement and graceful degradation?",
    "content": "Explain these two strategies in frontend development.",
    "type": "multiple-choice",
    "category": "UX",
    "subcategory": "Best Practices",
    "difficulty": "intermediate",
    "topic": "Frontend System Design",
    "isActive": true,
    "createdAt": "2025-01-08T00:00:00Z",
    "updatedAt": "2025-01-08T00:00:00Z",
    "tags": [
      "ux",
      "frontend",
      "progressive-enhancement",
      "graceful-degradation"
    ],
    "options": [
      {
        "id": "o1",
        "text": "Progressive enhancement starts with basic functionality and adds features for modern browsers",
        "isCorrect": true
      },
      {
        "id": "o2",
        "text": "Graceful degradation starts with full features and reduces functionality for older browsers",
        "isCorrect": true
      },
      {
        "id": "o3",
        "text": "They are exactly the same",
        "isCorrect": false
      }
    ]
  },
  {
    "id": "q90",
    "title": "How do you ensure a frontend app is usable for all users, including those with disabilities?",
    "content": "Describe strategies for inclusive frontend design.",
    "type": "open-ended",
    "category": "Accessibility",
    "subcategory": "Inclusive Design",
    "difficulty": "advanced",
    "topic": "Frontend System Design",
    "isActive": true,
    "createdAt": "2025-01-08T00:00:00Z",
    "updatedAt": "2025-01-08T00:00:00Z",
    "tags": ["inclusive-design", "accessibility", "frontend", "ux"],
    "sampleAnswers": [
      "Follow WCAG guidelines, use semantic HTML, ARIA roles, keyboard navigable interfaces, screen reader testing, color contrast compliance, and responsive layouts."
    ]
  },
  {
    "id": "q91",
    "title": "What is WebSocket and when should you use it?",
    "content": "Explain WebSocket protocol and its use cases in frontend applications.",
    "type": "open-ended",
    "category": "Real-Time Data",
    "subcategory": "WebSocket",
    "difficulty": "intermediate",
    "topic": "Frontend System Design",
    "isActive": true,
    "createdAt": "2025-01-08T00:00:00Z",
    "updatedAt": "2025-01-08T00:00:00Z",
    "tags": ["websocket", "realtime", "frontend"],
    "sampleAnswers": [
      "WebSocket is a full-duplex, persistent connection between client and server for real-time communication. Use it for chat apps, notifications, and live feeds."
    ]
  },
  {
    "id": "q92",
    "title": "What is Server-Sent Events (SSE) and how does it differ from WebSocket?",
    "content": "Compare SSE and WebSocket in terms of use cases and protocol features.",
    "type": "open-ended",
    "category": "Real-Time Data",
    "subcategory": "SSE",
    "difficulty": "intermediate",
    "topic": "Frontend System Design",
    "isActive": true,
    "createdAt": "2025-01-08T00:00:00Z",
    "updatedAt": "2025-01-08T00:00:00Z",
    "tags": ["sse", "realtime", "frontend"],
    "sampleAnswers": [
      "SSE is a unidirectional protocol where server pushes updates to the client over HTTP. Use SSE for live feeds or notifications where the client doesn't need to send frequent data."
    ]
  },
  {
    "id": "q93",
    "title": "What is long polling and when is it used?",
    "content": "Explain long polling technique for real-time updates.",
    "type": "open-ended",
    "category": "Real-Time Data",
    "subcategory": "Long Polling",
    "difficulty": "intermediate",
    "topic": "Frontend System Design",
    "isActive": true,
    "createdAt": "2025-01-08T00:00:00Z",
    "updatedAt": "2025-01-08T00:00:00Z",
    "tags": ["long-polling", "realtime", "frontend"],
    "sampleAnswers": [
      "Long polling is a technique where the client sends a request and the server holds it until data is available. Use it when WebSocket or SSE is not possible."
    ]
  },
  {
    "id": "q94",
    "title": "What are the pros and cons of WebSocket vs SSE vs long polling?",
    "content": "Compare these real-time strategies in terms of latency, scalability, and complexity.",
    "type": "open-ended",
    "category": "Real-Time Data",
    "subcategory": "Comparison",
    "difficulty": "advanced",
    "topic": "Frontend System Design",
    "isActive": true,
    "createdAt": "2025-01-08T00:00:00Z",
    "updatedAt": "2025-01-08T00:00:00Z",
    "tags": ["websocket", "sse", "long-polling", "realtime", "frontend"],
    "sampleAnswers": [
      "WebSocket: low latency, bidirectional, more complex, heavier on server.\nSSE: simple, unidirectional, uses HTTP, auto-reconnect, limited to text/event-stream.\nLong Polling: compatible with HTTP, higher latency, server holds connections, less efficient."
    ]
  },
  {
    "id": "q95",
    "title": "How do you handle reconnection logic in real-time frontend apps?",
    "content": "Describe strategies to maintain real-time connectivity.",
    "type": "open-ended",
    "category": "Real-Time Data",
    "subcategory": "Connection Management",
    "difficulty": "intermediate",
    "topic": "Frontend System Design",
    "isActive": true,
    "createdAt": "2025-01-08T00:00:00Z",
    "updatedAt": "2025-01-08T00:00:00Z",
    "tags": ["realtime", "websocket", "sse", "frontend"],
    "sampleAnswers": [
      "Implement exponential backoff retry, detect disconnections, optionally queue messages during downtime, and re-subscribe to channels after reconnect."
    ]
  },
  {
    "id": "q96",
    "title": "What are the best practices for handling high-frequency real-time data in the frontend?",
    "content": "Explain strategies to manage performance when receiving frequent updates.",
    "type": "open-ended",
    "category": "Real-Time Data",
    "subcategory": "Performance",
    "difficulty": "advanced",
    "topic": "Frontend System Design",
    "isActive": true,
    "createdAt": "2025-01-08T00:00:00Z",
    "updatedAt": "2025-01-08T00:00:00Z",
    "tags": ["realtime", "performance", "frontend"],
    "sampleAnswers": [
      "Throttle or debounce updates, batch multiple events into a single render, use virtualization for lists, and avoid unnecessary state updates."
    ]
  },
  {
    "id": "q97",
    "title": "How do you secure WebSocket connections in frontend apps?",
    "content": "Discuss authentication and encryption for WebSocket connections.",
    "type": "open-ended",
    "category": "Security",
    "subcategory": "WebSocket",
    "difficulty": "intermediate",
    "topic": "Frontend System Design",
    "isActive": true,
    "createdAt": "2025-01-08T00:00:00Z",
    "updatedAt": "2025-01-08T00:00:00Z",
    "tags": ["websocket", "security", "frontend"],
    "sampleAnswers": [
      "Use WSS (WebSocket over TLS), validate tokens or cookies on handshake, limit origin access, and avoid exposing sensitive data over the connection."
    ]
  },
  {
    "id": "q98",
    "title": "How do you manage subscriptions to multiple real-time channels efficiently?",
    "content": "Explain strategies for handling multiple feeds in frontend apps.",
    "type": "open-ended",
    "category": "Real-Time Data",
    "subcategory": "Subscription Management",
    "difficulty": "advanced",
    "topic": "Frontend System Design",
    "isActive": true,
    "createdAt": "2025-01-08T00:00:00Z",
    "updatedAt": "2025-01-08T00:00:00Z",
    "tags": ["realtime", "channels", "frontend", "subscriptions"],
    "sampleAnswers": [
      "Use a central subscription manager, reuse connections, dynamically subscribe/unsubscribe as needed, and debounce updates from high-frequency channels."
    ]
  },
  {
    "id": "q99",
    "title": "How do you handle fallback mechanisms if WebSocket or SSE fails?",
    "content": "Describe strategies to maintain real-time updates when primary methods fail.",
    "type": "open-ended",
    "category": "Real-Time Data",
    "subcategory": "Fallback",
    "difficulty": "intermediate",
    "topic": "Frontend System Design",
    "isActive": true,
    "createdAt": "2025-01-08T00:00:00Z",
    "updatedAt": "2025-01-08T00:00:00Z",
    "tags": ["realtime", "fallback", "frontend"],
    "sampleAnswers": [
      "Use long polling as a fallback, retry WebSocket connections periodically, or display stale cached data with visual indication until connection restores."
    ]
  },
  {
    "id": "q100",
    "title": "When would you choose SSE over WebSocket in a frontend system?",
    "content": "Explain scenarios where Server-Sent Events are more suitable than WebSocket.",
    "type": "open-ended",
    "category": "Real-Time Data",
    "subcategory": "Decision Making",
    "difficulty": "intermediate",
    "topic": "Frontend System Design",
    "isActive": true,
    "createdAt": "2025-01-08T00:00:00Z",
    "updatedAt": "2025-01-08T00:00:00Z",
    "tags": ["sse", "websocket", "frontend", "realtime"],
    "sampleAnswers": [
      "Use SSE for unidirectional updates like live feeds, notifications, or stock tickers where client doesn't send frequent data and simplicity is preferred over bidirectional communication."
    ]
  },
  {
    "id": "q101",
    "title": "What is the difference between browser cache and CDN cache?",
    "content": "Explain how browser caching and CDN caching work and their differences.",
    "type": "open-ended",
    "category": "Caching",
    "subcategory": "Basics",
    "difficulty": "beginner",
    "topic": "Frontend System Design",
    "isActive": true,
    "createdAt": "2025-01-08T00:00:00Z",
    "updatedAt": "2025-01-08T00:00:00Z",
    "tags": ["cache", "cdn", "frontend", "performance"],
    "sampleAnswers": [
      "Browser cache stores assets locally on the client device. CDN cache stores assets on edge servers closer to the user. CDN reduces network latency while browser cache reduces repeated downloads."
    ]
  },
  {
    "id": "q102",
    "title": "What are cache-control headers and why are they important?",
    "content": "Explain cache-control strategies for frontend assets.",
    "type": "open-ended",
    "category": "Caching",
    "subcategory": "Headers",
    "difficulty": "intermediate",
    "topic": "Frontend System Design",
    "isActive": true,
    "createdAt": "2025-01-08T00:00:00Z",
    "updatedAt": "2025-01-08T00:00:00Z",
    "tags": ["cache-control", "headers", "frontend"],
    "sampleAnswers": [
      "Cache-control headers define how long and where a resource can be cached. Examples: `max-age`, `no-store`, `must-revalidate`. They help control freshness and prevent stale content."
    ]
  },
  {
    "id": "q103",
    "title": "What is a service worker and what role does it play in caching?",
    "content": "Explain service workers and how they enable offline-first frontend apps.",
    "type": "open-ended",
    "category": "Offline Support",
    "subcategory": "Service Worker",
    "difficulty": "intermediate",
    "topic": "Frontend System Design",
    "isActive": true,
    "createdAt": "2025-01-08T00:00:00Z",
    "updatedAt": "2025-01-08T00:00:00Z",
    "tags": ["service-worker", "offline", "caching", "pwa"],
    "sampleAnswers": [
      "A service worker is a script running in the background that intercepts network requests. It can cache assets, serve offline content, and enable push notifications for PWAs."
    ]
  },
  {
    "id": "q104",
    "title": "What is the difference between AppCache and Service Worker?",
    "content": "Compare the deprecated AppCache and modern Service Worker approach.",
    "type": "multiple-choice",
    "category": "Offline Support",
    "subcategory": "History",
    "difficulty": "beginner",
    "topic": "Frontend System Design",
    "isActive": true,
    "createdAt": "2025-01-08T00:00:00Z",
    "updatedAt": "2025-01-08T00:00:00Z",
    "tags": ["service-worker", "appcache", "offline"],
    "options": [
      {
        "id": "o1",
        "text": "AppCache was limited and inflexible",
        "isCorrect": true
      },
      {
        "id": "o2",
        "text": "Service Worker provides programmable caching and background sync",
        "isCorrect": true
      },
      {
        "id": "o3",
        "text": "Both are actively supported",
        "isCorrect": false
      }
    ]
  },
  {
    "id": "q105",
    "title": "What is stale-while-revalidate caching strategy?",
    "content": "Explain how stale-while-revalidate improves perceived performance.",
    "type": "open-ended",
    "category": "Caching",
    "subcategory": "Strategies",
    "difficulty": "intermediate",
    "topic": "Frontend System Design",
    "isActive": true,
    "createdAt": "2025-01-08T00:00:00Z",
    "updatedAt": "2025-01-08T00:00:00Z",
    "tags": ["caching", "swr", "frontend"],
    "sampleAnswers": [
      "Stale-while-revalidate serves cached content immediately while fetching a fresh version in the background. The user sees fast responses while data stays up-to-date."
    ]
  },
  {
    "id": "q106",
    "title": "How does IndexedDB help with offline frontend applications?",
    "content": "Explain the role of IndexedDB for client-side storage.",
    "type": "open-ended",
    "category": "Offline Support",
    "subcategory": "Storage",
    "difficulty": "intermediate",
    "topic": "Frontend System Design",
    "isActive": true,
    "createdAt": "2025-01-08T00:00:00Z",
    "updatedAt": "2025-01-08T00:00:00Z",
    "tags": ["indexeddb", "offline", "frontend"],
    "sampleAnswers": [
      "IndexedDB is a low-level NoSQL database in the browser. It stores structured data, useful for offline applications where data must persist across sessions."
    ]
  },
  {
    "id": "q107",
    "title": "How do you implement offline-first design in frontend apps?",
    "content": "Describe strategies to make a web app work offline.",
    "type": "open-ended",
    "category": "Offline Support",
    "subcategory": "Design Patterns",
    "difficulty": "advanced",
    "topic": "Frontend System Design",
    "isActive": true,
    "createdAt": "2025-01-08T00:00:00Z",
    "updatedAt": "2025-01-08T00:00:00Z",
    "tags": ["offline", "pwa", "frontend"],
    "sampleAnswers": [
      "Use service workers for caching, IndexedDB for persistent storage, queue requests for background sync, and gracefully degrade UI when offline."
    ]
  },
  {
    "id": "q108",
    "title": "What is background sync and how does it work with service workers?",
    "content": "Explain background sync and its benefits for frontend apps.",
    "type": "open-ended",
    "category": "Offline Support",
    "subcategory": "Background Sync",
    "difficulty": "intermediate",
    "topic": "Frontend System Design",
    "isActive": true,
    "createdAt": "2025-01-08T00:00:00Z",
    "updatedAt": "2025-01-08T00:00:00Z",
    "tags": ["background-sync", "service-worker", "frontend"],
    "sampleAnswers": [
      "Background sync allows deferred actions like sending requests once connectivity is restored. Service workers handle queued tasks even when the app is closed."
    ]
  },
  {
    "id": "q109",
    "title": "How do you cache API responses efficiently on the frontend?",
    "content": "Discuss strategies for API caching in frontend applications.",
    "type": "open-ended",
    "category": "Caching",
    "subcategory": "API Caching",
    "difficulty": "advanced",
    "topic": "Frontend System Design",
    "isActive": true,
    "createdAt": "2025-01-08T00:00:00Z",
    "updatedAt": "2025-01-08T00:00:00Z",
    "tags": ["api-caching", "frontend", "performance"],
    "sampleAnswers": [
      "Use IndexedDB or in-memory caching, implement SWR/React Query strategies, leverage service workers for offline API responses, and use ETag headers to revalidate."
    ]
  },
  {
    "id": "q110",
    "title": "What is the role of a Content Delivery Network (CDN) in caching?",
    "content": "Explain how CDNs optimize asset delivery in frontend systems.",
    "type": "open-ended",
    "category": "Caching",
    "subcategory": "CDN",
    "difficulty": "beginner",
    "topic": "Frontend System Design",
    "isActive": true,
    "createdAt": "2025-01-08T00:00:00Z",
    "updatedAt": "2025-01-08T00:00:00Z",
    "tags": ["cdn", "caching", "frontend", "performance"],
    "sampleAnswers": [
      "A CDN caches static assets at edge servers near users, reducing latency and improving load times for global audiences."
    ]
  },
  {
    "id": "q111",
    "title": "What is the difference between authentication and authorization?",
    "content": "Explain the roles of authentication and authorization in frontend applications.",
    "type": "multiple-choice",
    "category": "Security",
    "subcategory": "Basics",
    "difficulty": "beginner",
    "topic": "Frontend System Design",
    "isActive": true,
    "createdAt": "2025-01-08T00:00:00Z",
    "updatedAt": "2025-01-08T00:00:00Z",
    "tags": ["security", "auth", "frontend"],
    "options": [
      {
        "id": "o1",
        "text": "Authentication verifies who the user is",
        "isCorrect": true
      },
      {
        "id": "o2",
        "text": "Authorization decides what the user can access",
        "isCorrect": true
      },
      {
        "id": "o3",
        "text": "They are the same thing",
        "isCorrect": false
      }
    ]
  },
  {
    "id": "q112",
    "title": "What is OAuth2 and how is it used in frontend apps?",
    "content": "Explain OAuth2 flow and its role in frontend authentication.",
    "type": "open-ended",
    "category": "Security",
    "subcategory": "OAuth",
    "difficulty": "intermediate",
    "topic": "Frontend System Design",
    "isActive": true,
    "createdAt": "2025-01-08T00:00:00Z",
    "updatedAt": "2025-01-08T00:00:00Z",
    "tags": ["oauth2", "auth", "frontend"],
    "sampleAnswers": [
      "OAuth2 is an authorization framework allowing apps to access resources on behalf of users. Frontend apps use it for social logins and delegated access with access tokens."
    ]
  },
  {
    "id": "q113",
    "title": "What is the difference between JWT and opaque tokens?",
    "content": "Compare JSON Web Tokens and opaque tokens in terms of usage and security.",
    "type": "open-ended",
    "category": "Security",
    "subcategory": "Tokens",
    "difficulty": "intermediate",
    "topic": "Frontend System Design",
    "isActive": true,
    "createdAt": "2025-01-08T00:00:00Z",
    "updatedAt": "2025-01-08T00:00:00Z",
    "tags": ["jwt", "tokens", "frontend", "auth"],
    "sampleAnswers": [
      "JWTs are self-contained tokens with claims, verifiable by signature, no DB lookup needed. Opaque tokens are random strings requiring server lookup. JWTs scale better but must be handled securely."
    ]
  },
  {
    "id": "q114",
    "title": "What are HttpOnly cookies and why are they important?",
    "content": "Explain HttpOnly cookies and their role in frontend security.",
    "type": "open-ended",
    "category": "Security",
    "subcategory": "Cookies",
    "difficulty": "beginner",
    "topic": "Frontend System Design",
    "isActive": true,
    "createdAt": "2025-01-08T00:00:00Z",
    "updatedAt": "2025-01-08T00:00:00Z",
    "tags": ["cookies", "httponly", "security", "frontend"],
    "sampleAnswers": [
      "HttpOnly cookies cannot be accessed via JavaScript, preventing XSS attacks from stealing tokens. They are useful for securely storing session tokens."
    ]
  },
  {
    "id": "q115",
    "title": "What is CSRF and how do you prevent it?",
    "content": "Explain Cross-Site Request Forgery and prevention techniques.",
    "type": "open-ended",
    "category": "Security",
    "subcategory": "CSRF",
    "difficulty": "intermediate",
    "topic": "Frontend System Design",
    "isActive": true,
    "createdAt": "2025-01-08T00:00:00Z",
    "updatedAt": "2025-01-08T00:00:00Z",
    "tags": ["csrf", "security", "frontend"],
    "sampleAnswers": [
      "CSRF tricks users into executing actions unknowingly. Prevent it using SameSite cookies, CSRF tokens in forms, and double-submit cookie patterns."
    ]
  },
  {
    "id": "q116",
    "title": "What is XSS and how can frontend apps defend against it?",
    "content": "Explain Cross-Site Scripting attacks and mitigation strategies.",
    "type": "open-ended",
    "category": "Security",
    "subcategory": "XSS",
    "difficulty": "advanced",
    "topic": "Frontend System Design",
    "isActive": true,
    "createdAt": "2025-01-08T00:00:00Z",
    "updatedAt": "2025-01-08T00:00:00Z",
    "tags": ["xss", "security", "frontend"],
    "sampleAnswers": [
      "XSS injects malicious scripts into webpages. Defenses include escaping user input, using CSP (Content Security Policy), sanitizing HTML, and avoiding `eval`."
    ]
  },
  {
    "id": "q117",
    "title": "What is CORS and why does it matter in frontend apps?",
    "content": "Explain Cross-Origin Resource Sharing and its impact on frontend development.",
    "type": "open-ended",
    "category": "Security",
    "subcategory": "CORS",
    "difficulty": "beginner",
    "topic": "Frontend System Design",
    "isActive": true,
    "createdAt": "2025-01-08T00:00:00Z",
    "updatedAt": "2025-01-08T00:00:00Z",
    "tags": ["cors", "security", "frontend"],
    "sampleAnswers": [
      "CORS defines which domains can access APIs from a frontend app. It prevents malicious websites from making unauthorized requests on behalf of users."
    ]
  },
  {
    "id": "q118",
    "title": "What is the difference between SameSite=Lax, Strict, and None for cookies?",
    "content": "Explain cookie SameSite attribute options.",
    "type": "multiple-choice",
    "category": "Security",
    "subcategory": "Cookies",
    "difficulty": "intermediate",
    "topic": "Frontend System Design",
    "isActive": true,
    "createdAt": "2025-01-08T00:00:00Z",
    "updatedAt": "2025-01-08T00:00:00Z",
    "tags": ["cookies", "samesite", "frontend"],
    "options": [
      {
        "id": "o1",
        "text": "Strict: cookie only sent for same-site requests",
        "isCorrect": true
      },
      {
        "id": "o2",
        "text": "Lax: cookie sent for same-site and top-level navigations",
        "isCorrect": true
      },
      {
        "id": "o3",
        "text": "None: cookie sent in all requests but must be Secure",
        "isCorrect": true
      }
    ]
  },
  {
    "id": "q119",
    "title": "What are signed URLs and how do they improve security?",
    "content": "Explain signed URLs in the context of serving private assets.",
    "type": "open-ended",
    "category": "Security",
    "subcategory": "Signed URLs",
    "difficulty": "intermediate",
    "topic": "Frontend System Design",
    "isActive": true,
    "createdAt": "2025-01-08T00:00:00Z",
    "updatedAt": "2025-01-08T00:00:00Z",
    "tags": ["signed-url", "security", "frontend"],
    "sampleAnswers": [
      "Signed URLs include a token or signature allowing temporary access to private assets like images or videos. They protect resources without exposing them publicly."
    ]
  },
  {
    "id": "q120",
    "title": "How do you implement secure logout in a frontend application?",
    "content": "Explain best practices for logging users out securely.",
    "type": "open-ended",
    "category": "Security",
    "subcategory": "Logout",
    "difficulty": "beginner",
    "topic": "Frontend System Design",
    "isActive": true,
    "createdAt": "2025-01-08T00:00:00Z",
    "updatedAt": "2025-01-08T00:00:00Z",
    "tags": ["security", "logout", "frontend"],
    "sampleAnswers": [
      "On logout, clear tokens from memory/storage, invalidate session cookies, revoke refresh tokens server-side, and redirect users to a safe page."
    ]
  },
  {
    "id": "q121",
    "title": "What is the difference between vertical and horizontal scaling in frontend systems?",
    "content": "Explain how vertical and horizontal scaling apply to frontend deployments.",
    "type": "open-ended",
    "category": "Scalability",
    "subcategory": "Scaling",
    "difficulty": "beginner",
    "topic": "Frontend System Design",
    "isActive": true,
    "createdAt": "2025-01-08T00:00:00Z",
    "updatedAt": "2025-01-08T00:00:00Z",
    "tags": ["scaling", "frontend", "deployment"],
    "sampleAnswers": [
      "Vertical scaling means adding more power (CPU/RAM) to a single server. Horizontal scaling means adding more servers and distributing traffic using load balancers or CDNs."
    ]
  },
  {
    "id": "q122",
    "title": "How do CDNs help with frontend scalability?",
    "content": "Explain the role of Content Delivery Networks in frontend performance and scalability.",
    "type": "open-ended",
    "category": "Scalability",
    "subcategory": "CDN",
    "difficulty": "beginner",
    "topic": "Frontend System Design",
    "isActive": true,
    "createdAt": "2025-01-08T00:00:00Z",
    "updatedAt": "2025-01-08T00:00:00Z",
    "tags": ["cdn", "scalability", "frontend"],
    "sampleAnswers": [
      "CDNs distribute static assets across global edge servers. This reduces latency, improves performance, and reduces load on origin servers."
    ]
  },
  {
    "id": "q123",
    "title": "What is edge computing and how can frontend apps benefit from it?",
    "content": "Explain edge computing in the context of frontend applications.",
    "type": "open-ended",
    "category": "Scalability",
    "subcategory": "Edge",
    "difficulty": "intermediate",
    "topic": "Frontend System Design",
    "isActive": true,
    "createdAt": "2025-01-08T00:00:00Z",
    "updatedAt": "2025-01-08T00:00:00Z",
    "tags": ["edge", "frontend", "scalability"],
    "sampleAnswers": [
      "Edge computing runs code closer to users, reducing latency. Frontend apps benefit from edge functions for caching, authentication, and A/B testing."
    ]
  },
  {
    "id": "q124",
    "title": "What is serverless frontend hosting?",
    "content": "Describe serverless frontend hosting platforms like Vercel or Netlify.",
    "type": "open-ended",
    "category": "Deployment",
    "subcategory": "Serverless Hosting",
    "difficulty": "beginner",
    "topic": "Frontend System Design",
    "isActive": true,
    "createdAt": "2025-01-08T00:00:00Z",
    "updatedAt": "2025-01-08T00:00:00Z",
    "tags": ["serverless", "frontend", "deployment"],
    "sampleAnswers": [
      "Serverless hosting platforms automatically scale static sites and serverless functions, handling SSL, CDN, and caching without manual infrastructure setup."
    ]
  },
  {
    "id": "q125",
    "title": "What is blue-green deployment and how does it apply to frontend apps?",
    "content": "Explain blue-green deployment strategy in frontend deployments.",
    "type": "open-ended",
    "category": "Deployment",
    "subcategory": "Strategies",
    "difficulty": "intermediate",
    "topic": "Frontend System Design",
    "isActive": true,
    "createdAt": "2025-01-08T00:00:00Z",
    "updatedAt": "2025-01-08T00:00:00Z",
    "tags": ["deployment", "blue-green", "frontend"],
    "sampleAnswers": [
      "Blue-green deployment maintains two environments: blue (current) and green (new). After testing the green environment, traffic is switched with zero downtime."
    ]
  },
  {
    "id": "q126",
    "title": "What is canary release and why is it useful for frontend apps?",
    "content": "Describe canary release strategy in frontend deployment.",
    "type": "open-ended",
    "category": "Deployment",
    "subcategory": "Strategies",
    "difficulty": "intermediate",
    "topic": "Frontend System Design",
    "isActive": true,
    "createdAt": "2025-01-08T00:00:00Z",
    "updatedAt": "2025-01-08T00:00:00Z",
    "tags": ["deployment", "canary", "frontend"],
    "sampleAnswers": [
      "Canary releases gradually roll out a new version to a small subset of users. If no issues arise, it expands to all users. Useful for catching bugs early."
    ]
  },
  {
    "id": "q127",
    "title": "What are micro-frontends and how do they improve scalability?",
    "content": "Explain the concept of micro-frontends and their trade-offs.",
    "type": "open-ended",
    "category": "Architecture",
    "subcategory": "Micro-Frontends",
    "difficulty": "advanced",
    "topic": "Frontend System Design",
    "isActive": true,
    "createdAt": "2025-01-08T00:00:00Z",
    "updatedAt": "2025-01-08T00:00:00Z",
    "tags": ["micro-frontends", "scalability", "frontend"],
    "sampleAnswers": [
      "Micro-frontends split a large frontend into smaller, independently deployable apps. They improve scalability and team autonomy but add complexity in integration and shared state."
    ]
  },
  {
    "id": "q128",
    "title": "What is SSR caching and why is it important for scaling Next.js apps?",
    "content": "Describe server-side rendering (SSR) caching in frontend applications.",
    "type": "open-ended",
    "category": "Scalability",
    "subcategory": "SSR",
    "difficulty": "advanced",
    "topic": "Frontend System Design",
    "isActive": true,
    "createdAt": "2025-01-08T00:00:00Z",
    "updatedAt": "2025-01-08T00:00:00Z",
    "tags": ["ssr", "caching", "frontend"],
    "sampleAnswers": [
      "SSR caching stores rendered HTML from server-side rendering, reducing repeated computations. It improves response times and scales Next.js apps under high traffic."
    ]
  },
  {
    "id": "q129",
    "title": "How does load balancing work for frontend applications?",
    "content": "Explain load balancing strategies in frontend system design.",
    "type": "open-ended",
    "category": "Scalability",
    "subcategory": "Load Balancing",
    "difficulty": "intermediate",
    "topic": "Frontend System Design",
    "isActive": true,
    "createdAt": "2025-01-08T00:00:00Z",
    "updatedAt": "2025-01-08T00:00:00Z",
    "tags": ["load balancing", "frontend", "scalability"],
    "sampleAnswers": [
      "Load balancers distribute traffic across multiple servers. Strategies include round-robin, least connections, and geo-based routing. This improves reliability and scalability."
    ]
  },
  {
    "id": "q130",
    "title": "What is progressive rollout in frontend deployments?",
    "content": "Describe progressive rollout strategy in frontend apps.",
    "type": "open-ended",
    "category": "Deployment",
    "subcategory": "Strategies",
    "difficulty": "intermediate",
    "topic": "Frontend System Design",
    "isActive": true,
    "createdAt": "2025-01-08T00:00:00Z",
    "updatedAt": "2025-01-08T00:00:00Z",
    "tags": ["progressive rollout", "frontend", "deployment"],
    "sampleAnswers": [
      "Progressive rollout gradually releases new features to specific user groups, regions, or percentages of traffic. It minimizes risk and enables monitoring of issues before full release."
    ]
  },
  {
    "id": "q131",
    "title": "What is frontend observability and why is it important?",
    "content": "Explain what observability means for frontend applications and how it differs from backend observability.",
    "type": "open-ended",
    "category": "Monitoring",
    "subcategory": "Observability",
    "difficulty": "beginner",
    "topic": "Frontend System Design",
    "isActive": true,
    "createdAt": "2025-01-08T00:00:00Z",
    "updatedAt": "2025-01-08T00:00:00Z",
    "tags": ["observability", "frontend", "monitoring"],
    "sampleAnswers": [
      "Frontend observability provides insights into client-side performance, errors, and user interactions. It's important for detecting issues that backend monitoring cannot catch, like slow rendering or script errors in browsers."
    ]
  },
  {
    "id": "q132",
    "title": "What are Real User Monitoring (RUM) tools?",
    "content": "Describe RUM and how it helps improve frontend system design.",
    "type": "open-ended",
    "category": "Monitoring",
    "subcategory": "RUM",
    "difficulty": "beginner",
    "topic": "Frontend System Design",
    "isActive": true,
    "createdAt": "2025-01-08T00:00:00Z",
    "updatedAt": "2025-01-08T00:00:00Z",
    "tags": ["rum", "monitoring", "frontend"],
    "sampleAnswers": [
      "RUM tools capture real user interactions, measuring page load time, errors, and responsiveness directly from user devices, giving true performance insights."
    ]
  },
  {
    "id": "q133",
    "title": "What is Synthetic Monitoring and how is it different from RUM?",
    "content": "Compare synthetic monitoring with real user monitoring for frontend apps.",
    "type": "multiple-choice",
    "category": "Monitoring",
    "subcategory": "Synthetic Monitoring",
    "difficulty": "intermediate",
    "topic": "Frontend System Design",
    "isActive": true,
    "createdAt": "2025-01-08T00:00:00Z",
    "updatedAt": "2025-01-08T00:00:00Z",
    "tags": ["synthetic-monitoring", "rum", "frontend"],
    "options": [
      {
        "id": "o1",
        "text": "Synthetic monitoring simulates user interactions with scripts",
        "isCorrect": true
      },
      {
        "id": "o2",
        "text": "RUM measures actual user interactions",
        "isCorrect": true
      },
      {
        "id": "o3",
        "text": "Synthetic monitoring always gives more accurate results than RUM",
        "isCorrect": false
      },
      {
        "id": "o4",
        "text": "RUM does not work for frontend applications",
        "isCorrect": false
      }
    ]
  },
  {
    "id": "q134",
    "title": "What are Core Web Vitals and why are they important?",
    "content": "Explain Google's Core Web Vitals and their impact on frontend design and SEO.",
    "type": "open-ended",
    "category": "Monitoring",
    "subcategory": "Performance Metrics",
    "difficulty": "beginner",
    "topic": "Frontend System Design",
    "isActive": true,
    "createdAt": "2025-01-08T00:00:00Z",
    "updatedAt": "2025-01-08T00:00:00Z",
    "tags": ["core-web-vitals", "performance", "seo"],
    "sampleAnswers": [
      "Core Web Vitals (LCP, FID, CLS) are user-focused performance metrics. They measure load speed, interactivity, and visual stability. They directly affect SEO rankings and user experience."
    ]
  },
  {
    "id": "q135",
    "title": "How can you capture and log JavaScript errors in production?",
    "content": "Explain different ways to handle and log frontend errors.",
    "type": "open-ended",
    "category": "Logging",
    "subcategory": "Error Tracking",
    "difficulty": "intermediate",
    "topic": "Frontend System Design",
    "isActive": true,
    "createdAt": "2025-01-08T00:00:00Z",
    "updatedAt": "2025-01-08T00:00:00Z",
    "tags": ["logging", "error-tracking", "frontend"],
    "sampleAnswers": [
      "Use `window.onerror` and `unhandledrejection` to capture errors, then send them to monitoring tools like Sentry, Datadog, or custom APIs for logging and alerting."
    ]
  },
  {
    "id": "q136",
    "title": "What is distributed tracing and how does it apply to frontend apps?",
    "content": "Explain distributed tracing in microservices and how frontend can participate.",
    "type": "open-ended",
    "category": "Monitoring",
    "subcategory": "Tracing",
    "difficulty": "advanced",
    "topic": "Frontend System Design",
    "isActive": true,
    "createdAt": "2025-01-08T00:00:00Z",
    "updatedAt": "2025-01-08T00:00:00Z",
    "tags": ["tracing", "monitoring", "frontend"],
    "sampleAnswers": [
      "Distributed tracing follows a request across multiple services. Frontend apps can pass trace IDs in headers, enabling correlation between frontend interactions and backend service performance."
    ]
  },
  {
    "id": "q137",
    "title": "How do you monitor frontend API calls?",
    "content": "Discuss ways to track the performance and errors of API calls from the frontend.",
    "type": "open-ended",
    "category": "Monitoring",
    "subcategory": "API Monitoring",
    "difficulty": "intermediate",
    "topic": "Frontend System Design",
    "isActive": true,
    "createdAt": "2025-01-08T00:00:00Z",
    "updatedAt": "2025-01-08T00:00:00Z",
    "tags": ["api-monitoring", "frontend", "observability"],
    "sampleAnswers": [
      "You can wrap fetch/axios calls to log response times, status codes, and errors. Monitoring tools can capture API latency and availability directly from the client side."
    ]
  },
  {
    "id": "q138",
    "title": "What are common tools for frontend monitoring and logging?",
    "content": "List and explain popular monitoring/logging tools used in frontend system design.",
    "type": "open-ended",
    "category": "Monitoring",
    "subcategory": "Tools",
    "difficulty": "beginner",
    "topic": "Frontend System Design",
    "isActive": true,
    "createdAt": "2025-01-08T00:00:00Z",
    "updatedAt": "2025-01-08T00:00:00Z",
    "tags": ["monitoring-tools", "frontend", "logging"],
    "sampleAnswers": [
      "Sentry, LogRocket, Datadog, New Relic, Elastic APM, and OpenTelemetry are commonly used for frontend monitoring, logging, and observability."
    ]
  },
  {
    "id": "q139",
    "title": "What is log aggregation and why is it useful in frontend observability?",
    "content": "Explain the role of log aggregation in debugging frontend issues.",
    "type": "open-ended",
    "category": "Logging",
    "subcategory": "Aggregation",
    "difficulty": "intermediate",
    "topic": "Frontend System Design",
    "isActive": true,
    "createdAt": "2025-01-08T00:00:00Z",
    "updatedAt": "2025-01-08T00:00:00Z",
    "tags": ["log-aggregation", "frontend", "monitoring"],
    "sampleAnswers": [
      "Log aggregation collects logs from multiple users and sessions into a central system. It helps identify patterns, diagnose errors, and analyze performance at scale."
    ]
  },
  {
    "id": "q140",
    "title": "What is the difference between proactive and reactive monitoring?",
    "content": "Compare proactive and reactive monitoring in frontend system design.",
    "type": "multiple-choice",
    "category": "Monitoring",
    "subcategory": "Strategies",
    "difficulty": "intermediate",
    "topic": "Frontend System Design",
    "isActive": true,
    "createdAt": "2025-01-08T00:00:00Z",
    "updatedAt": "2025-01-08T00:00:00Z",
    "tags": ["monitoring", "frontend", "strategies"],
    "options": [
      {
        "id": "o1",
        "text": "Proactive monitoring aims to detect issues before users are impacted",
        "isCorrect": true
      },
      {
        "id": "o2",
        "text": "Reactive monitoring only responds after an issue is reported",
        "isCorrect": true
      },
      {
        "id": "o3",
        "text": "Proactive monitoring is not possible for frontend apps",
        "isCorrect": false
      },
      {
        "id": "o4",
        "text": "Reactive monitoring uses tools like alerts and dashboards",
        "isCorrect": false
      }
    ]
  },
  {
    "id": "q141",
    "title": "What is XSS (Cross-Site Scripting) and how can frontend apps prevent it?",
    "content": "Explain XSS attacks and mitigation techniques in frontend applications.",
    "type": "open-ended",
    "category": "Security",
    "subcategory": "XSS",
    "difficulty": "intermediate",
    "topic": "Frontend System Design",
    "isActive": true,
    "createdAt": "2025-01-08T00:00:00Z",
    "updatedAt": "2025-01-08T00:00:00Z",
    "tags": ["xss", "security", "frontend"],
    "sampleAnswers": [
      "XSS allows attackers to inject malicious scripts. Prevention includes escaping user input, using Content Security Policy (CSP), and avoiding dangerous APIs like innerHTML."
    ]
  },
  {
    "id": "q142",
    "title": "What is CSRF and how can it be mitigated in frontend apps?",
    "content": "Describe CSRF attacks and frontend strategies to prevent them.",
    "type": "open-ended",
    "category": "Security",
    "subcategory": "CSRF",
    "difficulty": "intermediate",
    "topic": "Frontend System Design",
    "isActive": true,
    "createdAt": "2025-01-08T00:00:00Z",
    "updatedAt": "2025-01-08T00:00:00Z",
    "tags": ["csrf", "security", "frontend"],
    "sampleAnswers": [
      "CSRF tricks users into submitting malicious requests. Mitigation includes anti-CSRF tokens, SameSite cookies, and requiring re-authentication for sensitive actions."
    ]
  },
  {
    "id": "q143",
    "title": "What is CORS and why is it important in frontend system design?",
    "content": "Explain CORS and how it impacts frontend API calls.",
    "type": "open-ended",
    "category": "Security",
    "subcategory": "CORS",
    "difficulty": "beginner",
    "topic": "Frontend System Design",
    "isActive": true,
    "createdAt": "2025-01-08T00:00:00Z",
    "updatedAt": "2025-01-08T00:00:00Z",
    "tags": ["cors", "security", "frontend"],
    "sampleAnswers": [
      "CORS (Cross-Origin Resource Sharing) controls how browsers allow cross-domain requests. It's important to configure properly to prevent unauthorized access while enabling required integrations."
    ]
  },
  {
    "id": "q144",
    "title": "What is HTTPS and why is it critical for frontend apps?",
    "content": "Explain how HTTPS secures frontend communication.",
    "type": "true-false",
    "category": "Security",
    "subcategory": "Encryption",
    "difficulty": "beginner",
    "topic": "Frontend System Design",
    "isActive": true,
    "createdAt": "2025-01-08T00:00:00Z",
    "updatedAt": "2025-01-08T00:00:00Z",
    "tags": ["https", "tls", "security"],
    "options": [
      {
        "id": "o1",
        "text": "HTTPS encrypts traffic between client and server, preventing eavesdropping",
        "isCorrect": true
      },
      {
        "id": "o2",
        "text": "HTTPS is optional for modern frontend apps",
        "isCorrect": false
      }
    ]
  },
  {
    "id": "q145",
    "title": "What is JWT and how is it used in frontend authentication?",
    "content": "Describe JSON Web Tokens (JWT) and their role in authentication.",
    "type": "open-ended",
    "category": "Authentication",
    "subcategory": "JWT",
    "difficulty": "intermediate",
    "topic": "Frontend System Design",
    "isActive": true,
    "createdAt": "2025-01-08T00:00:00Z",
    "updatedAt": "2025-01-08T00:00:00Z",
    "tags": ["jwt", "authentication", "frontend"],
    "sampleAnswers": [
      "JWTs are stateless tokens used for authentication. The frontend stores and sends JWTs in headers or cookies to prove user identity when making API requests."
    ]
  },
  {
    "id": "q146",
    "title": "What are HttpOnly cookies and why are they important for frontend security?",
    "content": "Explain how HttpOnly cookies protect authentication tokens.",
    "type": "open-ended",
    "category": "Security",
    "subcategory": "Cookies",
    "difficulty": "beginner",
    "topic": "Frontend System Design",
    "isActive": true,
    "createdAt": "2025-01-08T00:00:00Z",
    "updatedAt": "2025-01-08T00:00:00Z",
    "tags": ["cookies", "security", "httponly"],
    "sampleAnswers": [
      "HttpOnly cookies cannot be accessed via JavaScript, protecting tokens from XSS attacks. They are recommended for storing session tokens securely."
    ]
  },
  {
    "id": "q147",
    "title": "What is OAuth 2.0 and how is it used in frontend applications?",
    "content": "Describe OAuth 2.0 flows and their relevance to frontend apps.",
    "type": "open-ended",
    "category": "Authentication",
    "subcategory": "OAuth",
    "difficulty": "advanced",
    "topic": "Frontend System Design",
    "isActive": true,
    "createdAt": "2025-01-08T00:00:00Z",
    "updatedAt": "2025-01-08T00:00:00Z",
    "tags": ["oauth", "security", "frontend"],
    "sampleAnswers": [
      "OAuth 2.0 is an authorization framework. Frontend apps use flows like Authorization Code with PKCE to securely authenticate users and obtain tokens."
    ]
  },
  {
    "id": "q148",
    "title": "What is multi-factor authentication (MFA) and how is it implemented in frontend apps?",
    "content": "Explain MFA and how frontend applications can support it.",
    "type": "open-ended",
    "category": "Authentication",
    "subcategory": "MFA",
    "difficulty": "intermediate",
    "topic": "Frontend System Design",
    "isActive": true,
    "createdAt": "2025-01-08T00:00:00Z",
    "updatedAt": "2025-01-08T00:00:00Z",
    "tags": ["mfa", "authentication", "frontend"],
    "sampleAnswers": [
      "MFA requires multiple verification factors (e.g., password + SMS code). Frontend apps can support MFA by integrating with APIs for OTPs, push notifications, or authenticator apps."
    ]
  },
  {
    "id": "q149",
    "title": "What are signed URLs and how do they enhance frontend security?",
    "content": "Describe signed URLs and their use cases in frontend apps.",
    "type": "open-ended",
    "category": "Security",
    "subcategory": "Signed URLs",
    "difficulty": "intermediate",
    "topic": "Frontend System Design",
    "isActive": true,
    "createdAt": "2025-01-08T00:00:00Z",
    "updatedAt": "2025-01-08T00:00:00Z",
    "tags": ["signed-urls", "security", "frontend"],
    "sampleAnswers": [
      "Signed URLs provide temporary, secure access to protected resources like images or files. They include a signature and expiration time, preventing unauthorized access."
    ]
  },
  {
    "id": "q150",
    "title": "What is rate limiting and why is it important for frontend APIs?",
    "content": "Explain rate limiting and how it protects frontend apps.",
    "type": "open-ended",
    "category": "Security",
    "subcategory": "API Security",
    "difficulty": "intermediate",
    "topic": "Frontend System Design",
    "isActive": true,
    "createdAt": "2025-01-08T00:00:00Z",
    "updatedAt": "2025-01-08T00:00:00Z",
    "tags": ["rate-limiting", "security", "frontend"],
    "sampleAnswers": [
      "Rate limiting restricts the number of API calls per user or IP within a time window. It prevents abuse, brute-force attacks, and protects backend resources."
    ]
  },
  {
    "id": "q151",
    "title": "What are the main types of tests in frontend apps?",
    "content": "Compare unit tests, integration tests, and end-to-end (E2E) tests: purpose, scope, and where they fit in the test pyramid.",
    "type": "multiple-choice",
    "category": "Testing",
    "subcategory": "Test Types",
    "difficulty": "beginner",
    "topic": "Frontend System Design",
    "isActive": true,
    "createdAt": "2025-10-08T11:00:00Z",
    "updatedAt": "2025-10-08T11:00:00Z",
    "tags": ["testing", "unit-tests", "e2e", "integration"],
    "explanation": "Unit tests verify small units in isolation; integration tests verify interactions between modules; E2E tests verify full flows in a real browser environment.",
    "options": [
      {
        "id": "o1",
        "text": "Unit tests: small, fast, isolated",
        "isCorrect": true
      },
      {
        "id": "o2",
        "text": "Integration tests: verify modules working together",
        "isCorrect": true
      },
      {
        "id": "o3",
        "text": "E2E tests: full system flows in browser",
        "isCorrect": true
      },
      {
        "id": "o4",
        "text": "E2E tests should replace unit tests",
        "isCorrect": false
      }
    ]
  },
  {
    "id": "q152",
    "title": "What is the test pyramid and why should you follow it?",
    "content": "Explain the test pyramid concept and how it guides test investment for frontend applications.",
    "type": "open-ended",
    "category": "Testing",
    "subcategory": "Strategy",
    "difficulty": "intermediate",
    "topic": "Frontend System Design",
    "isActive": true,
    "createdAt": "2025-10-08T11:01:00Z",
    "updatedAt": "2025-10-08T11:01:00Z",
    "tags": ["test-pyramid", "testing-strategy", "frontend"],
    "sampleAnswers": [
      "The test pyramid recommends many fast unit tests at the bottom, fewer integration tests in the middle, and even fewer E2E tests at the top. This balances speed, reliability, and coverage."
    ]
  },
  {
    "id": "q153",
    "title": "How do you test React components effectively?",
    "content": "Describe practices and tools for testing React components (rendering, interactions, state, async behavior, accessibility).",
    "type": "open-ended",
    "category": "Testing",
    "subcategory": "Component Testing",
    "difficulty": "intermediate",
    "topic": "Frontend System Design",
    "isActive": true,
    "createdAt": "2025-10-08T11:02:00Z",
    "updatedAt": "2025-10-08T11:02:00Z",
    "tags": ["react", "testing-library", "jest", "accessibility", "rtl"],
    "sampleAnswers": [
      "Use React Testing Library + Jest to test rendered output and user interactions, mock network calls, test accessibility using axe, avoid implementation-detail assertions, and use snapshots sparingly."
    ]
  },
  {
    "id": "q154",
    "title": "Which tools are commonly used for E2E testing in modern frontend apps?",
    "content": "Select the commonly used E2E testing tools and one key advantage of each (Cypress, Playwright, Selenium).",
    "type": "multiple-choice",
    "category": "Testing",
    "subcategory": "E2E Tools",
    "difficulty": "beginner",
    "topic": "Frontend System Design",
    "isActive": true,
    "createdAt": "2025-10-08T11:03:00Z",
    "updatedAt": "2025-10-08T11:03:00Z",
    "tags": ["cypress", "playwright", "selenium", "e2e"],
    "options": [
      {
        "id": "o1",
        "text": "Cypress: developer-friendly, great debugging UX",
        "isCorrect": true
      },
      {
        "id": "o2",
        "text": "Playwright: cross-browser automation and parallelism",
        "isCorrect": true
      },
      {
        "id": "o3",
        "text": "Selenium: mature but heavier and more complex to manage",
        "isCorrect": true
      },
      {
        "id": "o4",
        "text": "None of the above are used for E2E",
        "isCorrect": false
      }
    ],
    "explanation": "Cypress and Playwright are popular for modern apps; Selenium is older and broad but more complex."
  },
  {
    "id": "q155",
    "title": "What causes flaky tests and how do you fix them?",
    "content": "Explain common causes of flaky tests (timing, network, order dependency) and strategies to make tests reliable.",
    "type": "open-ended",
    "category": "Testing",
    "subcategory": "Flaky Tests",
    "difficulty": "advanced",
    "topic": "Frontend System Design",
    "isActive": true,
    "createdAt": "2025-10-08T11:04:00Z",
    "updatedAt": "2025-10-08T11:04:00Z",
    "tags": ["flaky-tests", "stability", "e2e", "testing"],
    "sampleAnswers": [
      "Flakiness can be caused by race conditions, unstable selectors, reliance on real network, or shared state. Fix by using stable selectors, mock network calls, add deterministic waits or better synchronization, isolate tests, and reset environment between runs."
    ]
  },
  {
    "id": "q156",
    "title": "Which checks should run locally vs in CI?",
    "content": "Decide which tasks are suitable for local developer runs and which should be enforced in CI (lint, unit tests, integration, E2E, build).",
    "type": "multiple-choice",
    "category": "CI/CD",
    "subcategory": "Pipeline Design",
    "difficulty": "intermediate",
    "topic": "Frontend System Design",
    "isActive": true,
    "createdAt": "2025-10-08T11:05:00Z",
    "updatedAt": "2025-10-08T11:05:00Z",
    "tags": ["ci", "cicd", "testing", "pipeline"],
    "options": [
      {
        "id": "o1",
        "text": "Run lint and unit tests locally before PR",
        "isCorrect": true
      },
      {
        "id": "o2",
        "text": "Run full E2E suite in CI (not required for every local dev run)",
        "isCorrect": true
      },
      {
        "id": "o3",
        "text": "Skip build step in CI",
        "isCorrect": false
      },
      {
        "id": "o4",
        "text": "Run heavy integration tests only in CI pipelines",
        "isCorrect": true
      }
    ],
    "explanation": "Developers should run fast checks locally; heavier/integration/E2E tests and release builds should run in CI."
  },
  {
    "id": "q157",
    "title": "How do you design a CI pipeline for a frontend app?",
    "content": "Outline a typical CI pipeline stages for frontend: install, lint, unit tests, build, integration/E2E, artifact publish, and deploy.",
    "type": "open-ended",
    "category": "CI/CD",
    "subcategory": "Pipeline Design",
    "difficulty": "intermediate",
    "topic": "Frontend System Design",
    "isActive": true,
    "createdAt": "2025-10-08T11:06:00Z",
    "updatedAt": "2025-10-08T11:06:00Z",
    "tags": ["ci", "pipeline", "frontend", "deployment"],
    "sampleAnswers": [
      "Typical pipeline: checkout -> install deps -> lint -> unit tests -> build -> static analysis/security scan -> run integration/E2E in parallel -> publish artifacts -> deploy to staging -> run smoke tests -> promote to production with deployment strategy (canary/blue-green)."
    ]
  },
  {
    "id": "q158",
    "title": "How can you speed up test suites in CI?",
    "content": "Discuss techniques such as test parallelization, caching node_modules, test sharding, and running only affected tests.",
    "type": "open-ended",
    "category": "CI/CD",
    "subcategory": "Optimization",
    "difficulty": "advanced",
    "topic": "Frontend System Design",
    "isActive": true,
    "createdAt": "2025-10-08T11:07:00Z",
    "updatedAt": "2025-10-08T11:07:00Z",
    "tags": ["ci", "test-parallelization", "sharding", "caching"],
    "sampleAnswers": [
      "Speedups: enable CI caching for dependencies, run tests in parallel across workers, shard E2E tests by test suites, run only affected tests using changed-file detection, and use lightweight mocked E2E for quick smoke."
    ]
  },
  {
    "id": "q159",
    "title": "What is visual regression testing and when should you use it?",
    "content": "Explain visual regression testing and tools for it (Percy, Chromatic, Playwright snapshot).",
    "type": "open-ended",
    "category": "Testing",
    "subcategory": "Visual Testing",
    "difficulty": "intermediate",
    "topic": "Frontend System Design",
    "isActive": true,
    "createdAt": "2025-10-08T11:08:00Z",
    "updatedAt": "2025-10-08T11:08:00Z",
    "tags": ["visual-testing", "regression", "ui", "testing"],
    "sampleAnswers": [
      "Visual regression testing captures UI screenshots and compares diffs to detect unintended UI changes. Use for design-critical components, theming changes, or when CSS changes might break layouts."
    ]
  },
  {
    "id": "q160",
    "title": "How do you enforce quality gates in CI and integrate them with code review?",
    "content": "Describe quality gates like test coverage thresholds, linting, security scans, and how to integrate results into pull requests and CI protections.",
    "type": "multiple-choice",
    "category": "CI/CD",
    "subcategory": "Quality Gates",
    "difficulty": "intermediate",
    "topic": "Frontend System Design",
    "isActive": true,
    "createdAt": "2025-10-08T11:09:00Z",
    "updatedAt": "2025-10-08T11:09:00Z",
    "tags": ["quality-gates", "pr", "ci", "testing"],
    "options": [
      {
        "id": "o1",
        "text": "Fail CI build on critical lint or test failures",
        "isCorrect": true
      },
      {
        "id": "o2",
        "text": "Block merge unless coverage meets threshold (e.g., >80%)",
        "isCorrect": true
      },
      {
        "id": "o3",
        "text": "Ignore E2E failures permanently",
        "isCorrect": false
      },
      {
        "id": "o4",
        "text": "Publish test reports and comments on PR for visibility",
        "isCorrect": true
      }
    ],
    "explanation": "Quality gates ensure that only PRs meeting minimum quality metrics are merged; surface results in PRs for reviewer context."
  }
]
