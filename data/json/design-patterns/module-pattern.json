[
  {
    "id": 41,
    "title": "Definition of Module Pattern",
    "content": "What is the Module Pattern in JavaScript and why is it used?",
    "type": "open-ended",
    "difficulty": "easy",
    "sampleAnswers": [
      "The Module Pattern is a design pattern that uses closures to create private and public encapsulation.",
      "It is used to avoid polluting the global scope and to create reusable, maintainable code structures."
    ]
  },
  {
    "id": 42,
    "title": "Basic Module Syntax",
    "content": "Which of the following correctly implements a simple Module Pattern in JavaScript?",
    "type": "multiple-choice",
    "difficulty": "easy",
    "options": [
      {
        "id": "a",
        "text": "function Module() { var x = 10; return x; }",
        "isCorrect": false
      },
      {
        "id": "b",
        "text": "var Module = (function(){ var privateVar = 10; return { get: function(){ return privateVar; } }; })();",
        "isCorrect": true
      },
      {
        "id": "c",
        "text": "let Module = class { constructor(){ this.x = 10; } }",
        "isCorrect": false
      }
    ]
  },
  {
    "id": 43,
    "title": "Encapsulation in Module Pattern",
    "content": "How does the Module Pattern achieve encapsulation?",
    "type": "open-ended",
    "difficulty": "medium",
    "sampleAnswers": [
      "By using an Immediately Invoked Function Expression (IIFE) to create a private scope.",
      "Only the returned object exposes public members, while variables/functions inside the closure remain private."
    ]
  },
  {
    "id": 44,
    "title": "Drawback of Module Pattern",
    "content": "Which of the following is a drawback of the Module Pattern?",
    "type": "multiple-choice",
    "difficulty": "medium",
    "options": [
      {
        "id": "a",
        "text": "It makes code modular and organized",
        "isCorrect": false
      },
      {
        "id": "b",
        "text": "Private members cannot be accessed or modified without changing the original module",
        "isCorrect": true
      },
      {
        "id": "c",
        "text": "It always requires classes",
        "isCorrect": false
      }
    ]
  },
  {
    "id": 45,
    "title": "Revealing Module Pattern",
    "content": "What is the difference between the classic Module Pattern and the Revealing Module Pattern?",
    "type": "open-ended",
    "difficulty": "medium",
    "sampleAnswers": [
      "The Revealing Module Pattern maps private functions/variables to a returned object explicitly, improving readability.",
      "It makes it clear which functions are public and which remain private."
    ]
  },
  {
    "id": 46,
    "title": "Debugging Modules",
    "content": "If you forget to return a method in your Module Pattern, what will happen?",
    "type": "multiple-choice",
    "difficulty": "easy",
    "options": [
      {
        "id": "a",
        "text": "The method is still accessible globally",
        "isCorrect": false
      },
      {
        "id": "b",
        "text": "The method remains private and cannot be accessed outside",
        "isCorrect": true
      },
      {
        "id": "c",
        "text": "JavaScript throws a syntax error",
        "isCorrect": false
      }
    ]
  },
  {
    "id": 47,
    "title": "Module Pattern vs ES6 Modules",
    "content": "How does the Module Pattern differ from ES6 Modules?",
    "type": "open-ended",
    "difficulty": "advanced",
    "sampleAnswers": [
      "Module Pattern relies on closures and IIFEs for encapsulation, while ES6 Modules are built-in language features with `import` and `export`.",
      "ES6 Modules are statically analyzed at compile time, while Module Pattern modules are runtime constructs."
    ]
  },
  {
    "id": 48,
    "title": "Use Case of Module Pattern",
    "content": "Which scenario is best suited for the Module Pattern?",
    "type": "multiple-choice",
    "difficulty": "medium",
    "options": [
      {
        "id": "a",
        "text": "When you want to encapsulate private state in legacy JavaScript without ES6 support",
        "isCorrect": true
      },
      {
        "id": "b",
        "text": "When you need dynamic imports and tree-shaking",
        "isCorrect": false
      },
      {
        "id": "c",
        "text": "When you only work with classes",
        "isCorrect": false
      }
    ]
  }
]
