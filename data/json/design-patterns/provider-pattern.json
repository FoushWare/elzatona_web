[
  {
    "id": 61,
    "title": "Provider Pattern Basics",
    "content": "What problem does the Provider Pattern primarily solve in React applications?",
    "type": "open-ended",
    "difficulty": "easy",
    "sampleAnswers": [
      "It solves the issue of prop drilling by allowing components to access shared state directly through context.",
      "It provides a way to make global state or values accessible to deeply nested components without passing props manually."
    ]
  },
  {
    "id": 62,
    "title": "Prop Drilling",
    "content": "Which of the following best describes 'prop drilling'?",
    "type": "multiple-choice",
    "difficulty": "easy",
    "options": [
      {
        "id": "a",
        "text": "Passing props through multiple components that don’t use them",
        "isCorrect": true
      },
      {
        "id": "b",
        "text": "Drilling into the DOM with refs",
        "isCorrect": false
      },
      {
        "id": "c",
        "text": "Creating deeply nested providers",
        "isCorrect": false
      }
    ]
  },
  {
    "id": 63,
    "title": "useContext Hook",
    "content": "In React, how does a component consume values from a Provider?",
    "type": "open-ended",
    "difficulty": "medium",
    "sampleAnswers": [
      "By using the useContext hook with the context object created via React.createContext().",
      "The component calls useContext(SomeContext) to directly access the value provided by the Provider."
    ]
  },
  {
    "id": 64,
    "title": "Provider Pattern Code",
    "content": "What will be rendered by the Header component in this example?\n\n```jsx\nconst DataContext = React.createContext();\n\nfunction App() {\n  const data = { title: 'Hello Provider' };\n  return (\n    <DataContext.Provider value={data}>\n      <Header />\n    </DataContext.Provider>\n  );\n}\n\nfunction Header() {\n  const data = React.useContext(DataContext);\n  return <h1>{data.title}</h1>;\n}\n```",
    "type": "multiple-choice",
    "difficulty": "medium",
    "options": [
      {
        "id": "a",
        "text": "Nothing, React throws an error",
        "isCorrect": false
      },
      {
        "id": "b",
        "text": "h1 with text 'Hello Provider'",
        "isCorrect": true
      },
      {
        "id": "c",
        "text": "h1 with text 'undefined'",
        "isCorrect": false
      }
    ]
  },
  {
    "id": 65,
    "title": "Performance Concern",
    "content": "What is a potential downside of overusing the Provider Pattern?",
    "type": "open-ended",
    "difficulty": "medium",
    "sampleAnswers": [
      "All components consuming the context re-render whenever the value changes, which can hurt performance in large apps.",
      "It can cause unnecessary re-renders if too much state is stored in a single provider."
    ]
  },
  {
    "id": 66,
    "title": "Theme Provider Use Case",
    "content": "Why is the Provider Pattern a good fit for managing application themes (dark/light mode)?",
    "type": "open-ended",
    "difficulty": "easy",
    "sampleAnswers": [
      "Because many components need access to the theme, and the Provider allows sharing it globally without prop drilling.",
      "It centralizes theme state and makes it easy to toggle or update across the entire app."
    ]
  },
  {
    "id": 67,
    "title": "Multiple Providers",
    "content": "How can you avoid unnecessary re-renders when using Providers for frequently changing values?",
    "type": "open-ended",
    "difficulty": "advanced",
    "sampleAnswers": [
      "By splitting contexts into multiple smaller providers so that components only re-render when the specific value they consume changes.",
      "Using memoization or selective context providers to isolate updates."
    ]
  },
  {
    "id": 68,
    "title": "Custom Hook for Context",
    "content": "What is the benefit of creating a custom hook like `useThemeContext()` instead of calling `useContext(ThemeContext)` directly in every component?",
    "type": "multiple-choice",
    "difficulty": "medium",
    "options": [
      {
        "id": "a",
        "text": "It enforces correct usage and can throw errors if used outside the provider",
        "isCorrect": true
      },
      {
        "id": "b",
        "text": "It avoids the need to import useContext at all",
        "isCorrect": false
      },
      {
        "id": "c",
        "text": "It improves runtime performance automatically",
        "isCorrect": false
      }
    ]
  },
  {
    "id": 69,
    "title": "Provider vs Redux",
    "content": "How does the Provider Pattern differ from using Redux for global state management?",
    "type": "open-ended",
    "difficulty": "advanced",
    "sampleAnswers": [
      "Provider Pattern with context is simpler and built into React, but doesn’t offer advanced features like middleware, devtools, or predictable reducers.",
      "Redux adds structure and tooling, while Context Providers are best for simpler shared state."
    ]
  },
  {
    "id": 70,
    "title": "Styled-Components Provider",
    "content": "What role does the ThemeProvider from styled-components play?",
    "type": "open-ended",
    "difficulty": "medium",
    "sampleAnswers": [
      "It provides a theme object via context so that styled components can access theme values without passing them as props.",
      "It applies consistent design tokens (colors, spacing, etc.) across the entire component tree."
    ]
  }
]
