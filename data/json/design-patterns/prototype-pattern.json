[
  {
    "id": 57,
    "title": "Definition of Prototype Pattern",
    "content": "What is the Prototype Pattern and why is it useful in JavaScript?",
    "type": "open-ended",
    "difficulty": "easy",
    "sampleAnswers": [
      "The Prototype Pattern allows objects to share properties and methods through the prototype chain.",
      "It avoids duplication and reduces memory usage by letting instances inherit methods from the prototype instead of redefining them."
    ]
  },
  {
    "id": 58,
    "title": "Prototype vs Instance Properties",
    "content": "In the Dog class example, where is the bark() method stored?",
    "type": "multiple-choice",
    "difficulty": "easy",
    "options": [
      {
        "id": "a",
        "text": "On each Dog instance",
        "isCorrect": false
      },
      {
        "id": "b",
        "text": "On Dog.prototype, shared by all instances",
        "isCorrect": true
      },
      {
        "id": "c",
        "text": "Inside the Dog constructor",
        "isCorrect": false
      },
      {
        "id": "d",
        "text": "In the global window object",
        "isCorrect": false
      }
    ]
  },
  {
    "id": 59,
    "title": "Adding Properties Dynamically",
    "content": "If you add Dog.prototype.play after creating instances, will existing instances have access to play()?",
    "type": "multiple-choice",
    "difficulty": "medium",
    "options": [
      {
        "id": "a",
        "text": "Yes, because all instances reference the same prototype",
        "isCorrect": true
      },
      {
        "id": "b",
        "text": "No, only future instances get it",
        "isCorrect": false
      },
      {
        "id": "c",
        "text": "It depends on whether the object was frozen",
        "isCorrect": false
      },
      {
        "id": "d",
        "text": "JavaScript throws an error",
        "isCorrect": false
      }
    ]
  },
  {
    "id": 60,
    "title": "Prototype Chain",
    "content": "How does JavaScript resolve a property that isnâ€™t found directly on an object?",
    "type": "open-ended",
    "difficulty": "easy",
    "sampleAnswers": [
      "It traverses the prototype chain via __proto__ until it finds the property or reaches null.",
      "This process is called prototype chaining."
    ]
  },
  {
    "id": 61,
    "title": "Inheritance with Prototype",
    "content": "In the SuperDog example, how does SuperDog gain access to bark() from Dog?",
    "type": "multiple-choice",
    "difficulty": "medium",
    "options": [
      {
        "id": "a",
        "text": "Through Object.assign copying methods",
        "isCorrect": false
      },
      {
        "id": "b",
        "text": "By extending Dog, SuperDog.prototype.__proto__ points to Dog.prototype",
        "isCorrect": true
      },
      {
        "id": "c",
        "text": "Each SuperDog has its own bark() copy",
        "isCorrect": false
      },
      {
        "id": "d",
        "text": "By redefining bark in the constructor",
        "isCorrect": false
      }
    ]
  },
  {
    "id": 62,
    "title": "Object.create Use Case",
    "content": "What does Object.create allow you to do?",
    "type": "open-ended",
    "difficulty": "easy",
    "sampleAnswers": [
      "It creates a new object with its prototype explicitly set to the provided object.",
      "This lets you directly inherit properties without using classes or constructors."
    ]
  },
  {
    "id": 63,
    "title": "Prototype Pattern Advantages",
    "content": "What are two main advantages of the Prototype Pattern?",
    "type": "open-ended",
    "difficulty": "medium",
    "sampleAnswers": [
      "It reduces memory usage by sharing methods across instances.",
      "It allows dynamic extension of behavior by modifying the prototype."
    ]
  },
  {
    "id": 64,
    "title": "Prototype Pitfalls",
    "content": "Which of the following can be a downside of relying too heavily on prototype chaining?",
    "type": "multiple-choice",
    "difficulty": "advanced",
    "options": [
      {
        "id": "a",
        "text": "Deep prototype chains can make debugging difficult and slow property lookups",
        "isCorrect": true
      },
      {
        "id": "b",
        "text": "It prevents dynamic property addition",
        "isCorrect": false
      },
      {
        "id": "c",
        "text": "It increases memory usage",
        "isCorrect": false
      },
      {
        "id": "d",
        "text": "It makes objects immutable",
        "isCorrect": false
      }
    ]
  }
]
