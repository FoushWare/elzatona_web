
## Question 91

The JavaScript global execution context creates two things for you: the global object, and the "this" keyword.

**A:** true  
**B:** false  
**C:** it depends

**Answer:** A

**Explanation:** The base execution context is the global execution context: it's what's accessible everywhere in your code.

## Question 92

What's the output?

```javascript
for (let i = 1; i < 5; i++) {
  if (i === 3) continue;
  console.log(i);
}
```

**A:** `1` `2`  
**B:** `1` `2` `3`  
**C:** `1` `2` `4`  
**D:** `1` `3` `4`

**Answer:** C

**Explanation:** The `continue` statement skips an iteration if a certain condition returns `true`.

## Question 93

What's the output?

```javascript
String.prototype.giveLydiaPizza = () => {
  return 'Just give Lydia pizza already!';
};

const name = 'Lydia';

console.log(name.giveLydiaPizza());
```

**A:** `"Just give Lydia pizza already!"`  
**B:** `TypeError: not a function`  
**C:** `SyntaxError`  
**D:** `undefined`

**Answer:** A

**Explanation:** `String` is a built-in constructor, that we can add properties to. I just added a method to its prototype. Primitive strings are automatically converted into a string object, generated by the string prototype function. So, all strings (string objects) have access to that method!

## Question 94

What's the output?

```javascript
const a = {};
const b = { key: 'b' };
const c = { key: 'c' };

a[b] = 123;
a[c] = 456;

console.log(a[b]);
```

**A:** `123`  
**B:** `456`  
**C:** `undefined`  
**D:** `ReferenceError`

**Answer:** B

**Explanation:** Object keys are automatically converted into strings. We are trying to set an object as a key to object `a`, with the value of `123`. However, when we stringify an object, it becomes `"[object Object]"`. So what we are saying here, is that `a["[object Object]"] = 123`. Then, we can try to do the same again. `c` is another object that we are implicitly stringifying. So then, `a["[object Object]"] = 456`. Then, we log `a[b]`, which is actually `a["[object Object]"]`. We just set that to `456`, so it returns `456`.

## Question 95

What's the output?

```javascript
const foo = () => console.log('First');
const bar = () => setTimeout(() => console.log('Second'));
const baz = () => console.log('Third');

bar();
foo();
baz();
```

**A:** `First` `Second` `Third`  
**B:** `First` `Third` `Second`  
**C:** `Second` `First` `Third`  
**D:** `Second` `Third` `First`

**Answer:** B

**Explanation:** We have a `setTimeout` function and invoked it first. Yet, it was logged last. This is because in browsers, we don't just have the runtime engine, we also have something called a `WebAPI`. The `WebAPI` gives us the `setTimeout` function to start with, and for example the DOM. After the _callback_ is pushed to the WebAPI, the `setTimeout` function itself (but not the callback!) is popped off the stack. Now, `foo` gets invoked, and `"First"` is being logged. `foo` is popped off the stack, and `baz` gets invoked. `"Third"` gets logged. The WebAPI can't just add stuff to the stack whenever it's ready. Instead, it pushes the callback function to something called the _queue_. This is where an event loop starts to work. An **event loop** looks at the stack and task queue. If the stack is empty, it takes the first thing on the queue and pushes it onto the stack. `bar` gets invoked, `"Second"` gets logged, and it's popped off the stack.

## Question 96

What is the event.target when clicking the button?

```html
<div onclick="console.log('first div')">
  <div onclick="console.log('second div')">
    <button onclick="console.log('button')">Click!</button>
  </div>
</div>
```

**A:** Outer `div`  
**B:** Inner `div`  
**C:** `button`  
**D:** An array of all nested elements.

**Answer:** C

**Explanation:** The deepest nested element that caused the event is the target of the event. You can stop bubbling by `event.stopPropagation`

## Question 97

When you click the paragraph, what's the logged output?

```html
<div onclick="console.log('div')">
  <p onclick="console.log('p')">Click here!</p>
</div>
```

**A:** `p` `div`  
**B:** `div` `p`  
**C:** `p`  
**D:** An error will occur.

**Answer:** A

**Explanation:** If we click `p`, we see two logs: `p` and `div`. During event propagation, there are 3 phases: capturing, target, and bubbling. By default, event handlers are executed in the bubbling phase (unless you set `useCapture` to `true`). We go from the deepest nested element outwards.

## Question 98

What's the output?

```javascript
const person = { name: 'Lydia' };

function sayHi(age) {
  console.log(`${this.name} is ${age}`);
}

sayHi.call(person, 21);
sayHi.bind(person, 21);
```

**A:** `undefined is 21` `Lydia is 21`  
**B:** `function` `function`  
**C:** `Lydia is 21` `Lydia is 21`  
**D:** `Lydia is 21` `function`

**Answer:** D

**Explanation:** With both, we can pass the object to which we want the `this` keyword to refer to. However, `.call` is also _executed immediately_! `.bind` returns a _copy_ of the function, but with a bound context! It is not executed immediately.

## Question 99

What's the output?

```javascript
function sayHi() {
  return (() => 0)();
}

typeof sayHi();
```

**A:** `"object"`  
**B:** `"number"`  
**C:** `"function"`  
**D:** `"undefined"`

**Answer:** B

**Explanation:** The `sayHi` function returns the returned value of an immediately invoked function expression (IIFE). This function returned `0`, which is type `"number"`. FYI: there are only 7 built-in types: `null`, `undefined`, `boolean`, `number`, `string`, `object`, and `symbol`. `"function"` is not a type, since functions are objects, it's of type `"object"`.

## Question 100

Which of these values are falsy?

```javascript
0;
new Number(0);
('');
(' ');
new Boolean(false);
undefined;
```

**A:** `0`, `''`, `undefined`  
**B:** `0`, `new Number(0)`, `''`, `new Boolean(false)`, `undefined`  
**C:** `0`, `''`, `new Boolean(false)`, `undefined`  
**D:** All of them are falsy

**Answer:** A

**Explanation:** There are only 6 falsy values: `undefined`, `null`, `NaN`, `0`, `''` (empty string), and `false`. Function constructors like `new Number` and `new Boolean` are truthy.
